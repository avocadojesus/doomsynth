(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/Users/avojeez0/Sites/doomsynth/node_modules/browserify/lib/_empty.js":[function(require,module,exports){

},{}],"/Users/avojeez0/Sites/doomsynth/node_modules/browserify/node_modules/path-browserify/index.js":[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":"/Users/avojeez0/Sites/doomsynth/node_modules/browserify/node_modules/process/browser.js"}],"/Users/avojeez0/Sites/doomsynth/node_modules/browserify/node_modules/process/browser.js":[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],"/Users/avojeez0/Sites/doomsynth/node_modules/browserify/node_modules/vm-browserify/index.js":[function(require,module,exports){
var indexOf = require('indexof');

var Object_keys = function (obj) {
    if (Object.keys) return Object.keys(obj)
    else {
        var res = [];
        for (var key in obj) res.push(key)
        return res;
    }
};

var forEach = function (xs, fn) {
    if (xs.forEach) return xs.forEach(fn)
    else for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
    }
};

var defineProp = (function() {
    try {
        Object.defineProperty({}, '_', {});
        return function(obj, name, value) {
            Object.defineProperty(obj, name, {
                writable: true,
                enumerable: false,
                configurable: true,
                value: value
            })
        };
    } catch(e) {
        return function(obj, name, value) {
            obj[name] = value;
        };
    }
}());

var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',
'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',
'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',
'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',
'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];

function Context() {}
Context.prototype = {};

var Script = exports.Script = function NodeScript (code) {
    if (!(this instanceof Script)) return new Script(code);
    this.code = code;
};

Script.prototype.runInContext = function (context) {
    if (!(context instanceof Context)) {
        throw new TypeError("needs a 'context' argument.");
    }
    
    var iframe = document.createElement('iframe');
    if (!iframe.style) iframe.style = {};
    iframe.style.display = 'none';
    
    document.body.appendChild(iframe);
    
    var win = iframe.contentWindow;
    var wEval = win.eval, wExecScript = win.execScript;

    if (!wEval && wExecScript) {
        // win.eval() magically appears when this is called in IE:
        wExecScript.call(win, 'null');
        wEval = win.eval;
    }
    
    forEach(Object_keys(context), function (key) {
        win[key] = context[key];
    });
    forEach(globals, function (key) {
        if (context[key]) {
            win[key] = context[key];
        }
    });
    
    var winKeys = Object_keys(win);

    var res = wEval.call(win, this.code);
    
    forEach(Object_keys(win), function (key) {
        // Avoid copying circular objects like `top` and `window` by only
        // updating existing context properties or new properties in the `win`
        // that was only introduced after the eval.
        if (key in context || indexOf(winKeys, key) === -1) {
            context[key] = win[key];
        }
    });

    forEach(globals, function (key) {
        if (!(key in context)) {
            defineProp(context, key, win[key]);
        }
    });
    
    document.body.removeChild(iframe);
    
    return res;
};

Script.prototype.runInThisContext = function () {
    return eval(this.code); // maybe...
};

Script.prototype.runInNewContext = function (context) {
    var ctx = Script.createContext(context);
    var res = this.runInContext(ctx);

    forEach(Object_keys(ctx), function (key) {
        context[key] = ctx[key];
    });

    return res;
};

forEach(Object_keys(Script.prototype), function (name) {
    exports[name] = Script[name] = function (code) {
        var s = Script(code);
        return s[name].apply(s, [].slice.call(arguments, 1));
    };
});

exports.createScript = function (code) {
    return exports.Script(code);
};

exports.createContext = Script.createContext = function (context) {
    var copy = new Context();
    if(typeof context === 'object') {
        forEach(Object_keys(context), function (key) {
            copy[key] = context[key];
        });
    }
    return copy;
};

},{"indexof":"/Users/avojeez0/Sites/doomsynth/node_modules/browserify/node_modules/vm-browserify/node_modules/indexof/index.js"}],"/Users/avojeez0/Sites/doomsynth/node_modules/browserify/node_modules/vm-browserify/node_modules/indexof/index.js":[function(require,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],"/Users/avojeez0/Sites/doomsynth/node_modules/flocking/dist/flocking-no-jquery.js":[function(require,module,exports){
(function (global){
/*! Flocking 0.1.4 (October 1, 2015), Copyright 2015 Colin Clark | flockingjs.org */

(function (root, factory) {
    if (typeof exports === "object") {
        // We're in a CommonJS-style loader.
        root.flock = exports;  // Always create the "flock" global.
        factory(exports, require("jquery"));
    } else if (typeof define === "function" && define.amd) {
        // We're in an AMD-style loader.
        define(["exports", "jquery"], function (exports, jQuery) {
            root.flock = exports; // Always create the "flock" global.
            return (root.flock, factory(exports, jQuery));
        });
    } else {
        // Plain old browser.
        root.flock = {};
        factory(root.flock, jQuery);
    }
}(this, function (exports, jQuery) {
    // To hell with isolationism.
    window.jQuery = jQuery;
;/*!
 * Fluid Infusion v2.0
 *
 * Infusion is distributed under the Educational Community License 2.0 and new BSD licenses:
 * http://wiki.fluidproject.org/display/fluid/Fluid+Licensing
 *
 * For information on copyright, see the individual Infusion source code files:
 * https://github.com/fluid-project/infusion/
 */
/*
Copyright 2007-2010 University of Cambridge
Copyright 2007-2009 University of Toronto
Copyright 2007-2009 University of California, Berkeley
Copyright 2010-2011 Lucendo Development Ltd.
Copyright 2010 OCAD University
Copyright 2011 Charly Molter

Licensed under the Educational Community License (ECL), Version 2.0 or the New
BSD license. You may not use this file except in compliance with one these
Licenses.

You may obtain a copy of the ECL 2.0 License and BSD License at
https://github.com/fluid-project/infusion/raw/master/Infusion-LICENSE.txt
*/

// Declare dependencies
/* global console, opera, YAHOO*/

var fluid_2_0 = fluid_2_0 || {};
var fluid = fluid || fluid_2_0;

(function ($, fluid) {
    "use strict";

    fluid.version = "Infusion 2.0-SNAPSHOT";

    // Export this for use in environments like node.js, where it is useful for
    // configuring stack trace behaviour
    fluid.Error = Error;

    fluid.environment = {
        fluid: fluid
    };

    fluid.global = fluid.global || window || {};

    // A standard utility to schedule the invocation of a function after the current
    // stack returns. On browsers this defaults to setTimeout(func, 1) but in
    // other environments can be customised - e.g. to process.nextTick in node.js
    // In future, this could be optimised in the browser to not dispatch into the event queue
    fluid.invokeLater = function (func) {
        return setTimeout(func, 1);
    };

    // The following flag defeats all logging/tracing activities in the most performance-critical parts of the framework.
    // This should really be performed by a build-time step which eliminates calls to pushActivity/popActivity and fluid.log.
    fluid.defeatLogging = true;

    // This flag enables the accumulating of all "activity" records generated by pushActivity into a running trace, rather
    // than removing them from the stack record permanently when receiving popActivity. This trace will be consumed by
    // visual debugging tools.
    fluid.activityTracing = false;
    fluid.activityTrace = [];

    var activityParser = /(%\w+)/g;

    // Renders a single activity element in a form suitable to be sent to a modern browser's console
    // unsupported, non-API function
    fluid.renderOneActivity = function (activity, nowhile) {
        var togo = nowhile === true ? [] : ["    while "];
        var message = activity.message;
        var index = activityParser.lastIndex = 0;
        while (true) {
            var match = activityParser.exec(message);
            if (match) {
                var key = match[1].substring(1);
                togo.push(message.substring(index, match.index));
                togo.push(activity.args[key]);
                index = activityParser.lastIndex;
            }
            else {
                break;
            }
        }
        if (index < message.length) {
            togo.push(message.substring(index));
        }
        return togo;
    };

    // Renders an activity stack in a form suitable to be sent to a modern browser's console
    // unsupported, non-API function
    fluid.renderActivity = function (activityStack, renderer) {
        renderer = renderer || fluid.renderOneActivity;
        return fluid.transform(activityStack, renderer);
    };

    // Return an array of objects describing the current activity
    // unsupported, non-API function
    fluid.getActivityStack = function () {
        var root = fluid.globalThreadLocal();
        if (!root.activityStack) {
            root.activityStack = [];
        }
        return root.activityStack;
    };

    // Return an array of objects describing the current activity
    // unsupported, non-API function
    fluid.describeActivity = fluid.getActivityStack;

    // Renders either the current activity or the supplied activity to the console
    fluid.logActivity = function (activity) {
        activity = activity || fluid.describeActivity();
        var rendered = fluid.renderActivity(activity).reverse();
        fluid.log("Current activity: ");
        fluid.each(rendered, function (args) {
            fluid.doLog(args);
        });
    };

    // Execute the supplied function with the specified activity description pushed onto the stack
    // unsupported, non-API function
    fluid.pushActivity = function (type, message, args) {
        var record = {type: type, message: message, args: args, time: new Date().getTime()};
        if (fluid.activityTracing) {
            fluid.activityTrace.push(record);
        }
        if (fluid.passLogLevel(fluid.logLevel.TRACE)) {
            fluid.doLog(fluid.renderOneActivity(record, true));
        }
        var activityStack = fluid.getActivityStack();
        activityStack.push(record);
    };

    // Undo the effect of the most recent pushActivity, or multiple frames if an argument is supplied
    fluid.popActivity = function (popframes) {
        popframes = popframes || 1;
        if (fluid.activityTracing) {
            fluid.activityTrace.push({pop: popframes});
        }
        var activityStack = fluid.getActivityStack();
        var popped = activityStack.length - popframes;
        activityStack.length = popped < 0 ? 0 : popped;
    };
    // "this-ist" style Error so that we can distinguish framework errors whilst still retaining access to platform Error features
    // unsupported, non-API function
    fluid.FluidError = function (message) {
        this.message = message;
        this.stack = new Error().stack;
    };
    fluid.FluidError.prototype = new Error();

    // The framework's built-in "fail" policy, in case a user-defined handler would like to
    // defer to it
    fluid.builtinFail = function (soft, args, activity) {
        fluid.log.apply(null, [fluid.logLevel.FAIL, "ASSERTION FAILED: "].concat(args));
        fluid.logActivity(activity);
        var message = args.join("");
        if (soft) {
            throw new fluid.FluidError(message);
        } else {
            message["Assertion failure - check console for details"](); // Intentionally cause a browser error by invoking a nonexistent function.
        }
    };

    var softFailure = [false];

    /**
     * Signals an error to the framework. The default behaviour is to log a structured error message and throw a variety of
     * exception (hard or soft) - see fluid.pushSoftFailure for configuration
     *
     * @param {String} message the error message to log
     * @param ... Additional arguments, suitable for being sent to native console.log function
     */
    fluid.fail = function (/* message, ... */) {
        var args = fluid.makeArray(arguments);
        var activity = fluid.makeArray(fluid.describeActivity()); // Take copy since we will destructively modify
        fluid.popActivity(activity.length);
        var topFailure = softFailure[0];
        if (typeof(topFailure) === "boolean") {
            fluid.builtinFail(topFailure, args, activity);
        } else if (typeof(topFailure) === "function") {
            topFailure(args, activity);
        }
    };

    /**
     * Configure the behaviour of fluid.fail by pushing or popping a disposition record onto a stack.
     * @param {Boolean|Number|Function} condition
     & Supply either a boolean flag choosing between built-in framework strategies to be used in fluid.fail
     * - <code>false</code>, the default causes a "hard failure" by using a nonexistent property on a String, which
     * will in all known environments trigger an unhandleable exception which aids debugging. The boolean value
     * <code>true</code> downgrades this behaviour to throw a conventional exception, which is more appropriate in
     * test cases which need to demonstrate failure, as well as in some production environments.
     * The argument may also be a function, which will be called with two arguments, args (the complete arguments to
     * fluid.fail) and activity, an array of strings describing the current framework invocation state.
     * Finally, the argument may be the number <code>-1</code> indicating that the previously supplied disposition should
     * be popped off the stack
     */
    fluid.pushSoftFailure = function (condition) {
        if (typeof (condition) === "boolean" || typeof (condition) === "function") {
            softFailure.unshift(condition);
        } else if (condition === -1) {
            softFailure.shift();
        }
    };

    fluid.notrycatch = true;

    // A wrapper for the try/catch/finally language feature, to aid debugging on environments
    // such as IE, where any try will destroy stack information for errors
    // TODO: The only non-deprecated call to this annoying utility is left in DataBinding.js to deal with
    // cleanup in source tracking. We should really review whether we mean to abolish all exception handling
    // code throughout the framework - on several considerations this is desirable.
    fluid.tryCatch = function (tryfun, catchfun, finallyfun) {
        finallyfun = finallyfun || fluid.identity;
        if (fluid.notrycatch) {
            var togo = tryfun();
            finallyfun();
            return togo;
        } else {
            try {
                return tryfun();
            } catch (e) {
                if (catchfun) {
                    catchfun(e);
                } else {
                    throw (e);
                }
            } finally {
                finallyfun();
            }
        }
    };

    // TODO: rescued from kettleCouchDB.js - clean up in time
    fluid.expect = function (name, members, target) {
        fluid.transform(fluid.makeArray(members), function (key) {
            if (typeof target[key] === "undefined") {
                fluid.fail(name + " missing required parameter " + key);
            }
        });
    };

    // Logging

    /** Returns whether logging is enabled **/
    fluid.isLogging = function () {
        return logLevelStack[0].priority > fluid.logLevel.IMPORTANT.priority;
    };

    /** Determines whether the supplied argument is a valid logLevel marker **/
    fluid.isLogLevel = function (arg) {
        return fluid.isMarker(arg) && arg.priority !== undefined;
    };

    /** Accepts one of the members of the <code>fluid.logLevel</code> structure. Returns <code>true</code> if
     *  a message supplied at that log priority would be accepted at the current logging level. Clients who
     *  issue particularly expensive log payload arguments are recommended to guard their logging statements with this
     *  function */

    fluid.passLogLevel = function (testLogLevel) {
        return testLogLevel.priority <= logLevelStack[0].priority;
    };

    /** Method to allow user to control the logging level. Accepts either a boolean, for which <code>true</code>
      * represents <code>fluid.logLevel.INFO</code> and <code>false</code> represents <code>fluid.logLevel.IMPORTANT</code> (the default),
      * or else any other member of the structure <code>fluid.logLevel</code>
      * Messages whose priority is strictly less than the current logging level will not be shown*/
    fluid.setLogging = function (enabled) {
        var logLevel;
        if (typeof enabled === "boolean") {
            logLevel = fluid.logLevel[enabled? "INFO" : "IMPORTANT"];
        } else if (fluid.isLogLevel(enabled)) {
            logLevel = enabled;
        } else {
            fluid.fail("Unrecognised fluid logging level ", enabled);
        }
        logLevelStack.unshift(logLevel);
    };

    fluid.setLogLevel = fluid.setLogging;

    /** Undo the effect of the most recent "setLogging", returning the logging system to its previous state **/
    fluid.popLogging = function () {
        return logLevelStack.length === 1? logLevelStack[0] : logLevelStack.shift();
    };

    /** Actually do the work of logging <code>args</code> to the environment's console. If the standard "console"
     * stream is available, the message will be sent there - otherwise either the
     * YAHOO logger or the Opera "postError" stream will be used. On capable environments (those other than
     * IE8 or IE9) the entire argument set will be dispatched to the logger - otherwise they will be flattened into
     * a string first, destroying any information held in non-primitive values.
     */
    fluid.doLog = function (args) {
        var str = args.join("");
        if (typeof (console) !== "undefined") {
            if (console.debug) {
                console.debug.apply(console, args);
            } else if (typeof (console.log) === "function") {
                console.log.apply(console, args);
            } else {
                console.log(str); // this branch executes on old IE, fully synthetic console.log
            }
        } else if (typeof (YAHOO) !== "undefined") {
            YAHOO.log(str);
        } else if (typeof (opera) !== "undefined") {
            opera.postError(str);
        }
    };

    /** Log a message to a suitable environmental console. If the first argument to fluid.log is
     * one of the members of the <code>fluid.logLevel</code> structure, this will be taken as the priority
     * of the logged message - else if will default to <code>fluid.logLevel.INFO</code>. If the logged message
     * priority does not exceed that set by the most recent call to the <code>fluid.setLogging</code> function,
     * the message will not appear.
     */
    fluid.log = function (/* message /*, ... */) {
        var directArgs = fluid.makeArray(arguments);
        var userLogLevel = fluid.logLevel.INFO;
        if (fluid.isLogLevel(directArgs[0])) {
            userLogLevel = directArgs.shift();
        }
        if (fluid.passLogLevel(userLogLevel)) {
            var arg0 = fluid.renderTimestamp(new Date()) + ":  ";
            var args = [arg0].concat(directArgs);
            fluid.doLog(args);
        }
    };

    // Functional programming utilities.

    /** A basic utility that returns its argument unchanged */

    fluid.identity = function (arg) {
        return arg;
    };

    // Framework and instantiation functions.


    /** Returns true if the argument is a value other than null or undefined **/
    fluid.isValue = function (value) {
        return value !== undefined && value !== null;
    };

    /** Returns true if the argument is a primitive type **/
    fluid.isPrimitive = function (value) {
        var valueType = typeof (value);
        return !value || valueType === "string" || valueType === "boolean" || valueType === "number" || valueType === "function";
    };

    /** Determines whether the supplied object is an array. The strategy used is an optimised
     * approach taken from an earlier version of jQuery - detecting whether the toString() version
     * of the object agrees with the textual form [object Array], or else whether the object is a
     * jQuery object (the most common source of "fake arrays").
     */
    fluid.isArrayable = function (totest) {
        return totest && (totest.jquery || Object.prototype.toString.call(totest) === "[object Array]");
    };

    /** Determines whether the supplied object is a plain JSON-forming container - that is, it is either a plain Object
     * or a plain Array */
    fluid.isPlainObject = function (totest) {
        if (!totest) {
            return false; // FLUID-5172 - on IE8 the line below produces [object Object] rather than [object Null] or [object Undefined]
        }
        var string = Object.prototype.toString.call(totest);
        return string === "[object Array]" || string === "[object Object]";
    };

    fluid.isDOMNode = function (obj) {
      // This could be more sound, but messy:
      // http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object
      // The real problem is browsers like IE6, 7 and 8 which still do not feature a "constructor" property on DOM nodes
        return obj && typeof (obj.nodeType) === "number";
    };

    fluid.isDOMish = function (obj) {
        return fluid.isDOMNode(obj) || obj.jquery;
    };

    fluid.isComponent = function (obj) {
        // TODO: improve this strategy in time - we may want to actually use a constructor-based test when we can drop IE8
        return obj && obj.typeName && obj.id;
    };

    /** Return an empty container as the same type as the argument (either an
     * array or hash */
    fluid.freshContainer = function (tocopy) {
        return fluid.isArrayable(tocopy) ? [] : {};
    };

    /** Performs a deep copy (clone) of its argument **/

    fluid.copy = function (tocopy) {
        if (fluid.isPrimitive(tocopy)) {
            return tocopy;
        }
        return $.extend(true, fluid.freshContainer(tocopy), tocopy);
    };

    /** Corrected version of jQuery makeArray that returns an empty array on undefined rather than crashing.
      * We don't deal with as many pathological cases as jQuery **/
    fluid.makeArray = function (arg) {
        var togo = [];
        if (arg !== null && arg !== undefined) {
            if (fluid.isPrimitive(arg) || typeof(arg.length) !== "number") {
                togo.push(arg);
            }
            else {
                for (var i = 0; i < arg.length; ++ i) {
                    togo[i] = arg[i];
                }
            }
        }
        return togo;
    };

    function transformInternal(source, togo, key, args) {
        var transit = source[key];
        for (var j = 0; j < args.length - 1; ++j) {
            transit = args[j + 1](transit, key);
        }
        togo[key] = transit;
    }

    /** Return a list or hash of objects, transformed by one or more functions. Similar to
     * jQuery.map, only will accept an arbitrary list of transformation functions and also
     * works on non-arrays.
     * @param source {Array or Object} The initial container of objects to be transformed.
     * @param fn1, fn2, etc. {Function} An arbitrary number of optional further arguments,
     * all of type Function, accepting the signature (object, index), where object is the
     * list member to be transformed, and index is its list index. Each function will be
     * applied in turn to each list member, which will be replaced by the return value
     * from the function.
     * @return The finally transformed list, where each member has been replaced by the
     * original member acted on by the function or functions.
     */
    fluid.transform = function (source) {
        var togo = fluid.freshContainer(source);
        if (fluid.isArrayable(source)) {
            for (var i = 0; i < source.length; ++i) {
                transformInternal(source, togo, i, arguments);
            }
        } else {
            for (var key in source) {
                transformInternal(source, togo, key, arguments);
            }
        }
        return togo;
    };

    /** Better jQuery.each which works on hashes as well as having the arguments
     * the right way round.
     * @param source {Arrayable or Object} The container to be iterated over
     * @param func {Function} A function accepting (value, key) for each iterated
     * object.
     */
    fluid.each = function (source, func) {
        if (fluid.isArrayable(source)) {
            for (var i = 0; i < source.length; ++i) {
                func(source[i], i);
            }
        } else {
            for (var key in source) {
                func(source[key], key);
            }
        }
    };

    fluid.make_find = function (find_if) {
        var target = find_if ? false : undefined;
        return function (source, func, deffolt) {
            var disp;
            if (fluid.isArrayable(source)) {
                for (var i = 0; i < source.length; ++i) {
                    disp = func(source[i], i);
                    if (disp !== target) {
                        return find_if ? source[i] : disp;
                    }
                }
            } else {
                for (var key in source) {
                    disp = func(source[key], key);
                    if (disp !== target) {
                        return find_if ? source[key] : disp;
                    }
                }
            }
            return deffolt;
        };
    };

    /** Scan through a list or hash of objects, terminating on the first member which
     * matches a predicate function.
     * @param source {Arrayable or Object} The list or hash of objects to be searched.
     * @param func {Function} A predicate function, acting on a member. A predicate which
     * returns any value which is not <code>undefined</code> will terminate
     * the search. The function accepts (object, index).
     * @param deflt {Object} A value to be returned in the case no predicate function matches
     * a list member. The default will be the natural value of <code>undefined</code>
     * @return The first return value from the predicate function which is not <code>undefined</code>
     */
    fluid.find = fluid.make_find(false);
    /** The same signature as fluid.find, only the return value is the actual element for which the
     * predicate returns a value different from <code>false</code>
     */
    fluid.find_if = fluid.make_find(true);

    /** Scan through a list of objects, "accumulating" a value over them
     * (may be a straightforward "sum" or some other chained computation). "accumulate" is the name derived
     * from the C++ STL, other names for this algorithm are "reduce" or "fold".
     * @param list {Array} The list of objects to be accumulated over.
     * @param fn {Function} An "accumulation function" accepting the signature (object, total, index) where
     * object is the list member, total is the "running total" object (which is the return value from the previous function),
     * and index is the index number.
     * @param arg {Object} The initial value for the "running total" object.
     * @return {Object} the final running total object as returned from the final invocation of the function on the last list member.
     */
    fluid.accumulate = function (list, fn, arg) {
        for (var i = 0; i < list.length; ++i) {
            arg = fn(list[i], arg, i);
        }
        return arg;
    };

    /** Scan through a list or hash of objects, removing those which match a predicate. Similar to
     * jQuery.grep, only acts on the list in-place by removal, rather than by creating
     * a new list by inclusion.
     * @param source {Array|Object} The list or hash of objects to be scanned over.
     * @param fn {Function} A predicate function determining whether an element should be
     * removed. This accepts the standard signature (object, index) and returns a "truthy"
     * result in order to determine that the supplied object should be removed from the list.
     * @param target {Array|Object} (optional) A target object of the same type as <code>source</code>, which will
     * receive any objects removed from it.
     * @return <code>target</code>, containing the removed elements, if it was supplied, or else <code>source</code>
     * modified by the operation of removing the matched elements.
     */
    fluid.remove_if = function (source, fn, target) {
        if (fluid.isArrayable(source)) {
            for (var i = source.length - 1; i >= 0; --i) {
                if (fn(source[i], i)) {
                    if (target) {
                        target.unshift(source[i]);
                    }
                    source.splice(i, 1);
                }
            }
        } else {
            for (var key in source) {
                if (fn(source[key], key)) {
                    if (target) {
                        target[key] = source[key];
                    }
                    delete source[key];
                }
            }
        }
        return target || source;
    };

    /** Fills an array of given size with copies of a value or result of a function invocation
     * @param n {Number} The size of the array to be filled
     * @param generator {Object|Function} Either a value to be replicated or function to be called
     * @param applyFunc {Boolean} If true, treat the generator value as a function to be invoked with
     * argument equal to the index position
     */

    fluid.generate = function (n, generator, applyFunc) {
        var togo = [];
        for (var i = 0; i < n; ++ i) {
            togo[i] = applyFunc? generator(i) : generator;
        }
        return togo;
    };

    /** Returns an array of size count, filled with increasing integers, starting at 0 or at the index specified by first.
     * @param count {Number} Size of the filled array to be returned
     * @param first {Number} (optional, defaults to 0) First element to appear in the array
     */

    fluid.iota = function (count, first) {
        first = first || 0;
        var togo = [];
        for (var i = 0; i < count; ++i) {
            togo[togo.length] = first++;
        }
        return togo;
    };

    /** Extracts a particular member from each top-level member of a container, returning a new container of the same type
     * @param holder {Array|Object} The container to be filtered
     * @param name {String|Array of String} An EL path to be fetched from each top-level member
     */

    fluid.getMembers = function (holder, name) {
        return fluid.transform(holder, function(member) {
            return fluid.get(member, name);
        });
    };

    /** Accepts an object to be filtered, and a list of keys. Either all keys not present in
     * the list are removed, or only keys present in the list are returned.
     * @param toFilter {Array|Object} The object to be filtered - this will be NOT modified by the operation (current implementation
     * passes through $.extend shallow algorithm)
     * @param keys {Array of String} The list of keys to operate with
     * @param exclude {boolean} If <code>true</code>, the keys listed are removed rather than included
     * @return the filtered object (the same object that was supplied as <code>toFilter</code>
     */

    fluid.filterKeys = function (toFilter, keys, exclude) {
        return fluid.remove_if($.extend({}, toFilter), function (value, key) {
            return exclude ^ ($.inArray(key, keys) === -1);
        });
    };

    /** A convenience wrapper for <code>fluid.filterKeys</code> with the parameter <code>exclude</code> set to <code>true</code>
     *  Returns the supplied object with listed keys removed */

    fluid.censorKeys = function (toCensor, keys) {
        return fluid.filterKeys(toCensor, keys, true);
    };

    // TODO: This is not as clever an idea as we think it is - this typically inner-loop function will optimise badly due to closure
    fluid.makeFlatten = function (index) {
        return function (obj) {
            var togo = [];
            fluid.each(obj, function (/* value, key */) {
                togo.push(arguments[index]);
            });
            return togo;
        };
    };

    /** Return the keys in the supplied object as an array **/
    fluid.keys = fluid.makeFlatten(1);

    /** Return the values in the supplied object as an array **/
    fluid.values = fluid.makeFlatten(0);

    /**
     * Searches through the supplied object, and returns <code>true</code> if the supplied value
     * can be found
     */
    fluid.contains = function (obj, value) {
        return obj ? (fluid.isArrayable(obj) ? $.inArray(value, obj) !== -1 : fluid.find(obj, function (thisValue) {
            if (value === thisValue) {
                return true;
            }
        })) : undefined;
    };

    /**
     * Searches through the supplied object for the first value which matches the one supplied.
     * @param obj {Object} the Object to be searched through
     * @param value {Object} the value to be found. This will be compared against the object's
     * member using === equality.
     * @return {String} The first key whose value matches the one supplied, or <code>null</code> if no
     * such key is found.
     */
    fluid.keyForValue = function (obj, value) {
        return fluid.find(obj, function (thisValue, key) {
            if (value === thisValue) {
                return key;
            }
        });
    };

    /**
     * This method is now deprecated and will be removed in a future release of Infusion.
     * See fluid.keyForValue instead.
     */
    fluid.findKeyInObject = fluid.keyForValue;

    /** Converts an array into an object whose keys are the elements of the array, each with the value "true"
     */

    fluid.arrayToHash = function (array) {
        var togo = {};
        fluid.each(array, function (el) {
            togo[el] = true;
        });
        return togo;
    };

    /**
     * Clears an object or array of its contents. For objects, each property is deleted.
     *
     * @param {Object|Array} target the target to be cleared
     */
    fluid.clear = function (target) {
        if (fluid.isArrayable(target)) {
            target.length = 0;
        } else {
            for (var i in target) {
                delete target[i];
            }
        }
    };

   /**
    * @param boolean ascending <code>true</code> if a comparator is to be returned which
    * sorts strings in descending order of length
    */
    fluid.compareStringLength = function (ascending) {
        return ascending ? function (a, b) {
            return a.length - b.length;
        } : function (a, b) {
            return b.length - a.length;
        };
    };

    fluid.logLevelsSpec = {
        "FATAL":      0,
        "FAIL":       5,
        "WARN":      10,
        "IMPORTANT": 12, // The default logging "off" level - corresponds to the old "false"
        "INFO":      15, // The default logging "on" level - corresponds to the old "true"
        "TRACE":     20
    };

    /** A structure holding all supported log levels as supplied as a possible first argument to fluid.log
     * Members with a higher value of the "priority" field represent lower priority logging levels */
    // Moved down here since it uses fluid.transform on startup
    fluid.logLevel = fluid.transform(fluid.logLevelsSpec, function (value, key) {
        return {type: "fluid.marker", value: key, priority: value};
    });
    var logLevelStack = [fluid.logLevel.IMPORTANT]; // The stack of active logging levels, with the current level at index 0

    /** A set of special "marker values" used in signalling in function arguments and return values,
      * to partially compensate for JavaScript's lack of distinguished types. These should never appear
      * in JSON structures or other kinds of static configuration. An API specifically documents if it
      * accepts or returns any of these values, and if so, what its semantic is  - most are of private
      * use internal to the framework **/

    /** A special "marker object" representing that a distinguished
     * (probably context-dependent) value should be substituted.
     */
    fluid.VALUE = {type: "fluid.marker", value: "VALUE"};

    /** A special "marker object" representing that no value is present (where
     * signalling using the value "undefined" is not possible - e.g. the return value from a "strategy") */
    fluid.NO_VALUE = {type: "fluid.marker", value: "NO_VALUE"};

    /** A marker indicating that a value requires to be expanded after component construction begins **/
    fluid.EXPAND = {type: "fluid.marker", value: "EXPAND"};
    /** A marker indicating that a value requires to be expanded immediately **/
    fluid.EXPAND_NOW = {type: "fluid.marker", value: "EXPAND_NOW"};

    /** Determine whether an object is any marker, or a particular marker - omit the
     * 2nd argument to detect any marker
     */
    fluid.isMarker = function (totest, type) {
        if (!totest || typeof (totest) !== "object" || totest.type !== "fluid.marker") {
            return false;
        }
        if (!type) {
            return true;
        }
        return totest.value === type.value;
    };

    // Model functions
    fluid.model = {}; // cannot call registerNamespace yet since it depends on fluid.model

    /** Copy a source "model" onto a target **/
    fluid.model.copyModel = function (target, source) {
        fluid.clear(target);
        $.extend(true, target, source);
    };

    /** Parse an EL expression separated by periods (.) into its component segments.
     * @param {String} EL The EL expression to be split
     * @return {Array of String} the component path expressions.
     * TODO: This needs to be upgraded to handle (the same) escaping rules (as RSF), so that
     * path segments containing periods and backslashes etc. can be processed, and be harmonised
     * with the more complex implementations in fluid.pathUtil(data binding).
     */
    fluid.model.parseEL = function (EL) {
        return EL === "" ? [] : String(EL).split(".");
    };

    /** Compose an EL expression from two separate EL expressions. The returned
     * expression will be the one that will navigate the first expression, and then
     * the second, from the value reached by the first. Either prefix or suffix may be
     * the empty string **/

    fluid.model.composePath = function (prefix, suffix) {
        return prefix === "" ? suffix : (suffix === "" ? prefix : prefix + "." + suffix);
    };

    /** Compose any number of path segments, none of which may be empty **/
    fluid.model.composeSegments = function () {
        return fluid.makeArray(arguments).join(".");
    };

    /** Helpful alias for old-style API **/
    fluid.path = fluid.model.composeSegments;
    fluid.composePath = fluid.model.composePath;


    // unsupported, NON-API function
    fluid.requireDataBinding = function () {
        fluid.fail("Please include DataBinding.js in order to operate complex model accessor configuration");
    };

    fluid.model.setWithStrategy = fluid.model.getWithStrategy = fluid.requireDataBinding;

    // unsupported, NON-API function
    fluid.model.resolvePathSegment = function (root, segment, create, origEnv) {
        if (!origEnv && root.resolvePathSegment) {
            return root.resolvePathSegment(segment);
        }
        if (create && root[segment] === undefined) {
            // This optimisation in this heavily used function has a fair effect
            return root[segment] = {}; // jshint ignore:line
        }
        return root[segment];
    };

    // unsupported, NON-API function
    fluid.model.pathToSegments = function (EL, config) {
        var parser = config && config.parser ? config.parser.parse : fluid.model.parseEL;
        var segs = typeof(EL) === "number" || typeof(EL) === "string" ? parser(EL) : EL;
        return segs;
    };

    // Overall strategy skeleton for all implementations of fluid.get/set
    fluid.model.accessImpl = function (root, EL, newValue, config, initSegs, returnSegs, traverser) {
        var segs = fluid.model.pathToSegments(EL, config);
        var initPos = 0;
        if (initSegs) {
            initPos = initSegs.length;
            segs = initSegs.concat(segs);
        }
        var uncess = newValue === fluid.NO_VALUE ? 0 : 1;
        root = traverser(root, segs, initPos, config, uncess);
        if (newValue === fluid.NO_VALUE || newValue === fluid.VALUE) { // get or custom
            return returnSegs ? {root: root, segs: segs} : root;
        }
        else { // set
            root[segs[segs.length - 1]] = newValue;
        }
    };

    // unsupported, NON-API function
    fluid.model.accessSimple = function (root, EL, newValue, environment, initSegs, returnSegs) {
        return fluid.model.accessImpl(root, EL, newValue, environment, initSegs, returnSegs, fluid.model.traverseSimple);
    };

    // unsupported, NON-API function
    fluid.model.traverseSimple = function (root, segs, initPos, environment, uncess) {
        var origEnv = environment;
        var limit = segs.length - uncess;
        for (var i = 0; i < limit; ++i) {
            if (!root) {
                return root;
            }
            var segment = segs[i];
            if (environment && environment[segment]) {
                root = environment[segment];
            } else {
                root = fluid.model.resolvePathSegment(root, segment, uncess === 1, origEnv);
            }
            environment = null;
        }
        return root;
    };

    fluid.model.setSimple = function (root, EL, newValue, environment, initSegs) {
        fluid.model.accessSimple(root, EL, newValue, environment, initSegs, false);
    };

    /** Optimised version of fluid.get for uncustomised configurations **/

    fluid.model.getSimple = function (root, EL, environment, initSegs) {
        if (EL === null || EL === undefined || EL.length === 0) {
            return root;
        }
        return fluid.model.accessSimple(root, EL, fluid.NO_VALUE, environment, initSegs, false);
    };

    // unsupported, NON-API function
    // Returns undefined to signal complex configuration which needs to be farmed out to DataBinding.js
    // any other return represents an environment value AND a simple configuration we can handle here
    fluid.decodeAccessorArg = function (arg3) {
        return (!arg3 || arg3 === fluid.model.defaultGetConfig || arg3 === fluid.model.defaultSetConfig) ?
            null : (arg3.type === "environment" ? arg3.value : undefined);
    };

    fluid.set = function (root, EL, newValue, config, initSegs) {
        var env = fluid.decodeAccessorArg(config);
        if (env === undefined) {
            fluid.model.setWithStrategy(root, EL, newValue, config, initSegs);
        } else {
            fluid.model.setSimple(root, EL, newValue, env, initSegs);
        }
    };

    /** Evaluates an EL expression by fetching a dot-separated list of members
     * recursively from a provided root.
     * @param root The root data structure in which the EL expression is to be evaluated
     * @param {string/array} EL The EL expression to be evaluated, or an array of path segments
     * @param config An optional configuration or environment structure which can customise the fetch operation
     * @return The fetched data value.
     */

    fluid.get = function (root, EL, config, initSegs) {
        var env = fluid.decodeAccessorArg(config);
        return env === undefined ?
            fluid.model.getWithStrategy(root, EL, config, initSegs)
            : fluid.model.accessImpl(root, EL, fluid.NO_VALUE, env, null, false, fluid.model.traverseSimple);
    };

    // This backward compatibility will be maintained for a number of releases, probably until Fluid 2.0
    fluid.model.setBeanValue = fluid.set;
    fluid.model.getBeanValue = fluid.get;

    fluid.getGlobalValue = function (path, env) {
        if (path) {
            env = env || fluid.environment;
            return fluid.get(fluid.global, path, {type: "environment", value: env});
        }
    };

    /**
     * Allows for the binding to a "this-ist" function
     * @param {Object} obj, "this-ist" object to bind to
     * @param {Object} fnName, the name of the function to call
     * @param {Object} args, arguments to call the function with
     */
    fluid.bind = function (obj, fnName, args) {
        return obj[fnName].apply(obj, fluid.makeArray(args));
    };

    /**
     * Allows for the calling of a function from an EL expression "functionPath", with the arguments "args", scoped to an framework version "environment".
     * @param {Object} functionPath - An EL expression
     * @param {Object} args - An array of arguments to be applied to the function, specified in functionPath
     * @param {Object} environment - (optional) The object to scope the functionPath to  (typically the framework root for version control)
     */
    fluid.invokeGlobalFunction = function (functionPath, args, environment) {
        var func = fluid.getGlobalValue(functionPath, environment);
        if (!func) {
            fluid.fail("Error invoking global function: " + functionPath + " could not be located");
        } else {
            // FLUID-4915: Fixes an issue for IE8 by defaulting to an empty array when args are falsey.
            return func.apply(null, args || []);
        }
    };

    /** Registers a new global function at a given path
     */

    fluid.registerGlobalFunction = function (functionPath, func, env) {
        env = env || fluid.environment;
        fluid.set(fluid.global, functionPath, func, {type: "environment", value: env});
    };

    fluid.setGlobalValue = fluid.registerGlobalFunction;

    /** Ensures that an entry in the global namespace exists. If it does not, a new entry is created as {} and returned. If an existing
     * value is found, it is returned instead **/
    fluid.registerNamespace = function (naimspace, env) {
        env = env || fluid.environment;
        var existing = fluid.getGlobalValue(naimspace, env);
        if (!existing) {
            existing = {};
            fluid.setGlobalValue(naimspace, existing, env);
        }
        return existing;
    };

    // stubs for two functions in FluidDebugging.js
    fluid.dumpEl = fluid.identity;
    fluid.renderTimestamp = fluid.identity;


    /*** The Model Events system. ***/

    fluid.registerNamespace("fluid.event");

    fluid.generateUniquePrefix = function () {
        return (Math.floor(Math.random() * 1e12)).toString(36) + "-";
    };

    var fluid_prefix = fluid.generateUniquePrefix();

    fluid.fluidInstance = fluid_prefix;

    var fluid_guid = 1;

    /** Allocate an string value that will be very likely unique within this Fluid scope (frame or process) **/

    fluid.allocateGuid = function () {
        return fluid_prefix + (fluid_guid++);
    };

    fluid.event.identifyListener = function (listener, soft) {
        if (typeof(listener) !== "string" && !listener.$$fluid_guid && !soft) {
            listener.$$fluid_guid = fluid.allocateGuid();
        }
        return listener.$$fluid_guid;
    };

    // unsupported, NON-API function
    fluid.event.impersonateListener = function (origListener, newListener) {
        fluid.event.identifyListener(origListener);
        newListener.$$fluid_guid = origListener.$$fluid_guid;
    };

    // unsupported, NON-API function
    fluid.event.mapPriority = function (priority, count) {
        // TODO: This should respect both priority and count by a bit-partitioning scheme
        return (priority === null || priority === undefined ? count :
           (priority === "last" ? Number.MAX_VALUE :
              (priority === "first" ? -Number.MAX_VALUE : -priority)));
    };

    // unsupported, NON-API function
    fluid.priorityComparator = function (recA, recB) {
        return recA.priority - recB.priority;
    };

    // unsupported, NON-API function
    fluid.event.sortListeners = function (listeners) {
        var togo = [];
        fluid.each(listeners, function (oneNamespace) {
            var headHard; // notify only the first listener with hard namespace - or else all if all are soft
            for (var i = 0; i < oneNamespace.length; ++ i) {
                var thisListener = oneNamespace[i];
                if (!thisListener.softNamespace && !headHard) {
                    headHard = thisListener;
                }
            }
            if (headHard) {
                togo.push(headHard);
            } else {
                togo = togo.concat(oneNamespace);
            }
        });
        return togo.sort(fluid.priorityComparator);
    };

    // unsupported, non-API function
    fluid.event.invokeListener = function (listener, args) {
        if (typeof(listener) === "string") {
            listener = fluid.event.resolveListener({globalName: listener}); // just resolves globals
        }
        return listener.apply(null, args);
    };

    // unsupported, NON-API function
    fluid.event.resolveListener = function (listener) {
        if (listener.globalName) {
            var listenerFunc = fluid.getGlobalValue(listener.globalName);
            if (!listenerFunc) {
                fluid.fail("Unable to look up name " + listener.globalName + " as a global function");
            } else {
                listener = listenerFunc;
            }
        }
        return listener;
    };

    /** Generate a name for a component for debugging purposes */
    fluid.nameComponent = function (that) {
        return that ? "component with typename " + that.typeName + " and id " + that.id : "[unknown component]";
    };

    fluid.event.nameEvent = function (that, eventName) {
        return eventName + " of " + fluid.nameComponent(that);
    };

    /** Construct an "event firer" object which can be used to register and deregister
     * listeners, to which "events" can be fired. These events consist of an arbitrary
     * function signature. General documentation on the Fluid events system is at
     * http://wiki.fluidproject.org/display/fluid/The+Fluid+Event+System .
     * @param {Object} options - A structure to configure this event firer. Supported fields:
     *     {String} name - a name for this firer
     *     {Boolean} preventable - If <code>true</code> the return value of each handler will
     * be checked for <code>false</code> in which case further listeners will be shortcircuited, and this
     * will be the return value of fire()
     */
    fluid.makeEventFirer = function (options) {
        options = options || {};
        var name = options.name || "<anonymous>";
        var that;
        function fireToListeners(listeners, args, wrapper) {
            if (!listeners || that.destroyed) { return; }
            fluid.log(fluid.logLevel.TRACE, "Firing event " + name + " to list of " + listeners.length + " listeners");
            for (var i = 0; i < listeners.length; ++i) {
                var lisrec = listeners[i];
                lisrec.listener = fluid.event.resolveListener(lisrec.listener);
                var listener = lisrec.listener;

                if (lisrec.predicate && !lisrec.predicate(listener, args)) {
                    continue;
                }
                var value;
                var ret = (wrapper ? wrapper(listener) : listener).apply(null, args);
                if (options.preventable && ret === false || that.destroyed) {
                    value = false;
                }
                if (value !== undefined) {
                    return value;
                }
            }
        }
        var identify = fluid.event.identifyListener;

        var lazyInit = function () { // Lazy init function to economise on object references for events which are never listened to
            that.listeners = {};
            that.byId = {};
            that.sortedListeners = [];
            that.addListener = function (listener, namespace, predicate, priority, softNamespace) {
                if (that.destroyed) {
                    fluid.fail("Cannot add listener to destroyed event firer " + that.name);
                }
                if (!listener) {
                    return;
                }
                if (typeof(listener) === "string") {
                    listener = {globalName: listener};
                }
                var id = identify(listener);
                namespace = namespace || id;
                var record = {listener: listener, predicate: predicate,
                    namespace: namespace,
                    softNamespace: softNamespace,
                    priority: fluid.event.mapPriority(priority, that.sortedListeners.length)};
                that.byId[id] = record;

                var thisListeners = (that.listeners[namespace] = fluid.makeArray(that.listeners[namespace]));
                thisListeners[softNamespace ? "push" : "unshift"] (record);

                that.sortedListeners = fluid.event.sortListeners(that.listeners);
            };
            that.addListener.apply(null, arguments);
        };
        that = {
            eventId: fluid.allocateGuid(),
            name: name,
            ownerId: options.ownerId,
            typeName: "fluid.event.firer",
            destroy: function () {
                that.destroyed = true;
            },
            addListener: function () {
                lazyInit.apply(null, arguments);
            },

            removeListener: function (listener) {
                if (!that.listeners) { return; }
                var namespace, id, record;
                if (typeof (listener) === "string") {
                    namespace = listener;
                    record = that.listeners[namespace];
                    if (!record) {
                        return;
                    }
                }
                else if (typeof(listener) === "function") {
                    id = identify(listener, true);
                    if (!id) {
                        fluid.fail("Cannot remove unregistered listener function ", listener, " from event " + that.name);
                    }
                }
                var rec = that.byId[id];
                var softNamespace = rec && rec.softNamespace;
                namespace = namespace || (rec && rec.namespace) || id;
                delete that.byId[id];
                record = that.listeners[namespace];
                if (!record) {
                    return;
                }
                if (softNamespace) {
                    fluid.remove_if(record, function (thisLis) {
                        return thisLis.listener.$$fluid_guid === id;
                    });
                } else {
                    record.shift();
                }
                if (record.length === 0) {
                    delete that.listeners[namespace];
                }
                that.sortedListeners = fluid.event.sortListeners(that.listeners);
            },
            // NB - this method exists only to support the old ChangeApplier. It will be removed along with it.
            fireToListeners: function (listeners, args, wrapper) {
                return fireToListeners(listeners, args, wrapper);
            },
            fire: function () {
                return fireToListeners(that.sortedListeners, arguments);
            }
        };
        return that;
    };

    /** Fire the specified event with supplied arguments. This call is an optimisation utility
     * which handles the case where the firer has not been instantiated (presumably as a result
     * of having no listeners registered)
     */

    fluid.fireEvent = function (component, path, args) {
        var firer = fluid.get(component, path);
        if (firer) {
            firer.fire.apply(null, fluid.makeArray(args));
        }
    };

    // unsupported, NON-API function
    fluid.event.addListenerToFirer = function (firer, value, namespace, wrapper) {
        wrapper = wrapper || fluid.identity;
        if (fluid.isArrayable(value)) {
            for (var i = 0; i < value.length; ++i) {
                fluid.event.addListenerToFirer(firer, value[i], namespace, wrapper);
            }
        } else if (typeof (value) === "function" || typeof (value) === "string") {
            wrapper(firer).addListener(value, namespace);
        } else if (value && typeof (value) === "object") {
            wrapper(firer).addListener(value.listener, namespace || value.namespace, value.predicate, value.priority, value.softNamespace);
        }
    };

    // unsupported, NON-API function - non-IOC passthrough
    fluid.event.resolveListenerRecord = function (records) {
        return { records: records };
    };

    fluid.expandOptions = function (material) {
        fluid.fail("fluid.expandOptions could not be loaded - please include FluidIoC.js in order to operate IoC-driven event with descriptor " + material);
    };

    // unsupported, NON-API function
    fluid.mergeListeners = function (that, events, listeners) {
        fluid.each(listeners, function (value, key) {
            var firer, namespace;
            if (key.charAt(0) === "{") {
                firer = fluid.expandOptions(key, that);
                if (!firer) {
                    fluid.fail("Error in listener record: key " + key + " could not be looked up to an event firer - did you miss out \"events.\" when referring to an event firer?");
                }
            } else {
                var keydot = key.indexOf(".");

                if (keydot !== -1) {
                    namespace = key.substring(keydot + 1);
                    key = key.substring(0, keydot);
                }
                if (!events[key]) {
                    fluid.fail("Listener registered for event " + key + " which is not defined for this component");
                }
                firer = events[key];
            }
            var record = fluid.event.resolveListenerRecord(value, that, key, namespace, true);
            fluid.event.addListenerToFirer(firer, record.records, namespace, record.adderWrapper);
        });
    };

    // unsupported, NON-API function
    fluid.eventFromRecord = function (eventSpec, eventKey, that) {
        var isIoCEvent = eventSpec && (typeof (eventSpec) !== "string" || eventSpec.charAt(0) === "{");
        var event;
        if (isIoCEvent) {
            if (!fluid.event.resolveEvent) {
                fluid.fail("fluid.event.resolveEvent could not be loaded - please include FluidIoC.js in order to operate IoC-driven event with descriptor ",
                    eventSpec);
            } else {
                event = fluid.event.resolveEvent(that, eventKey, eventSpec);
            }
        } else {
            event = fluid.makeEventFirer({
                name: fluid.event.nameEvent(that, eventKey),
                preventable: eventSpec === "preventable",
                ownerId: that.id
            });
        }
        return event;
    };

    // unsupported, NON-API function - this is patched from FluidIoC.js
    fluid.instantiateFirers = function (that, options) {
        fluid.each(options.events, function (eventSpec, eventKey) {
            that.events[eventKey] = fluid.eventFromRecord(eventSpec, eventKey, that);
        });
    };

    // unsupported, NON-API function
    fluid.mergeListenerPolicy = function (target, source, key) {
        if (typeof (key) !== "string") {
            fluid.fail("Error in listeners declaration - the keys in this structure must resolve to event names - got " + key + " from ", source);
        }
        // cf. triage in mergeListeners
        var hasNamespace = key.charAt(0) !== "{" && key.indexOf(".") !== -1;
        return hasNamespace ? (source || target) : fluid.arrayConcatPolicy(target, source);
    };

    // unsupported, NON-API function
    fluid.makeMergeListenersPolicy = function (merger) {
        return function (target, source) {
            target = target || {};
            fluid.each(source, function (listeners, key) {
                target[key] = merger(target[key], listeners, key);
            });
            return target;
        };
    };

    /** Removes duplicated and empty elements from an already sorted array **/
    fluid.unique = function (array) {
        return fluid.remove_if(array, function (element, i) {
            return !element || i > 0 && element === array[i - 1];
        });
    };

    fluid.arrayConcatPolicy = function (target, source) {
        return fluid.makeArray(target).concat(fluid.makeArray(source));
    };

    /*** DEFAULTS AND OPTIONS MERGING SYSTEM ***/

    /** Create a "type tag" component with no state but simply a type name and id. The most
     *  minimal form of Fluid component */

    fluid.typeTag = function (name) {
        return name ? {
            typeName: name,
            id: fluid.allocateGuid()
        } : null;
    };

    // Definitions for ThreadLocals, the static and dynamic environment - lifted here from
    // FluidIoC.js so that we can issue calls to fluid.describeActivity for debugging purposes
    // in the core framework

    fluid.staticEnvironment = fluid.typeTag("fluid.staticEnvironment");

    // unsupported, non-API function
    fluid.singleThreadLocal = function (initFunc) {
        var value = initFunc();
        return function (newValue) {
            return newValue === undefined ? value : value = newValue;
        };
    };

    // Currently we only support single-threaded environments - ensure that this function
    // is not used on startup so it can be successfully monkey-patched
    // unsupported, non-API function
    fluid.threadLocal = fluid.singleThreadLocal;

    // unsupported, non-API function
    fluid.globalThreadLocal = fluid.threadLocal(function () {
        return fluid.typeTag("fluid.dynamicEnvironment");
    });

    var gradeTick = 1; // tick counter for managing grade cache invalidation
    var gradeTickStore = {};

    var defaultsStore = {};

    var resolveGradesImpl = function (gs, gradeNames, base) {
        var raw = true;
        if (base) {
            raw = gradeNames.length === 1; // We are just resolving a single grade and populating the cache
        }
        else {
            gradeNames = fluid.makeArray(gradeNames);
        }
        fluid.each(gradeNames, function (gradeName) {
            if (gradeName && !gs.gradeHash[gradeName]) {
                var isDynamic = gradeName.charAt(0) === "{";
                var options = (isDynamic ? null : (raw ? fluid.rawDefaults(gradeName) : fluid.getGradedDefaults(gradeName))) || {};
                var thisTick = gradeTickStore[gradeName] || (gradeTick - 1); // a nonexistent grade is recorded as previous to current
                gs.lastTick = Math.max(gs.lastTick, thisTick);
                gs.gradeHash[gradeName] = true;
                gs.gradeChain.push(gradeName);
                gs.optionsChain.push(options);
                var oGradeNames = fluid.makeArray(options.gradeNames);
                for (var i = 0; i < oGradeNames.length; ++ i) {
                    var oGradeName = oGradeNames[i];
                    var isAuto = oGradeName === "autoInit";
                    if (!raw) {
                        if (!gs.gradeHash[oGradeName] && !isAuto) {
                            gs.gradeHash[oGradeName] = true; // these have already been resolved
                            gs.gradeChain.push(oGradeName);
                        }
                    }
                    else if (!isAuto) {
                        resolveGradesImpl(gs, oGradeName);
                    }
                }
            }
        });
        return gs;
    };

    // unsupported, NON-API function
    fluid.resolveGradeStructure = function (defaultName, gradeNames) {
        var gradeStruct = {
            lastTick: 0,
            gradeChain: [],
            gradeHash: {},
            optionsChain: []
        };
        // stronger grades appear to the left in defaults - dynamic grades are stronger still - FLUID-5085
        return resolveGradesImpl(gradeStruct, (fluid.makeArray(gradeNames).reverse() || []).concat([defaultName]), true);
    };

    var mergedDefaultsCache = {};

    // unsupported, NON-API function
    fluid.gradeNamesToKey = function (defaultName, gradeNames) {
        return defaultName + "|" + gradeNames.join("|");
    };

    fluid.hasGrade = function (options, gradeName) {
        return !options || !options.gradeNames ? false : fluid.contains(options.gradeNames, gradeName);
    };

    // unsupported, NON-API function
    fluid.resolveGrade = function (defaults, defaultName, gradeNames) {
        var gradeStruct = fluid.resolveGradeStructure(defaultName, gradeNames);
        var mergeArgs = gradeStruct.optionsChain.reverse();
        var mergePolicy = {};
        for (var i = 0; i < mergeArgs.length; ++ i) {
            if (mergeArgs[i] && mergeArgs[i].mergePolicy) {
                mergePolicy = $.extend(true, mergePolicy, mergeArgs[i].mergePolicy);
            }
        }
        mergeArgs = [mergePolicy, {}].concat(mergeArgs);
        var mergedDefaults = fluid.merge.apply(null, mergeArgs);
        mergedDefaults.gradeNames = gradeStruct.gradeChain;
        if (fluid.hasGrade(defaults, "autoInit")) {
            mergedDefaults.gradeNames.push("autoInit");
        }
        return {defaults: mergedDefaults, lastTick: gradeStruct && gradeStruct.lastTick};
    };

    // unsupported, NON-API function
    fluid.getGradedDefaults = function (defaultName, gradeNames) {
        gradeNames = fluid.makeArray(gradeNames);
        var key = fluid.gradeNamesToKey(defaultName, gradeNames);
        var mergedDefaults = mergedDefaultsCache[key];
        if (mergedDefaults) {
            var lastTick = 0; // check if cache should be invalidated through real latest tick being later than the one stored
            var searchGrades = mergedDefaults.defaults.gradeNames || [];
            for (var i = 0; i < searchGrades.length; ++ i) {
                lastTick = Math.max(lastTick, gradeTickStore[searchGrades[i]] || 0);
            }
            if (lastTick > mergedDefaults.lastTick) {
                fluid.log("Clearing cache for component " + defaultName + " with gradeNames ", searchGrades);
                mergedDefaults = null;
            }
        }
        if (!mergedDefaults) {
            var defaults = fluid.rawDefaults(defaultName);
            if (!defaults) {
                return defaults;
            }
            mergedDefaults = mergedDefaultsCache[key] = fluid.resolveGrade(defaults, defaultName, gradeNames);
        }
        return mergedDefaults.defaults;
    };

    // unsupported, NON-API function
    // Modify supplied options record to include "componentSource" annotation required by FLUID-5082
    // TODO: This function really needs to act recursively in order to catch listeners registered for subcomponents
    fluid.annotateListeners = function (componentName, options) {
        if (options.listeners) {
            options.listeners = fluid.transform(options.listeners, function (record) {
                var togo = fluid.makeArray(record);
                return fluid.transform(togo, function (onerec) {
                    if (!fluid.isPrimitive(onerec)) {
                        onerec.componentSource = componentName;
                    }
                    return onerec;
                });
            });
        }
    };

    // unsupported, NON-API function
    fluid.rawDefaults = function (componentName, options) {
        if (options === undefined) {
            return defaultsStore[componentName];
        } else {
            fluid.pushActivity("registerDefaults", "registering defaults for grade %componentName with options %options",
                {componentName: componentName, options: options});
            var optionsCopy = fluid.expandCompact ? fluid.expandCompact(options) : fluid.copy(options);
            fluid.annotateListeners(componentName, optionsCopy);
            defaultsStore[componentName] = optionsCopy;
            gradeTickStore[componentName] = gradeTick++;
            fluid.popActivity();
        }
    };

    // unsupported, NON-API function
    fluid.doIndexDefaults = function (defaultName, defaults, index, indexSpec) {
        var requiredGrades = fluid.makeArray(indexSpec.gradeNames);
        for (var i = 0; i < requiredGrades.length; ++ i) {
            if (!fluid.hasGrade(defaults, requiredGrades[i])) { return; }
        }
        var indexFunc = typeof(indexSpec.indexFunc) === "function" ? indexSpec.indexFunc : fluid.getGlobalValue(indexSpec.indexFunc);
        var keys = indexFunc(defaults) || [];
        for (var j = 0; j < keys.length; ++ j) {
            (index[keys[j]] = index[keys[j]] || []).push(defaultName);
        }
    };

    /** Evaluates an index specification over all the defaults records registered into the system.
     * @param indexName {String} The name of this index record (currently ignored)
     * @param indexSpec {Object} Specification of the index to be performed - fields:
     *     gradeNames: {String/Array of String} List of grades that must be matched by this indexer
     *     indexFunc:  {String/Function} An index function which accepts a defaults record and returns a list of keys
     * @return A structure indexing keys to lists of matched gradenames
     */
    // The expectation is that this function is extremely rarely used with respect to registration of defaults
    // in the system, so currently we do not make any attempts to cache the results. The field "indexName" is
    // supplied in case a future implementation chooses to implement caching
    fluid.indexDefaults = function (indexName, indexSpec) {
        var index = {};
        for (var defaultName in defaultsStore) {
            var defaults = fluid.getGradedDefaults(defaultName);
            fluid.doIndexDefaults(defaultName, defaults, index, indexSpec);
        }
        return index;
    };

    /**
     * Retrieves and stores a component's default settings centrally.
     * @param {String} componentName the name of the component
     * @param {Object} (optional) an container of key/value pairs to set
     */

    fluid.defaults = function (componentName, options) {
        if (options === undefined) {
            return fluid.getGradedDefaults(componentName);
        }
        else {
            if (options && options.options) {
                fluid.fail("Probable error in options structure for " + componentName +
                    " with option named \"options\" - perhaps you meant to write these options at top level in fluid.defaults? - ", options);
            }
            fluid.rawDefaults(componentName, options);
            if (fluid.hasGrade(options, "autoInit")) {
                fluid.makeComponent(componentName, fluid.getGradedDefaults(componentName));
            }
        }
    };

    fluid.makeComponent = function (componentName, options) {
        if (!options.gradeNames || options.gradeNames.length === 0) {
            fluid.fail("Cannot autoInit component " + componentName + " which does not have any gradeNames defined");
        } else if (!options.initFunction) {
            var blankGrades = [];
            for (var i = 0; i < options.gradeNames.length; ++ i) {
                var gradeName = options.gradeNames[i];
                var defaults = fluid.rawDefaults(gradeName);
                if (!defaults && gradeName !== "autoInit") {
                    blankGrades.push(gradeName);
                }
            }
            if (blankGrades.length === 0) {
                fluid.fail("Cannot autoInit component " + componentName + " which does not have an initFunction defined");
            } else {
                fluid.fail("The grade hierarchy of component with typeName " + componentName + " is incomplete - it inherits from the following grade(s): " +
                 blankGrades.join(", ") + " for which the grade definitions are corrupt or missing. Please check the files which might include these " +
                 "grades and ensure they are readable and have been loaded by this instance of Infusion");
            }
        }
        var creator = function () {
            return fluid.initComponent(componentName, arguments);
        };
        var existing = fluid.getGlobalValue(componentName);
        if (existing) {
            $.extend(creator, existing);
        }
        fluid.setGlobalValue(componentName, creator);
    };

    fluid.makeComponents = function (components) {
        fluid.each(components, function (value, key) {
            var options = {
                gradeNames: fluid.makeArray(value).concat(["autoInit"])
            };
            fluid.defaults(key, options);
        });
    };

    // Cheapskate implementation which avoids dependency on DataBinding.js
    fluid.model.mergeModel = function (target, source) {
        if (!fluid.isPrimitive(target)) {
            var copySource = fluid.copy(source);
            $.extend(true, source, target);
            $.extend(true, source, copySource);
        }
        return source;
    };

    var emptyPolicy = {};
    // unsupported, NON-API function
    fluid.derefMergePolicy = function (policy) {
        return (policy? policy["*"]: emptyPolicy) || emptyPolicy;
    };

    // unsupported, NON-API function
    fluid.compileMergePolicy = function (mergePolicy) {
        var builtins = {}, defaultValues = {};
        var togo = {builtins: builtins, defaultValues: defaultValues};

        if (!mergePolicy) {
            return togo;
        }
        fluid.each(mergePolicy, function (value, key) {
            var parsed = {}, builtin = true;
            if (typeof(value) === "function") {
                parsed.func = value;
            }
            else if (typeof(value) === "object") {
                parsed = value;
            }
            else if (!fluid.isDefaultValueMergePolicy(value)) {
                var split = value.split(/\s*,\s*/);
                for (var i = 0; i < split.length; ++ i) {
                    parsed[split[i]] = true;
                }
            }
            else {
                // Convert to ginger self-reference - NB, this can only be parsed by IoC
                fluid.set(defaultValues, key, "{that}.options." + value);
                togo.hasDefaults = true;
                builtin = false;
            }
            if (builtin) {
                fluid.set(builtins, fluid.composePath(key, "*"), parsed);
            }
        });
        return togo;
    };

    // TODO: deprecate this method of detecting default value merge policies before 1.6 in favour of
    // explicit typed records a la ModelTransformations
    // unsupported, NON-API function
    fluid.isDefaultValueMergePolicy = function (policy) {
        return typeof(policy) === "string" &&
            (policy.indexOf(",") === -1 && !/replace|preserve|nomerge|noexpand/.test(policy));
    };

    // unsupported, NON-API function
    fluid.mergeOneImpl = function (thisTarget, thisSource, j, sources, newPolicy, i, segs) {
        var togo = thisTarget;

        var primitiveTarget = fluid.isPrimitive(thisTarget);

        if (thisSource !== undefined) {
            if (!newPolicy.func && thisSource !== null && fluid.isPlainObject(thisSource) &&
                    !fluid.isDOMish(thisSource) && thisSource !== fluid.VALUE &&
                    !newPolicy.preserve && !newPolicy.nomerge) {
                if (primitiveTarget) {
                    togo = thisTarget = fluid.freshContainer(thisSource);
                }
                // recursion is now external? We can't do it from here since sources are not all known
                // options.recurse(thisTarget, i + 1, segs, sources, newPolicyHolder, options);
            } else {
                sources[j] = undefined;
                if (newPolicy.func) {
                    togo = newPolicy.func.call(null, thisTarget, thisSource, segs[i - 1], segs, i); // NB - change in this mostly unused argument
                } else {
                    togo = fluid.isValue(thisTarget) && newPolicy.preserve ? fluid.model.mergeModel(thisTarget, thisSource) : thisSource;
                }
            }
        }
        return togo;
    };
    // NB - same quadratic worry about these as in FluidIoC in the case the RHS trundler is live -
    // since at each regeneration step driving the RHS we are discarding the "cursor arguments" these
    // would have to be regenerated at each step - although in practice this can only happen once for
    // each object for all time, since after first resolution it will be concrete.
    function regenerateCursor (source, segs, limit, sourceStrategy) {
        for (var i = 0; i < limit; ++ i) {
            source = sourceStrategy(source, segs[i], i, fluid.makeArray(segs)); // copy for FLUID-5243
        }
        return source;
    }

    function regenerateSources (sources, segs, limit, sourceStrategies) {
        var togo = [];
        for (var i = 0; i < sources.length; ++ i) {
            var thisSource = regenerateCursor(sources[i], segs, limit, sourceStrategies[i]);
            if (thisSource !== undefined) {
                togo.push(thisSource);
            }
        }
        return togo;
    }

    // unsupported, NON-API function
    fluid.fetchMergeChildren = function (target, i, segs, sources, mergePolicy, options) { /* unused parameter left for documentation purposes */ // jshint ignore:line
        var thisPolicy = fluid.derefMergePolicy(mergePolicy);
        for (var j = sources.length - 1; j >= 0; -- j) { // this direction now irrelevant - control is in the strategy
            var source = sources[j];
            // NB - this detection relies on strategy return being complete objects - which they are
            // although we need to set up the roots separately. We need to START the process of evaluating each
            // object root (sources) COMPLETELY, before we even begin! Even if the effect of this is to cause a
            // dispatch into ourselves almost immediately. We can do this because we can take control over our
            // TARGET objects and construct them early. Even if there is a self-dispatch, it will be fine since it is
            // DIRECTED and so will not trouble our "slow" detection of properties. After all self-dispatches end, control
            // will THEN return to "evaluation of arguments" (expander blocks) and only then FINALLY to this "slow"
            // traversal of concrete properties to do the final merge.
            if (source !== undefined) {
                // This use of function creation within a loop is acceptable since
                // the function does not attempt to close directly over the loop counter
                fluid.each(source, function (newSource, name) {
                    if (!target.hasOwnProperty(name)) { // only request each new target key once -- all sources will be queried per strategy
                        segs[i] = name;
                        options.strategy(target, name, i + 1, segs, sources, mergePolicy);
                    }
                });  /* function in loop */ //jshint ignore:line
                if (thisPolicy.replace) { // this branch primarily deals with a policy of replace at the root
                    break;
                }
            }
        }
        return target;
    };

    // A special marker object which will be placed at a current evaluation point in the tree in order
    // to protect against circular evaluation
    fluid.inEvaluationMarker = {"__CURRENTLY_IN_EVALUATION__": true};
    fluid.destroyedMarker = {"__COMPONENT_DESTROYED__": true};

    // A path depth above which the core "process strategies" will bail out, assuming that the
    // structure has become circularly linked. Helpful in environments such as Firebug which will
    // kill the browser process if they happen to be open when a stack overflow occurs. Also provides
    // a more helpful diagnostic.
    fluid.strategyRecursionBailout = 50;

    // unsupported, NON-API function
    fluid.makeMergeStrategy = function (options) {
        var strategy = function (target, name, i, segs, sources, policy) {
            if (i > fluid.strategyRecursionBailout) {
                fluid.fail("Overflow/circularity in options merging, current path is ", segs, " at depth " , i, " - please protect components from merging using the \"nomerge\" merge policy");
            }
            if (fluid.isPrimitive(target)) { // For "use strict"
                return undefined; // Review this after FLUID-4925 since the only trigger is in slow component lookahead
            }
            if (fluid.isTracing) {
                fluid.tracing.pathCount.push(fluid.path(segs.slice(0, i)));
            }

            var oldTarget;
            if (target.hasOwnProperty(name)) { // bail out if our work has already been done
                oldTarget = target[name];
                if (!options.evaluateFully) { // see notes on this hack in "initter" - early attempt to deal with FLUID-4930
                    return oldTarget;
                }
            }
            else { // This is hardwired here for performance reasons - no need to protect deeper strategies
                target[name] = fluid.inEvaluationMarker;
            }
            if (sources === undefined) { // recover our state in case this is an external entry point
                segs = fluid.makeArray(segs); // avoid trashing caller's segs
                sources = regenerateSources(options.sources, segs, i - 1, options.sourceStrategies);
                policy = regenerateCursor(options.mergePolicy, segs, i - 1, fluid.concreteTrundler);
            }
            // var thisPolicy = fluid.derefMergePolicy(policy);
            var newPolicyHolder = fluid.concreteTrundler(policy, name);
            var newPolicy = fluid.derefMergePolicy(newPolicyHolder);

            var start, limit, mul;
            if (newPolicy.replace) {
                start = 1 - sources.length; limit = 0; mul = -1; /* on one line for easier visual comparison of the two algorithms  */ // jshint ignore:line
            }
            else {
                start = 0; limit = sources.length - 1; mul = +1; /* on one line for easier visual comparison of the two algorithms  */ // jshint ignore:line
            }
            var newSources = [];
            var thisTarget;

            for (var j = start; j <= limit; ++j) { // TODO: try to economise on this array and on gaps
                var k = mul * j;
                var thisSource = options.sourceStrategies[k](sources[k], name, i, segs); // Run the RH algorithm in "driving" mode
                if (thisSource !== undefined) {
                    newSources[k] = thisSource;
                    if (oldTarget === undefined) {
                        if (mul === -1) { // if we are going backwards, it is "replace"
                            thisTarget = target[name] = thisSource;
                            break;
                        }
                        else {
                            // write this in early, since early expansions may generate a trunk object which is written in to by later ones
                            thisTarget = target[name] = fluid.mergeOneImpl(thisTarget, thisSource, j, newSources, newPolicy, i, segs, options);
                        }
                    }
                }
            }
            if (oldTarget !== undefined) {
                thisTarget = oldTarget;
            }
            if (newSources.length > 0) {
                if (!fluid.isPrimitive(thisTarget)) {
                    fluid.fetchMergeChildren(thisTarget, i, segs, newSources, newPolicyHolder, options);
                }
            }
            if (oldTarget === undefined && newSources.length === 0) {
                delete target[name]; // remove the evaluation marker - nothing to evaluate
            }
            return thisTarget;
        };
        options.strategy = strategy;
        return strategy;
    };

    // A simple stand-in for "fluid.get" where the material is covered by a single strategy
    fluid.driveStrategy = function (root, pathSegs, strategy) {
        pathSegs = fluid.makeArray(pathSegs);
        for (var i = 0; i < pathSegs.length; ++ i) {
            if (!root) {
                return undefined;
            }
            root = strategy(root, pathSegs[i], i + 1, pathSegs);
        }
        return root;
    };

    // A very simple "new inner trundler" that just performs concrete property access
    // Note that every "strategy" is also a "trundler" of this type, considering just the first two arguments
    fluid.concreteTrundler = function (source, seg) {
        return !source? undefined : source[seg];
    };

    /** Merge a collection of options structures onto a target, following an optional policy.
     * This method is now used only for the purpose of merging "dead" option documents in order to
     * cache graded component defaults. Component option merging is now performed by the
     * fluid.makeMergeOptions pathway which sets up a deferred merging process. This function
     * will not be removed in the Fluid 2.0 release but it is recommended that users not call it
     * directly.
     * The behaviour of this function is explained more fully on
     * the page http://wiki.fluidproject.org/display/fluid/Options+Merging+for+Fluid+Components .
     * @param policy {Object/String} A "policy object" specifiying the type of merge to be performed.
     * If policy is of type {String} it should take on the value "replace" representing
     * a static policy. If it is an
     * Object, it should contain a mapping of EL paths onto these String values, representing a
     * fine-grained policy. If it is an Object, the values may also themselves be EL paths
     * representing that a default value is to be taken from that path.
     * @param options1, options2, .... {Object} an arbitrary list of options structure which are to
     * be merged together. These will not be modified.
     */

    fluid.merge = function (policy /*, ... sources */) {
        var sources = Array.prototype.slice.call(arguments, 1);
        var compiled = fluid.compileMergePolicy(policy).builtins;
        var options = fluid.makeMergeOptions(compiled, sources, {});
        options.initter();
        return options.target;
    };

    // unsupported, NON-API function
    fluid.simpleGingerBlock = function (source, recordType) {
        var block = {
            target: source,
            simple: true,
            strategy: fluid.concreteTrundler,
            initter: fluid.identity,
            recordType: recordType,
            priority: fluid.mergeRecordTypes[recordType]
        };
        return block;
    };

    // unsupported, NON-API function
    fluid.makeMergeOptions = function (policy, sources, userOptions) {
        var options = {
            mergePolicy: policy,
            sources: sources
        };
        options = $.extend(options, userOptions);
        options.target = options.target || fluid.freshContainer(options.sources[0]);
        options.sourceStrategies = options.sourceStrategies || fluid.generate(options.sources.length, fluid.concreteTrundler);
        options.initter = function () {
            // This hack is necessary to ensure that the FINAL evaluation doesn't balk when discovering a trunk path which was already
            // visited during self-driving via the expander. This bi-modality is sort of rubbish, but we currently don't have "room"
            // in the strategy API to express when full evaluation is required - and the "flooding API" is not standardised. See FLUID-4930
            options.evaluateFully = true;
            fluid.fetchMergeChildren(options.target, 0, [], options.sources, options.mergePolicy, options);
        };
        fluid.makeMergeStrategy(options);
        return options;
    };

    // unsupported, NON-API function
    fluid.transformOptions = function (options, transRec) {
        fluid.expect("Options transformation record", ["transformer", "config"], transRec);
        var transFunc = fluid.getGlobalValue(transRec.transformer);
        return transFunc.call(null, options, transRec.config);
    };

    // unsupported, NON-API function
    fluid.findMergeBlocks = function (mergeBlocks, recordType) {
        return fluid.remove_if(fluid.makeArray(mergeBlocks), function (block) { return block.recordType !== recordType; });
    };

    // unsupported, NON-API function
    fluid.transformOptionsBlocks = function (mergeBlocks, transformOptions, recordTypes) {
        fluid.each(recordTypes, function (recordType) {
            var blocks = fluid.findMergeBlocks(mergeBlocks, recordType);
            fluid.each(blocks, function (block) {
                block[block.simple? "target": "source"] = fluid.transformOptions(block.source, transformOptions);
            });
        });
    };

    // unsupported, NON-API function
    fluid.deliverOptionsStrategy = fluid.identity;
    fluid.computeComponentAccessor = fluid.identity;
    fluid.computeDynamicComponents = fluid.identity;

    // The (extensible) types of merge record the system supports, with the weakest records first
    fluid.mergeRecordTypes = {
        defaults:             0,
        localOptions:        50, // provisional
        defaultValueMerge:  100,
        subcomponentRecord: 200,
        distribution:       300,
        // rendererDecorator:  400, // TODO, these are probably honoured already as "user"
        user:               500,
        demands:            600 // and above
    };

    /** Delete the value in the supplied object held at the specified path
     * @param target {Object} The object holding the value to be deleted (possibly empty)
     * @param path {String/Array of String} the path of the value to be deleted
     */

    fluid.destroyValue = function (target, path) {
        if (target) {
            fluid.model.applyChangeRequest(target, {type: "DELETE", path: path});
        }
    };
    /**
     * Merges the component's declared defaults, as obtained from fluid.defaults(),
     * with the user's specified overrides.
     *
     * @param {Object} that the instance to attach the options to
     * @param {String} componentName the unique "name" of the component, which will be used
     * to fetch the default options from store. By recommendation, this should be the global
     * name of the component's creator function.
     * @param {Object} userOptions the user-specified configuration options for this component
     */
    // unsupported, NON-API function
    fluid.mergeComponentOptions = function (that, componentName, userOptions, localOptions) {
        var rawDefaults = fluid.rawDefaults(componentName);
        var defaults = fluid.getGradedDefaults(componentName, rawDefaults && rawDefaults.gradeNames ? null : localOptions.gradeNames);
        var sharedMergePolicy = {};

        var mergeBlocks = [];

        if (fluid.expandComponentOptions) {
            mergeBlocks = mergeBlocks.concat(fluid.expandComponentOptions(sharedMergePolicy, defaults, userOptions, that));
        }
        else {
            mergeBlocks = mergeBlocks.concat([fluid.simpleGingerBlock(defaults, "defaults"),
                                              fluid.simpleGingerBlock(userOptions, "user")]);
        }
        var options = {}; // ultimate target
        var sourceStrategies = [], sources = [];
        var baseMergeOptions = {
            target: options,
            sourceStrategies: sourceStrategies
        };
        // Called both from here and from IoC whenever there is a change of block content or arguments which
        // requires them to be resorted and rebound
        var updateBlocks = function () {
            mergeBlocks.sort(fluid.priorityComparator);
            sourceStrategies.length = 0;
            sources.length = 0;
            fluid.each(mergeBlocks, function (block) {
                sourceStrategies.push(block.strategy);
                sources.push(block.target);
            });
        };
        updateBlocks();
        var mergeOptions = fluid.makeMergeOptions(sharedMergePolicy, sources, baseMergeOptions);
        mergeOptions.mergeBlocks = mergeBlocks;
        mergeOptions.updateBlocks = updateBlocks;
        mergeOptions.destroyValue = function (path) { // This method is a temporary hack to assist FLUID-5091
            for (var i = 0; i < mergeBlocks.length; ++ i) {
                fluid.destroyValue(mergeBlocks[i].target, path);
            }
            fluid.destroyValue(baseMergeOptions.target, path);
        };

        var compiledPolicy;
        var mergePolicy;
        function computeMergePolicy() {
            // Decode the now available mergePolicy
            mergePolicy = fluid.driveStrategy(options, "mergePolicy", mergeOptions.strategy);
            mergePolicy = $.extend({}, fluid.rootMergePolicy, mergePolicy);
            compiledPolicy = fluid.compileMergePolicy(mergePolicy);
            // TODO: expandComponentOptions has already put some builtins here - performance implications of the now huge
            // default mergePolicy material need to be investigated as well as this deep merge
            $.extend(true, sharedMergePolicy, compiledPolicy.builtins); // ensure it gets broadcast to all sharers
        }
        computeMergePolicy();

        if (compiledPolicy.hasDefaults) {
            if (fluid.generateExpandBlock) {
                mergeBlocks.push(fluid.generateExpandBlock({
                        options: compiledPolicy.defaultValues,
                        recordType: "defaultValueMerge",
                        priority: fluid.mergeRecordTypes.defaultValueMerge
                    }, that, {}));
                updateBlocks();
            }
            else {
                fluid.fail("Cannot operate mergePolicy ", mergePolicy, " for component ", that, " without including FluidIoC.js");
            }
        }
        that.options = options;
        var optionsNickName = fluid.driveStrategy(options, "nickName", mergeOptions.strategy);
        that.nickName = optionsNickName || fluid.computeNickName(that.typeName);
        fluid.driveStrategy(options, "gradeNames", mergeOptions.strategy);

        fluid.deliverOptionsStrategy(that, options, mergeOptions); // do this early to broadcast and receive "distributeOptions"

        var transformOptions = fluid.driveStrategy(options, "transformOptions", mergeOptions.strategy);
        if (transformOptions) {
            fluid.transformOptionsBlocks(mergeBlocks, transformOptions, ["user", "subcomponentRecord"]);
            updateBlocks(); // because the possibly simple blocks may have changed target
        }

        fluid.computeComponentAccessor(that);
        if (!baseMergeOptions.target.mergePolicy) {
            computeMergePolicy();
        }

        return mergeOptions;
    };

    // The Fluid Component System proper

    // The base system grade definitions

    fluid.defaults("fluid.function", {});

    /** Invoke a global function by name and named arguments. A courtesy to allow declaratively encoded function calls
     * to use named arguments rather than bare arrays.
     * @param name {String} A global name which can be resolved to a Function. The defaults for this name must
     * resolve onto a grade including "fluid.function". The defaults record should also contain an entry
     * <code>argumentMap</code>, a hash of argument names onto indexes.
     * @param spec {Object} A named hash holding the argument values to be sent to the function. These will be looked
     * up in the <code>argumentMap</code> and resolved into a flat list of arguments.
     * @return {Any} The return value from the function
     */

    fluid.invokeGradedFunction = function (name, spec) {
        var defaults = fluid.defaults(name);
        if (!defaults || !defaults.argumentMap || !fluid.hasGrade(defaults, "fluid.function")) {
            fluid.fail("Cannot look up name " + name +
                " to a function with registered argumentMap - got defaults ", defaults);
        }
        var args = [];
        fluid.each(defaults.argumentMap, function (value, key) {
            args[value] = spec[key];
        });
        return fluid.invokeGlobalFunction(name, args);
    };

    fluid.lifecycleFunctions = {
        preInitFunction: true,
        postInitFunction: true,
        finalInitFunction: true
    };

    fluid.rootMergePolicy = $.extend({
        gradeNames: fluid.arrayConcatPolicy,
        distributeOptions: fluid.arrayConcatPolicy,
        transformOptions: "replace"
    }, fluid.transform(fluid.lifecycleFunctions, function () {
        return fluid.mergeListenerPolicy;
    }));

    fluid.defaults("fluid.littleComponent", {
        gradeNames: ["autoInit"],
        initFunction: "fluid.initLittleComponent",
        mergePolicy: fluid.rootMergePolicy,
        argumentMap: {
            options: 0
        }
    });

    fluid.defaults("fluid.eventedComponent", {
        gradeNames: ["fluid.littleComponent", "autoInit"],
        events: { // Five standard lifecycle points common to all components
            onCreate:     null,
            onAttach:     null, // onAttach, onClear are only fired for IoC-configured components
            onClear:      null,
            onDestroy:    null,
            afterDestroy: null
        },
        mergePolicy: {
            listeners: fluid.makeMergeListenersPolicy(fluid.mergeListenerPolicy)
        }
    });

    /** A special "marker object" which is recognised as one of the arguments to
     * fluid.initSubcomponents. This object is recognised by reference equality -
     * where it is found, it is replaced in the actual argument position supplied
     * to the specific subcomponent instance, with the particular options block
     * for that instance attached to the overall "that" object.
     * NOTE: The use of this marker has been deprecated as of the Fluid 1.4 release in
     * favour of the contextual EL path "{options}" - it will be removed in a future
     * release of the framework.
     */
    fluid.COMPONENT_OPTIONS = {type: "fluid.marker", value: "COMPONENT_OPTIONS"};

    /** Construct a dummy or "placeholder" subcomponent, that optionally provides empty
     * implementations for a set of methods.
     */
    // TODO: this method is inefficient and inappropriate, should simply discard options entirely pending review
    fluid.emptySubcomponent = function (options) {
        var that = fluid.typeTag("fluid.emptySubcomponent");
        that.options = options || {};
        that.options.gradeNames = [that.typeName];

        options = fluid.makeArray(options);
        for (var i = 0; i < options.length; ++i) {
            that[options[i]] = fluid.identity;
        }
        return that;
    };

    /** Compute a "nickname" given a fully qualified typename, by returning the last path
     * segment.
     */

    fluid.computeNickName = function (typeName) {
        var segs = fluid.model.parseEL(typeName);
        return segs[segs.length - 1];
    };

    /** A combined "component and grade name" which allows type tags to be declaratively constructed
     * from options material. Any component found bearing this grade will be instantiated first amongst
     * its set of siblings, since it is likely to bear a context-forming type name */

    fluid.typeFount = function (options) {
        var that = fluid.initLittleComponent("fluid.typeFount", options);
        return fluid.typeTag(that.options.targetTypeName);
    };

    /**
     * Creates a new "little component": a that-ist object with options merged into it by the framework.
     * This method is a convenience for creating small objects that have options but don't require full
     * View-like features such as the DOM Binder or events
     *
     * @param {Object} name the name of the little component to create
     * @param {Object} options user-supplied options to merge with the defaults
     */
    // NOTE: the 3rd argument localOptions is NOT to be advertised as part of the stable API, it is present
    // just to allow backward compatibility whilst grade specifications are not mandatory - similarly for 4th arg "receiver"
    fluid.initLittleComponent = function (name, userOptions, localOptions, receiver) {
        var that = fluid.typeTag(name);
        localOptions = localOptions || {gradeNames: "fluid.littleComponent"};

        that.destroy = fluid.makeRootDestroy(that); // overwritten by FluidIoC for constructed subcomponents
        var mergeOptions = fluid.mergeComponentOptions(that, name, userOptions, localOptions);
        var options = that.options;
        var evented = fluid.hasGrade(options, "fluid.eventedComponent");
        if (evented) {
            that.events = {};
        }
        // deliver to a non-IoC side early receiver of the component (currently only initView)
        (receiver || fluid.identity)(that, options, mergeOptions.strategy);
        fluid.computeDynamicComponents(that, mergeOptions);

        // TODO: ****THIS**** is the point we must deliver and suspend!! Construct the "component skeleton" first, and then continue
        // for as long as we can continue to find components.
        for (var i = 0; i < mergeOptions.mergeBlocks.length; ++ i) {
            mergeOptions.mergeBlocks[i].initter();
        }
        mergeOptions.initter();
        delete options.mergePolicy;

        fluid.initLifecycleFunctions(that);
        fluid.fireEvent(options, "preInitFunction", that);

        if (evented) {
            fluid.instantiateFirers(that, options);
            fluid.mergeListeners(that, that.events, options.listeners);
        }
        if (!fluid.hasGrade(options, "autoInit")) {
            fluid.clearLifecycleFunctions(options);
        }
        return that;
    };

    // unsupported, NON-API function
    fluid.updateWithDefaultLifecycle = function (key, value, typeName) {
        var funcName = typeName + "." + key.substring(0, key.length - "function".length);
        var funcVal = fluid.getGlobalValue(funcName);
        if (typeof (funcVal) === "function") {
            value = fluid.makeArray(value);
            var existing = fluid.find(value, function (el) {
                var listener = el.listener || el;
                if (listener === funcVal || listener === funcName) {
                    return true;
                }
            });
            if (!existing) {
                value.push(funcVal);
            }
        }
        return value;
    };

    // unsupported, NON-API function
    fluid.initLifecycleFunctions = function (that) {
        var gradeNames = that.options.gradeNames || [];
        fluid.each(fluid.lifecycleFunctions, function (func, key) {
            var value = that.options[key];
            for (var i = gradeNames.length - 1; i >= 0; -- i) { // most specific grades are at front
                if (gradeNames[i] !== "autoInit") {
                    value = fluid.updateWithDefaultLifecycle(key, value, gradeNames[i]);
                }
            }
            if (value) {
                that.options[key] = fluid.makeEventFirer({name: key, ownerId: that.id});
                fluid.event.addListenerToFirer(that.options[key], value);
            }
        });
    };

    // unsupported, NON-API function
    fluid.clearLifecycleFunctions = function (options) {
        fluid.each(fluid.lifecycleFunctions, function (value, key) {
            delete options[key];
        });
        delete options.initFunction;
    };

    fluid.diagnoseFailedView = fluid.identity;

    // unsupported, NON-API function
    fluid.makeRootDestroy = function (that) {
        return function () {
            fluid.fireEvent(that, "events.onClear", [that, "", null]);
            fluid.doDestroy(that);
            fluid.fireEvent(that, "events.afterDestroy", [that, "", null]);
        };
    };

    /** Returns <code>true</code> if the supplied reference holds a component which has been destroyed **/

    fluid.isDestroyed = function (that) {
        return that.destroy === fluid.destroyedMarker;
    };

    // unsupported, NON-API function
    fluid.doDestroy = function (that, name, parent) {
        fluid.fireEvent(that, "events.onDestroy", [that, name || "", parent]);
        that.destroy = fluid.destroyedMarker;
        for (var key in that.events) {
            if (key !== "afterDestroy" && typeof(that.events[key].destroy) === "function") {
                that.events[key].destroy();
            }
        }
        if (that.applier) { // TODO: Break this out into the grade's destroyer
            that.applier.destroy();
        }
    };

    fluid.resolveReturnedPath = fluid.identity;

    // unsupported, NON-API function
    fluid.initComponent = function (componentName, initArgs) {
        var options = fluid.defaults(componentName);
        if (!options.gradeNames) {
            fluid.fail("Cannot initialise component " + componentName + " which has no gradeName registered");
        }
        var args = [componentName].concat(fluid.makeArray(initArgs)); // TODO: support different initFunction variants
        var that;
        fluid.pushActivity("initComponent", "constructing component of type %componentName with arguments %initArgs",
            {componentName: componentName, initArgs: initArgs});
        that = fluid.invokeGlobalFunction(options.initFunction, args);
        fluid.diagnoseFailedView(componentName, that, options, args);
        fluid.fireEvent(that.options, "postInitFunction", that);
        if (fluid.initDependents) {
            fluid.initDependents(that);
        }
        fluid.fireEvent(that.options, "finalInitFunction", that);
        fluid.clearLifecycleFunctions(that.options);
        fluid.fireEvent(that, "events.onCreate", that);
        fluid.popActivity();
        return fluid.resolveReturnedPath(that.options.returnedPath, that) ? fluid.get(that, that.options.returnedPath) : that;
    };

    // unsupported, NON-API function
    fluid.initSubcomponentImpl = function (that, entry, args) {
        var togo;
        if (typeof (entry) !== "function") {
            var entryType = typeof (entry) === "string" ? entry : entry.type;
            togo = entryType === "fluid.emptySubcomponent" ?
                fluid.emptySubcomponent(entry.options) :
                fluid.invokeGlobalFunction(entryType, args);
        } else {
            togo = entry.apply(null, args);
        }
        return togo;
    };

    /** Initialise all the "subcomponents" which are configured to be attached to
     * the supplied top-level component, which share a particular "class name". This method
     * of instantiating components is deprecated and will be removed in favour of the automated
     * IoC system in the Fluid 2.0 release.
     * @param {Component} that The top-level component for which sub-components are
     * to be instantiated. It contains specifications for these subcomponents in its
     * <code>options</code> structure.
     * @param {String} className The "class name" or "category" for the subcomponents to
     * be instantiated. A class name specifies an overall "function" for a class of
     * subcomponents and represents a category which accept the same signature of
     * instantiation arguments.
     * @param {Array of Object} args The instantiation arguments to be passed to each
     * constructed subcomponent. These will typically be members derived from the
     * top-level <code>that</code> or perhaps globally discovered from elsewhere. One
     * of these arguments may be <code>fluid.COMPONENT_OPTIONS</code> in which case this
     * placeholder argument will be replaced by instance-specific options configured
     * into the member of the top-level <code>options</code> structure named for the
     * <code>className</code>
     * @return {Array of Object} The instantiated subcomponents, one for each member
     * of <code>that.options[className]</code>.
     */

    fluid.initSubcomponents = function (that, className, args) {
        var entry = that.options[className];
        if (!entry) {
            return;
        }
        var entries = fluid.makeArray(entry);
        var optindex = -1;
        var togo = [];
        args = fluid.makeArray(args);
        for (var i = 0; i < args.length; ++i) {
            if (args[i] === fluid.COMPONENT_OPTIONS) {
                optindex = i;
            }
        }
        for (i = 0; i < entries.length; ++i) {
            entry = entries[i];
            if (optindex !== -1) {
                args[optindex] = entry.options;
            }
            togo[i] = fluid.initSubcomponentImpl(that, entry, args);
        }
        return togo;
    };

    fluid.initSubcomponent = function (that, className, args) {
        return fluid.initSubcomponents(that, className, args)[0];
    };

    // ******* SELECTOR ENGINE *********

    // selector regexps copied from jQuery - recent versions correct the range to start C0
    // The initial portion of the main character selector "just add water" to add on extra
    // accepted characters, as well as the "\\\\." -> "\." portion necessary for matching
    // period characters escaped in selectors
    var charStart = "(?:[\\w\\u00c0-\\uFFFF*_-";

    fluid.simpleCSSMatcher = {
        regexp: new RegExp("([#.]?)(" + charStart + "]|\\\\.)+)", "g"),
        charToTag: {
            "": "tag",
            "#": "id",
            ".": "clazz"
        }
    };

    fluid.IoCSSMatcher = {
        regexp: new RegExp("([&#]?)(" + charStart + "]|\\.)+)", "g"),
        charToTag: {
            "": "context",
            "&": "context",
            "#": "id"
        }
    };

    var childSeg = new RegExp("\\s*(>)?\\s*", "g");
//    var whiteSpace = new RegExp("^\\w*$");

    // Parses a selector expression into a data structure holding a list of predicates
    // 2nd argument is a "strategy" structure, e.g.  fluid.simpleCSSMatcher or fluid.IoCSSMatcher
    // unsupported, non-API function
    fluid.parseSelector = function (selstring, strategy) {
        var togo = [];
        selstring = $.trim(selstring);
        //ws-(ss*)[ws/>]
        var regexp = strategy.regexp;
        regexp.lastIndex = 0;
        var lastIndex = 0;
        while (true) {
            var atNode = []; // a list of predicates at a particular node
            var first = true;
            while (true) {
                var segMatch = regexp.exec(selstring);
                if (!segMatch) {
                    break;
                }
                if (segMatch.index !== lastIndex) {
                    if (first) {
                        fluid.fail("Error in selector string - cannot match child selector expression starting at " + selstring.substring(lastIndex));
                    }
                    else {
                        break;
                    }
                }
                var thisNode = {};
                var text = segMatch[2];
                var targetTag = strategy.charToTag[segMatch[1]];
                if (targetTag) {
                    thisNode[targetTag] = text;
                }
                atNode[atNode.length] = thisNode;
                lastIndex = regexp.lastIndex;
                first = false;
            }
            childSeg.lastIndex = lastIndex;
            var fullAtNode = {predList: atNode};
            var childMatch = childSeg.exec(selstring);
            if (!childMatch || childMatch.index !== lastIndex) {
                fluid.fail("Error in selector string - can not match child selector expression at " + selstring.substring(lastIndex));
            }
            if (childMatch[1] === ">") {
                fullAtNode.child = true;
            }
            togo[togo.length] = fullAtNode;
            // >= test here to compensate for IE bug http://blog.stevenlevithan.com/archives/exec-bugs
            if (childSeg.lastIndex >= selstring.length) {
                break;
            }
            lastIndex = childSeg.lastIndex;
            regexp.lastIndex = childSeg.lastIndex;
        }
        return togo;
    };

    // Message resolution and templating

   /**
    * Converts a string to a regexp with the specified flags given in parameters
    * @param {String} a string that has to be turned into a regular expression
    * @param {String} the flags to provide to the reg exp
    */
    fluid.stringToRegExp = function (str, flags) {
        return new RegExp(str.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&"), flags);
    };

    /**
     * Simple string template system.
     * Takes a template string containing tokens in the form of "%value".
     * Returns a new string with the tokens replaced by the specified values.
     * Keys and values can be of any data type that can be coerced into a string. Arrays will work here as well.
     *
     * @param {String}    template    a string (can be HTML) that contains tokens embedded into it
     * @param {object}    values      a collection of token keys and values
     */
    fluid.stringTemplate = function (template, values) {
        var keys = fluid.keys(values);
        keys = keys.sort(fluid.compareStringLength());
        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            var re = fluid.stringToRegExp("%" + key, "g");
            template = template.replace(re, values[key]);
        }
        return template;
    };

    fluid.defaults("fluid.messageResolver", {
        gradeNames: ["fluid.littleComponent", "autoInit"],
        mergePolicy: {
            messageBase: "nomerge",
            parents: "nomerge"
        },
        resolveFunc: fluid.stringTemplate,
        parseFunc: fluid.identity,
        messageBase: {},
        parents: []
    });

    fluid.messageResolver.preInit = function (that) {
        that.messageBase = that.options.parseFunc(that.options.messageBase);

        that.lookup = function (messagecodes) {
            var resolved = fluid.messageResolver.resolveOne(that.messageBase, messagecodes);
            if (resolved === undefined) {
                return fluid.find(that.options.parents, function (parent) {
                    return parent ? parent.lookup(messagecodes) : undefined;
                });
            } else {
                return {template: resolved, resolveFunc: that.options.resolveFunc};
            }
        };
        that.resolve = function (messagecodes, args) {
            if (!messagecodes) {
                return "[No messagecodes provided]";
            }
            messagecodes = fluid.makeArray(messagecodes);
            var looked = that.lookup(messagecodes);
            return looked ? looked.resolveFunc(looked.template, args) :
                "[Message string for key " + messagecodes[0] + " not found]";
        };
    };

    // unsupported, NON-API function
    fluid.messageResolver.resolveOne = function (messageBase, messagecodes) {
        for (var i = 0; i < messagecodes.length; ++i) {
            var code = messagecodes[i];
            var message = messageBase[code];
            if (message !== undefined) {
                return message;
            }
        }
    };

    /** Converts a data structure consisting of a mapping of keys to message strings,
     * into a "messageLocator" function which maps an array of message codes, to be
     * tried in sequence until a key is found, and an array of substitution arguments,
     * into a substituted message string.
     */
    fluid.messageLocator = function (messageBase, resolveFunc) {
        var resolver = fluid.messageResolver({messageBase: messageBase, resolveFunc: resolveFunc});
        return function (messagecodes, args) {
            return resolver.resolve(messagecodes, args);
        };
    };

})(jQuery, fluid_2_0);
;/*
Copyright 2007-2010 University of Cambridge
Copyright 2007-2009 University of Toronto
Copyright 2010-2011 Lucendo Development Ltd.
Copyright 2010 OCAD University
Copyright 2005-2013 jQuery Foundation, Inc. and other contributors

Licensed under the Educational Community License (ECL), Version 2.0 or the New
BSD license. You may not use this file except in compliance with one these
Licenses.

You may obtain a copy of the ECL 2.0 License and BSD License at
https://github.com/fluid-project/infusion/raw/master/Infusion-LICENSE.txt
*/

/** This file contains functions which depend on the presence of a DOM document
 * but which do not depend on the contents of Fluid.js **/

var fluid_2_0 = fluid_2_0 || {};

(function ($, fluid) {
    "use strict";

    // polyfill for $.browser which was removed in jQuery 1.9 and later
    // Taken from jquery-migrate-1.2.1.js,
    // jQuery Migrate - v1.2.1 - 2013-05-08
    // https://github.com/jquery/jquery-migrate
    // Copyright 2005, 2013 jQuery Foundation, Inc. and other contributors; Licensed MIT

    fluid.uaMatch = function (ua) {
        ua = ua.toLowerCase();

        var match = /(chrome)[ \/]([\w.]+)/.exec( ua ) ||
            /(webkit)[ \/]([\w.]+)/.exec( ua ) ||
            /(opera)(?:.*version|)[ \/]([\w.]+)/.exec( ua ) ||
            /(msie) ([\w.]+)/.exec( ua ) ||
        ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec( ua ) || [];

        return {
            browser: match[ 1 ] || "",
            version: match[ 2 ] || "0"
        };
    };

    var matched, browser;

    // Don't clobber any existing jQuery.browser in case it's different
    if (!$.browser) {
        if (!!navigator.userAgent.match(/Trident\/7\./)) {
            browser = { // From http://stackoverflow.com/questions/18684099/jquery-fail-to-detect-ie-11
                msie: true,
                version: 11
            };
        } else {
            matched = fluid.uaMatch(navigator.userAgent);
            browser = {};

            if (matched.browser) {
                browser[matched.browser] = true;
                browser.version = matched.version;
            }
            // Chrome is Webkit, but Webkit is also Safari.
            if (browser.chrome) {
                browser.webkit = true;
            } else if (browser.webkit) {
                browser.safari = true;
            }
        }
        $.browser = browser;
    }

    // Private constants.
    var NAMESPACE_KEY = "fluid-scoped-data";

    /**
     * Gets stored state from the jQuery instance's data map.
     * This function is unsupported: It is not really intended for use by implementors.
     */
    fluid.getScopedData = function(target, key) {
        var data = $(target).data(NAMESPACE_KEY);
        return data ? data[key] : undefined;
    };

    /**
     * Stores state in the jQuery instance's data map. Unlike jQuery's version,
     * accepts multiple-element jQueries.
     * This function is unsupported: It is not really intended for use by implementors.
     */
    fluid.setScopedData = function(target, key, value) {
        $(target).each(function() {
            var data = $.data(this, NAMESPACE_KEY) || {};
            data[key] = value;

            $.data(this, NAMESPACE_KEY, data);
        });
    };

    /** Global focus manager - makes use of "focusin" event supported in jquery 1.4.2 or later.
     */

    var lastFocusedElement = null;

    $(document).bind("focusin", function (event){
        lastFocusedElement = event.target;
    });

    fluid.getLastFocusedElement = function () {
        return lastFocusedElement;
    };


    var ENABLEMENT_KEY = "enablement";

    /** Queries or sets the enabled status of a control. An activatable node
     * may be "disabled" in which case its keyboard bindings will be inoperable
     * (but still stored) until it is reenabled again.
     * This function is unsupported: It is not really intended for use by implementors.
     */

    fluid.enabled = function(target, state) {
        target = $(target);
        if (state === undefined) {
            return fluid.getScopedData(target, ENABLEMENT_KEY) !== false;
        }
        else {
            $("*", target).add(target).each(function() {
                if (fluid.getScopedData(this, ENABLEMENT_KEY) !== undefined) {
                    fluid.setScopedData(this, ENABLEMENT_KEY, state);
                }
                else if (/select|textarea|input/i.test(this.nodeName)) {
                    $(this).prop("disabled", !state);
                }
            });
            fluid.setScopedData(target, ENABLEMENT_KEY, state);
        }
    };

    fluid.initEnablement = function(target) {
        fluid.setScopedData(target, ENABLEMENT_KEY, true);
    };

    // This utility is required through the use of newer versions of jQuery which will obscure the original
    // event responsible for interaction with a target. This is currently use in Tooltip.js and FluidView.js
    // "dead man's blur" but would be of general utility

    fluid.resolveEventTarget = function (event) {
        while (event.originalEvent && event.originalEvent.target) {
            event = event.originalEvent;
        }
        return event.target;
    };

    // These function (fluid.focus() and fluid.blur()) serve several functions. They should be used by
    // all implementation both in test cases and component implementation which require to trigger a focus
    // event. Firstly, they restore the old behaviour in jQuery versions prior to 1.10 in which a focus
    // trigger synchronously relays to a focus handler. In newer jQueries this defers to the real browser
    // relay with numerous platform and timing-dependent effects.
    // Secondly, they are necessary since simulation of focus events by jQuery under IE
    // is not sufficiently good to intercept the "focusin" binding. Any code which triggers
    // focus or blur synthetically throughout the framework and client code must use this function,
    // especially if correct cross-platform interaction is required with the "deadMansBlur" function.

    function applyOp(node, func) {
        node = $(node);
        node.trigger("fluid-"+func);
        node.triggerHandler(func);
        node[func]();
        return node;
    }

    $.each(["focus", "blur"], function(i, name) {
        fluid[name] = function(elem) {
            return applyOp(elem, name);
        };
    });

})(jQuery, fluid_2_0);
;/*
Copyright 2008-2010 University of Cambridge
Copyright 2008-2009 University of Toronto

Licensed under the Educational Community License (ECL), Version 2.0 or the New
BSD license. You may not use this file except in compliance with one these
Licenses.

You may obtain a copy of the ECL 2.0 License and BSD License at
https://github.com/fluid-project/infusion/raw/master/Infusion-LICENSE.txt
*/

var fluid_2_0 = fluid_2_0 || {};

(function ($, fluid) {
    "use strict";

    fluid.dom = fluid.dom || {};

    // Node walker function for iterateDom.
    var getNextNode = function (iterator) {
        if (iterator.node.firstChild) {
            iterator.node = iterator.node.firstChild;
            iterator.depth += 1;
            return iterator;
        }
        while (iterator.node) {
            if (iterator.node.nextSibling) {
                iterator.node = iterator.node.nextSibling;
                return iterator;
            }
            iterator.node = iterator.node.parentNode;
            iterator.depth -= 1;
        }
        return iterator;
    };

    /**
     * Walks the DOM, applying the specified acceptor function to each element.
     * There is a special case for the acceptor, allowing for quick deletion of elements and their children.
     * Return "delete" from your acceptor function if you want to delete the element in question.
     * Return "stop" to terminate iteration.

     * Implementation note - this utility exists mainly for performance reasons. It was last tested
     * carefully some time ago (around jQuery 1.2) but at that time was around 3-4x faster at raw DOM
     * filtration tasks than the jQuery equivalents, which was an important source of performance loss in the
     * Reorderer component. General clients of the framework should use this method with caution if at all, and
     * the performance issues should be reassessed when we have time.
     *
     * @param {Element} node the node to start walking from
     * @param {Function} acceptor the function to invoke with each DOM element
     * @param {Boolean} allnodes Use <code>true</code> to call acceptor on all nodes,
     * rather than just element nodes (type 1)
     */
    fluid.dom.iterateDom = function (node, acceptor, allNodes) {
        var currentNode = {node: node, depth: 0};
        var prevNode = node;
        var condition;
        while (currentNode.node !== null && currentNode.depth >= 0 && currentNode.depth < fluid.dom.iterateDom.DOM_BAIL_DEPTH) {
            condition = null;
            if (currentNode.node.nodeType === 1 || allNodes) {
                condition = acceptor(currentNode.node, currentNode.depth);
            }
            if (condition) {
                if (condition === "delete") {
                    currentNode.node.parentNode.removeChild(currentNode.node);
                    currentNode.node = prevNode;
                }
                else if (condition === "stop") {
                    return currentNode.node;
                }
            }
            prevNode = currentNode.node;
            currentNode = getNextNode(currentNode);
        }
    };

    // Work around IE circular DOM issue. This is the default max DOM depth on IE.
    // http://msdn2.microsoft.com/en-us/library/ms761392(VS.85).aspx
    fluid.dom.iterateDom.DOM_BAIL_DEPTH = 256;

    /**
     * Checks if the specified container is actually the parent of containee.
     *
     * @param {Element} container the potential parent
     * @param {Element} containee the child in question
     */
    fluid.dom.isContainer = function (container, containee) {
        for (; containee; containee = containee.parentNode) {
            if (container === containee) {
                return true;
            }
        }
        return false;
    };

    /** Return the element text from the supplied DOM node as a single String.
     * Implementation note - this is a special-purpose utility used in the framework in just one
     * position in the Reorderer. It only performs a "shallow" traversal of the text and was intended
     * as a quick and dirty means of extracting element labels where the user had not explicitly provided one.
     * It should not be used by general users of the framework and its presence here needs to be
     * reassessed.
     */
    fluid.dom.getElementText = function (element) {
        var nodes = element.childNodes;
        var text = "";
        for (var i = 0; i < nodes.length; ++i) {
            var child = nodes[i];
            if (child.nodeType === 3) {
                text = text + child.nodeValue;
            }
        }
        return text;
    };

})(jQuery, fluid_2_0);
;/*
Copyright 2007-2010 University of Cambridge
Copyright 2007-2009 University of Toronto
Copyright 2007-2009 University of California, Berkeley
Copyright 2010 OCAD University
Copyright 2010-2011 Lucendo Development Ltd.

Licensed under the Educational Community License (ECL), Version 2.0 or the New
BSD license. You may not use this file except in compliance with one these
Licenses.

You may obtain a copy of the ECL 2.0 License and BSD License at
https://github.com/fluid-project/infusion/raw/master/Infusion-LICENSE.txt
*/

var fluid_2_0 = fluid_2_0 || {};
var fluid = fluid || fluid_2_0;

(function ($, fluid) {
    "use strict";

    /** Render a timestamp from a Date object into a helpful fixed format for debug logs to millisecond accuracy
     * @param date {Date} The date to be rendered
     * @return {String} A string format consisting of hours:minutes:seconds.millis for the datestamp padded to fixed with 
     */

    fluid.renderTimestamp = function (date) {
        var zeropad = function (num, width) {
            if (!width) { width = 2; }
            var numstr = (num === undefined ? "" : num.toString());
            return "00000".substring(5 - width + numstr.length) + numstr;
        };
        return zeropad(date.getHours()) + ":" + zeropad(date.getMinutes()) + ":" + zeropad(date.getSeconds()) + "." + zeropad(date.getMilliseconds(), 3);
    };

    fluid.isTracing = false;

    fluid.registerNamespace("fluid.tracing");

    fluid.tracing.pathCount = [];

    fluid.tracing.summarisePathCount = function (pathCount) {
        pathCount = pathCount || fluid.tracing.pathCount;
        var togo = {};
        for (var i = 0; i < pathCount.length; ++ i) {
            var path = pathCount[i];
            if (!togo[path]) {
                togo[path] = 1;
            }
            else {
                ++togo[path];
            }
        }
        var toReallyGo = [];
        fluid.each(togo, function (el, path) {
            toReallyGo.push({path: path, count: el});
        });
        toReallyGo.sort(function (a, b) {return b.count - a.count;});
        return toReallyGo;
    };

    fluid.tracing.condensePathCount = function (prefixes, pathCount) {
        prefixes = fluid.makeArray(prefixes);
        var prefixCount = {};
        fluid.each(prefixes, function(prefix) {
            prefixCount[prefix] = 0;
        });
        var togo = [];
        fluid.each(pathCount, function (el) {
            var path = el.path;
            if (!fluid.find(prefixes, function(prefix) {
                if (path.indexOf(prefix) === 0) {
                    prefixCount[prefix] += el.count;
                    return true;
                }
            })) {
                togo.push(el);
            }
        });
        fluid.each(prefixCount, function(count, path) {
            togo.unshift({path: path, count: count});
        });
        return togo;
    };

    // Exception stripping code taken from https://github.com/emwendelin/javascript-stacktrace/blob/master/stacktrace.js
    // BSD licence, see header

    fluid.detectStackStyle = function (e) {
        var style = "other";
        var stackStyle = {
            offset: 0
        };
        if (e["arguments"]) {
            style = "chrome";
        } else if (typeof window !== "undefined" && window.opera && e.stacktrace) {
            style = "opera10";
        } else if (e.stack) {
            style = "firefox";
            // Detect FireFox 4-style stacks which are 1 level less deep
            stackStyle.offset = e.stack.indexOf("Trace exception") === -1? 1 : 0;
        } else if (typeof window !== "undefined" && window.opera && !("stacktrace" in e)) { //Opera 9-
            style = "opera";
        }
        stackStyle.style = style;
        return stackStyle;
    };

    fluid.obtainException = function () {
        try {
            throw new Error("Trace exception");
        }
        catch (e) {
            return e;
        }
    };

    var stackStyle = fluid.detectStackStyle(fluid.obtainException());

    fluid.registerNamespace("fluid.exceptionDecoders");

    fluid.decodeStack = function () {
        if (stackStyle.style !== "firefox") {
            return null;
        }
        var e = fluid.obtainException();
        return fluid.exceptionDecoders[stackStyle.style](e);
    };

    fluid.exceptionDecoders.firefox = function (e) {
        var lines = e.stack.replace(/(?:\n@:0)?\s+$/m, "").replace(/^\(/gm, "{anonymous}(").split("\n");
        return fluid.transform(lines, function (line) {
            var atind = line.indexOf("@");
            return atind === -1? [line] : [line.substring(atind + 1), line.substring(0, atind)];
        });
    };

    // Main entry point for callers. 
    // TODO: This infrastructure is several years old and probably still only works on Firefox if there
    fluid.getCallerInfo = function (atDepth) {
        atDepth = (atDepth || 3) - stackStyle.offset;
        var stack = fluid.decodeStack();
        return stack? stack[atDepth][0] : null;
    };

    /** Generates a string for padding purposes by replicating a character a given number of times
     * @param c {Character} A character to be used for padding
     * @param count {Integer} The number of times to repeat the character
     * @return A string of length <code>count</code> consisting of repetitions of the supplied character
     */
    // UNOPTIMISED 
    fluid.generatePadding = function (c, count) {
        var togo = "";
        for (var i = 0; i < count; ++ i) {
            togo += c;
        }
        return togo;
    };
     
    // Marker so that we can render a custom string for properties which are not direct and concrete
    fluid.SYNTHETIC_PROPERTY = {};

    // utility to avoid triggering custom getter code which could throw an exception - e.g. express 3.x's request object 
    fluid.getSafeProperty = function (obj, key) {
        var desc = Object.getOwnPropertyDescriptor(obj, key); // supported on all of our environments - is broken on IE8
        return desc && !desc.get ? obj[key] : fluid.SYNTHETIC_PROPERTY;
    };

    function printImpl (obj, small, options) {
        var big = small + options.indentChars, togo, isFunction = typeof(obj) === "function";
        if (obj === null) {
            togo = "null";
        } else if (obj === undefined) {
            togo = "undefined"; // NB - object invalid for JSON interchange
        } else if (obj === fluid.SYNTHETIC_PROPERTY) {
            togo = "[Synthetic property]";
        } else if (fluid.isPrimitive(obj) && !isFunction) {
            togo = JSON.stringify(obj);
        }
        else {
            if ($.inArray(obj, options.stack) !== -1) {
                return "(CIRCULAR)"; // NB - object invalid for JSON interchange
            }
            options.stack.push(obj);
            var j = [];
            var i;
            if (fluid.isArrayable(obj)) {
                if (obj.length === 0) {
                    togo = "[]";
                } else {
                    for (i = 0; i < obj.length; ++ i) {
                        j[i] = printImpl(obj[i], big, options);
                    }
                    togo = "[\n" + big + j.join(",\n" + big) + "\n" + small + "]";
                }
            }
            else {
                i = 0;
                togo = "{" + (isFunction ? " Function" : "") + "\n"; // NB - Function object invalid for JSON interchange
                for (var key in obj) {
                    var value = fluid.getSafeProperty(obj, key);
                    j[i++] = JSON.stringify(key) + ": " + printImpl(value, big, options);
                }
                togo += big + j.join(",\n" + big) + "\n" + small + "}";
            }
            options.stack.pop();
        }
        return togo;
    }

    /** Render a complex JSON object into a nicely indented format suitable for human readability.
     * @param obj {Object} The object to be rendered
     * @param options {Object} An options structure governing the rendering process. The only option which
     * is currently supported is <code>indent</code> holding the number of space characters to be used to
     * indent each level of containment.
     */
    fluid.prettyPrintJSON = function (obj, options) {
        options = $.extend({indent: 4, stack: []}, options);
        options.indentChars = fluid.generatePadding(" ", options.indent);
        return printImpl(obj, "", options);
    };

    /**
     * Dumps a DOM element into a readily recognisable form for debugging - produces a
     * "semi-selector" summarising its tag name, class and id, whichever are set.
     *
     * @param {jQueryable} element The element to be dumped
     * @return A string representing the element.
     */
    fluid.dumpEl = function (element) {
        var togo;

        if (!element) {
            return "null";
        }
        if (element.nodeType === 3 || element.nodeType === 8) {
            return "[data: " + element.data + "]";
        }
        if (element.nodeType === 9) {
            return "[document: location " + element.location + "]";
        }
        if (!element.nodeType && fluid.isArrayable(element)) {
            togo = "[";
            for (var i = 0; i < element.length; ++ i) {
                togo += fluid.dumpEl(element[i]);
                if (i < element.length - 1) {
                    togo += ", ";
                }
            }
            return togo + "]";
        }
        element = $(element);
        togo = element.get(0).tagName;
        if (element.id) {
            togo += "#" + element.id;
        }
        if (element.attr("class")) {
            togo += "." + element.attr("class");
        }
        return togo;
    };

})(jQuery, fluid_2_0);
;/*
Copyright 2011-2013 OCAD University
Copyright 2010-2011 Lucendo Development Ltd.

Licensed under the Educational Community License (ECL), Version 2.0 or the New
BSD license. You may not use this file except in compliance with one these
Licenses.

You may obtain a copy of the ECL 2.0 License and BSD License at
https://github.com/fluid-project/infusion/raw/master/Infusion-LICENSE.txt
*/

var fluid_2_0 = fluid_2_0 || {};

(function ($, fluid) {
    "use strict";

    /** The Fluid "IoC System proper" - resolution of references and
     * completely automated instantiation of declaratively defined
     * component trees */

    // unsupported, non-API function
    // Currently still uses manual traversal - once we ban manually instantiated components,
    // it will use the instantiator's records instead.
    fluid.visitComponentChildren = function (that, visitor, options, path, i) {
        var instantiator = fluid.getInstantiator(that);
        for (var name in that) {
            var newPath = instantiator.composePath(path, name);
            var component = that[name];
            // This entire algorithm is primitive and expensive and will be removed once we can abolish manual init components
            if (!fluid.isComponent(component) || (options.visited && options.visited[component.id])) {continue; }
            if (options.visited) {
                options.visited[component.id] = true;
            }
            if (visitor(component, name, newPath, path, i)) {
                return true;
            }
            if (!options.flat) {
                fluid.visitComponentChildren(component, visitor, options, newPath);
            }
        }
    };

    // unsupported, non-API function
    fluid.getMemberNames = function (instantiator, thatStack) {
        var path = instantiator.idToPath(thatStack[thatStack.length - 1].id);
        var segs = fluid.model.parseEL(path);
        segs.unshift.apply(segs, fluid.generate(thatStack.length - segs.length, ""));
        return segs;
    };

    // thatStack contains an increasing list of MORE SPECIFIC thats.
    // this visits all components starting from the current location (end of stack)
    // in visibility order up the tree.
    var visitComponents = function (instantiator, thatStack, visitor, options) {
        options = options || {
            visited: {},
            flat: true,
            instantiator: instantiator
        };
        var memberNames = fluid.getMemberNames(instantiator, thatStack);
        for (var i = thatStack.length - 1; i >= 0; --i) {
            var that = thatStack[i], path;
            if (that.typeName) {
                options.visited[that.id] = true;
                path = instantiator.idToPath[that.id];
                if (visitor(that, memberNames[i], path, path, i)) {
                    return;
                }
            }
            if (fluid.visitComponentChildren(that, visitor, options, path, i)) {
                return;
            }
        }
    };

    fluid.mountStrategy = function (prefix, root, toMount) {
        var offset = prefix.length;
        return function (target, name, i, segs) {
            if (i <= prefix.length) { // Avoid OOB to not trigger deoptimisation!
                return;
            }
            for (var j = 0; j < prefix.length; ++ j) {
                if (segs[j] !== prefix[j]) {
                    return;
                }
            }
            return toMount(target, name, i - prefix.length, segs.slice(offset));
        };
    };

    // unsupported, NON-API function
    fluid.invokerFromRecord = function (invokerec, name, that) {
        fluid.pushActivity("makeInvoker", "beginning instantiation of invoker with name %name and record %record as child of %that",
            {name: name, record: invokerec, that: that});
        var invoker = fluid.makeInvoker(that, invokerec, name);
        fluid.popActivity();
        return invoker;
    };

    // unsupported, NON-API function
    fluid.memberFromRecord = function (memberrec, name, that) {
        var value = fluid.expandOptions(memberrec, that, null, null, {freeRoot: true});
        return value;
    };

    // unsupported, NON-API function
    fluid.recordStrategy = function (that, options, optionsStrategy, recordPath, recordMaker, prefix) {
        prefix = prefix || [];
        return {
            strategy: function (target, name, i) {
                if (i !== 1) {
                    return;
                }
                var record = fluid.driveStrategy(options, [recordPath, name], optionsStrategy);
                if (record === undefined) {
                    return;
                }
                fluid.set(target, [name], fluid.inEvaluationMarker);
                var member = recordMaker(record, name, that);
                fluid.set(target, [name], member);
                return member;
            },
            initter: function () {
                var records = fluid.driveStrategy(options, recordPath, optionsStrategy) || {};
                for (var name in records) {
                    fluid.getForComponent(that, prefix.concat([name]));
                }
            }
        };
    };

    // patch Fluid.js version for timing
    // unsupported, NON-API function
    fluid.instantiateFirers = function (that) {
        var shadow = fluid.shadowForComponent(that);
        var initter = fluid.get(shadow, ["eventStrategyBlock", "initter"]) || fluid.identity;
        initter();
    };

    // unsupported, NON-API function
    fluid.makeDistributionRecord = function (contextThat, sourceRecord, sourcePath, targetSegs, exclusions, offset, sourceType) {
        offset = offset || 0;
        sourceType = sourceType || "distribution";

        var source = fluid.copy(fluid.get(sourceRecord, sourcePath));
        fluid.each(exclusions, function (exclusion) {
            fluid.model.applyChangeRequest(source, {path: exclusion, type: "DELETE"});
        });

        var record = {options: {}};
        var primitiveSource = fluid.isPrimitive(source);
        fluid.model.applyChangeRequest(record, {path: targetSegs, type: primitiveSource? "ADD": "MERGE", value: source});
        return $.extend(record, {contextThat: contextThat, recordType: sourceType, priority: fluid.mergeRecordTypes.distribution + offset});
    };

    // unsupported, NON-API function
    // Part of the early "distributeOptions" workflow. Given the description of the blocks to be distributed, assembles "canned" records
    // suitable to be either registered into the shadow record for later or directly pushed to an existing component, as well as honouring
    // any "removeSource" annotations by removing these options from the source block.
    fluid.filterBlocks = function (contextThat, sourceBlocks, sourcePath, targetSegs, exclusions, removeSource) {
        var togo = [], offset = 0;
        fluid.each(sourceBlocks, function (block) {
            var source = fluid.get(block.source, sourcePath);
            if (source) {
                togo.push(fluid.makeDistributionRecord(contextThat, block.source, sourcePath, targetSegs, exclusions, offset++, block.recordType));
                var rescued = $.extend({}, source);
                if (removeSource) {
                    fluid.model.applyChangeRequest(block.source, {path: sourcePath, type: "DELETE"});
                }
                fluid.each(exclusions, function (exclusion) {
                    var orig = fluid.get(rescued, exclusion);
                    fluid.set(block.source, sourcePath.concat(exclusion), orig);
                });
            }
        });
        return togo;
    };

    // unsupported, NON-API function
    // TODO: This implementation is obviously poor and has numerous flaws
    fluid.matchIoCSelector = function (selector, thatStack, contextHashes, memberNames, i) {
        var thatpos = thatStack.length - 1;
        var selpos = selector.length - 1;
        while (true) {
            var mustMatchHere = thatpos === thatStack.length - 1 || selector[selpos].child;

            var that = thatStack[thatpos];
            var selel = selector[selpos];
            var match = true;
            for (var j = 0; j < selel.predList.length; ++j) {
                var pred = selel.predList[j];
                if (pred.context && !(contextHashes[thatpos][pred.context] || memberNames[thatpos] === pred.context)) {
                    match = false;
                    break;
                }
                if (pred.id && that.id !== pred.id) {
                    match = false;
                    break;
                }
            }
            if (selpos === 0 && thatpos > i && mustMatchHere) {
                match = false; // child selector must exhaust stack completely - FLUID-5029
            }
            if (match) {
                if (selpos === 0) {
                    return true;
                }
                --thatpos;
                --selpos;
            }
            else {
                if (mustMatchHere) {
                    return false;
                }
                else {
                    --thatpos;
                }
            }
            if (thatpos < i) {
                return false;
            }
        }
    };

    // Use this peculiar signature since the actual component and shadow itself may not exist yet. Perhaps clean up with FLUID-4925
    fluid.noteCollectedDistribution = function (parentShadow, memberName, distribution) {
        fluid.model.setSimple(parentShadow, ["collectedDistributions", memberName, distribution.id], true);
    };

    fluid.isCollectedDistribution = function (parentShadow, memberName, distribution) {
        return fluid.model.getSimple(parentShadow, ["collectedDistributions", memberName, distribution.id]);
    };

    fluid.clearCollectedDistributions = function (parentShadow, memberName) {
        fluid.model.applyChangeRequest(parentShadow, {path: ["collectedDistributions", memberName], type: "DELETE"});
    };

    // unsupported, NON-API function
    fluid.collectDistributions = function (distributedBlocks, parentShadow, distribution, thatStack, contextHashes, memberNames, i) {
        var lastMember = memberNames[memberNames.length - 1];
        if (!fluid.isCollectedDistribution(parentShadow, lastMember, distribution) &&
                fluid.matchIoCSelector(distribution.selector, thatStack, contextHashes, memberNames, i)) {
            distributedBlocks.push.apply(distributedBlocks, distribution.blocks);
            fluid.noteCollectedDistribution(parentShadow, lastMember, distribution);
        }
    };

    // Slightly silly function to clean up the "appliedDistributions" records. In general we need to be much more aggressive both
    // about clearing instantiation garbage (e.g. onCreate and most of the shadow)
    // as well as caching frequently-used records such as the "thatStack" which
    // would mean this function could be written in a sensible way
    fluid.registerCollectedClearer = function (shadow, parentShadow, memberName) {
        if (!shadow.collectedClearer && parentShadow) {
            shadow.collectedClearer = function () {
                fluid.clearCollectedDistributions(parentShadow, memberName);
            };
        }
    };

    // unsupported, NON-API function
    fluid.receiveDistributions = function (parentThat, gradeNames, memberName, that) {
        var instantiator = fluid.getInstantiator(parentThat || that);
        var thatStack = instantiator.getThatStack(parentThat || that); // most specific is at end
        var memberNames = fluid.getMemberNames(instantiator, thatStack);
        var distributedBlocks = [];
        var shadows = fluid.transform(thatStack, function (thisThat) {
            return instantiator.idToShadow[thisThat.id];
        });
        var parentShadow = shadows[shadows.length - (parentThat ? 1 : 2)];
        var contextHashes = fluid.getMembers(shadows, "contextHash");
        if (parentThat) { // if called before construction of component from embodyDemands - NB this path will be abolished/amalgamated
            memberNames.push(memberName);
            contextHashes.push(fluid.gradeNamesToHash(gradeNames));
            thatStack.push(that);
        } else {
            fluid.registerCollectedClearer(shadows[shadows.length - 1], parentShadow, memberNames[memberNames.length - 1]);
        }
        // This use of function creation within a loop is acceptable since
        // the function does not attempt to close directly over the loop counter
        for (var i = 0; i < thatStack.length - 1; ++ i) {
            fluid.each(shadows[i].distributions, function (distribution) {
                fluid.collectDistributions(distributedBlocks, parentShadow, distribution, thatStack, contextHashes, memberNames, i);
            });  /* function in loop */ /* jshint ignore:line */
        }
        return distributedBlocks;
    };

    // unsupported, NON-API function
    // convert "preBlocks" as produced from fluid.filterBlocks into "real blocks" suitable to be used by the expansion machinery.
    fluid.applyDistributions = function (that, preBlocks, targetShadow) {
        var distributedBlocks = fluid.transform(preBlocks, function (preBlock) {
            return fluid.generateExpandBlock(preBlock, that, targetShadow.mergePolicy);
        });
        var mergeOptions = targetShadow.mergeOptions;
        mergeOptions.mergeBlocks.push.apply(mergeOptions.mergeBlocks, distributedBlocks);
        mergeOptions.updateBlocks();
        return distributedBlocks;
    };

    // unsupported, NON-API function
    fluid.parseExpectedOptionsPath = function (path, role) {
        var segs = fluid.model.parseEL(path);
        if (segs.length > 1 && segs[0] !== "options") {
            fluid.fail("Error in options distribution path ", path, " - only " + role + " paths beginning with \"options\" are supported");
        }
        return segs.slice(1);
    };

    // unsupported, NON-API function
    fluid.isIoCSSSelector = function (context) {
        return context.indexOf(" ") !== -1; // simple-minded check for an IoCSS reference
    };

    // unsupported, NON-API function
    fluid.pushDistributions = function (targetHead, selector, blocks) {
        var targetShadow = fluid.shadowForComponent(targetHead);
        var id = fluid.allocateGuid();
        var distributions = (targetShadow.distributions = targetShadow.distributions || []);
        distributions.push({
            id: id, // This id is used in clearDistributions - which itself currently only seems to appear in IoCTestUtils
            selector: selector,
            blocks: blocks
        });
        return id;
    };

    // unsupported, NON-API function
    fluid.clearDistributions = function (targetHead, id) {
        var targetShadow = fluid.shadowForComponent(targetHead);
        fluid.remove_if(targetShadow.distributions, function (distribution) {
            return distribution.id === id;
        });
    };

    // unsupported, NON-API function
    // Modifies a parsed selector to extra its head context which will be matched upwards
    fluid.extractSelectorHead = function (parsedSelector) {
        var predList = parsedSelector[0].predList;
        var context = predList[0].context;
        predList.length = 0;
        return context;
    };

    fluid.undistributableOptions = ["gradeNames", "distributeOptions", "returnedPath", "argumentMap", "initFunction", "mergePolicy", "progressiveCheckerOptions"]; // automatically added to "exclusions" of every distribution

    // unsupported, NON-API function
    fluid.distributeOptions = function (that, optionsStrategy) {
        var records = fluid.makeArray(fluid.driveStrategy(that.options, "distributeOptions", optionsStrategy));
        fluid.each(records, function (record) {
            var targetRef = fluid.parseContextReference(record.target);
            var targetComp, selector;
            if (fluid.isIoCSSSelector(targetRef.context)) {
                selector = fluid.parseSelector(targetRef.context, fluid.IoCSSMatcher);
                var headContext = fluid.extractSelectorHead(selector);
                if (headContext !== "that") {
                    fluid.fail("Downwards options distribution not supported from component other than \"that\"");
                }
                targetComp = that;
            }
            else {
                targetComp = fluid.resolveContext(targetRef.context, that);
                if (!targetComp) {
                    fluid.fail("Error in options distribution record ", record, " - could not resolve context selector {"+targetRef.context+"} to a root component");
                }
            }
            var targetSegs = fluid.model.parseEL(targetRef.path);
            var preBlocks;
            if (record.record !== undefined) {
                preBlocks = [(fluid.makeDistributionRecord(that, record.record, [], targetSegs, [], 0))];
            }
            else {
                var thatShadow = fluid.shadowForComponent(that);
                var source = fluid.parseContextReference(record.source || "{that}.options"); // TODO: This is probably not a sensible default
                if (source.context !== "that") {
                    fluid.fail("Error in options distribution record ", record, " only a context of {that} is supported");
                }
                var sourcePath = fluid.parseExpectedOptionsPath(source.path, "source");
                var fullExclusions = fluid.makeArray(record.exclusions).concat(sourcePath.length === 0 ? fluid.undistributableOptions : []);

                var exclusions = fluid.transform(fullExclusions, function (exclusion) {
                    return fluid.model.parseEL(exclusion);
                });

                preBlocks = fluid.filterBlocks(that, thatShadow.mergeOptions.mergeBlocks, sourcePath, targetSegs, exclusions, record.removeSource);
                thatShadow.mergeOptions.updateBlocks(); // perhaps unnecessary
            }
            // TODO: inline material has to be expanded in its original context!

            if (selector) {
                fluid.pushDistributions(targetComp, selector, preBlocks);
            }
            else { // The component exists now, we must rebalance it
                var targetShadow = fluid.shadowForComponent(targetComp);
                fluid.applyDistributions(that, preBlocks, targetShadow);
            }
        });
    };

    // unsupported, NON-API function
    fluid.gradeNamesToHash = function (gradeNames) {
        var contextHash = {};
        fluid.each(gradeNames, function (gradeName) {
            contextHash[gradeName] = true;
            contextHash[fluid.computeNickName(gradeName)] = true;
        });
        return contextHash;
    };

    // unsupported, NON-API function
    fluid.cacheShadowGrades = function (that, shadow) {
        var contextHash = fluid.gradeNamesToHash(that.options.gradeNames);
        contextHash[that.nickName] = true;
        shadow.contextHash = contextHash;
    };

    // First sequence point where the mergeOptions strategy is delivered from Fluid.js - here we take care
    // of both receiving and transmitting options distributions
    // unsupported, NON-API function
    fluid.deliverOptionsStrategy = function (that, target, mergeOptions) {
        var shadow = fluid.shadowForComponent(that, shadow);
        fluid.cacheShadowGrades(that, shadow);
        shadow.mergeOptions = mergeOptions;
    };

    // unsupported, NON-API function
    fluid.resolveReturnedPath = function (returnedPath, that) {
        var shadow = fluid.shadowForComponent(that);
        // This prevents corruption of instantiator records by defeating effect of "returnedPath" for non-roots
        return shadow && shadow.path !== "" ? null : returnedPath;
    };

    fluid.defaults("fluid.gradeLinkageRecord", {
        gradeNames: ["fluid.littleComponent"]
    });

    /** A "tag component" to opt in to the grade linkage system (FLUID-5212) which is currently very expensive -
      * this will become the default once we have a better implementation and have stabilised requirements
      */
    fluid.defaults("fluid.applyGradeLinkage", { });

    fluid.gradeLinkageIndexer = function (defaults) {
        if (defaults.contextGrades && defaults.resultGrades) {
            return ["*"];
        }
    };

    fluid.getLinkedGrades = function (gradeNames) {
        var togo = [];
        var gradeLinkages = fluid.indexDefaults("gradeLinkages", {
            gradeNames: "fluid.gradeLinkageRecord",
            indexFunc: fluid.gradeLinkageIndexer
        });
        fluid.each(gradeLinkages["*"], function (defaultsName) {
            var defaults = fluid.defaults(defaultsName);
            var exclude = fluid.find(fluid.makeArray(defaults.contextGrades),
                function (grade) {
                    if (!fluid.contains(gradeNames, grade)) {
                        return true;
                    }
                }
            );
            if (!exclude) {
                togo.push.apply(togo, fluid.makeArray(defaults.resultGrades));
            }
        });
        return togo;
    };

    fluid.expandDynamicGrades = function (that, shadow, gradeNames, dynamicGrades) {
        var resolved = [];
        fluid.each(dynamicGrades, function (dynamicGrade) {
            var expanded = fluid.expandOptions(dynamicGrade, that);
            if (typeof(expanded) === "function") {
                expanded = expanded();
            }
            if (expanded) {
                resolved = resolved.concat(expanded);
            }
        });
        var allGrades = fluid.makeArray(gradeNames).concat(resolved);
        if (fluid.contains(allGrades, "fluid.applyGradeLinkage")) {
            var linkedGrades = fluid.getLinkedGrades(allGrades);
            fluid.remove_if(linkedGrades, function (gradeName) {
                return fluid.contains(allGrades, gradeName);
            });
            resolved = resolved.concat(linkedGrades);
        }
        var distributedBlocks = fluid.receiveDistributions(null, null, null, that);
        if (distributedBlocks.length > 0) {
            var readyBlocks = fluid.applyDistributions(that, distributedBlocks, shadow);
            // rely on the fact that "dirty tricks are not permitted" wrt. resolving gradeNames - each element must be a literal entry or array
            // holding primitive or EL values - otherwise we would have to go all round the houses and reenter the top of fluid.computeDynamicGrades
            var gradeNamesList = fluid.transform(fluid.getMembers(readyBlocks, ["source", "gradeNames"]), fluid.makeArray);
            resolved = resolved.concat.apply(resolved, gradeNamesList);
        }
        return resolved;
    };

    // Discover further grades that are entailed by the given base typeName and the current total "dynamic grades list" held in the argument "resolved".
    // These are looked up conjointly in the grade registry, and then any further i) dynamic grades references {} ii) grade linkage records
    // are expanded and added into the list and concatenated into "resolved". Additional grades discovered during this function are returned as
    // "furtherResolved".
    fluid.collectDynamicGrades = function (that, shadow, defaultsBlock, gradeNames, dynamicGrades, resolved) {
        var newDefaults = fluid.copy(fluid.getGradedDefaults(that.typeName, resolved));
        gradeNames.length = 0; // acquire derivatives of dynamic grades (FLUID-5054)
        gradeNames.push.apply(gradeNames, newDefaults.gradeNames);

        fluid.cacheShadowGrades(that, shadow);
        // This cheap strategy patches FLUID-5091 for now - some more sophisticated activity will take place
        // at this site when we have a full fix for FLUID-5028
        shadow.mergeOptions.destroyValue("mergePolicy");
        shadow.mergeOptions.destroyValue("components");
        shadow.mergeOptions.destroyValue("invokers");

        defaultsBlock.source = newDefaults;
        shadow.mergeOptions.updateBlocks();

        var furtherResolved = fluid.remove_if(gradeNames, function (gradeName) {
            return gradeName.charAt(0) === "{" && !fluid.contains(dynamicGrades, gradeName);
        }, []);
        dynamicGrades.push.apply(dynamicGrades, furtherResolved);
        furtherResolved = fluid.expandDynamicGrades(that, shadow, gradeNames, furtherResolved);

        resolved.push.apply(resolved, furtherResolved);

        return furtherResolved;
    };

    // unsupported, NON-API function
    fluid.computeDynamicGrades = function (that, shadow, strategy) {
        delete that.options.gradeNames; // Recompute gradeNames for FLUID-5012 and others

        var gradeNames = fluid.driveStrategy(that.options, "gradeNames", strategy);
        // TODO: In complex distribution cases, a component might end up with multiple default blocks
        var defaultsBlock = fluid.findMergeBlocks(shadow.mergeOptions.mergeBlocks, "defaults")[0];
        var dynamicGrades = fluid.remove_if(gradeNames, function (gradeName) {
            return gradeName.charAt(0) === "{" || !fluid.hasGrade(defaultsBlock.target, gradeName);
        }, []);
        var resolved = fluid.expandDynamicGrades(that, shadow, gradeNames, dynamicGrades);
        if (resolved.length !== 0) {
            var furtherResolved;
            do { // repeatedly collect dynamic grades whilst they arrive (FLUID-5155)
                furtherResolved = fluid.collectDynamicGrades(that, shadow, defaultsBlock, gradeNames, dynamicGrades, resolved);
            }
            while (furtherResolved.length !== 0);
        }
        if (shadow.collectedClearer) {
            shadow.collectedClearer();
            delete shadow.collectedClearer;
        }
    };

    fluid.computeDynamicComponentKey = function (recordKey, sourceKey) {
        return recordKey + (sourceKey === 0 ? "" : "-" + sourceKey); // TODO: configurable name strategies
    };

    // unsupported, NON-API function
    fluid.registerDynamicRecord = function (that, recordKey, sourceKey, record, toCensor) {
        var key = fluid.computeDynamicComponentKey(recordKey, sourceKey);
        var cRecord = fluid.copy(record);
        delete cRecord[toCensor];
        fluid.set(that.options, ["components", key], cRecord);
        return key;
    };

    // unsupported, NON-API function
    fluid.computeDynamicComponents = function (that, mergeOptions) {
        var shadow = fluid.shadowForComponent(that);
        var localSub = shadow.subcomponentLocal = {};
        var records = fluid.driveStrategy(that.options, "dynamicComponents", mergeOptions.strategy);
        fluid.each(records, function (record, recordKey) {
            if (!record.sources && !record.createOnEvent) {
                fluid.fail("Cannot process dynamicComponents record ", record, " without a \"sources\" or \"createOnEvent\" entry");
            }
            if (record.sources) {
                var sources = fluid.expandOptions(record.sources, that);
                fluid.each(sources, function (source, sourceKey) {
                    var key = fluid.registerDynamicRecord(that, recordKey, sourceKey, record, "sources");
                    localSub[key] = {"source": source, "sourcePath": sourceKey};
                });
            }
            else if (record.createOnEvent) {
                var event = fluid.event.expandOneEvent(that, record.createOnEvent);
                fluid.set(shadow, ["dynamicComponentCount", recordKey], 0);
                var listener = function () {
                    var key = fluid.registerDynamicRecord(that, recordKey, shadow.dynamicComponentCount[recordKey]++, record, "createOnEvent");
                    localSub[key] = {"arguments": fluid.makeArray(arguments)};
                    fluid.initDependent(that, key);
                };
                event.addListener(listener);
                fluid.recordListener(event, listener, shadow);
            }
        });
    };

    // Second sequence point for mergeOptions from Fluid.js - here we construct all further
    // strategies required on the IoC side and mount them into the shadow's getConfig for universal use
    // unsupported, NON-API function
    fluid.computeComponentAccessor = function (that) {
        var shadow = fluid.shadowForComponent(that);
        var options = that.options;
        var strategy = shadow.mergeOptions.strategy;
        var optionsStrategy = fluid.mountStrategy(["options"], options, strategy);
        shadow.invokerStrategy = fluid.recordStrategy(that, options, strategy, "invokers", fluid.invokerFromRecord);
        shadow.eventStrategyBlock = fluid.recordStrategy(that, options, strategy, "events", fluid.eventFromRecord, ["events"]);
        var eventStrategy = fluid.mountStrategy(["events"], that, shadow.eventStrategyBlock.strategy, ["events"]);
        shadow.memberStrategy = fluid.recordStrategy(that, options, strategy, "members", fluid.memberFromRecord);
        // NB - ginger strategy handles concrete, rationalise
        shadow.getConfig = {strategies: [fluid.model.funcResolverStrategy, fluid.makeGingerStrategy(that),
            optionsStrategy, shadow.invokerStrategy.strategy, shadow.memberStrategy.strategy, eventStrategy]};

        fluid.computeDynamicGrades(that, shadow, strategy, shadow.mergeOptions.mergeBlocks);
        fluid.distributeOptions(that, strategy);

        return shadow.getConfig;
    };

    fluid.shadowForComponent = function (component) {
        var instantiator = fluid.getInstantiator(component);
        return instantiator && component ? instantiator.idToShadow[component.id] : null;
    };

    fluid.getForComponent = function (component, path) {
        var shadow = fluid.shadowForComponent(component);
        var getConfig = shadow ? shadow.getConfig : undefined;
        return fluid.get(component, path, getConfig);
    };

    // An EL segment resolver strategy that will attempt to trigger creation of
    // components that it discovers along the EL path, if they have been defined but not yet
    // constructed.
    // unsupported, NON-API function
    fluid.makeGingerStrategy = function (that) {
        var instantiator = fluid.getInstantiator(that);
        return function (component, thisSeg, index, segs) {
            var atval = component[thisSeg];
            if (atval === fluid.inEvaluationMarker && index === segs.length) {
                fluid.fail("Error in component configuration - a circular reference was found during evaluation of path segment \"" + thisSeg +
                    "\": for more details, see the activity records following this message in the console, or issue fluid.setLogging(fluid.logLevel.TRACE) when running your application");
            }
            if (index > 1) {
                return atval;
            }
            if (atval === undefined && component.hasOwnProperty(thisSeg)) { // avoid recomputing properties that have been explicitly evaluated to undefined
                return fluid.NO_VALUE;
            }
            if (atval === undefined) { // pick up components in instantiation here - we can cut this branch by attaching early
                var parentPath = instantiator.idToShadow[component.id].path;
                var childPath = fluid.composePath(parentPath, thisSeg);
                atval = instantiator.pathToComponent[childPath];
            }
            if (atval === undefined) {
                // TODO: This check is very expensive - once gingerness is stable, we ought to be able to
                // eagerly compute and cache the value of options.components - check is also incorrect and will miss injections
                var subRecord = fluid.getForComponent(component, ["options", "components", thisSeg]);
                if (subRecord) {
                    if (subRecord.createOnEvent) {
                        fluid.fail("Error resolving path segment \"" + thisSeg + "\" of path " + segs.join(".") + " since component with record ", subRecord,
                            " has annotation \"createOnEvent\" - this very likely represents an implementation error. Either alter the reference so it does not " +
                            " match this component, or alter your workflow to ensure that the component is instantiated by the time this reference resolves");
                    }
                    fluid.initDependent(component, thisSeg);
                    atval = component[thisSeg];
                }
            }
            return atval;
        };
    };

    fluid.filterBuiltinGrades = function (gradeNames) {
        return fluid.remove_if(fluid.makeArray(gradeNames), function (gradeName) {
            return (/^(autoInit|fluid.littleComponent|fluid.modelComponent|fluid.eventedComponent|fluid.viewComponent|fluid.typeFount)$/).test(gradeName);
        });
    };

    fluid.dumpGradeNames = function (that) {
        return that.options && that.options.gradeNames ?
            " gradeNames: " + JSON.stringify(fluid.filterBuiltinGrades(that.options.gradeNames)) : "";
    };

    // unsupported, non-API function
    fluid.dumpThat = function (that) {
        return "{ typeName: \"" + that.typeName + "\"" + fluid.dumpGradeNames(that) + " id: " + that.id + "}";
    };

    // unsupported, non-API function
    fluid.dumpThatStack = function (thatStack, instantiator) {
        var togo = fluid.transform(thatStack, function(that) {
            var path = instantiator.idToPath(that.id);
            return fluid.dumpThat(that) + (path? (" - path: " + path) : "");
        });
        return togo.join("\n");
    };

    // unsupported, NON-API function
    fluid.resolveContext = function (context, that) {
        var instantiator = fluid.getInstantiator(that);
        if (context === "instantiator") {
            return instantiator;
        }
        else if (context === "that") {
            return that;
        }
        var foundComponent;
        var thatStack = instantiator.getFullStack(that);
        visitComponents(instantiator, thatStack, function (component, name) {
            var shadow = fluid.shadowForComponent(component);
            // TODO: Some components, e.g. the static environment and typeTags do not have a shadow, which slows us down here
            if (context === name || shadow && shadow.contextHash && shadow.contextHash[context] || context === component.typeName || context === component.nickName) {
                foundComponent = component;
                return true; // YOUR VISIT IS AT AN END!!
            }
            if (fluid.getForComponent(component, ["options", "components", context, "type"]) && !component[context]) {
  // This is an expensive guess since we make it for every component up the stack - must apply the WAVE OF EXPLOSIONS (FLUID-4925) to discover all components first
  // This line attempts a hopeful construction of components that could be guessed by nickname through finding them unconstructed
  // in options. In the near future we should eagerly BEGIN the process of constructing components, discovering their
  // types and then attaching them to the tree VERY EARLY so that we get consistent results from different strategies.
                foundComponent = fluid.getForComponent(component, context);
                return true;
            }
        });
        return foundComponent;
    };

    var localRecordExpected = /^(arguments|options|container|source|sourcePath|change)$/;

    // unsupported, NON-API function
    fluid.makeStackFetcher = function (parentThat, localRecord) {
        var fetcher = function (parsed) {
            if (parentThat && parentThat.destroy === fluid.destroyedMarker) {
                fluid.fail("Cannot resolve reference " + fluid.renderContextReference(parsed) + " from component " + fluid.dumpThat(parentThat) + " which has been destroyed");
            }
            var context = parsed.context;
            if (localRecord && localRecordExpected.test(context)) {
                var fetched = fluid.get(localRecord[context], parsed.path);
                return context === "arguments" || context === "source" || context === "sourcePath" || context === "change" ? fetched : {
                    marker: context === "options" ? fluid.EXPAND : fluid.EXPAND_NOW,
                    value: fetched
                };
            }
            var foundComponent = fluid.resolveContext(context, parentThat);
            if (!foundComponent && parsed.path !== "") {
                var ref = fluid.renderContextReference(parsed);
                fluid.fail("Failed to resolve reference " + ref + " - could not match context with name " +
                    context + " from component " + fluid.dumpThat(parentThat), parentThat);
            }
            return fluid.getForComponent(foundComponent, parsed.path);
        };
        return fetcher;
    };

    // unsupported, NON-API function
    fluid.makeStackResolverOptions = function (parentThat, localRecord) {
        return $.extend(fluid.copy(fluid.rawDefaults("fluid.makeExpandOptions")), {
            fetcher: fluid.makeStackFetcher(parentThat, localRecord),
            contextThat: parentThat
        });
    };

    // unsupported, non-API function
    fluid.clearListeners = function (shadow) {
        // TODO: bug here - "afterDestroy" listeners will be unregistered already unless they come from this component
        fluid.each(shadow.listeners, function (rec) {
            rec.event.removeListener(rec.listener);
        });
        delete shadow.listeners;
    };

    // unsupported, non-API function
    fluid.recordListener = function (event, listener, shadow) {
        if (event.ownerId !== shadow.that.id) { // don't bother recording listeners registered from this component itself
            var listeners = shadow.listeners;
            if (!listeners) {
                listeners = shadow.listeners = [];
            }
            listeners.push({event: event, listener: listener});
        }
    };

    var idToInstantiator = {};

    // unsupported, non-API function - however, this structure is of considerable interest to those debugging
    // into IoC issues. The structures idToShadow and pathToComponent contain a complete map of the component tree
    // forming the surrounding scope
    fluid.instantiator = function (freeInstantiator) {
        var that = {
            id: fluid.allocateGuid(),
            free: freeInstantiator,
            nickName: "instantiator",
            pathToComponent: {},
            idToShadow: {},
            modelTransactions: {init: {}}, // a map of transaction id to map of component id to records of components enlisted in a current model initialisation transaction
            composePath: fluid.composePath // For speed, we declare that no component's name may contain a period
        };
        // We frequently get requests for components not in this instantiator - e.g. from the dynamicEnvironment or manually created ones
        that.idToPath = function (id) {
            var shadow = that.idToShadow[id];
            return shadow ? shadow.path : "";
        };
        that.getThatStack = function (component) {
            var shadow = that.idToShadow[component.id];
            if (shadow) {
                var path = shadow.path;
                var parsed = fluid.model.parseEL(path);
                var togo = fluid.transform(parsed, function (value, i) {
                    var parentPath = fluid.model.composeSegments.apply(null, parsed.slice(0, i + 1));
                    return that.pathToComponent[parentPath];
                });
                var root = that.pathToComponent[""];
                if (root) {
                    togo.unshift(root);
                }
                return togo;
            }
            else { return [component];}
        };
        that.getEnvironmentalStack = function () {
            var togo = [fluid.staticEnvironment];
            if (!freeInstantiator) {
                togo.push(fluid.globalThreadLocal());
            }
            return togo;
        };
        that.getFullStack = function (component) {
            var thatStack = component? that.getThatStack(component) : [];
            return that.getEnvironmentalStack().concat(thatStack);
        };
        function recordComponent(component, path, created) {
            if (created) {
                idToInstantiator[component.id] = that;
                var shadow = that.idToShadow[component.id] = {};
                shadow.that = component;
                shadow.path = path;
            }
            if (that.pathToComponent[path]) {
                fluid.fail("Error during instantiation - path " + path + " which has just created component " + fluid.dumpThat(component) +
                    " has already been used for component " + fluid.dumpThat(that.pathToComponent[path]) + " - this is a circular instantiation or other oversight." +
                    " Please clear the component using instantiator.clearComponent() before reusing the path.");
            }
            that.pathToComponent[path] = component;
        }
        that.recordRoot = function (component) {
            if (component && component.id && !that.pathToComponent[""]) {
                recordComponent(component, "", true);
            }
        };
        that.recordKnownComponent = function (parent, component, name, created) {
            var parentPath = that.idToShadow[parent.id].path;
            var path = that.composePath(parentPath, name);
            recordComponent(component, path, created);
        };
        that.clearComponent = function (component, name, child, options, noModTree, path) {
            var record = that.idToShadow[component.id].path;
            // use flat recursion since we want to use our own recursion rather than rely on "visited" records
            options = options || {flat: true, instantiator: that};
            child = child || component[name];
            path = path || record;
            if (path === undefined) {
                fluid.fail("Cannot clear component " + name + " from component ", component,
                    " which was not created by this instantiator");
            }
            fluid.fireEvent(child, "events.onClear", [child, name, component]);

            var childPath = that.composePath(path, name);
            var childRecord = that.idToShadow[child.id];

            // only recurse on components which were created in place - if the id record disagrees with the
            // recurse path, it must have been injected
            if (childRecord && childRecord.path === childPath) {
                fluid.doDestroy(child, name, component);
                // TODO: There needs to be a call to fluid.clearDistributions here
                fluid.clearListeners(childRecord);
                fluid.visitComponentChildren(child, function(gchild, gchildname, newPath, parentPath) {
                    that.clearComponent(child, gchildname, null, options, true, parentPath);
                }, options, childPath);
                fluid.fireEvent(child, "events.afterDestroy", [child, name, component]);
                delete that.idToShadow[child.id];
                delete idToInstantiator[child.id];
            }
            delete that.pathToComponent[childPath]; // there may be no entry - if created informally
            if (!noModTree) {
                delete component[name]; // there may be no entry - if creation is not concluded
            }
        };
        return that;
    };

    // An instantiator to be used in the "free environment", unattached to any component tree
    fluid.freeInstantiator = fluid.instantiator(true);

    // Look up the globally registered instantiator for a particular component
    fluid.getInstantiator = function (component) {
        return component && idToInstantiator[component.id] || fluid.freeInstantiator;
    };

    /** Expand a set of component options either immediately, or with deferred effect.
     *  The current policy is to expand immediately function arguments within fluid.embodyDemands which are not the main options of a
     *  component. The component's own options take <code>{defer: true}</code> as part of
     *  <code>outerExpandOptions</code> which produces an "expandOptions" structure holding the "strategy" and "initter" pattern
     *  common to ginger participants.
     *  Probably not to be advertised as part of a public API, but is considerably more stable than most of the rest
     *  of the IoC API structure especially with respect to the first arguments.
     */

    fluid.expandOptions = function (args, that, mergePolicy, localRecord, outerExpandOptions) {
        if (!args) {
            return args;
        }
        fluid.pushActivity("expandOptions", "expanding options %args for component %that ", {that: that, args: args});
        var expandOptions = fluid.makeStackResolverOptions(that, localRecord);
        expandOptions.mergePolicy = mergePolicy;
        expandOptions.freeRoot = outerExpandOptions && outerExpandOptions.freeRoot;
        var expanded = outerExpandOptions && outerExpandOptions.defer ?
            fluid.makeExpandOptions(args, expandOptions) : fluid.expand(args, expandOptions);
        fluid.popActivity();
        return expanded;
    };

    // unsupported, non-API function
    fluid.localRecordExpected = ["type", "options", "args", "mergeOptions", "createOnEvent", "priority", "recordType"]; // last element unavoidably polluting
    // unsupported, non-API function
    fluid.checkComponentRecord = function (defaults, localRecord) {
        var expected = fluid.arrayToHash(fluid.localRecordExpected);
        fluid.each(defaults && defaults.argumentMap, function(value, key) {
            expected[key] = true;
        });
        fluid.each(localRecord, function (value, key) {
            if (!expected[key]) {
                fluid.fail("Probable error in subcomponent record - key \"" + key +
                    "\" found, where the only legal options are " +
                    fluid.keys(expected).join(", "));
            }
        });
    };

    // unsupported, non-API function
    fluid.pushDemands = function (list, demands) {
        demands = fluid.makeArray(demands);
        var thisp = fluid.mergeRecordTypes.demands;
        function push(rec) {
            rec.recordType = "demands";
            rec.priority = thisp++;
            list.push(rec);
        }
        function buildAndPush(rec) {
            push({options: rec});
        }
        // Assume these are sorted at source by intersect count (can't pre-merge if we want "mergeOptions")
        for (var i = 0; i < demands.length; ++ i) {
            var thisd = demands[i];
            if (thisd.options) {
                push(thisd);
            }
            else if (thisd.mergeOptions) {
                var mergeOptions = fluid.makeArray(thisd.mergeOptions);
                fluid.each(mergeOptions, buildAndPush);
            }
            else {
                fluid.fail("Uninterpretable demands record without options or mergeOptions ", thisd);
            }
        }
    };

    // unsupported, non-API function
    fluid.mergeRecordsToList = function (mergeRecords) {
        var list = [];
        fluid.each(mergeRecords, function (value, key) {
            value.recordType = key;
            if (key === "distributions") {
                list.push.apply(list, value);
            }
            else if (key !== "demands") {
                if (!value.options) { return; }
                value.priority = fluid.mergeRecordTypes[key];
                if (value.priority === undefined) {
                    fluid.fail("Merge record with unrecognised type " + key + ": ", value);
                }
                list.push(value);
            }
            else {
                fluid.pushDemands(list, value);
            }
        });
        return list;
    };

    // TODO: overall efficiency could huge be improved by resorting to the hated PROTOTYPALISM as an optimisation
    // for this mergePolicy which occurs in every component. Although it is a deep structure, the root keys are all we need
    var addPolicyBuiltins = function (policy) {
        fluid.each(["gradeNames", "mergePolicy", "argumentMap", "components", "dynamicComponents", "members", "invokers", "events", "listeners", "modelListeners", "distributeOptions", "transformOptions"], function (key) {
            fluid.set(policy, [key, "*", "noexpand"], true);
        });
        return policy;
    };

    // unsupported, NON-API function - used from Fluid.js
    fluid.generateExpandBlock = function (record, that, mergePolicy, localRecord) {
        var expanded = fluid.expandOptions(record.options, record.contextThat || that, mergePolicy, localRecord, {defer: true});
        expanded.priority = record.priority;
        expanded.recordType = record.recordType;
        return expanded;
    };

    var expandComponentOptionsImpl = function (mergePolicy, defaults, userOptions, that) {
        var defaultCopy = fluid.copy(defaults);
        addPolicyBuiltins(mergePolicy);
        var shadow = fluid.shadowForComponent(that);
        shadow.mergePolicy = mergePolicy;
        var mergeRecords = {
            defaults: {options: defaultCopy}
        };

        if (userOptions) {
            if (userOptions.marker === fluid.EXPAND) {
                $.extend(mergeRecords, userOptions.mergeRecords);
                // Do this here for gradeless components that were corrected by "localOptions"
                if (mergeRecords.subcomponentRecord) {
                    fluid.checkComponentRecord(defaults, mergeRecords.subcomponentRecord);
                }
            }
            else {
                mergeRecords.user = {options: fluid.expandCompact(userOptions, true)};
            }
        }
        var expandList = fluid.mergeRecordsToList(mergeRecords);

        var togo = fluid.transform(expandList, function (value) {
            return fluid.generateExpandBlock(value, that, mergePolicy, userOptions && userOptions.localRecord);
        });
        return togo;
    };

    // unsupported, non-API function
    fluid.makeIoCRootDestroy = function (instantiator, that) {
        return function () {
            instantiator.clearComponent(that, "", that, null, true);
        };
    };
    
    // NON-API function
    fluid.fabricateDestroyMethod = function (that, name, instantiator, child) {
        return function () {
            instantiator.clearComponent(that, name, child);
        };
    };

    // unsupported, non-API function
    fluid.expandComponentOptions = function (mergePolicy, defaults, userOptions, that) {
        var instantiator = userOptions && userOptions.marker === fluid.EXPAND && userOptions.memberName !== undefined ?
            userOptions.instantiator : null;
        var fresh;
        if (!instantiator) {
            instantiator = fluid.instantiator();
            fresh = true;
            fluid.log("Created new instantiator with id " + instantiator.id + " in order to operate on component " + (that? that.typeName : "[none]"));
            that.destroy = fluid.makeIoCRootDestroy(instantiator, that);
        }
        fluid.pushActivity("expandComponentOptions", "expanding component options %options with record %record for component %that",
            {options: userOptions && userOptions.mergeRecords, record: userOptions, that: that});
        if (fresh) {
            instantiator.recordRoot(that);
        }
        else {
            instantiator.recordKnownComponent(userOptions.parentThat, that, userOptions.memberName, true);
        }
        var togo = expandComponentOptionsImpl(mergePolicy, defaults, userOptions, that);
        fluid.popActivity();
        return togo;
    };

    // unsupported, non-API function
    fluid.argMapToDemands = function (argMap) {
        var togo = [];
        fluid.each(argMap, function (value, key) {
            togo[value] = "{" + key + "}";
        });
        return togo;
    };

    // unsupported, non-API function
    fluid.makePassArgsSpec = function (initArgs) {
        return fluid.transform(initArgs, function(arg, index) {
            return "{arguments}." + index;
        });
    };

    // unsupported, NON-API function
    fluid.pushDemandSpec = function (record, options, mergeOptions) {
        if (options && options !== "{options}") {
            record.push({options: options});
        }
        if (mergeOptions) {
            record.push({mergeOptions: mergeOptions});
        }
    };

    /** Given a concrete argument list and/or options, determine the final concrete
     * "invocation specification" which is coded by the supplied demandspec in the
     * environment "thatStack" - the return is a package of concrete global function name
     * and argument list which is suitable to be executed directly by fluid.invokeGlobalFunction.
     */
    // unsupported, non-API function
    // options is just a disposition record containing memberName, componentRecord + passArgs
    // various built-in effects of this method
    // i) note that it makes no effort to actually propagate direct
    // options from "initArgs", assuming that they will be seen again in expandComponentOptions
    fluid.embodyDemands = function (parentThat, demandspec, initArgs, options) {
        options = options || {};

        if (demandspec.mergeOptions && demandspec.options) {
            fluid.fail("demandspec ", demandspec,
                    " is invalid - cannot specify literal options together with mergeOptions");
        }
        if (demandspec.transformOptions) { // Support for "transformOptions" at top level in a demands record
            demandspec.options = $.extend(true, {}, demandspec.options, {
                transformOptions: demandspec.transformOptions
            });
        }
        var demands = fluid.makeArray(demandspec.args);

        var upDefaults = fluid.defaults(demandspec.funcName);

        var fakeThat = {}; // fake "that" for receiveDistributions since we try to match selectors before creation for FLUID-5013
        var distributions = upDefaults && parentThat ? fluid.receiveDistributions(parentThat, upDefaults.gradeNames, options.memberName, fakeThat) : [];

        var argMap = upDefaults? upDefaults.argumentMap : null;
        var inferMap = false;
        if (upDefaults) {
            options.passArgs = false; // Don't attempt to construct a component using "passArgs" spec
        }
        if (!argMap && (upDefaults || (options && options.componentRecord))) {
            inferMap = true;
            // infer that it must be a little component if we have any reason to believe it is a component
            if (demands.length < 2) {
                argMap = fluid.rawDefaults("fluid.littleComponent").argumentMap;
            }
            else {
                var optionpos = $.inArray("{options}", demands);
                if (optionpos === -1) {
                    optionpos = demands.length - 1; // wild guess in the old style
                }
                argMap = {options: optionpos};
            }
        }
        options = options || {};
        if (demands.length === 0) {
            if (argMap) {
                demands = fluid.argMapToDemands(argMap);
            }
            else if (options.passArgs) {
                demands = fluid.makePassArgsSpec(initArgs);
            }
        }
        var shadow = fluid.shadowForComponent(parentThat);
        var localDynamic = shadow && options.memberName ? shadow.subcomponentLocal[options.memberName] : null;

        // confusion remains with "localRecord" - it is a random mishmash of user arguments and the component record
        // this should itself be absorbed into "mergeRecords" and let stackFetcher sort it out
        var localRecord = $.extend({"arguments": initArgs}, fluid.censorKeys(options.componentRecord, ["type"]), localDynamic);

        fluid.each(argMap, function (index, name) {
            // this is incorrect anyway! What if the supplied arguments were not in the same order as the target argmap,
            // which was obtained from the target defaults
            if (initArgs.length > 0) {
                localRecord[name] = localRecord["arguments"][index];
            }
            if (demandspec[name] !== undefined && localRecord[name] === undefined) {
                localRecord[name] = demandspec[name];
            }
            if (name !== "options") {
                for (var i = 0; i < distributions.length; ++ i) { // Apply non-options material from distributions (FLUID-5013)
                    if (distributions[i][name] !== undefined) {
                        localRecord[name] = distributions[i][name];
                    }
                }
            }
        });
        var i;
        for (i = 0; i < distributions.length; ++ i) {
            if (distributions[i].type !== undefined) {
                demandspec.funcName = distributions[i].type;
            }
        }

        var mergeRecords = {distributions: distributions};

        if (options.componentRecord !== undefined) {
            // Deliberately put too many things here so they can be checked in expandComponentOptions (FLUID-4285)
            mergeRecords.subcomponentRecord = $.extend({}, options.componentRecord);
        }
        var expandOptions = fluid.makeStackResolverOptions(parentThat, localRecord);
        var pushBackSpec = function (backSpec) {
            fluid.pushDemandSpec(mergeRecords.demands, backSpec.options, backSpec.mergeOptions);
        };
        var args = [];
        if (demands) {
            for (i = 0; i < demands.length; ++i) {
                var arg = demands[i];
                // Weak detection since we cannot guarantee this material has not been copied
                if (fluid.isMarker(arg) && arg.value === fluid.COMPONENT_OPTIONS.value) {
                    arg = "{options}";
                    // Backwards compatibility for non-users of GRADES - last-ditch chance to correct the inference
                    if (inferMap) {
                        argMap = {options: i};
                    }
                }
                if (typeof(arg) === "string") {
                    if (arg.charAt(0) === "@") {
                        var argpos = arg.substring(1);
                        arg = "{arguments}." + argpos;
                    }
                }
                demands[i] = arg;
                if (!argMap || argMap.options !== i) {
                    // expand immediately if there can be no options or this is not the options
                    args[i] = fluid.expand(arg, expandOptions);
                }
                else { // It is the component options
                    if (options.passArgs) {
                        fluid.fail("Error invoking function " + demandspec.funcName + ": found component creator rather than free function");
                    }
                    if (typeof(arg) === "object" && !arg.targetTypeName) {
                        arg.targetTypeName = demandspec.funcName;
                    }
                    mergeRecords.demands = [];
                    fluid.each((demandspec.backSpecs).reverse(), pushBackSpec);
                    fluid.pushDemandSpec(mergeRecords.demands, demandspec.options || arg, demandspec.mergeOptions);
                    if (initArgs.length > 0) {
                        mergeRecords.user = {options: localRecord.options};
                    }
                    args[i] = {marker: fluid.EXPAND,
                               localRecord: localDynamic,
                               mergeRecords: mergeRecords,
                               instantiator: fluid.getInstantiator(parentThat),
                               parentThat: parentThat,
                               memberName: options.memberName};
                }
                if (args[i] && fluid.isMarker(args[i].marker, fluid.EXPAND_NOW)) {
                    args[i] = fluid.expand(args[i].value, expandOptions);
                }
            }
        }
        else {
            args = initArgs? initArgs : [];
        }

        var togo = {
            args: args,
            preExpand: demands,
            funcName: demandspec.funcName
        };
        return togo;
    };

    /** Instantiate the subcomponent with the supplied name of the supplied top-level component. Although this method
     * is published as part of the Fluid API, it should not be called by general users and may not remain stable. It is
     * currently the only mechanism provided for instantiating components whose definitions are dynamic, and will be
     * replaced in time by dedicated declarative framework described by FLUID-5022.
     * @param that {Component} the parent component for which the subcomponent is to be instantiated
     * @param name {String} the name of the component - the index of the options block which configures it as part of the
     * <code>components</code> section of its parent's options
     */
     // NB "directArgs" is now disused by the framework

    fluid.initDependent = function (that, name, directArgs) {
        if (that[name]) { return; } // TODO: move this into strategy
        directArgs = directArgs || [];
        var component = that.options.components[name];
        fluid.pushActivity("initDependent", "instantiating dependent component with name \"%name\" with record %record as child of %parent",
            {name: name, record: component, parent: that});
        var instance;
        var instantiator = idToInstantiator[that.id];

        if (typeof(component) === "string") {
            instance = fluid.expandOptions(component, that);
            instantiator.recordKnownComponent(that, instance, name, false);
        }
        else if (component.type) {
            var type = fluid.expandOptions(component.type, that);
            if (!type) {
                fluid.fail("Error in subcomponent record: ", component.type, " could not be resolved to a type for component ", name,
                    " of parent ", that);
            }
            var invokeSpec = fluid.resolveDemands(that, [type, name], directArgs,
                {componentRecord: component, memberName: name});
            instance = fluid.initSubcomponentImpl(that, {type: invokeSpec.funcName}, invokeSpec.args);
            // The existing instantiator record will be provisional, adjust it to take account of the true return
            // TODO: Instantiator contents are generally extremely incomplete
            var path = instantiator.composePath(instantiator.idToPath(that.id), name);
            var existing = instantiator.pathToComponent[path];
            // This branch deals with the case where the component creator registered a component into "pathToComponent"
            // that does not agree with the component which was the return value. We need to clear out "pathToComponent" but
            // not shred the component since most of it is probably still valid
            if (existing && existing !== instance) {
                instantiator.clearComponent(that, name, existing);
            }
            if (instance && instance.typeName && instance.id && instance !== existing) {
                instantiator.recordKnownComponent(that, instance, name, true);
            }
            instance.destroy = fluid.fabricateDestroyMethod(that, name, instantiator, instance);
        }
        else {
            fluid.fail("Unrecognised material in place of subcomponent " + name + " - no \"type\" field found");
        }
        that[name] = instance;
        fluid.fireEvent(instance, "events.onAttach", [instance, name, that]);
        fluid.popActivity();
        return instance;
    };

    // unsupported, non-API function
    fluid.bindDeferredComponent = function (that, componentName, component) {
        var events = fluid.makeArray(component.createOnEvent);
        fluid.each(events, function(eventName) {
            var event = eventName.charAt(0) === "{" ? fluid.expandOptions(eventName, that) : that.events[eventName];
            if (!event || !event.addListener) {
                fluid.fail("Error instantiating createOnEvent component with name " + componentName + " of parent ", that, " since event specification " +
                    eventName + " could not be expanded to an event - got ", event);
            }
            event.addListener(function () {
                fluid.pushActivity("initDeferred", "instantiating deferred component %componentName of parent %that due to event %eventName",
                 {componentName: componentName, that: that, eventName: eventName});
                if (that[componentName]) {
                    var instantiator = idToInstantiator[that.id];
                    instantiator.clearComponent(that, componentName);
                }
                fluid.initDependent(that, componentName);
                fluid.popActivity();
            }, null, null, component.priority);
        });
    };

    // unsupported, non-API function
    fluid.priorityForComponent = function (component) {
        return component.priority? component.priority :
            (component.type === "fluid.typeFount" || fluid.hasGrade(fluid.defaults(component.type), "fluid.typeFount"))?
            "first" : undefined;
    };

    fluid.initDependents = function (that) {
        fluid.pushActivity("initDependents", "instantiating dependent components for component %that", {that: that});
        var shadow = fluid.shadowForComponent(that);
        shadow.memberStrategy.initter();

        var options = that.options;
        var components = options.components || {};
        var componentSort = {};

        fluid.each(components, function (component, name) {
            if (!component.createOnEvent) {
                var priority = fluid.priorityForComponent(component);
                componentSort[name] = [{key: name, priority: fluid.event.mapPriority(priority, 0)}];
            }
            else {
                fluid.bindDeferredComponent(that, name, component);
            }
        });
        var componentList = fluid.event.sortListeners(componentSort);
        fluid.each(componentList, function (entry) {
            fluid.initDependent(that, entry.key);
        });

        shadow.invokerStrategy.initter();
        fluid.popActivity();
    };

    var dependentStore = {};

    function searchDemands (demandingName, contextNames) {
        var exist = dependentStore[demandingName] || [];
outer:  for (var i = 0; i < exist.length; ++i) {
            var rec = exist[i];
            for (var j = 0; j < contextNames.length; ++j) {
                if (rec.contexts[j] !== contextNames[j]) {
                    continue outer;
                }
            }
            return rec.spec; // jslint:ok
        }
    }

    var isDemandLogging = false;
    fluid.setDemandLogging = function (set) {
        isDemandLogging = set;
    };

    // unsupported, non-API function
    fluid.isDemandLogging = function () {
        return isDemandLogging && fluid.isLogging();
    };

    fluid.demands = function (demandingName, contextName, spec) {
        var contextNames = fluid.makeArray(contextName).sort();
        if (!spec) {
            return searchDemands(demandingName, contextNames);
        }
        else if (spec.length) {
            spec = {args: spec};
        }
        if (fluid.getCallerInfo && fluid.isDemandLogging()) {
            var callerInfo = fluid.getCallerInfo(5);
            if (callerInfo) {
                spec.registeredFrom = callerInfo;
            }
        }
        spec.demandId = fluid.allocateGuid();
        var exist = dependentStore[demandingName];
        if (!exist) {
            exist = [];
            dependentStore[demandingName] = exist;
        }
        exist.push({contexts: contextNames, spec: spec});
    };

    // unsupported, non-API function
    fluid.compareDemands = function (speca, specb) {
        return specb.intersect - speca.intersect;
    };

    // unsupported, non-API function
    fluid.locateAllDemands = function (parentThat, demandingNames) {
        var demandLogging = fluid.isDemandLogging(demandingNames);
        if (demandLogging) {
            fluid.log("Resolving demands for function names ", demandingNames, " in context of " +
                (parentThat? "component " + parentThat.typeName : "no component"));
        }

        var contextNames = {};
        var visited = [];
        var instantiator = fluid.getInstantiator(parentThat);
        var thatStack = instantiator.getFullStack(parentThat);
        visitComponents(instantiator, thatStack, function (component, xname, path, xpath, depth) {
            // NB - don't use shadow's cache here because we allow fewer names for demand resolution than for value resolution
            contextNames[component.typeName] = depth;
            var gradeNames = fluid.makeArray(fluid.get(component, ["options", "gradeNames"]));
            fluid.each(gradeNames, function (gradeName) {
                contextNames[gradeName] = depth;
            });
            visited.push(component);
        });
        if (demandLogging) {
            fluid.log("Components in scope for resolution:\n" + fluid.dumpThatStack(visited, instantiator));
        }
        var matches = [];
        for (var i = 0; i < demandingNames.length; ++i) {
            var rec = dependentStore[demandingNames[i]] || [];
            for (var j = 0; j < rec.length; ++j) {
                var spec = rec[j];
                var horizonLevel = spec.spec.horizon ? contextNames[spec.spec.horizon] : -1;
                var record = {spec: spec, intersect: 0, uncess: 0};
                for (var k = 0; k < spec.contexts.length; ++k) {
                    var depth = contextNames[spec.contexts[k]];
                    record[depth !== undefined && depth >= horizonLevel ? "intersect" : "uncess"] += 2;
                }
                if (spec.contexts.length === 0) { // allow weak priority for contextless matches
                    record.intersect++;
                }
                if (record.uncess === 0) {
                    matches.push(record);
                }
            }
        }
        matches.sort(fluid.compareDemands);
        return matches;
    };

    // unsupported, non-API function
    fluid.locateDemands = function (parentThat, demandingNames) {
        var matches = fluid.locateAllDemands(parentThat, demandingNames);
        var demandspec = fluid.getMembers(matches, ["spec", "spec"]);
        if (fluid.isDemandLogging(demandingNames)) {
            if (demandspec.length) {
                fluid.log("Located " + matches.length + " potential match" + (matches.length === 1? "" : "es") + ", selected best match with " + matches[0].intersect +
                    " matched context names: ", demandspec);
            }
            else {
                fluid.log("No matches found for demands, using direct implementation");
            }
        }
        return demandspec;
    };

    /** Determine the appropriate demand specification held in the fluid.demands environment
     * relative the supplied component position for the function name(s) funcNames.
     */
    // unsupported, non-API function
    fluid.determineDemands = function (parentThat, funcNames) {
        funcNames = fluid.makeArray(funcNames);
        var newFuncName = funcNames[0];
        var demandspec = fluid.locateDemands(parentThat, funcNames);
        if (demandspec.length && demandspec[0].funcName) {
            newFuncName = demandspec[0].funcName;
        }

        return $.extend(true, {funcName: newFuncName,
                                args: demandspec[0] ? fluid.makeArray(demandspec[0].args) : []
                                },
                                { backSpecs: demandspec.slice(1) }, // Fix for FLUID-5126
            fluid.censorKeys(demandspec[0], ["funcName", "args"]));
    };
    // "options" includes - passArgs, componentRecord, memberName (latter two from initDependent route)
    // unsupported, non-API function
    fluid.resolveDemands = function (parentThat, funcNames, initArgs, options) {
        var demandspec = fluid.determineDemands(parentThat, funcNames);
        return fluid.embodyDemands(parentThat, demandspec, initArgs, options);
    };

    // unsupported, non-API function
    fluid.thisistToApplicable = function (record, recthis, that) {
        return {
            apply: function (noThis, args) {
                // Resolve this material late, to deal with cases where the target has only just been brought into existence
                // (e.g. a jQuery target for rendered material) - TODO: Possibly implement cached versions of these as we might do for invokers
                var resolvedThis = fluid.expandOptions(recthis, that);
                if (typeof(resolvedThis) === "string") {
                    resolvedThis = fluid.getGlobalValue(resolvedThis);
                }
                if (!resolvedThis) {
                    fluid.fail("Could not resolve reference " + recthis + " to a value");
                }
                var resolvedFunc = resolvedThis[record.method];
                if (typeof(resolvedFunc) !== "function") {
                    fluid.fail("Object ", resolvedThis, " at reference " + recthis + " has no member named " + record.method + " which is a function ");
                }
                fluid.log("Applying arguments ", args, " to method " + record.method + " of instance ", resolvedThis);
                return resolvedFunc.apply(resolvedThis, args);
            }
        };
    };

    fluid.changeToApplicable = function (record, that) {
        return {
            apply: function (noThis, args) {
                var parsed = fluid.parseValidModelReference(that, "changePath listener record", record.changePath);
                var value = fluid.expandOptions(record.value, that, {}, {"arguments": args});
                fluid.fireSourcedChange(parsed.applier, parsed.path, value, record.source);
            }
        };
    };

    // Convert "exotic records" into an applicable form ("this/method" for FLUID-4878 or "changePath" for FLUID-3674)
    // unsupported, non-API function
    fluid.recordToApplicable = function (record, that) {
        if (record.changePath) {
            return fluid.changeToApplicable(record, that);
        }
        var recthis = record["this"];
        if (record.method ^ recthis) {
            fluid.fail("Record ", that, " must contain both entries \"method\" and \"this\" if it contains either");
        }
        return record.method ? fluid.thisistToApplicable(record, recthis, that) : null;
    };

    // TODO: make a *slightly* more performant version of fluid.invoke that perhaps caches the demands
    // after the first successful invocation
    fluid.invoke = function (functionName, args, that, environment) {
        fluid.pushActivity("invokeFunc", "invoking function with name \"%functionName\" from component %that", {functionName: functionName, that: that});
        var invokeSpec = fluid.resolveDemands(that, functionName, fluid.makeArray(args), {passArgs: true});
        var togo = fluid.invokeGlobalFunction(invokeSpec.funcName, invokeSpec.args, environment);
        fluid.popActivity();
        return togo;
    };

    /** Make a function which performs only "static redispatch" of the supplied function name -
     * that is, taking only account of the contents of the "static environment". Since the static
     * environment is assumed to be constant, the dispatch of the call will be evaluated at the
     * time this call is made, as an optimisation.
     */
    // unsupported, non-API function
    fluid.makeFreeInvoker = function (functionName, environment) {
        var demandSpec = fluid.determineDemands(null, functionName);
        return function () {
            var invokeSpec = fluid.embodyDemands(null, demandSpec, fluid.makeArray(arguments), {passArgs: true});
            return fluid.invokeGlobalFunction(invokeSpec.funcName, invokeSpec.args, environment);
        };
    };

    var argPrefix = "{arguments}.";

    fluid.parseInteger = function (string) {
        return isFinite(string) && ((string % 1) === 0) ? Number(string) : NaN;
    };

    fluid.makeFastInvoker = function (invokeSpec, func) {
        var argMap;
        if (invokeSpec.preExpand) {
            argMap = {};
            for (var i = 0; i < invokeSpec.preExpand.length; ++ i) {
                var value = invokeSpec.preExpand[i];
                if (typeof(value) === "string") {
                    if (value.indexOf("}.model") !== -1) {
                        return {noFast: true};
                    }
                    if (value === "{arguments}") {
                        argMap[i] = "*";
                    } else if (value.indexOf(argPrefix) === 0) {
                        var argIndex = fluid.parseInteger(value.substring(argPrefix.length));
                        if (isNaN(argIndex)) {
                            return {noFast: true};
                        }
                        else {
                            argMap[i] = argIndex; // target arg pos = original arg pos
                        }
                    }
                }
            }
        }
        var outArgs = invokeSpec.args;
        var invoke = argMap ? function invoke(args) {
            for (var i in argMap) {
                outArgs[i] = argMap[i] === "*" ? args : args[argMap[i]];
            }
            return func.apply(null, outArgs);
        } : function invoke (args) {
            return func.apply(null, args);
        };
        return {
            invoke: invoke
        };
    };

    // unsupported, non-API function
    fluid.makeInvoker = function (that, invokerec, name, environment) {
        var functionName;
        if (typeof(invokerec) === "string") {
            if (invokerec.charAt(0) === "{") { // shorthand case for direct function invokers (FLUID-4926)
                invokerec = {func: invokerec};
            } else {
                functionName = invokerec;
            }
        }
        var demandspec = functionName? fluid.determineDemands(that, functionName) : invokerec;
        var fastRec = {noFast: invokerec.dynamic};
        return function invokeInvoker () {
            if (fluid.defeatLogging === false) {
                fluid.pushActivity("invokeInvoker", "invoking invoker with name %name and record %record from component %that", {name: name, record: invokerec, that: that});
            }
            var togo;
            if (fastRec.invoke) {
                togo = fastRec.invoke(arguments);
            }
            else {
                var func = fluid.recordToApplicable(invokerec, that);
                var args = fluid.makeArray(arguments);
                var invokeSpec = fluid.embodyDemands(that, demandspec, args, {passArgs: true});
                func = func || (invokeSpec.funcName? fluid.getGlobalValue(invokeSpec.funcName, environment)
                    : fluid.expandOptions(demandspec.func, that));
                if (!func || !func.apply) {
                    fluid.fail("Error in invoker record: could not resolve members func, funcName or method to a function implementation - got " + func + " from ", demandspec);
                }
                if (fastRec.noFast !== true) {
                    fastRec = fluid.makeFastInvoker(invokeSpec, func);
                }
                togo = func.apply(null, invokeSpec.args);
            }
            if (fluid.defeatLogging === false) {
                fluid.popActivity();
            }
            return togo;
        };
    };

    // unsupported, non-API function
    // weird higher-order function so that we can staightforwardly dispatch original args back onto listener
    fluid.event.makeTrackedListenerAdder = function (source) {
        var shadow = fluid.shadowForComponent(source);
        return function (event) {
            return {addListener: function (listener) {
                    fluid.recordListener(event, listener, shadow);
                    event.addListener.apply(null, arguments);
                }
            };
        };
    };

    // unsupported, non-API function
    fluid.event.listenerEngine = function (eventSpec, callback, adder) {
        var argstruc = {};
        function checkFire() {
            var notall = fluid.find(eventSpec, function(value, key) {
                if (argstruc[key] === undefined) {
                    return true;
                }
            });
            if (!notall) {
                var oldstruc = argstruc;
                argstruc = {}; // guard against the case the callback perversely fires one of its prerequisites (FLUID-5112)
                callback(oldstruc);
            }
        }
        fluid.each(eventSpec, function (event, eventName) {
            adder(event).addListener(function () {
                argstruc[eventName] = fluid.makeArray(arguments);
                checkFire();
            });
        });
    };

    // unsupported, non-API function
    fluid.event.dispatchListener = function (that, listener, eventName, eventSpec, indirectArgs) {
        var togo = function () {
            fluid.pushActivity("dispatchListener", "firing to listener to event named %eventName of component %that",
                {eventName: eventName, that: that});

            var args = indirectArgs? arguments[0] : fluid.makeArray(arguments);
            var demandspec = fluid.determineDemands(that, eventName); // TODO: This name may contain a namespace
            if (demandspec.args.length === 0 && eventSpec.args) {
                demandspec.args = eventSpec.args;
            }
            // TODO: create a "fast path" here as for invokers. Eliminate redundancy with invoker code
            var resolved = fluid.embodyDemands(that, demandspec, args, {passArgs: true});
            var togo = fluid.event.invokeListener(listener, resolved.args);
            fluid.popActivity();
            return togo;
        };
        fluid.event.impersonateListener(listener, togo);
        return togo;
    };

    // unsupported, non-API function
    fluid.event.resolveSoftNamespace = function (key) {
        if (typeof(key) !== "string") {
            return null;
        } else {
            var lastpos = Math.max(key.lastIndexOf("."), key.lastIndexOf("}"));
            return key.substring(lastpos + 1);
        }
    };

    // unsupported, non-API function
    fluid.event.resolveListenerRecord = function (lisrec, that, eventName, namespace, standard) {
        var badRec = function (record, extra) {
            fluid.fail("Error in listener record - could not resolve reference ", record, " to a listener or firer. " +
                "Did you miss out \"events.\" when referring to an event firer?" + extra);
        };
        fluid.pushActivity("resolveListenerRecord", "resolving listener record for event named %eventName for component %that",
            {eventName: eventName, that: that});
        var records = fluid.makeArray(lisrec);
        var transRecs = fluid.transform(records, function (record) {
            // TODO: FLUID-5242 fix - we copy here since distributeOptions does not copy options blocks that it distributes and we can hence corrupt them.
            // need to clarify policy on options sharing - for slightly better efficiency, copy should happen during distribution and not here
            var expanded = fluid.isPrimitive(record) || record.expander ? {listener: record} : fluid.copy(record);
            var methodist = fluid.recordToApplicable(record, that);
            if (methodist) {
                expanded.listener = methodist;
            }
            else {
                expanded.listener = expanded.listener || expanded.func || expanded.funcName;
            }
            if (!expanded.listener) {
                badRec(record, " Listener record must contain a member named \"listener\", \"func\", \"funcName\" or \"method\"");
            }
            var softNamespace = record.method ?
                fluid.event.resolveSoftNamespace(record["this"]) + "." + record.method :
                fluid.event.resolveSoftNamespace(expanded.listener);
            if (!expanded.namespace && !namespace && softNamespace) {
                expanded.softNamespace = true;
                expanded.namespace = (record.componentSource ? record.componentSource : that.typeName) + "." + softNamespace;
            }
            var listener = expanded.listener = fluid.expandOptions(expanded.listener, that);
            if (!listener) {
                badRec(record, "");
            }
            var firer = false;
            if (listener.typeName === "fluid.event.firer") {
                listener = listener.fire;
                firer = true;
            }
            expanded.listener = (standard && (expanded.args || firer)) ? fluid.event.dispatchListener(that, listener, eventName, expanded) : listener;
            return expanded;
        });
        var togo = {
            records: transRecs,
            adderWrapper: standard ? fluid.event.makeTrackedListenerAdder(that) : null
        };
        fluid.popActivity();
        return togo;
    };

    // unsupported, non-API function
    fluid.event.expandOneEvent = function (that, event) {
        var origin;
        if (typeof(event) === "string" && event.charAt(0) !== "{") {
            // Shorthand for resolving onto our own events, but with GINGER WORLD!
            origin = fluid.getForComponent(that, ["events", event]);
        }
        else {
            origin = fluid.expandOptions(event, that);
        }
        if (!origin || origin.typeName !== "fluid.event.firer") {
            fluid.fail("Error in event specification - could not resolve base event reference ", event, " to an event firer: got ", origin);
        }
        return origin;
    };

    // unsupported, non-API function
    fluid.event.expandEvents = function (that, event) {
        return typeof(event) === "string" ?
            fluid.event.expandOneEvent(that, event) :
            fluid.transform(event, function (oneEvent) {
                return fluid.event.expandOneEvent(that, oneEvent);
            });
    };

    // unsupported, non-API function
    fluid.event.resolveEvent = function (that, eventName, eventSpec) {
        fluid.pushActivity("resolveEvent", "resolving event with name %eventName attached to component %that",
            {eventName: eventName, that: that});
        var adder = fluid.event.makeTrackedListenerAdder(that);
        if (typeof(eventSpec) === "string") {
            eventSpec = {event: eventSpec};
        }
        var event = eventSpec.event || eventSpec.events;
        if (!event) {
            fluid.fail("Event specification for event with name " + eventName + " does not include a base event specification: ", eventSpec);
        }

        var origin = fluid.event.expandEvents(that, event);

        var isMultiple = origin.typeName !== "fluid.event.firer";
        var isComposite = eventSpec.args || isMultiple;
        // If "event" is not composite, we want to share the listener list and FIRE method with the original
        // If "event" is composite, we need to create a new firer. "composite" includes case where any boiling
        // occurred - this was implemented wrongly in 1.4.
        var firer;
        if (isComposite) {
            firer = fluid.makeEventFirer({name: " [composite] " + fluid.event.nameEvent(that, eventName)});
            var dispatcher = fluid.event.dispatchListener(that, firer.fire, eventName, eventSpec, isMultiple);
            if (isMultiple) {
                fluid.event.listenerEngine(origin, dispatcher, adder);
            }
            else {
                adder(origin).addListener(dispatcher);
            }
        }
        else {
            firer = {typeName: "fluid.event.firer"}; // jslint:ok - already defined
            firer.fire = function () {
                var outerArgs = fluid.makeArray(arguments);
                fluid.pushActivity("fireSynthetic", "firing synthetic event %eventName ", {eventName: eventName});
                var togo = origin.fire.apply(null, outerArgs);
                fluid.popActivity();
                return togo;
            };
            firer.addListener = function (listener, namespace, predicate, priority, softNamespace) {
                var dispatcher = fluid.event.dispatchListener(that, listener, eventName, eventSpec);
                adder(origin).addListener(dispatcher, namespace, predicate, priority, softNamespace);
            };
            firer.removeListener = function (listener) {
                origin.removeListener(listener);
            };
        }
        fluid.popActivity();
        return firer;
    };

    /** BEGIN unofficial IoC material **/
    // Although the following three functions are unsupported and not part of the IoC
    // implementation proper, they are still used in the renderer
    // expander as well as in some old-style tests and various places in CSpace.

    // unsupported, non-API function
    fluid.withEnvironment = function (envAdd, func, root) {
        root = root || fluid.globalThreadLocal();
        return fluid.tryCatch(function() {
            for (var key in envAdd) {
                root[key] = envAdd[key];
            }
            $.extend(root, envAdd);
            return func();
        }, null, function() {
            for (var key in envAdd) { // jslint:ok duplicate "value"
                delete root[key]; // TODO: users may want a recursive "scoping" model
            }
        });
    };

    // unsupported, NON-API function
    fluid.fetchContextReference = function (parsed, directModel, env, elResolver, externalFetcher) {
        // The "elResolver" is a hack to make certain common idioms in protoTrees work correctly, where a contextualised EL
        // path actually resolves onto a further EL reference rather than directly onto a value target
        if (elResolver) {
            parsed = elResolver(parsed, env);
        }
        var base = parsed.context? env[parsed.context] : directModel;
        if (!base) {
            var resolveExternal = externalFetcher && externalFetcher(parsed);
            return resolveExternal || base;
        }
        return parsed.noDereference? parsed.path : fluid.get(base, parsed.path);
    };

    // unsupported, non-API function
    fluid.makeEnvironmentFetcher = function (directModel, elResolver, envGetter, externalFetcher) {
        envGetter = envGetter || fluid.globalThreadLocal;
        return function(parsed) {
            var env = envGetter();
            return fluid.fetchContextReference(parsed, directModel, env, elResolver, externalFetcher);
        };
    };

    /** END of unofficial IoC material **/

    // unsupported, non-API function
    fluid.coerceToPrimitive = function (string) {
        return string === "false" ? false : (string === "true" ? true :
            (isFinite(string) ? Number(string) : string));
    };

    // unsupported, non-API function
    fluid.compactStringToRec = function (string, type) {
        var openPos = string.indexOf("(");
        var closePos = string.indexOf(")");
        if (openPos === -1 ^ closePos === -1 || openPos > closePos) {
            fluid.fail("Badly-formed compact " + type + " record without matching parentheses: ", string);
        }
        if (openPos !== -1 && closePos !== -1) {
            var prefix = string.substring(0, openPos);
            var body = string.substring(openPos + 1, closePos);
            var args = fluid.transform(body.split(","), $.trim, fluid.coerceToPrimitive);
            var togo = {
                args: args
            };
            if (type === "invoker" && prefix.charAt(openPos - 1) === "!") {
                prefix = string.substring(0, openPos - 1);
                togo.dynamic = true;
            }
            togo[prefix.charAt(0) === "{" ? "func" : "funcName"] = prefix;
            return togo;
        }
        else if (type === "expander") {
            fluid.fail("Badly-formed compact expander record without parentheses: ", string);
        }
        return string;
    };

    fluid.expandPrefix = "@expand:";
    // unsupported, non-API function
    fluid.expandCompactString = function (string, active) {
        var rec = string;
        if (string.indexOf(fluid.expandPrefix) === 0) {
            var rem = string.substring(fluid.expandPrefix.length);
            rec = {
                expander: fluid.compactStringToRec(rem, "expander")
            };
        }
        else if (active) {
            rec = fluid.compactStringToRec(string, active);
        }
        return rec;
    };

    var singularPenRecord = {
        listeners: "listener",
        modelListeners: "modelListener"
    };

    var singularRecord = $.extend({
        invokers: "invoker"
    }, singularPenRecord);

    // unsupported, non-API function
    fluid.expandCompactRec = function (segs, target, source, userOptions) {
        var pen = segs.length > 0 ? segs[segs.length - 1] : "";
        var active = singularRecord[pen];
        if (!active && segs.length > 1) {
            active = singularPenRecord[segs[segs.length - 2]]; // support array of listeners and modelListeners
        }
        fluid.each(source, function (value, key) {
            // TODO: hack here to avoid corrupting old-style model references which were listed with "preserve" - eliminate this along with that mergePolicy
            if (fluid.isPlainObject(value) && !fluid.isDOMish(value) && !(userOptions && key === "model" && segs.length === 0)) {
                target[key] = fluid.freshContainer(value);
                segs.push(key);
                fluid.expandCompactRec(segs, target[key], value);
                segs.pop();
                return;
            }
            else if (typeof(value) === "string") {
                value = fluid.expandCompactString(value, active);
            }
            target[key] = value;
        });
    };

    // unsupported, non-API function
    fluid.expandCompact = function (options, userOptions) {
        var togo = {};
        fluid.expandCompactRec([], togo, options, userOptions);
        return togo;
    };

    // unsupported, non-API function
    fluid.extractEL = function (string, options) {
        if (options.ELstyle === "ALL") {
            return string;
        }
        else if (options.ELstyle.length === 1) {
            if (string.charAt(0) === options.ELstyle) {
                return string.substring(1);
            }
        }
        else if (options.ELstyle === "${}") {
            var i1 = string.indexOf("${");
            var i2 = string.lastIndexOf("}");
            if (i1 === 0 && i2 !== -1) {
                return string.substring(2, i2);
            }
        }
    };

    // unsupported, non-API function
    fluid.extractELWithContext = function (string, options) {
        var EL = fluid.extractEL(string, options);
        if (EL && EL.charAt(0) === "{" && EL.indexOf("}") > 0) {
            return fluid.parseContextReference(EL);
        }
        return EL? {path: EL} : EL;
    };

    fluid.parseContextReference = function (reference, index, delimiter) {
        index = index || 0;
        var endcpos = reference.indexOf("}", index + 1);
        if (endcpos === -1) {
            fluid.fail("Cannot parse context reference \"" + reference + "\": Malformed context reference without }");
        }
        var context = reference.substring(index + 1, endcpos);
        var endpos = delimiter? reference.indexOf(delimiter, endcpos + 1) : reference.length;
        var path = reference.substring(endcpos + 1, endpos);
        if (path.charAt(0) === ".") {
            path = path.substring(1);
        }
        return {context: context, path: path, endpos: endpos};
    };

    fluid.renderContextReference = function (parsed) {
        return "{" + parsed.context + "}" + (parsed.path ? "." + parsed.path : "");
    };

    // unsupported, non-API function
    fluid.resolveContextValue = function (string, options) {
        function fetch(parsed) {
            fluid.pushActivity("resolveContextValue", "resolving context value %string", {string: string});
            var togo = options.fetcher(parsed);
            fluid.pushActivity("resolvedContextValue", "resolved value %string to value %value", {string: string, value: togo});
            fluid.popActivity(2);
            return togo;
        }
        var parsed;
        if (options.bareContextRefs && string.charAt(0) === "{" && string.indexOf("}") > 0) {
            parsed = fluid.parseContextReference(string);
            return fetch(parsed);
        }
        else if (options.ELstyle && options.ELstyle !== "${}") {
            parsed = fluid.extractELWithContext(string, options);
            if (parsed) {
                return fetch(parsed);
            }
        }
        while (typeof(string) === "string") {
            var i1 = string.indexOf("${");
            var i2 = string.indexOf("}", i1 + 2);
            if (i1 !== -1 && i2 !== -1) {
                if (string.charAt(i1 + 2) === "{") {
                    parsed = fluid.parseContextReference(string, i1 + 2, "}");
                    i2 = parsed.endpos;
                }
                else {
                    parsed = {path: string.substring(i1 + 2, i2)};
                }
                var subs = fetch(parsed);
                var all = (i1 === 0 && i2 === string.length - 1);
                // TODO: test case for all undefined substitution
                if (subs === undefined || subs === null) {
                    return subs;
                }
                string = all? subs : string.substring(0, i1) + subs + string.substring(i2 + 1);
            }
            else {
                break;
            }
        }
        return string;
    };

    // unsupported, NON-API function
    fluid.expandExpander = function (target, source, options) {
        var expander = fluid.getGlobalValue(source.expander.type || "fluid.deferredInvokeCall");
        if (expander) {
            return expander.call(null, target, source, options);
        }
    };

    // This function appears somewhat reusable, but not entirely - it probably needs to be packaged
    // along with the particular "strategy". Very similar to the old "filter"... the "outer driver" needs
    // to execute it to get the first recursion going at top level. This was one of the most odd results
    // of the reorganisation, since the "old work" seemed much more naturally expressed in terms of values
    // and what happened to them. The "new work" is expressed in terms of paths and how to move amongst them.
    fluid.fetchExpandChildren = function (target, i, segs, source, mergePolicy, miniWorld, options) {
        if (source.expander /* && source.expander.type */) { // possible expander at top level
            var expanded = fluid.expandExpander(target, source, options);
            if (options.freeRoot || fluid.isPrimitive(expanded) || fluid.isDOMish(expanded) || !fluid.isPlainObject(expanded) || (fluid.isArrayable(expanded) ^ fluid.isArrayable(target))) {
                return expanded;
            }
            else { // make an attempt to preserve the root reference if possible
                $.extend(true, target, expanded);
            }
        }
        // NOTE! This expects that RHS is concrete! For material input to "expansion" this happens to be the case, but is not
        // true for other algorithms. Inconsistently, this algorithm uses "sourceStrategy" below. In fact, this "fetchChildren"
        // operation looks like it is a fundamental primitive of the system. We do call "deliverer" early which enables correct
        // reference to parent nodes up the tree - however, anyone processing a tree IN THE CHAIN requires that it is produced
        // concretely at the point STRATEGY returns. Which in fact it is...............
        fluid.each(source, function (newSource, key) {
            if (newSource === undefined) {
                target[key] = undefined; // avoid ever dispatching to ourselves with undefined source
            }
            else if (key !== "expander") {
                segs[i] = key;
                options.strategy(target, key, i + 1, segs, source, mergePolicy, miniWorld);
            }
        });
        return target;
    };

    // TODO: This method is unnecessary and will quadratic inefficiency if RHS block is not concrete.
    // The driver should detect "homogeneous uni-strategy trundling" and agree to preserve the extra
    // "cursor arguments" which should be advertised somehow (at least their number)
    function regenerateCursor (source, segs, limit, sourceStrategy) {
        for (var i = 0; i < limit; ++ i) {
            // copy segs to avoid aliasing with FLUID-5243
            source = sourceStrategy(source, segs[i], i, fluid.makeArray(segs));
        }
        return source;
    }

    // unsupported, NON-API function
    fluid.isUnexpandable = function (source) {
        return fluid.isPrimitive(source) || fluid.isComponent(source) || source.nodeType !== undefined || source.jquery || !fluid.isPlainObject(source);
    };

    // unsupported, NON-API function
    fluid.expandSource = function (options, target, i, segs, deliverer, source, policy, miniWorld, recurse) {
        var expanded, isTrunk, isLate;
        var thisPolicy = fluid.derefMergePolicy(policy);
        if (typeof (source) === "string" && !thisPolicy.noexpand) {
            if (!options.defaultEL || source.charAt(0) === "{") { // hard-code this for performance
                fluid.pushActivity("expandContextValue", "expanding context value %source held at path %path", {source: source, path: fluid.path.apply(null, segs.slice(0, i))});
                expanded = fluid.resolveContextValue(source, options);
                fluid.popActivity(1);
            } else {
                expanded = source;
            }
        }
        else if (thisPolicy.noexpand || fluid.isUnexpandable(source)) {
            expanded = source;
        }
        else if (source.expander) {
            expanded = fluid.expandExpander(deliverer, source, options);
        }
        else {
            if (thisPolicy.preserve) {
                expanded = source;
                isLate = true;
            }
            else {
                expanded = fluid.freshContainer(source);
            }
            isTrunk = true;
        }
        if (!isLate && expanded !== fluid.NO_VALUE) {
            deliverer(expanded);
        }
        if (isTrunk) {
            recurse(expanded, source, i, segs, policy, miniWorld || isLate);
        }
        if (isLate && expanded !== fluid.NO_VALUE) {
            deliverer(expanded);
        }
        return expanded;
    };

    // unsupported, NON-API function
    fluid.makeExpandStrategy = function (options) {
        var recurse = function (target, source, i, segs, policy, miniWorld) {
            return fluid.fetchExpandChildren(target, i || 0, segs || [], source, policy, miniWorld, options);
        };
        var strategy = function (target, name, i, segs, source, policy, miniWorld) {
            if (i > fluid.strategyRecursionBailout) {
                fluid.fail("Overflow/circularity in options expansion, current path is ", segs, " at depth " , i, " - please ensure options are not circularly connected, or protect from expansion using the \"noexpand\" policy or expander");
            }
            if (!target) {
                return;
            }
            if (!miniWorld && target.hasOwnProperty(name)) { // bail out if our work has already been done
                return target[name];
            }
            if (source === undefined) { // recover our state in case this is an external entry point
                source = regenerateCursor(options.source, segs, i - 1, options.sourceStrategy);
                policy = regenerateCursor(options.mergePolicy, segs, i - 1, fluid.concreteTrundler);
            }
            var thisSource = options.sourceStrategy(source, name, i, segs);
            var thisPolicy = fluid.concreteTrundler(policy, name);
            function deliverer(value) {
                target[name] = value;
            }
            return fluid.expandSource(options, target, i, segs, deliverer, thisSource, thisPolicy, miniWorld, recurse);
        };
        options.recurse = recurse;
        options.strategy = strategy;
        return strategy;
    };

    fluid.defaults("fluid.makeExpandOptions", {
        ELstyle:          "${}",
        bareContextRefs:  true,
        target:           fluid.inCreationMarker
    });

    // unsupported, NON-API function
    fluid.makeExpandOptions = function (source, options) {
        options = $.extend({}, fluid.rawDefaults("fluid.makeExpandOptions"), options);
        options.defaultEL = options.ELStyle === "${}" && options.bareContextRefs; // optimisation to help expander
        options.expandSource = function (source) {
            return fluid.expandSource(options, null, 0, [], fluid.identity, source, options.mergePolicy, false);
        };
        if (!fluid.isUnexpandable(source)) {
            options.source = source;
            options.target = fluid.freshContainer(source);
            options.sourceStrategy = options.sourceStrategy || fluid.concreteTrundler;
            fluid.makeExpandStrategy(options);
            options.initter = function () {
                options.target = fluid.fetchExpandChildren(options.target, 0, [], options.source, options.mergePolicy, false, options);
            };
        }
        else { // these init immediately since we must deliver a valid root target
            options.strategy = fluid.concreteTrundler;
            options.initter = fluid.identity;
            if (typeof(source) === "string") {
                options.target = options.expandSource(source);
            }
            else {
                options.target = source;
            }
        }
        return options;
    };

    fluid.expand = function (source, options) {
        var expandOptions = fluid.makeExpandOptions(source, options);
        expandOptions.initter();
        return expandOptions.target;
    };

    fluid.registerNamespace("fluid.expander");

    /** "light" expanders, starting with support functions for the so-called "deferredCall" expanders,
         which make an arbitrary function call (after expanding arguments) and are then replaced in
         the configuration with the call results. These will probably be abolished and replaced with
         equivalent model transformation machinery **/

    fluid.expander.deferredCall = function (deliverer, source, options) {
        var expander = source.expander;
        var args = (!expander.args || fluid.isArrayable(expander.args))? expander.args : fluid.makeArray(expander.args);
        args = options.recurse([], args);
        return fluid.invokeGlobalFunction(expander.func, args);
    };

    fluid.deferredCall = fluid.expander.deferredCall; // put in top namespace for convenience

    // This one is now positioned as the "universal expander" - default if no type supplied
    fluid.deferredInvokeCall = function (deliverer, source, options) {
        var expander = source.expander;
        var args = fluid.makeArray(expander.args);
        args = options.recurse([], args); // TODO: risk of double expansion here. embodyDemands will sometimes expand, sometimes not...
        var funcEntry = expander.func || expander.funcName;
        var func = options.expandSource(funcEntry) || fluid.recordToApplicable(expander, options.contextThat);
        if (!func) {
            fluid.fail("Error in expander record - " + funcEntry + " could not be resolved to a function for component ", options.contextThat);
        }
        return func.apply ? func.apply(null, args) : fluid.invoke(func, args, options.contextThat);
    };

    // The "noexpand" expander which simply unwraps one level of expansion and ceases.
    fluid.expander.noexpand = function (deliverer, source) {
        return source.expander.value ? source.expander.value : source.expander.tree;
    };

    fluid.noexpand = fluid.expander.noexpand; // TODO: check naming and namespacing


})(jQuery, fluid_2_0);
;/*
Copyright 2008-2010 University of Cambridge
Copyright 2008-2009 University of Toronto
Copyright 2010-2011 Lucendo Development Ltd.
Copyright 2010-2014 OCAD University

Licensed under the Educational Community License (ECL), Version 2.0 or the New
BSD license. You may not use this file except in compliance with one these
Licenses.

You may obtain a copy of the ECL 2.0 License and BSD License at
https://github.com/fluid-project/infusion/raw/master/Infusion-LICENSE.txt
*/

var fluid_2_0 = fluid_2_0 || {};

(function ($, fluid) {
    "use strict";

    /** NOTE: The contents of this file are by default NOT PART OF THE PUBLIC FLUID API unless explicitly annotated before the function **/

    /** MODEL ACCESSOR ENGINE **/

    /** Standard strategies for resolving path segments **/

    fluid.model.makeEnvironmentStrategy = function (environment) {
        return function (root, segment, index) {
            return index === 0 && environment[segment] ?
                environment[segment] : undefined;
        };
    };

    fluid.model.defaultCreatorStrategy = function (root, segment) {
        if (root[segment] === undefined) {
            root[segment] = {};
            return root[segment];
        }
    };

    fluid.model.defaultFetchStrategy = function (root, segment) {
        return root[segment];
    };

    fluid.model.funcResolverStrategy = function (root, segment) {
        if (root.resolvePathSegment) {
            return root.resolvePathSegment(segment);
        }
    };

    fluid.model.traverseWithStrategy = function (root, segs, initPos, config, uncess) {
        var strategies = config.strategies;
        var limit = segs.length - uncess;
        for (var i = initPos; i < limit; ++i) {
            if (!root) {
                return root;
            }
            var accepted;
            for (var j = 0; j < strategies.length; ++ j) {
                accepted = strategies[j](root, segs[i], i + 1, segs);
                if (accepted !== undefined) {
                    break; // May now short-circuit with stateless strategies
                }
            }
            if (accepted === fluid.NO_VALUE) {
                accepted = undefined;
            }
            root = accepted;
        }
        return root;
    };

    /** Returns both the value and the path of the value held at the supplied EL path **/
    fluid.model.getValueAndSegments = function (root, EL, config, initSegs) {
        return fluid.model.accessWithStrategy(root, EL, fluid.NO_VALUE, config, initSegs, true);
    };

    // Very lightweight remnant of trundler, only used in resolvers
    fluid.model.makeTrundler = function (config) {
        return function (valueSeg, EL) {
            return fluid.model.getValueAndSegments(valueSeg.root, EL, config, valueSeg.segs);
        };
    };

    fluid.model.getWithStrategy = function (root, EL, config, initSegs) {
        return fluid.model.accessWithStrategy(root, EL, fluid.NO_VALUE, config, initSegs);
    };

    fluid.model.setWithStrategy = function (root, EL, newValue, config, initSegs) {
        fluid.model.accessWithStrategy(root, EL, newValue, config, initSegs);
    };

    fluid.model.accessWithStrategy = function (root, EL, newValue, config, initSegs, returnSegs) {
        // This function is written in this unfortunate style largely for efficiency reasons. In many cases
        // it should be capable of running with 0 allocations (EL is preparsed, initSegs is empty)
        if (!fluid.isPrimitive(EL) && !fluid.isArrayable(EL)) {
            var key = EL.type || "default";
            var resolver = config.resolvers[key];
            if (!resolver) {
                fluid.fail("Unable to find resolver of type " + key);
            }
            var trundler = fluid.model.makeTrundler(config); // very lightweight trundler for resolvers
            var valueSeg = {root: root, segs: initSegs};
            valueSeg = resolver(valueSeg, EL, trundler);
            if (EL.path && valueSeg) { // every resolver supports this piece of output resolution
                valueSeg = trundler(valueSeg, EL.path);
            }
            return returnSegs ? valueSeg : (valueSeg ? valueSeg.root : undefined);
        }
        else {
            return fluid.model.accessImpl(root, EL, newValue, config, initSegs, returnSegs, fluid.model.traverseWithStrategy);
        }
    };

    // Implementation notes: The EL path manipulation utilities here are somewhat more thorough
    // and expensive versions of those provided in Fluid.js - there is some duplication of
    // functionality. This is a tradeoff between stability and performance - the versions in
    // Fluid.js are the most frequently used and do not implement escaping of characters .
    // as \. and \ as \\ as the versions here. The implementations here are not
    // performant and are left here partially as an implementation note. Problems will
    // arise if clients manipulate JSON structures containing "." characters in keys as if they
    // are models. The basic utilities fluid.path(), fluid.parseEL and fluid.composePath are
    // the ones recommended for general users and the following implementations will
    // be upgraded to use regexes in future to make them better alternatives

    fluid.registerNamespace("fluid.pathUtil");

    var getPathSegmentImpl = function (accept, path, i) {
        var segment = null; // TODO: rewrite this with regexes and replaces
        if (accept) {
            segment = "";
        }
        var escaped = false;
        var limit = path.length;
        for (; i < limit; ++i) {
            var c = path.charAt(i);
            if (!escaped) {
                if (c === ".") {
                    break;
                }
                else if (c === "\\") {
                    escaped = true;
                }
                else if (segment !== null) {
                    segment += c;
                }
            }
            else {
                escaped = false;
                if (segment !== null) {
                    segment += c;
                }
            }
        }
        if (segment !== null) {
            accept[0] = segment;
        }
        return i;
    };

    var globalAccept = []; // TODO: serious reentrancy risk here, why is this impl like this?

    /** A version of fluid.model.parseEL that apples escaping rules - this allows path segments
     * to contain period characters . - characters "\" and "}" will also be escaped. WARNING -
     * this current implementation is EXTREMELY slow compared to fluid.model.parseEL and should
     * not be used in performance-sensitive applications */
    // supported, PUBLIC API function
    fluid.pathUtil.parseEL = function (path) {
        var togo = [];
        var index = 0;
        var limit = path.length;
        while (index < limit) {
            var firstdot = getPathSegmentImpl(globalAccept, path, index);
            togo.push(globalAccept[0]);
            index = firstdot + 1;
        }
        return togo;
    };

    // supported, PUBLIC API function
    fluid.pathUtil.composeSegment = function (prefix, toappend) {
        toappend = toappend.toString();
        for (var i = 0; i < toappend.length; ++i) {
            var c = toappend.charAt(i);
            if (c === "." || c === "\\" || c === "}") {
                prefix += "\\";
            }
            prefix += c;
        }
        return prefix;
    };

    /** Escapes a single path segment by replacing any character ".", "\" or "}" with
     * itself prepended by \
     */
    // supported, PUBLIC API function
    fluid.pathUtil.escapeSegment = function (segment) {
        return fluid.pathUtil.composeSegment("", segment);
    };

    /**
     * Compose a prefix and suffix EL path, where the prefix is already escaped.
     * Prefix may be empty, but not null. The suffix will become escaped.
     */
    // supported, PUBLIC API function
    fluid.pathUtil.composePath = function (prefix, suffix) {
        if (prefix.length !== 0) {
            prefix += ".";
        }
        return fluid.pathUtil.composeSegment(prefix, suffix);
    };

    /**
     * Compose a set of path segments supplied as arguments into an escaped EL expression. Escaped version
     * of fluid.model.composeSegments
     */

    // supported, PUBLIC API function
    fluid.pathUtil.composeSegments = function () {
        var path = "";
        for (var i = 0; i < arguments.length; ++ i) {
            path = fluid.pathUtil.composePath(path, arguments[i]);
        }
        return path;
    };

    fluid.model.unescapedParser = {
        parse: fluid.model.parseEL,
        compose: fluid.model.composeSegments
    };

    // supported, PUBLIC API record
    fluid.model.defaultGetConfig = {
        parser: fluid.model.unescapedParser,
        strategies: [fluid.model.funcResolverStrategy, fluid.model.defaultFetchStrategy]
    };

    // supported, PUBLIC API record
    fluid.model.defaultSetConfig = {
        parser: fluid.model.unescapedParser,
        strategies: [fluid.model.funcResolverStrategy, fluid.model.defaultFetchStrategy, fluid.model.defaultCreatorStrategy]
    };

    fluid.model.escapedParser = {
        parse: fluid.pathUtil.parseEL,
        compose: fluid.pathUtil.composeSegments
    };

    // supported, PUBLIC API record
    fluid.model.escapedGetConfig = {
        parser: fluid.model.escapedParser,
        strategies: [fluid.model.defaultFetchStrategy]
    };

    // supported, PUBLIC API record
    fluid.model.escapedSetConfig = {
        parser: fluid.model.escapedParser,
        strategies: [fluid.model.defaultFetchStrategy, fluid.model.defaultCreatorStrategy]
    };

    /** MODEL COMPONENT HIERARCHY AND RELAY SYSTEM **/

    fluid.initSimpleModel = function (that, optionsModel) {
        that.model = optionsModel || {};
        return that.model;
    };

    fluid.initRelayModel = function (that, modelRelayModel) {
        return modelRelayModel;
    };

    // TODO: This utility compensates for our lack of control over "wave of explosions" initialisation - we may
    // catch a model when it is apparently "completely initialised" and that's the best we can do, since we have
    // missed its own initial transaction

    fluid.isModelComplete = function (that) {
        return that.model !== fluid.inEvaluationMarker;
    };

    // Enlist this model component as part of the "initial transaction" wave - note that "special transaction" init
    // is indexed by component, not by applier, and has special record type (complete + initModel), not transaction
    fluid.enlistModelComponent = function (that) {
        var instantiator = fluid.getInstantiator(that);
        var enlist = instantiator.modelTransactions.init[that.id];
        if (!enlist) {
            enlist = {
                that: that,
                applier: fluid.getForComponent(that, "applier"), // required for FLUID-5504 even though currently unused
                complete: fluid.isModelComplete(that)
            };
            instantiator.modelTransactions.init[that.id] = enlist;
        }
        return enlist;
    };

    // Utility to coordinate with our crude "oscillation prevention system" which limits each link to 2 updates (presumably
    // in opposite directions). In the case of the initial transaction, we need to reset the count given that genuine
    // changes are arising in the system with each new enlisted model. TODO: if we ever get users operating their own
    // transactions, think of a way to incorporate this into that workflow
    fluid.clearLinkCounts = function (transRec, relaysAlso) {
        fluid.each(transRec, function (value, key) {
            if (typeof(value) === "number") {
                transRec[key] = 0;
            } else if (relaysAlso && value.options && typeof(value.options.relayCount) === "number") {
                value.options.relayCount = 0;
            }
        });
    };

    fluid.sortCompleteLast = function (reca, recb) {
        return (reca.completeOnInit ? 1 : 0) - (recb.completeOnInit ? 1 : 0);
    };

    // Operate all coordinated transactions by bringing models to their respective initial values, and then commit them all
    fluid.operateInitialTransaction = function (instantiator, mrec) {
        var transId = fluid.allocateGuid();
        var transRec = fluid.getModelTransactionRec(instantiator, transId);
        var transac;
        var transacs = fluid.transform(mrec, function (recel) {
            transac = recel.that.applier.initiate("init", transId);
            transRec[recel.that.applier.applierId] = {transaction: transac};
            return transac;
        });
        // TODO: This sort has very little effect in any current test (can be replaced by no-op - see FLUID-5339) - but
        // at least can't be performed in reverse order ("FLUID-3674 event coordination test" will fail) - need more cases
        var recs = fluid.values(mrec).sort(fluid.sortCompleteLast);
        fluid.each(recs, function (recel) {
            var that = recel.that;
            var transac = transacs[that.id];
            if (recel.completeOnInit) {
                fluid.initModelEvent(that, transac, that.applier.changeListeners.listeners);
            } else {
                fluid.each(recel.initModels, function (initModel) {
                    transac.fireChangeRequest({type: "ADD", segs: [], value: initModel});
                    fluid.clearLinkCounts(transRec, true);
                });
            }
            var shadow = fluid.shadowForComponent(that);
            shadow.modelComplete = true; // technically this is a little early, but this flag is only read in fluid.connectModelRelay
        });

        transac.commit(); // committing one representative transaction will commit them all
    };

    // This modelComponent has now concluded initialisation - commit its initialisation transaction if it is the last such in the wave
    fluid.deenlistModelComponent = function (that) {
        var instantiator = fluid.getInstantiator(that);
        var mrec = instantiator.modelTransactions.init;
        that.model = undefined; // Abuse of the ginger system - in fact it is "currently in evaluation" - we need to return a proper initial model value even if no init occurred yet
        mrec[that.id].complete = true; // flag means - "complete as in ready to participate in this transaction"
        var incomplete = fluid.find_if(mrec, function (recel) {
            return recel.complete !== true;
        });
        if (!incomplete) {
            fluid.operateInitialTransaction(instantiator, mrec);
            // NB: Don't call fluid.concludeTransaction since "init" is not a standard record - this occurs in commitRelays for the corresponding genuine record as usual
            instantiator.modelTransactions.init = {};
        }
    };

    fluid.transformToAdapter = function (transform, targetPath) {
        var basedTransform = {};
        basedTransform[targetPath] = transform;
        return function (trans, newValue /*, sourceSegs, targetSegs */) {
            // TODO: More efficient model that can only run invalidated portion of transform (need to access changeMap of source transaction)
            fluid.model.transformWithRules(newValue, basedTransform, {finalApplier: trans});
        };
    };

    fluid.parseModelReference = function (that, ref) {
        var parsed = fluid.parseContextReference(ref);
        parsed.segs = that.applier.parseEL(parsed.path);
        return parsed;
    };

    fluid.parseValidModelReference = function (that, name, ref) {
        var reject = function (message) {
            fluid.fail("Error in " + name + ": " + ref + message);
        };
        var parsed, target;
        if (ref.charAt(0) === "{") {
            parsed = fluid.parseModelReference(that, ref);
            if (parsed.segs[0] !== "model") {
                reject(" must be a reference into a component model beginning with \"model\"");
            } else {
                parsed.modelSegs = parsed.segs.slice(1);
                delete parsed.path;
            }
            target = fluid.resolveContext(parsed.context, that);
            if (!target) {
                reject(" must be a reference to an existing component");
            }
        } else {
            target = that;
            parsed = {
                path: ref,
                modelSegs: that.applier.parseEL(ref)
            };
        }
        if (!target.applier) {
            fluid.getForComponent(target, ["applier"]);
        }
        if (!target.applier) {
            reject(" must be a reference to a component with a ChangeApplier (descended from fluid.modelComponent)");
        }
        parsed.that = target;
        parsed.applier = target.applier;
        // TODO: remove this when the old ChangeApplier is abolished
        if (!parsed.path) {
            parsed.path = target.applier.composeSegments.apply(null, parsed.modelSegs);
        }
        return parsed;
    };

    // Gets global record for a particular transaction id - looks up applier id to transaction,
    // as well as looking up source id (linkId in below) to count/true
    fluid.getModelTransactionRec = function (instantiator, transId) {
        if (!transId) {
            fluid.fail("Cannot get transaction record without transaction id");
        }
        var transRec = instantiator.modelTransactions[transId];
        if (!transRec && !instantiator.free) {
            transRec = instantiator.modelTransactions[transId] = {};
            transRec.externalChanges = {}; // index by applierId to changePath to listener record
        }
        return transRec;
    };

    fluid.recordChangeListener = function (component, applier, sourceListener) {
        var shadow = fluid.shadowForComponent(component);
        fluid.recordListener(applier.modelChanged, sourceListener, shadow);
    };

    // Used with various arg combinations from different sources. For standard "implicit relay" or fully lensed relay,
    // the first 4 args will be set, and "options" will be empty

    // For a model-dependent relay, this will be used in two halves - firstly, all of the model
    // sources will bind to the relay transform document itself. In this case the argument "targetApplier" within "options" will be set.
    // In this case, the component known as "target" is really the source - it is a component reference discovered by parsing the
    // relay document.

    // Secondly, the relay itself will schedule an invalidation (as if receiving change to "*" of its source - which may in most
    // cases actually be empty) and play through its transducer. "Source" component itself is never empty, since it is used for listener
    // degistration on destruction (check this is correct for external model relay). However, "sourceSegs" may be empty in the case
    // there is no "source" component registered for the link. This change is played in a "half-transactional" way - that is, we wait
    // for all other changes in the system to settle before playing the relay document, in order to minimise the chances of multiple
    // firing and corruption. This is done via the "preCommit" hook registered at top level in establishModelRelay. This listener
    // is transactional but it does not require the transaction to conclude in order to fire - it may be reused as many times as
    // required within the "overall" transaction whilst genuine (external) changes continue to arrive.

    fluid.registerDirectChangeRelay = function (target, targetSegs, source, sourceSegs, linkId, transducer, options) {
        var instantiator = fluid.getInstantiator(target);
        var targetApplier = options.targetApplier || target.applier; // implies the target is a relay document
        var sourceApplier = options.sourceApplier || source.applier; // implies the source is a relay document - listener will be transactional
        var applierId = targetApplier.applierId;
        targetSegs = fluid.makeArray(targetSegs);
        sourceSegs = sourceSegs ? fluid.makeArray(sourceSegs) : sourceSegs; // take copies since originals will be trashed
        var sourceListener = function (newValue, oldValue, path, changeRequest, trans, applier) {
            var transId = trans.id;
            var transRec = fluid.getModelTransactionRec(instantiator, transId);
            if (applier && trans && !transRec[applier.applierId]) { // don't trash existing record which may contain "options" (FLUID-5397)
                transRec[applier.applierId] = {transaction: trans}; // enlist the outer user's original transaction
            }
            var existing = transRec[applierId];
            transRec[linkId] = transRec[linkId] || 0;
            // Crude "oscillation prevention" system limits each link to maximum of 2 operations per cycle (presumably in opposite directions)
            var relay = true; // TODO: See FLUID-5303 - we currently disable this check entirely to solve FLUID-5293 - perhaps we might remove link counts entirely
            if (relay) {
                ++transRec[linkId];
                if (!existing) {
                    var newTrans = targetApplier.initiate("relay", transId); // non-top-level transaction will defeat postCommit
                    existing = transRec[applierId] = {transaction: newTrans, options: options};
                }
                if (transducer && !options.targetApplier) {
                    // TODO: This is just for safety but is still unusual and now abused. The transducer doesn't need the "newValue" since all the transform information
                    // has been baked into the transform document itself. However, we now rely on this special signalling value to make sure we regenerate transforms in 
                    // the "forwardAdapter"
                    transducer(existing.transaction, options.sourceApplier ? undefined : newValue, sourceSegs, targetSegs);
                } else if (newValue !== undefined) {
                    existing.transaction.fireChangeRequest({type: "ADD", segs: targetSegs, value: newValue});
                }
            }
        };
        if (sourceSegs) {
            sourceApplier.modelChanged.addListener({
                isRelay: true,
                segs: sourceSegs,
                transactional: options.transactional
            }, sourceListener);
        }
        if (source) { // TODO - we actually may require to register on THREE sources in the case modelRelay is attached to a
            // component which is neither source nor target. Note there will be problems if source, say, is destroyed and recreated,
            // and holder is not - relay will in that case be lost. Need to integrate relay expressions with IoCSS.
            fluid.recordChangeListener(source, sourceApplier, sourceListener);
            if (target !== source) {
                fluid.recordChangeListener(target, sourceApplier, sourceListener);
            }
        }
    };

    // When called during parsing a contextualised model relay document, these arguments are reversed - "source" refers to the
    // current component, and "target" refers successively to the various "source" components.
    // "options" will be transformPackage
    fluid.connectModelRelay = function (source, sourceSegs, target, targetSegs, options) {
        var linkId = fluid.allocateGuid();
        function enlistComponent(component) {
            var enlist = fluid.enlistModelComponent(component);

            if (enlist.complete) {
                var shadow = fluid.shadowForComponent(component);
                if (shadow.modelComplete) {
                    enlist.completeOnInit = true;
                }
            }
        }
        enlistComponent(target);
        enlistComponent(source); // role of "source" and "target" may have been swapped in a modelRelay document

        if (options.update) { // it is a call via parseImplicitRelay for a relay document
            if (options.targetApplier) {
                // register changes from the model onto changes to the model relay document
                fluid.registerDirectChangeRelay(source, sourceSegs, target, targetSegs, linkId, null, {
                    transactional: false,
                    targetApplier: options.targetApplier,
                    relayCount: options.relayCount,
                    update: options.update
                });
            } else {
                // if parsing a contextualised MR, skip the "orthogonal" registration - instead
                // register the "half-transactional" listener which binds changes from the relay itself onto the target
                fluid.registerDirectChangeRelay(target, targetSegs, source, [], linkId+"-transform", options.forwardAdapter, {transactional: true, sourceApplier: options.forwardApplier});
            }
        } else { // more efficient branch where relay is uncontextualised
            fluid.registerDirectChangeRelay(target, targetSegs, source, sourceSegs, linkId, options.forwardAdapter, {transactional: false});
            if (sourceSegs) {
                fluid.registerDirectChangeRelay(source, sourceSegs, target, targetSegs, linkId, options.backwardAdapter, {transactional: false});
            }
        }
    };

    fluid.model.guardedAdapter = function (componentThat, cond, func, args) {
        // TODO: We can't use fluid.isModelComplete here because of the broken half-transactional system - it may appear that model has arrived halfway through init transaction
        var isInit = componentThat.modelRelay === fluid.inEvaluationMarker;
        var condValue = cond[isInit ? "init" : "live"];
        if (condValue) {
            func.apply(null, args);
        }
    };

    fluid.makeTransformPackage = function (componentThat, transform, sourcePath, targetPath, forwardCond, backwardCond) {
        var that = {
            forwardHolder: {model: transform},
            backwardHolder: {model: null}
        };
        that.generateAdapters = function (trans) {
            // can't commit "half-transaction" or events will fire - violate encapsulation in this way
            that.forwardAdapterImpl = fluid.transformToAdapter(trans ? trans.newHolder.model : that.forwardHolder.model, targetPath);
            if (sourcePath !== null) {
                that.backwardHolder.model = fluid.model.transform.invertConfiguration(transform);
                that.backwardAdapterImpl = fluid.transformToAdapter(that.backwardHolder.model, sourcePath);
            }
        };
        that.forwardAdapter = function (transaction, newValue) { // create a stable function reference for this possibly changing adapter
            if (newValue === undefined) {
                that.generateAdapters(); // TODO: Quick fix for incorrect scheduling of invalidation/transducing
                // "it so happens" that fluid.registerDirectChangeRelay invokes us with empty newValue in the case of invalidation -> transduction
            }
            fluid.model.guardedAdapter(componentThat, forwardCond, that.forwardAdapterImpl, arguments);
        };
        // fired from fluid.model.updateRelays via invalidator event
        that.runTransform = function (trans) {
            trans.commit(); // this will reach the special "half-transactional listener" registered in fluid.connectModelRelay,
            // branch with options.targetApplier - by committing the transaction, we update the relay document in bulk and then cause
            // it to execute (via "transducer")
            trans.reset();
        };
        that.forwardApplier = fluid.makeNewChangeApplier(that.forwardHolder);
        that.forwardApplier.isRelayApplier = true; // special annotation so these can be discovered in the transaction record
        that.invalidator = fluid.makeEventFirer({name: "Invalidator for model relay with applier " + that.forwardApplier.applierId});
        if (sourcePath !== null) {
            that.backwardApplier = fluid.makeNewChangeApplier(that.backwardHolder);
            that.backwardAdapter = function () {
                fluid.model.guardedAdapter(componentThat, backwardCond, that.backwardAdapterImpl, arguments);
            };
        }
        that.update = that.invalidator.fire; // necessary so that both routes to fluid.connectModelRelay from here hit the first branch
        var implicitOptions = {
            relayCount: 0, // this count is updated in fluid.model.updateRelays
            targetApplier: that.forwardApplier, // this special field identifies us to fluid.connectModelRelay
            update: that.update,
            refCount: 0
        };
        that.forwardHolder.model = fluid.parseImplicitRelay(componentThat, transform, [], implicitOptions);
        that.refCount = implicitOptions.refCount;
        that.generateAdapters();
        that.invalidator.addListener(that.generateAdapters);
        that.invalidator.addListener(that.runTransform);
        return that;
    };

    fluid.singleTransformToFull = function (singleTransform) {
        var withPath = $.extend(true, {valuePath: ""}, singleTransform);
        return {
            "": {
                transform: withPath
            }
        };
    };

    fluid.model.relayConditions = {
        initOnly: {init: true,  live: false},
        liveOnly: {init: false, live: true},
        never:    {init: false, live: false},
        always:   {init: true,  live: true}
    };

    fluid.model.parseRelayCondition = function (condition) {
        return fluid.model.relayConditions[condition || "always"];
    };

    fluid.parseModelRelay = function (that, mrrec) {
        var parsedSource = mrrec.source ? fluid.parseValidModelReference(that, "modelRelay record member \"source\"", mrrec.source) :
            {path: null, modelSegs: null};
        var parsedTarget = fluid.parseValidModelReference(that, "modelRelay record member \"target\"", mrrec.target);

        var transform = mrrec.singleTransform ? fluid.singleTransformToFull(mrrec.singleTransform) : mrrec.transform;
        if (!transform) {
            fluid.fail("Cannot parse modelRelay record without element \"singleTransform\" or \"transform\":", mrrec);
        }
        var forwardCond = fluid.model.parseRelayCondition(mrrec.forward), backwardCond = fluid.model.parseRelayCondition(mrrec.backward);
        var transformPackage = fluid.makeTransformPackage(that, transform, parsedSource.path, parsedTarget.path, forwardCond, backwardCond);
        if (transformPackage.refCount === 0) {
            // This first call binds changes emitted from the relay ends to each other, synchronously
            fluid.connectModelRelay(parsedSource.that || that, parsedSource.modelSegs, parsedTarget.that, parsedTarget.modelSegs, {
                forwardAdapter: transformPackage.forwardAdapter,
                backwardAdapter: transformPackage.backwardAdapter
            });
        } else {
            // This second call binds changes emitted from the relay document itself onto the relay ends (using the "half-transactional system")
            fluid.connectModelRelay(parsedSource.that || that, parsedSource.modelSegs, parsedTarget.that, parsedTarget.modelSegs, transformPackage);
        }
    };

    fluid.parseImplicitRelay = function (that, modelRec, segs, options) {
        var value;
        if (typeof(modelRec) === "string" && modelRec.charAt(0) === "{") {
            var parsed = fluid.parseModelReference(that, modelRec);
            var target = fluid.resolveContext(parsed.context, that);
            if (parsed.segs[0] === "model") {
                var modelSegs = parsed.segs.slice(1);
                ++options.refCount;
                fluid.connectModelRelay(that, segs, target, modelSegs, options);
            } else {
                value = fluid.getForComponent(target, parsed.segs);
            }
        } else if (fluid.isPrimitive(modelRec) || !fluid.isPlainObject(modelRec)) {
            value = modelRec;
        } else if (modelRec.expander && fluid.isPlainObject(modelRec.expander)) {
            value = fluid.expandOptions(modelRec, that);
        } else {
            value = fluid.freshContainer(modelRec);
            fluid.each(modelRec, function (innerValue, key) {
                segs.push(key);
                var innerTrans = fluid.parseImplicitRelay(that, innerValue, segs, options);
                if (innerTrans !== undefined) {
                    value[key] = innerTrans;
                }
                segs.pop();
            });
        }
        return value;
    };


    // Conclude the transaction by firing to all external listeners in priority order
    fluid.model.notifyExternal = function (transRec) {
        var allChanges = transRec ? fluid.values(transRec.externalChanges) : [];
        allChanges.sort(fluid.priorityComparator);
        for (var i = 0; i < allChanges.length; ++ i) {
            var change = allChanges[i];
            var targetApplier = change.args[5]; // NOTE: This argument gets here via fluid.model.storeExternalChange from fluid.notifyModelChanges
            if (!targetApplier.destroyed) { // 3rd point of guarding for FLUID-5592
                change.listener.apply(null, change.args);
            }
        }
        fluid.clearLinkCounts(transRec, true); // "options" structures for relayCount are aliased
    };

    fluid.model.commitRelays = function (instantiator, transactionId) {
        var transRec = instantiator.modelTransactions[transactionId];
        fluid.each(transRec, function (transEl) {
        // EXPLAIN: This must commit ALL current transactions, not just those for relays - why?
            if (transEl.transaction) { // some entries are links
                transEl.transaction.commit("relay");
                transEl.transaction.reset();
            }
        });
    };

    fluid.model.updateRelays = function (instantiator, transactionId) {
        var transRec = instantiator.modelTransactions[transactionId];
        var updates = 0;
        fluid.each(transRec, function (transEl) {
            // TODO: integrate the "source" if any into this computation, and fire the relay if it has changed - perhaps by adding a listener
            // to it that updates changeRecord.changes (assuming we can find it)
            if (transEl.options && transEl.transaction && transEl.transaction.changeRecord.changes > 0 && transEl.options.relayCount < 2 && transEl.options.update) {
                transEl.options.relayCount++;
                fluid.clearLinkCounts(transRec);
                transEl.options.update(transEl.transaction, transRec);
                ++updates;
            }
        });
        return updates;
    };

    fluid.establishModelRelay = function (that, optionsModel, optionsML, optionsMR, applier) {
        fluid.mergeModelListeners(that, optionsML);

        var enlist = fluid.enlistModelComponent(that);
        fluid.each(optionsMR, function (mrrec) {
            fluid.parseModelRelay(that, mrrec);
        });

        var initModels = fluid.transform(optionsModel, function (modelRec) {
            return fluid.parseImplicitRelay(that, modelRec, [], {refCount: 0});
        });
        enlist.initModels = initModels;

        var instantiator = fluid.getInstantiator(that);

        function updateRelays(transaction) {
            while (fluid.model.updateRelays(instantiator, transaction.id) > 0){}
        }

        function commitRelays(transaction, applier, code) {
            if (code !== "relay") { // don't commit relays if this commit is already a relay commit
                fluid.model.commitRelays(instantiator, transaction.id);
            }
        }

        function concludeTransaction(transaction, applier, code) {
            if (code !== "relay") {
                fluid.model.notifyExternal(instantiator.modelTransactions[transaction.id]);
                delete instantiator.modelTransactions[transaction.id];
            }
        }

        applier.preCommit.addListener(updateRelays);
        applier.preCommit.addListener(commitRelays);
        applier.postCommit.addListener(concludeTransaction);

        fluid.deenlistModelComponent(that);

        return applier.holder.model;
    };

    // Grade common to "old" and "new" model components
    fluid.defaults("fluid.commonModelComponent", {
        gradeNames: ["fluid.littleComponent", "autoInit"],
        mergePolicy: {
            modelListeners: fluid.makeMergeListenersPolicy(fluid.arrayConcatPolicy)
        }
    });

    // supported, PUBLIC API grade
    fluid.defaults("fluid.modelComponent", {
        gradeNames: ["fluid.commonModelComponent", "autoInit"],
        members: {
            model: "@expand:fluid.initSimpleModel({that}, {that}.options.model)",
            applier: "@expand:fluid.makeChangeApplier({that}.model, {that}.options.changeApplierOptions)",
            modelListeners: "@expand:fluid.mergeModelListeners({that}, {that}.options.modelListeners)"
        },
        mergePolicy: {
            model: "preserve"
        }
    });

    // supported, PUBLIC API grade
    fluid.defaults("fluid.modelRelayComponent", {
        gradeNames: ["fluid.commonModelComponent", "fluid.eventedComponent", "autoInit"],
        changeApplierOptions: {
            relayStyle: true,
            cullUnchanged: true
        },
        members: {
            model: "@expand:fluid.initRelayModel({that}, {that}.modelRelay)",
            applier: "@expand:fluid.makeNewChangeApplier({that}, {that}.options.changeApplierOptions)",
            modelRelay: "@expand:fluid.establishModelRelay({that}, {that}.options.model, {that}.options.modelListeners, {that}.options.modelRelay, {that}.applier)"
        },
        mergePolicy: {
            model: {
                noexpand: true,
                func: fluid.arrayConcatPolicy
            },
            modelRelay: {
                noexpand: true,
                func: fluid.arrayConcatPolicy
            }
        }
    });

    // supported, PUBLIC API record
    fluid.defaults("fluid.standardComponent", {
        gradeNames: ["fluid.modelComponent", "fluid.eventedComponent", "autoInit"]
    });

    // supported, PUBLIC API record
    fluid.defaults("fluid.standardRelayComponent", {
        gradeNames: ["fluid.modelRelayComponent", "autoInit"]
    });

    fluid.modelChangedToChange = function (isNewApplier, args) {
        var newModel = args[0], oldModel = args[1], path = args[3]; // in 4th position for old applier
        return isNewApplier ? {
            value: args[0],
            oldValue: args[1],
            path: args[2]
        } : {
            value: fluid.get(newModel, path),
            oldValue: fluid.get(oldModel, path),
            path: path
        };
    };

    fluid.resolveModelListener = function (that, record, isNewApplier) {
        var togo = function () {
            if (fluid.isDestroyed(that)) { // first guarding point to resolve FLUID-5592
                return;
            }
            var change = fluid.modelChangedToChange(isNewApplier, arguments);
            var args = [change];
            var localRecord = {change: change, "arguments": args};
            if (record.args) {
                args = fluid.expandOptions(record.args, that, {}, localRecord);
            }
            fluid.event.invokeListener(record.listener, fluid.makeArray(args));
        };
        fluid.event.impersonateListener(record.listener, togo);
        return togo;
    };

    fluid.mergeModelListeners = function (that, listeners) {
        var listenerCount = 0;
        fluid.each(listeners, function (value, path) {
            if (typeof(value) === "string") {
                value = {
                    funcName: value
                };
            }
            var records = fluid.event.resolveListenerRecord(value, that, "modelListeners", null, false);
            var parsed = fluid.parseValidModelReference(that, "modelListeners entry", path);
            var isNewApplier = parsed.applier.preCommit;
            // Bypass fluid.event.dispatchListener by means of "standard = false" and enter our custom workflow including expanding "change":
            fluid.each(records.records, function (record) {
                var func = fluid.resolveModelListener(that, record, isNewApplier);
                var spec = {
                    listener: func, // for initModelEvent
                    listenerIndex: listenerCount,
                    segs: parsed.modelSegs,
                    path: parsed.path,
                    includeSource: record.includeSource,
                    excludeSource: record.excludeSource,
                    priority: record.priority,
                    guardSource: record.guardSource, // compatibility for obsolete system - will remove with old applier
                    transactional: true
                };
                ++listenerCount;
                if (record.guardSource) {
                    fluid.addSourceGuardedListener(parsed.applier, spec, record.guardSource, func, "modelChanged", record.namespace, record.softNamespace);
                } else {
                    parsed.applier.modelChanged.addListener(spec, func, record.namespace, record.softNamespace);
                }

                fluid.recordChangeListener(that, parsed.applier, func);
                function initModelEvent() {
                    if (isNewApplier && fluid.isModelComplete(parsed.that)) {
                        var trans = parsed.applier.initiate("init");
                        fluid.initModelEvent(that, trans, [spec]);
                        trans.commit();
                    }
                }
                if (that !== parsed.that && !fluid.isModelComplete(that)) { // TODO: Use FLUID-4883 "latched events" when available
                    // Don't confuse the end user by firing their listener before the component is constructed
                    // TODO: Better detection than this is requred - we assume that the target component will not be discovered as part
                    // of the initial transaction wave, but if it is, it will get a double notification - we really need "wave of explosions"
                    // since we are currently too early in initialisation of THIS component in order to tell if other will be found
                    // independently.
                    that.events.onCreate.addListener(initModelEvent);
                }
            });
        });
    };


    /** CHANGE APPLIER **/

    /** COMMON UTILITIES common between old and new ChangeAppliers **/

    /** Add a listener to a ChangeApplier event that only acts in the case the event
     * has not come from the specified source (typically ourself)
     * @param modelEvent An model event held by a changeApplier (typically applier.modelChanged)
     * @param path The path specification to listen to
     * @param source The source value to exclude (direct equality used)
     * @param func The listener to be notified of a change
     * @param [eventName] - optional - the event name to be listened to - defaults to "modelChanged"
     * @param [namespace] - optional - the event namespace
     */
    fluid.addSourceGuardedListener = function(applier, path, source, func, eventName, namespace, softNamespace) {
        eventName = eventName || "modelChanged";
        var wrapped = function (newValue, oldValue, path, changes) { // TODO: adapt signature
            if (!applier.hasChangeSource(source, changes)) {
                return func.apply(null, arguments);
            }
        };
        fluid.event.impersonateListener(func, wrapped);
        applier[eventName].addListener(path, wrapped, namespace, softNamespace);
    };

    /** Convenience method to fire a change event to a specified applier, including
     * a supplied "source" identified (perhaps for use with addSourceGuardedListener)
     */
    fluid.fireSourcedChange = function (applier, path, value, source) {
        applier.fireChangeRequest({
            path: path,
            value: value,
            source: source
        });
    };

    /** Dispatches a list of changes to the supplied applier */
    fluid.requestChanges = function (applier, changes) {
        for (var i = 0; i < changes.length; ++i) {
            applier.fireChangeRequest(changes[i]);
        }
    };


    // Automatically adapts requestChange onto fireChangeRequest
    fluid.bindRequestChange = function (that) {
        // The name "requestChange" will be deprecated in 1.5, removed in 2.0
        that.requestChange = that.change = function (path, value, type) {
            var changeRequest = {
                path: path,
                value: value,
                type: type
            };
            that.fireChangeRequest(changeRequest);
        };
    };

    fluid.identifyChangeListener = function (listener) {
        return fluid.event.identifyListener(listener) || listener;
    };


    /** NEW CHANGEAPPLIER IMPLEMENTATION (Will be default in Infusion 2.0 onwards **/

    fluid.typeCode = function (totest) {
        return fluid.isPrimitive(totest) || !fluid.isPlainObject(totest) ? "primitive" :
            fluid.isArrayable(totest) ? "array" : "object";
    };

    fluid.model.isChangedPath = function (changeMap, segs) {
        for (var i = 0; i <= segs.length; ++ i) {
            if (typeof(changeMap) === "string") {
                return true;
            }
            if (i < segs.length && changeMap) {
                changeMap = changeMap[segs[i]];
            }
        }
        return false;
    };

    fluid.model.setChangedPath = function (options, segs, value) {
        var notePath = function (record) {
            segs.unshift(record);
            fluid.model.setSimple(options, segs, value);
            segs.shift();
        };
        if (!fluid.model.isChangedPath(options.changeMap, segs)) {
            ++options.changes;
            notePath("changeMap");
        }
        if (!fluid.model.isChangedPath(options.deltaMap, segs)) {
            ++options.deltas;
            notePath("deltaMap");
        }
    };

    fluid.model.fetchChangeChildren = function (target, i, segs, source, options) {
        fluid.each(source, function (value, key) {
            segs[i] = key;
            fluid.model.applyChangeStrategy(target, key, i, segs, value, options);
            segs.length = i;
        });
    };

    // Called with two primitives which are compared for equality. This takes account of "floating point slop" to avoid
    // continuing to propagate inverted values as changes
    // TODO: replace with a pluggable implementation
    fluid.model.isSameValue = function (a, b) {
        if (typeof(a) !== "number" || typeof(b) !== "number") {
            return a === b;
        } else {
            if (a === b) {
                return true;
            } else {
                var relError = Math.abs((a - b) / b);
                return relError < 1e-12; // 64-bit floats have approx 16 digits accuracy, this should deal with most reasonable transforms
            }
        }
    };

    fluid.model.applyChangeStrategy = function (target, name, i, segs, source, options) {
        var targetSlot = target[name];
        var sourceCode = fluid.typeCode(source);
        var targetCode = fluid.typeCode(targetSlot);
        var changedValue = fluid.NO_VALUE;
        if (sourceCode === "primitive") {
            if (!fluid.model.isSameValue(targetSlot, source)) {
                changedValue = source;
                ++options.unchanged;
            }
        } else if (targetCode !== sourceCode || sourceCode === "array" && source.length !== targetSlot.length) {
            // RH is not primitive - array or object and mismatching or any array rewrite
            changedValue = fluid.freshContainer(source);
        }
        if (changedValue !== fluid.NO_VALUE) {
            target[name] = changedValue;
            if (options.changeMap) {
                fluid.model.setChangedPath(options, segs, options.inverse ? "DELETE" : "ADD");
            }
        }
        if (sourceCode !== "primitive") {
            fluid.model.fetchChangeChildren(target[name], i + 1, segs, source, options);
        }
    };

    fluid.model.stepTargetAccess = function (target, type, segs, startpos, endpos, options) {
        for (var i = startpos; i < endpos; ++ i) {
            var oldTrunk = target[segs[i]];
            target = fluid.model.traverseWithStrategy(target, segs, i, options[type === "ADD" ? "resolverSetConfig" : "resolverGetConfig"],
                segs.length - i - 1);
            if (oldTrunk !== target && options.changeMap) {
                fluid.model.setChangedPath(options, segs.slice(0, i + 1), "ADD");
            }
        }
        return {root: target, last: segs[endpos]};
    };

    fluid.model.defaultAccessorConfig = function (options) {
        options = options || {};
        options.resolverSetConfig = options.resolverSetConfig || fluid.model.defaultSetConfig;
        options.resolverGetConfig = options.resolverGetConfig || fluid.model.defaultGetConfig;
        return options;
    };

    // After the 1.5 release, this will replace the old "applyChangeRequest"
    // Changes: "MERGE" action abolished
    // ADD/DELETE at root can be destructive
    // changes tracked in optional final argument holding "changeMap: {}, changes: 0, unchanged: 0"
    fluid.model.applyHolderChangeRequest = function (holder, request, options) {
        options = fluid.model.defaultAccessorConfig(options);
        options.deltaMap = options.changeMap ? {} : null;
        options.deltas = 0;
        var length = request.segs.length;
        var pen, atRoot = length === 0;
        if (atRoot) {
            pen = {root: holder, last: "model"};
        } else {
            if (!holder.model) {
                holder.model = {};
                fluid.model.setChangedPath(options, [], options.inverse ? "DELETE" : "ADD");
            }
            pen = fluid.model.stepTargetAccess(holder.model, request.type, request.segs, 0, length - 1, options);
        }
        if (request.type === "ADD") {
            var value = request.value;
            var segs = fluid.makeArray(request.segs);
            fluid.model.applyChangeStrategy(pen.root, pen.last, length - 1, segs, value, options, atRoot);
        } else if (request.type === "DELETE") {
            if (pen.root && pen.root[pen.last] !== undefined) {
                delete pen.root[pen.last];
                if (options.changeMap) {
                    fluid.model.setChangedPath(options, request.segs, "DELETE");
                }
            }
        } else {
            fluid.fail("Unrecognised change type of " + request.type);
        }
        return options.deltas ? options.deltaMap : null;
    };
    
    /** Compare two models for equality using a deep algorithm. It is assumed that both models are JSON-equivalent and do
     * not contain circular links.
     * @param modela The first model to be compared
     * @param modelb The second model to be compared
     * @param options {Object} If supplied, will receive a map and summary of the change content between the objects. Structure is:
     *     changeMap: {Object/String} An isomorphic map of the object structures to values "ADD" or "DELETE" indicating
     * that values have been added/removed at that location. Note that in the case the object structure differs at the root, <code>changeMap</code> will hold
     * the plain String value "ADD" or "DELETE"
     *     changes: {Integer} Counts the number of changes between the objects - The two objects are identical iff <code>changes === 0</code>.
     *     unchanged: {Integer} Counts the number of leaf (primitive) values at which the two objects are identical. Note that the current implementation will
     * double-count, this summary should be considered indicative rather than precise.
     * @return <code>true</code> if the models are identical
     */
    // TODO: This algorithm is quite inefficient in that both models will be copied once each
    // supported, PUBLIC API function
    fluid.model.diff = function (modela, modelb, options) {
        options = options || {changes: 0, unchanged: 0, changeMap: {}}; // current algorithm can't avoid the expense of changeMap
        var typea = fluid.typeCode(modela);
        var typeb = fluid.typeCode(modelb);
        var togo;
        if (typea === "primitive" && typeb === "primitive") {
            togo = fluid.model.isSameValue(modela, modelb);
        } else if (typea === "primitive" ^ typeb === "primitive") {
            togo = false;
        } else {
            // Apply both forward and reverse changes - if no changes either way, models are identical
            // "ADD" reported in the reverse direction must be accounted as a "DELETE"
            var holdera = {
                model: fluid.copy(modela)
            };
            fluid.model.applyHolderChangeRequest(holdera, {value: modelb, segs: [], type: "ADD"}, options);
            var holderb = {
                model: fluid.copy(modelb)
            };
            options.inverse = true;
            fluid.model.applyHolderChangeRequest(holderb, {value: modela, segs: [], type: "ADD"}, options);
            togo = options.changes === 0;
        }
        if (togo === false && options.changes === 0) { // catch all primitive cases
            options.changes = 1;
            options.changeMap = modelb === undefined ? "DELETE" : "ADD";
        } else if (togo === true && options.unchanged === 0) {
            options.unchanged = 1;
        }
        return togo;
    };

    // Here we only support for now very simple expressions which have at most one
    // wildcard which must appear in the final segment
    fluid.matchChanges = function (changeMap, specSegs, newHolder) {
        var root = newHolder.model;
        var map = changeMap;
        var outSegs = ["model"];
        var wildcard = false;
        var togo = [];
        for (var i = 0; i < specSegs.length; ++ i) {
            var seg = specSegs[i];
            if (seg === "*") {
                if (i === specSegs.length - 1) {
                    wildcard = true;
                } else {
                    fluid.fail("Wildcard specification in modelChanged listener is only supported for the final path segment: " + specSegs.join("."));
                }
            } else {
                outSegs.push(seg);
                map = fluid.isPrimitive(map) ? map : map[seg];
                root = root ? root[seg] : undefined;
            }
        }
        if (map) {
            if (wildcard) {
                fluid.each(root, function (value, key) {
                    togo.push(outSegs.concat(key));
                });
            } else {
                togo.push(outSegs);
            }
        }
        return togo;
    };

    fluid.storeExternalChange = function (transRec, applier, invalidPath, spec, args) {
        var pathString = applier.composeSegments.apply(null, invalidPath);
        var keySegs = [applier.applierId, fluid.event.identifyListener(spec.listener), spec.listenerIndex, pathString];
        var keyString = keySegs.join("|");
        // These are unbottled in fluid.concludeTransaction
        transRec.externalChanges[keyString] = {listener: spec.listener, priority: spec.priority, args: args};
    };
    
    fluid.isExcludedChangeSource = function (transaction, spec) {
        if (!spec.excludeSource) { // mergeModelListeners initModelEvent fabricates a fake spec that bypasses processing
            return false;
        }
        var excluded = spec.excludeSource["*"];
        for (var source in transaction.sources) {
            if (spec.excludeSource[source]) {
                excluded = true;
            }
            if (spec.includeSource[source]) {
                excluded = false;
            }
        }
        return excluded;
    };

    fluid.notifyModelChanges = function (listeners, changeMap, newHolder, oldHolder, changeRequest, transaction, applier, that) {
        var instantiator = fluid.getInstantiator(that);
        var transRec = transaction && fluid.getModelTransactionRec(instantiator, transaction.id);
        for (var i = 0; i < listeners.length; ++ i) {
            var spec = listeners[i];
            var invalidPaths = fluid.matchChanges(changeMap, spec.segs, newHolder);
            for (var j = 0; j < invalidPaths.length; ++ j) {
                if (applier.destroyed) { // 2nd guarding point for FLUID-5592
                    return;
                }
                var invalidPath = invalidPaths[j];
                spec.listener = fluid.event.resolveListener(spec.listener);
                // TODO: process namespace and softNamespace rules, and propagate "sources" in 4th argument
                var args = [fluid.model.getSimple(newHolder, invalidPath), fluid.model.getSimple(oldHolder, invalidPath), invalidPath.slice(1), changeRequest, transaction, applier];
                // FLUID-5489: Do not notify of null changes which were reported as a result of invalidating a higher path
                // TODO: We can improve greatly on efficiency by i) reporting a special code from fluid.matchChanges which signals the difference between invalidating a higher and lower path,
                // ii) improving fluid.model.diff to create fewer intermediate structures and no copies
                // TODO: The relay invalidation system is broken and must always be notified (branch 1) - since our old/new value detection is based on the wrong (global) timepoints in the transaction here,
                // rather than the "last received model" by the holder of the transform document
                if (!spec.isRelay) {
                    var isNull = fluid.model.diff(args[0], args[1]);
                    if (isNull) {
                        continue;
                    }
                    var sourceExcluded = fluid.isExcludedChangeSource(transaction, spec);
                    if (sourceExcluded) {
                        continue;
                    }
                }
                if (transRec && !spec.isRelay && spec.transactional) { // bottle up genuine external changes so we can sort and dedupe them later
                    fluid.storeExternalChange(transRec, applier, invalidPath, spec, args);
                } else {
                    spec.listener.apply(null, args);
                }
            }
        }
    };

    fluid.bindELMethods = function (applier) {
        applier.parseEL = function (EL) {
            return fluid.model.pathToSegments(EL, applier.options.resolverSetConfig);
        };
        applier.composeSegments = function () {
            return applier.options.resolverSetConfig.parser.compose.apply(null, arguments);
        };
    };

    fluid.initModelEvent = function (that, trans, listeners) {
        fluid.notifyModelChanges(listeners, "ADD", trans.oldHolder, fluid.emptyHolder, null, trans, that);
    };

    fluid.emptyHolder = { model: undefined };

    fluid.makeNewChangeApplier = function (holder, options) {
        options = fluid.model.defaultAccessorConfig(options);
        var applierId = fluid.allocateGuid();
        var that = {
            applierId: applierId,
            holder: holder,
            changeListeners: {
                listeners: [],
                transListeners: []
            },
            options: options,
            modelChanged: {},
            preCommit: fluid.makeEventFirer({name: "preCommit event for ChangeApplier " }),
            postCommit: fluid.makeEventFirer({name: "postCommit event for ChangeApplier "})
        };
        function preFireChangeRequest(changeRequest) {
            if (!changeRequest.type) {
                changeRequest.type = "ADD";
            }
            changeRequest.segs = changeRequest.segs || that.parseEL(changeRequest.path);
        }
        that.destroy = function () {
            that.preCommit.destroy();
            that.postCommit.destroy();
            that.destroyed = true;
        };
        that.modelChanged.addListener = function (spec, listener, namespace, softNamespace) {
            if (typeof(spec) === "string") {
                spec = {path: spec};
            } else {
                spec = fluid.copy(spec);
            }
            spec.id = fluid.event.identifyListener(listener);
            spec.namespace = namespace;
            spec.softNamespace = softNamespace;
            if (typeof(listener) === "string") { // TODO: replicate this nonsense from Fluid.js until we remember its purpose
                listener = {globalName: listener};
            }
            spec.listener = listener;
            if (spec.transactional !== false) {
                spec.transactional = true;
            }
            spec.segs = spec.segs || that.parseEL(spec.path);
            var collection = that.changeListeners[spec.transactional ? "transListeners" : "listeners"];
            spec.excludeSource = fluid.arrayToHash(fluid.makeArray(spec.excludeSource || (spec.includeSource ? "*" : undefined)));
            spec.includeSource = fluid.arrayToHash(fluid.makeArray(spec.includeSource));
            spec.priority = fluid.event.mapPriority(spec.priority, collection.length);
            collection.push(spec);
        };
        that.modelChanged.removeListener = function (listener) {
            var id = fluid.event.identifyListener(listener);
            var namespace = typeof(listener) === "string" ? listener: null;
            var removePred = function (record) {
                return record.id === id || record.namespace === namespace;
            };
            fluid.remove_if(that.changeListeners.listeners, removePred);
            fluid.remove_if(that.changeListeners.transListeners, removePred);
        };
        that.modelChanged.isRelayEvent = true; // TODO: cheap helper for IoC testing framework - remove when old ChangeApplier goes
        that.fireChangeRequest = function (changeRequest) {
            var ation = that.initiate();
            ation.fireChangeRequest(changeRequest);
            ation.commit();
        };

        that.initiate = function (source, transactionId) {
            source = source || "local";
            var defeatPost = source === "relay"; // defeatPost is supplied for all non-top-level transactions
            var trans = {
                instanceId: fluid.allocateGuid(), // for debugging only
                id: transactionId || fluid.allocateGuid(),
                sources: {},
                changeRecord: {
                    resolverSetConfig: options.resolverSetConfig, // here to act as "options" in applyHolderChangeRequest
                    resolverGetConfig: options.resolverGetConfig
                },
                reset: function () {
                    trans.oldHolder = holder;
                    trans.newHolder = { model: fluid.copy(holder.model) };
                    trans.changeRecord.changes = 0;
                    trans.changeRecord.unchanged = 0; // just for type consistency - we don't use these values in the ChangeApplier
                    trans.changeRecord.changeMap = {};
                },
                commit: function (code) {
                    that.preCommit.fire(trans, that, code);
                    if (trans.changeRecord.changes > 0) {
                        var oldHolder = {model: holder.model};
                        holder.model = trans.newHolder.model;
                        fluid.notifyModelChanges(that.changeListeners.transListeners, trans.changeRecord.changeMap, holder, oldHolder, null, trans, that, holder);
                    }
                    if (!defeatPost) {
                        that.postCommit.fire(trans, that, code);
                    }
                },
                fireChangeRequest: function (changeRequest) {
                    preFireChangeRequest(changeRequest);
                    changeRequest.transactionId = trans.id;
                    var deltaMap = fluid.model.applyHolderChangeRequest(trans.newHolder, changeRequest, trans.changeRecord);
                    fluid.notifyModelChanges(that.changeListeners.listeners, deltaMap, trans.newHolder, holder, changeRequest, trans, that, holder);
                }
            };
            trans.sources[source] = true;
            trans.reset();
            fluid.bindRequestChange(trans);
            return trans;
        };
        that.hasChangeSource = function (source, changes) { // compatibility for old API
            return changes ? changes[source] : false;
        };

        fluid.bindRequestChange(that);
        fluid.bindELMethods(that);
        return that;
    };


    /** OLD CHANGEAPPLIER IMPLEMENTATION (Infusion 1.5 and before - this will be removed on Fluid 2.0) **/

    /** Parses a path segment, following escaping rules, starting from character index i in the supplied path */
    fluid.pathUtil.getPathSegment = function (path, i) {
        getPathSegmentImpl(globalAccept, path, i);
        return globalAccept[0];
    };

    /** Returns just the head segment of an EL path */
    fluid.pathUtil.getHeadPath = function (path) {
        return fluid.pathUtil.getPathSegment(path, 0);
    };

    /** Returns all of an EL path minus its first segment - if the path consists of just one segment, returns "" */
    fluid.pathUtil.getFromHeadPath = function (path) {
        var firstdot = getPathSegmentImpl(null, path, 0);
        return firstdot === path.length ? "" : path.substring(firstdot + 1);
    };

    function lastDotIndex(path) {
        // TODO: proper escaping rules
        return path.lastIndexOf(".");
    }

    /** Returns all of an EL path minus its final segment - if the path consists of just one segment, returns "" -
     * WARNING - this method does not follow escaping rules */
    fluid.pathUtil.getToTailPath = function (path) {
        var lastdot = lastDotIndex(path);
        return lastdot === -1 ? "" : path.substring(0, lastdot);
    };

    /** Returns the very last path component of an EL path
     * WARNING - this method does not follow escaping rules */
    fluid.pathUtil.getTailPath = function (path) {
        var lastdot = lastDotIndex(path);
        return fluid.pathUtil.getPathSegment(path, lastdot + 1);
    };

    /** Helpful utility for use in resolvers - matches a path which has already been
      * parsed into segments **/

    fluid.pathUtil.matchSegments = function (toMatch, segs, start, end) {
        if (end - start !== toMatch.length) {
            return false;
        }
        for (var i = start; i < end; ++ i) {
            if (segs[i] !== toMatch[i - start]) {
                return false;
            }
        }
        return true;
    };

    /** Determine the path by which a given path is nested within another **/
    // TODO: This utility is not used in the framework, and will cease to be useful in client code
    // once we move over to the declarative system for change binding
    fluid.pathUtil.getExcessPath = function (base, longer) {
        var index = longer.indexOf(base);
        if (index !== 0) {
            fluid.fail("Path " + base + " is not a prefix of path " + longer);
        }
        if (base.length === longer.length) {
            return "";
        }
        if (longer[base.length] !== ".") {
            fluid.fail("Path " + base + " is not properly nested in path " + longer);
        }
        return longer.substring(base.length + 1);
    };

    /** Determines whether a particular EL path matches a given path specification.
     * The specification consists of a path with optional wildcard segments represented by "*".
     * @param spec (string) The specification to be matched
     * @param path (string) The path to be tested
     * @param exact (boolean) Whether the path must exactly match the length of the specification in
     * terms of path segments in order to count as match. If exact is falsy, short specifications will
     * match all longer paths as if they were padded out with "*" segments
     * @return (array of string) The path segments which matched the specification, or <code>null</code> if there was no match
     */

    fluid.pathUtil.matchPath = function (spec, path, exact) {
        var togo = [];
        while (true) {
            if (((path === "") ^ (spec === "")) && exact) {
                return null;
            }
            // FLUID-4625 - symmetry on spec and path is actually undesirable, but this
            // quickly avoids at least missed notifications - improved (but slower)
            // implementation should explode composite changes
            if (!spec || !path) {
                break;
            }
            var spechead = fluid.pathUtil.getHeadPath(spec);
            var pathhead = fluid.pathUtil.getHeadPath(path);
            // if we fail to match on a specific component, fail.
            if (spechead !== "*" && spechead !== pathhead) {
                return null;
            }
            togo.push(pathhead);
            spec = fluid.pathUtil.getFromHeadPath(spec);
            path = fluid.pathUtil.getFromHeadPath(path);
        }
        return togo;
    };

    fluid.model.isNullChange = function (model, request, resolverGetConfig) {
        if (request.type === "ADD" && !request.forceChange) {
            var existing = fluid.get(model, request.segs, resolverGetConfig);
            if (existing === request.value) {
                return true;
            }
        }
    };

    /** Applies the supplied ChangeRequest object directly to the supplied model.
     */

    fluid.model.applyChangeRequest = function (model, request, resolverSetConfig) {
        var pen = fluid.model.accessWithStrategy(model, request.path, fluid.VALUE, resolverSetConfig || fluid.model.defaultSetConfig, null, true);
        var last = pen.segs[pen.segs.length - 1];

        if (request.type === "ADD" || request.type === "MERGE") {
            if (pen.segs.length === 0 || (request.type === "MERGE" && pen.root[last])) {
                if (request.type === "ADD") {
                    fluid.clear(pen.root);
                }
                $.extend(true, pen.segs.length === 0 ? pen.root : pen.root[last], request.value);
            }
            else {
                pen.root[last] = request.value;
            }
        }
        else if (request.type === "DELETE") {
            if (pen.segs.length === 0) {
                fluid.clear(pen.root);
            }
            else {
                delete pen.root[last];
            }
        }
    };

    // Utility used for source tracking in changeApplier

    function sourceWrapModelChanged(modelChanged, threadLocal) {
        return function (changeRequest) {
            var sources = threadLocal().sources;
            var args = arguments;
            var source = changeRequest.source || "";
            fluid.tryCatch(function () {
                if (sources[source] === undefined) {
                    sources[source] = 0;
                }
                ++sources[source];
                modelChanged.apply(null, args);
            }, null, function() {
                --sources[source];
            });
        };
    }


    /** The core creator function constructing ChangeAppliers. See API documentation
     * at http://wiki.fluidproject.org/display/fluid/ChangeApplier+API for the various
     * options supported in the options structure */

    fluid.makeChangeApplier = function (model, options) {
        return fluid.makeHolderChangeApplier({model: model}, options);
    };

    /** Make a "new-style" ChangeApplier that allows the base model reference to be overwritten. This is
     *  re-read on every access from the object "holder" (in typical usage, the component owning the
     *  ChangeApplier). This implementation will be removed after the 1.5 release */

    fluid.makeHolderChangeApplier = function (holder, options) {
        options = fluid.model.defaultAccessorConfig(options);
        var baseEvents = {
            guards: fluid.makeEventFirer({preventable: true, name: "guard event"}),
            postGuards: fluid.makeEventFirer({preventable: true, name: "postGuard event"}),
            modelChanged: fluid.makeEventFirer({name: "modelChanged event"})
        };
        var threadLocal = fluid.threadLocal(function() { return {sources: {}};});
        var that = {
        // For now, we don't use "id" to avoid confusing component detection which uses
        // a simple algorithm looking for that field
            applierId: fluid.allocateGuid(),
            holder: holder,
            options: options,
            destroy: fluid.identity // dummy function to avoid confusing FLUID-5592 code - we don't support this subtlety for old appliers
        };

        function makeGuardWrapper(cullUnchanged) {
            if (!cullUnchanged) {
                return null;
            }
            var togo = function (guard) {
                return function (model, changeRequest, internalApplier) {
                    var oldRet = guard(model, changeRequest, internalApplier);
                    if (oldRet === false) {
                        return false;
                    }
                    else {
                        if (fluid.model.isNullChange(model, changeRequest)) {
                            togo.culled = true;
                            return false;
                        }
                    }
                };
            };
            return togo;
        }

        function wrapListener(listener, spec) {
            var pathSpec = spec;
            var transactional = false;
            var priority = Number.MAX_VALUE;
            if (typeof (spec) === "string") {
                spec = {path: spec};
            }
            pathSpec = spec.path;
            transactional = spec.transactional;
            if (spec.priority !== undefined) {
                priority = spec.priority;
            }
            if (pathSpec.charAt(0) === "!") {
                transactional = true;
                pathSpec = pathSpec.substring(1);
            }
            var wrapped = function (changePath, fireSpec, accum) {
                var guid = fluid.event.identifyListener(listener);
                var exist = fireSpec.guids[guid];
                if (!exist || !accum) {
                    var match = fluid.pathUtil.matchPath(pathSpec, changePath);
                    if (match !== null) {
                        var record = {
                            match: match,
                            pathSpec: pathSpec,
                            listener: listener,
                            priority: priority,
                            transactional: transactional
                        };
                        if (accum) {
                            record.accumulate = [accum];
                        }
                        fireSpec.guids[guid] = record;
                        var collection = transactional ? "transListeners" : "listeners";
                        fireSpec[collection].push(record);
                        fireSpec.all.push(record);
                    }
                }
                else if (accum) {
                    if (!exist.accumulate) {
                        exist.accumulate = [];
                    }
                    exist.accumulate.push(accum);
                }
            };
            fluid.event.impersonateListener(listener, wrapped);
            return wrapped;
        }

        function fireFromSpec(name, fireSpec, args, category, wrapper) {
            return baseEvents[name].fireToListeners(fireSpec[category], args, wrapper);
        }

        function fireComparator(recA, recB) {
            return recA.priority - recB.priority;
        }

        function prepareFireEvent(name, changePath, fireSpec, accum) {
            baseEvents[name].fire(changePath, fireSpec, accum);
            fireSpec.all.sort(fireComparator);
            fireSpec.listeners.sort(fireComparator);
            fireSpec.transListeners.sort(fireComparator);
        }

        function makeFireSpec() {
            return {guids: {}, all: [], listeners: [], transListeners: []};
        }

        function getFireSpec(name, changePath) {
            var fireSpec = makeFireSpec();
            prepareFireEvent(name, changePath, fireSpec);
            return fireSpec;
        }

        function fireEvent(name, changePath, args, wrapper) {
            var fireSpec = getFireSpec(name, changePath);
            return fireFromSpec(name, fireSpec, args, "all", wrapper);
        }

        function adaptListener(that, name) {
            that[name] = {
                addListener: function (spec, listener, namespace, softNamespace) {
                    baseEvents[name].addListener(wrapListener(listener, spec), namespace, null, null, softNamespace);
                },
                removeListener: function (listener) {
                    baseEvents[name].removeListener(listener);
                }
            };
        }
        adaptListener(that, "guards");
        adaptListener(that, "postGuards");
        adaptListener(that, "modelChanged");

        function preFireChangeRequest(changeRequest) {
            if (!changeRequest.type) {
                changeRequest.type = "ADD";
            }
            changeRequest.segs = that.parseEL(changeRequest.path);
        }

        var bareApplier = {
            fireChangeRequest: function (changeRequest) {
                that.fireChangeRequest(changeRequest, true);
            }
        };
        fluid.bindRequestChange(bareApplier);

        that.fireChangeRequest = function (changeRequest) {
            preFireChangeRequest(changeRequest);
            var ation = that.initiate();
            ation.fireChangeRequest(changeRequest);
            ation.commit();
        };

        that.fireChangeRequest = sourceWrapModelChanged(that.fireChangeRequest, threadLocal);
        fluid.bindRequestChange(that);
        fluid.bindELMethods(that);

        // TODO: modelChanged has been moved to new model for firing. Once we abolish "guards", fireAgglomerated can go too.
        // Possibly also all the prepareFireEvent/wrapListener/fireSpec nonsense too.
        function fireAgglomerated(eventName, formName, changes, args, accpos, matchpos) {
            var fireSpec = makeFireSpec();
            for (var i = 0; i < changes.length; ++i) {
                prepareFireEvent(eventName, changes[i].path, fireSpec, changes[i]);
            }
            for (var j = 0; j < fireSpec[formName].length; ++j) {
                var spec = fireSpec[formName][j];
                if (accpos !== undefined) {
                    args[accpos] = spec.accumulate;
                }
                if (matchpos !== undefined) {
                    args[matchpos] = spec.match;
                }
                var ret = spec.listener.apply(null, args);
                if (ret === false) {
                    return false;
                }
            }
        }

        that.initiate = function (newModel) {
            var cancelled = false;
            var changes = [];
            if (options.thin) {
                newModel = holder.model;
            }
            else {
                newModel = newModel || {};
                fluid.model.copyModel(newModel, holder.model);
            }
            var ation = {
                commit: function () {
                    var oldModel;
                    if (cancelled) {
                        return false;
                    }
                    var ret = fireAgglomerated("postGuards", "transListeners", changes, [newModel, null, ation], 1);
                    if (ret === false || cancelled) {
                        return false;
                    }
                    if (options.thin) {
                        oldModel = holder.model;
                    }
                    else {
                        oldModel = {};
                        fluid.model.copyModel(oldModel, holder.model);
                        fluid.clear(holder.model);
                        fluid.model.copyModel(holder.model, newModel);
                    }
                    fireAgglomerated("modelChanged", "all", changes, [holder.model, oldModel, null, null], 2, 3);
                },
                fireChangeRequest: function (changeRequest) {
                    preFireChangeRequest(changeRequest);
                    if (options.cullUnchanged && fluid.model.isNullChange(holder.model, changeRequest, options.resolverGetConfig)) {
                        return;
                    }
                    var wrapper = makeGuardWrapper(options.cullUnchanged);
                    var prevent = fireEvent("guards", changeRequest.path, [newModel, changeRequest, ation], wrapper);
                    if (prevent === false && !(wrapper && wrapper.culled)) {
                        cancelled = true;
                    }
                    if (!cancelled) {
                        if (!(wrapper && wrapper.culled)) {
                            fluid.model.applyChangeRequest(newModel, changeRequest, options.resolverSetConfig);
                            changes.push(changeRequest);
                        }
                    }
                }
            };

            ation.fireChangeRequest = sourceWrapModelChanged(ation.fireChangeRequest, threadLocal);
            fluid.bindRequestChange(ation);

            return ation;
        };

        that.hasChangeSource = function (source) {
            return threadLocal().sources[source] > 0;
        };

        return that;
    };

    /** Old "SuperApplier" implementation - will be removed in 1.5 **/

    fluid.makeSuperApplier = function () {
        var subAppliers = [];
        var that = {};
        that.addSubApplier = function (path, subApplier) {
            subAppliers.push({path: path, subApplier: subApplier});
        };
        that.fireChangeRequest = function (request) {
            for (var i = 0; i < subAppliers.length; ++i) {
                var path = subAppliers[i].path;
                if (request.path.indexOf(path) === 0) {
                    var subpath = request.path.substring(path.length + 1);
                    var subRequest = fluid.copy(request);
                    subRequest.path = subpath;
                    // TODO: Deal with the as yet unsupported case of an EL rvalue DAR
                    subAppliers[i].subApplier.fireChangeRequest(subRequest);
                }
            }
        };
        fluid.bindRequestChange(that);
        return that;
    };

    fluid.attachModel = function (baseModel, path, model) {
        var segs = fluid.model.parseEL(path);
        for (var i = 0; i < segs.length - 1; ++i) {
            var seg = segs[i];
            var subModel = baseModel[seg];
            if (!subModel) {
                baseModel[seg] = subModel = {};
            }
            baseModel = subModel;
        }
        baseModel[segs[segs.length - 1]] = model;
    };

    fluid.assembleModel = function (modelSpec) {
        var model = {};
        var superApplier = fluid.makeSuperApplier();
        var togo = {model: model, applier: superApplier};
        for (var path in modelSpec) {
            var rec = modelSpec[path];
            fluid.attachModel(model, path, rec.model);
            if (rec.applier) {
                superApplier.addSubApplier(path, rec.applier);
            }
        }
        return togo;
    };

})(jQuery, fluid_2_0);
;/*
Copyright 2010 University of Toronto
Copyright 2010-2011 OCAD University

Licensed under the Educational Community License (ECL), Version 2.0 or the New
BSD license. You may not use this file except in compliance with one these
Licenses.

You may obtain a copy of the ECL 2.0 License and BSD License at
https://github.com/fluid-project/infusion/raw/master/Infusion-LICENSE.txt
*/

var fluid_2_0 = fluid_2_0 || {};
var fluid = fluid || fluid_2_0;

(function ($, fluid) {
    "use strict";

    fluid.registerNamespace("fluid.model.transform");

    /** Grade definitions for standard transformation function hierarchy **/

    fluid.defaults("fluid.transformFunction", {
        gradeNames: "fluid.function"
    });

    // uses standard layout and workflow involving inputPath
    fluid.defaults("fluid.standardInputTransformFunction", {
        gradeNames: "fluid.transformFunction"
    });

    fluid.defaults("fluid.standardOutputTransformFunction", {
        gradeNames: "fluid.transformFunction"
    });

    fluid.defaults("fluid.multiInputTransformFunction", {
        gradeNames: "fluid.transformFunction"
    });

    // uses the standard layout and workflow involving inputPath and outputPath
    fluid.defaults("fluid.standardTransformFunction", {
        gradeNames: ["fluid.standardInputTransformFunction", "fluid.standardOutputTransformFunction"]
    });

    fluid.defaults("fluid.lens", {
        gradeNames: "fluid.transformFunction",
        invertConfiguration: null
        // this function method returns "inverted configuration" rather than actually performing inversion
        // TODO: harmonise with strategy used in VideoPlayer_framework.js
    });

    /***********************************
     * Base utilities for transformers *
     ***********************************/

    // unsupported, NON-API function
    fluid.model.transform.pathToRule = function (inputPath) {
        return {
            transform: {
                type: "fluid.transforms.value",
                inputPath: inputPath
            }
        };
    };

    // unsupported, NON-API function
    fluid.model.transform.literalValueToRule = function (value) {
        return {
            transform: {
                type: "fluid.transforms.literalValue",
                value: value
            }
        };
    };

    /** Accepts two fully escaped paths, either of which may be empty or null **/
    fluid.model.composePaths = function (prefix, suffix) {
        prefix = prefix === 0 ? "0" : prefix || "";
        suffix = suffix === 0 ? "0" : suffix || "";
        return !prefix ? suffix : (!suffix ? prefix : prefix + "." + suffix);
    };

    fluid.model.transform.accumulateInputPath = function (inputPath, transform, paths) {
        if (inputPath !== undefined) {
            paths.push(fluid.model.composePaths(transform.inputPrefix, inputPath));
        }
    };

    fluid.model.transform.accumulateStandardInputPath = function (input, transformSpec, transform, paths) {
        fluid.model.transform.getValue(undefined, transformSpec[input], transform);
        fluid.model.transform.accumulateInputPath(transformSpec[input + "Path"], transform, paths);
    };

    fluid.model.transform.accumulateMultiInputPaths = function (inputVariables, transformSpec, transform, paths) {
        fluid.each(inputVariables, function (v, k) {
            fluid.model.transform.accumulateStandardInputPath(k, transformSpec, transform, paths);
        });
    };

    fluid.model.transform.getValue = function (inputPath, value, transform) {
        var togo;
        if (inputPath !== undefined) { // NB: We may one day want to reverse the crazy jQuery-like convention that "no path means root path"
            togo = fluid.get(transform.source, fluid.model.composePaths(transform.inputPrefix, inputPath), transform.resolverGetConfig);
        }
        if (togo === undefined) {
            togo = fluid.isPrimitive(value) ? value : transform.expand(value);
        }
        return togo;
    };

    // distinguished value which indicates that a transformation rule supplied a
    // non-default output path, and so the user should be prevented from making use of it
    // in a compound transform definition
    fluid.model.transform.NONDEFAULT_OUTPUT_PATH_RETURN = {};

    fluid.model.transform.setValue = function (userOutputPath, value, transform) {
        // avoid crosslinking to input object - this might be controlled by a "nocopy" option in future
        var toset = fluid.copy(value);
        var outputPath = fluid.model.composePaths(transform.outputPrefix, userOutputPath);
        // TODO: custom resolver config here to create non-hash output model structure
        if (toset !== undefined) {
            transform.applier.requestChange(outputPath, toset);
        }
        return userOutputPath ? fluid.model.transform.NONDEFAULT_OUTPUT_PATH_RETURN : toset;
    };

    /* Resolves the <key> given as parameter by looking up the path <key>Path in the object
     * to be transformed. If not present, it resolves the <key> by using the literal value if primitive,
     * or expanding otherwise. <def> defines the default value if unableto resolve the key. If no
     * default value is given undefined is returned
     */
    fluid.model.transform.resolveParam = function (transformSpec, transform, key, def) {
        var val = fluid.model.transform.getValue(transformSpec[key + "Path"], transformSpec[key], transform);
        return (val !== undefined) ? val : def;
    };

    // Compute a "match score" between two pieces of model material, with 0 indicating a complete mismatch, and
    // higher values indicating increasingly good matches
    fluid.model.transform.matchValue = function (expected, actual, partialMatches) {
        var stats = {changes: 0, unchanged: 0, changeMap: {}};
        fluid.model.diff(expected, actual, stats);
        // i) a pair with 0 matches counts for 0 in all cases
        // ii) without "partial match mode" (the default), we simply count matches, with any mismatch giving 0
        // iii) with "partial match mode", a "perfect score" in the top 24 bits is
        // penalised for each mismatch, with a positive score of matches store in the bottom 24 bits
        return stats.unchanged === 0 ? 0
            : (partialMatches ? 0xffffff000000 - 0x1000000 * stats.changes + stats.unchanged :
            (stats.changes ? 0 : 0xffffff000000 + stats.unchanged));
    };

    fluid.firstDefined = function (a, b) {
        return a === undefined ? b : a;
    };


    // TODO: prefixApplier is a transform which is currently unused and untested
    fluid.model.transform.prefixApplier = function (transformSpec, transform) {
        if (transformSpec.inputPrefix) {
            transform.inputPrefixOp.push(transformSpec.inputPrefix);
        }
        if (transformSpec.outputPrefix) {
            transform.outputPrefixOp.push(transformSpec.outputPrefix);
        }
        transform.expand(transformSpec.value);
        if (transformSpec.inputPrefix) {
            transform.inputPrefixOp.pop();
        }
        if (transformSpec.outputPrefix) {
            transform.outputPrefixOp.pop();
        }
    };

    fluid.defaults("fluid.model.transform.prefixApplier", {
        gradeNames: ["fluid.transformFunction"]
    });

    // unsupported, NON-API function
    fluid.model.makePathStack = function (transform, prefixName) {
        var stack = transform[prefixName + "Stack"] = [];
        transform[prefixName] = "";
        return {
            push: function (prefix) {
                var newPath = fluid.model.composePaths(transform[prefixName], prefix);
                stack.push(transform[prefixName]);
                transform[prefixName] = newPath;
            },
            pop: function () {
                transform[prefixName] = stack.pop();
            }
        };
    };

    fluid.model.transform.aliasStandardInput = function (transformSpec) {
        return { // alias input and value, and their paths
            value: transformSpec.value === undefined ? transformSpec.input : transformSpec.value,
            valuePath: transformSpec.valuePath === undefined ? transformSpec.inputPath : transformSpec.valuePath
        };
    };

    // unsupported, NON-API function
    fluid.model.transform.doTransform = function (transformSpec, transform, transformOpts) {
        var expdef = transformOpts.defaults;
        var transformFn = fluid.getGlobalValue(transformOpts.typeName);
        if (typeof(transformFn) !== "function") {
            fluid.fail("Transformation record specifies transformation function with name " +
                transformSpec.type + " which is not a function - ", transformFn);
        }
        if (!fluid.hasGrade(expdef, "fluid.transformFunction")) {
            // If no suitable grade is set up, assume that it is intended to be used as a standardTransformFunction
            expdef = fluid.defaults("fluid.standardTransformFunction");
        }
        var transformArgs = [transformSpec, transform];
        if (fluid.hasGrade(expdef, "fluid.standardInputTransformFunction")) {
            var valueHolder = fluid.model.transform.aliasStandardInput(transformSpec);
            var expanded = fluid.model.transform.getValue(valueHolder.valuePath, valueHolder.value, transform);

            transformArgs.unshift(expanded);
            // if the function has no input, the result is considered undefined, and this is returned
            if (expanded === undefined) {
                return undefined;
            }
        } else if (fluid.hasGrade(expdef, "fluid.multiInputTransformFunction")) {
            var inputs = {};
            fluid.each(expdef.inputVariables, function (v, k) {
                inputs[k] = function () {
                    var input = fluid.model.transform.getValue(transformSpec[k + "Path"], transformSpec[k], transform);
                    // if no match, assign default if one exists (v != null)
                    input = (input === undefined && v !== null) ? v : input;
                    return input;
                };
            });
            transformArgs.unshift(inputs);
        }
        var transformed = transformFn.apply(null, transformArgs);
        if (fluid.hasGrade(expdef, "fluid.standardOutputTransformFunction")) {
            // "doOutput" flag is currently set nowhere, but could be used in future
            var outputPath = transformSpec.outputPath !== undefined ? transformSpec.outputPath : (transformOpts.doOutput ? "" : undefined);
            if (outputPath !== undefined && transformed !== undefined) {
                //If outputPath is given in the expander we want to:
                // (1) output to the document
                // (2) return undefined, to ensure that expanders higher up in the hierarchy doesn't attempt to output it again
                fluid.model.transform.setValue(transformSpec.outputPath, transformed, transform);
                transformed = undefined;
            }
        }
        return transformed;
    };

    // unsupported, NON-API function
    fluid.model.transform.expandWildcards = function (transform, source) {
        fluid.each(source, function (value, key) {
            var q = transform.queuedTransforms;
            transform.pathOp.push(fluid.pathUtil.escapeSegment(key.toString()));
            for (var i = 0; i < q.length; ++i) {
                if (fluid.pathUtil.matchPath(q[i].matchPath, transform.path, true)) {
                    var esCopy = fluid.copy(q[i].transformSpec);
                    if (esCopy.inputPath === undefined || fluid.model.transform.hasWildcard(esCopy.inputPath)) {
                        esCopy.inputPath = "";
                    }
                    // TODO: allow some kind of interpolation for output path
                    // TODO: Also, we now require outputPath to be specified in these cases for output to be produced as well.. Is that something we want to continue with?
                    transform.inputPrefixOp.push(transform.path);
                    transform.outputPrefixOp.push(transform.path);
                    var transformOpts = fluid.model.transform.lookupType(esCopy.type);
                    var result = fluid.model.transform.doTransform(esCopy, transform, transformOpts);
                    if (result !== undefined) {
                        fluid.model.transform.setValue(null, result, transform);
                    }
                    transform.outputPrefixOp.pop();
                    transform.inputPrefixOp.pop();
                }
            }
            if (!fluid.isPrimitive(value)) {
                fluid.model.transform.expandWildcards(transform, value);
            }
            transform.pathOp.pop();
        });
    };

    // unsupported, NON-API function
    fluid.model.transform.hasWildcard = function (path) {
        return typeof(path) === "string" && path.indexOf("*") !== -1;
    };

    // unsupported, NON-API function
    fluid.model.transform.maybePushWildcard = function (transformSpec, transform) {
        var hw = fluid.model.transform.hasWildcard;
        var matchPath;
        if (hw(transformSpec.inputPath)) {
            matchPath = fluid.model.composePaths(transform.inputPrefix, transformSpec.inputPath);
        }
        else if (hw(transform.outputPrefix) || hw(transformSpec.outputPath)) {
            matchPath = fluid.model.composePaths(transform.outputPrefix, transformSpec.outputPath);
        }

        if (matchPath) {
            transform.queuedTransforms.push({transformSpec: transformSpec, outputPrefix: transform.outputPrefix, inputPrefix: transform.inputPrefix, matchPath: matchPath});
            return true;
        }
        return false;
    };

    fluid.model.sortByKeyLength = function (inObject) {
        var keys = fluid.keys(inObject);
        return keys.sort(fluid.compareStringLength(true));
    };

    // Three handler functions operating the (currently) three different processing modes
    // unsupported, NON-API function
    fluid.model.transform.handleTransformStrategy = function (transformSpec, transform, transformOpts) {
        if (fluid.model.transform.maybePushWildcard(transformSpec, transform)) {
            return;
        }
        else {
            return fluid.model.transform.doTransform(transformSpec, transform, transformOpts);
        }
    };
    // unsupported, NON-API function
    fluid.model.transform.handleInvertStrategy = function (transformSpec, transform, transformOpts) {
        var invertor = transformOpts.defaults && transformOpts.defaults.invertConfiguration;
        if (invertor) {
            var inverted = fluid.invokeGlobalFunction(invertor, [transformSpec, transform]);
            transform.inverted.push(inverted);
        }
    };

    // unsupported, NON-API function
    fluid.model.transform.handleCollectStrategy = function (transformSpec, transform, transformOpts) {
        var defaults = transformOpts.defaults;
        var standardInput = fluid.hasGrade(defaults, "fluid.standardInputTransformFunction");
        var multiInput = fluid.hasGrade(defaults, "fluid.multiInputTransformFunction");

        if (standardInput) {
            fluid.model.transform.accumulateStandardInputPath("input", transformSpec, transform, transform.inputPaths);
        } else if (multiInput) {
            fluid.model.transform.accumulateMultiInputPaths(defaults.inputVariables, transformSpec, transform, transform.inputPaths);
        } else {
            var collector = defaults.collectInputPaths;
            if (collector) {
                var collected = fluid.makeArray(fluid.invokeGlobalFunction(collector, [transformSpec, transform]));
                transform.inputPaths = transform.inputPaths.concat(collected);
            }
        }
    };

    fluid.model.transform.lookupType = function (typeName, transformSpec) {
        if (!typeName) {
            fluid.fail("Transformation record is missing a type name: ", transformSpec);
        }
        if (typeName.indexOf(".") === -1) {
            typeName = "fluid.transforms." + typeName;
        }
        var defaults = fluid.defaults(typeName);
        return { defaults: defaults, typeName: typeName};
    };
    
    // A utility which is helpful in computing inverses involving compound values. 
    // For example, with the valueMapper, compound input values are accepted as literals implicitly,
    // whereas as output values they must be escaped. This utility escapes a value if it is not primitive.
    fluid.model.transform.literaliseValue = function (value) {
        return fluid.isPrimitive(value) ? value : {
            literalValue: value
        };
    };

    // unsupported, NON-API function
    fluid.model.transform.processRule = function (rule, transform) {
        if (typeof(rule) === "string") {
            rule = fluid.model.transform.pathToRule(rule);
        }
        // special dispensation to allow "literalValue" to escape any value
        else if (rule.literalValue !== undefined) {
            rule = fluid.model.transform.literalValueToRule(rule.literalValue);
        }
        var togo;
        if (rule.transform) {
            var transformSpec, transformOpts;

            if (fluid.isArrayable(rule.transform)) {
                // if the transform holds an array, each transformer within that is responsible for its own output
                var transforms = rule.transform;
                togo = undefined;
                for (var i = 0; i < transforms.length; ++i) {
                    transformSpec = transforms[i];
                    transformOpts = fluid.model.transform.lookupType(transformSpec.type);
                    transform.transformHandler(transformSpec, transform, transformOpts);
                }
            } else {
                // else we just have a normal single transform which will return 'undefined' as a flag to defeat cascading output
                transformSpec = rule.transform;
                transformOpts = fluid.model.transform.lookupType(transformSpec.type);
                togo = transform.transformHandler(transformSpec, transform, transformOpts);
            }
        }
        // if rule is an array, save path for later use in schema strategy on final applier (so output will be interpreted as array)
        if (fluid.isArrayable(rule)) {
            transform.collectedFlatSchemaOpts = transform.collectedFlatSchemaOpts || {};
            transform.collectedFlatSchemaOpts[transform.outputPrefix] = "array";
        }
        fluid.each(rule, function (value, key) {
            if (key !== "transform") {
                transform.outputPrefixOp.push(key);
                var togo = transform.expand(value, transform);
                // Value expanders and arrays as rules implicitly outputs, unless they have nothing (undefined) to output
                if (togo !== undefined) {
                    fluid.model.transform.setValue(null, togo, transform);
                    // ensure that expanders further up does not try to output this value as well.
                    togo = undefined;
                }
                transform.outputPrefixOp.pop();
            }
        });
        return togo;
    };

    // unsupported, NON-API function
    // 3rd arg is disused by the framework and always defaults to fluid.model.transform.processRule
    fluid.model.transform.makeStrategy = function (transform, handleFn, transformFn) {
        transformFn = transformFn || fluid.model.transform.processRule;
        transform.expand = function (rules) {
            return transformFn(rules, transform);
        };
        transform.outputPrefixOp = fluid.model.makePathStack(transform, "outputPrefix");
        transform.inputPrefixOp = fluid.model.makePathStack(transform, "inputPrefix");
        transform.transformHandler = handleFn;
    };

    fluid.model.transform.invertConfiguration = function (rules) {
        var transform = {
            inverted: []
        };
        fluid.model.transform.makeStrategy(transform, fluid.model.transform.handleInvertStrategy);
        transform.expand(rules);
        return {
            transform: transform.inverted
        };
    };

    fluid.model.transform.collectInputPaths = function (rules) {
        var transform = {
            inputPaths: []
        };
        fluid.model.transform.makeStrategy(transform, fluid.model.transform.handleCollectStrategy);
        transform.expand(rules);
        return transform.inputPaths;
    };

    // unsupported, NON-API function
    fluid.model.transform.flatSchemaStrategy = function (flatSchema, getConfig) {
        var keys = fluid.model.sortByKeyLength(flatSchema);
        return function (root, segment, index, segs) {
            var path = getConfig.parser.compose.apply(null, segs.slice(0, index));
          // TODO: clearly this implementation could be much more efficient
            for (var i = 0; i < keys.length; ++i) {
                var key = keys[i];
                if (fluid.pathUtil.matchPath(key, path, true) !== null) {
                    return flatSchema[key];
                }
            }
        };
    };

    // unsupported, NON-API function
    fluid.model.transform.defaultSchemaValue = function (schemaValue) {
        var type = fluid.isPrimitive(schemaValue) ? schemaValue : schemaValue.type;
        return type === "array" ? [] : {};
    };

    // unsupported, NON-API function
    fluid.model.transform.isomorphicSchemaStrategy = function (source, getConfig) {
        return function (root, segment, index, segs) {
            var existing = fluid.get(source, segs.slice(0, index), getConfig);
            return fluid.isArrayable(existing) ? "array" : "object";
        };
    };

    // unsupported, NON-API function
    fluid.model.transform.decodeStrategy = function (source, options, getConfig) {
        if (options.isomorphic) {
            return fluid.model.transform.isomorphicSchemaStrategy(source, getConfig);
        }
        else if (options.flatSchema) {
            return fluid.model.transform.flatSchemaStrategy(options.flatSchema, getConfig);
        }
    };

    // unsupported, NON-API function
    fluid.model.transform.schemaToCreatorStrategy = function (strategy) {
        return function (root, segment, index, segs) {
            if (root[segment] === undefined) {
                var schemaValue = strategy(root, segment, index, segs);
                root[segment] = fluid.model.transform.defaultSchemaValue(schemaValue);
                return root[segment];
            }
        };
    };

    /** Transforms a model by a sequence of rules. Parameters as for fluid.model.transform,
     * only with an array accepted for "rules"
     */
    fluid.model.transform.sequence = function (source, rules, options) {
        for (var i = 0; i < rules.length; ++i) {
            source = fluid.model.transform(source, rules[i], options);
        }
        return source;
    };

    fluid.model.compareByPathLength = function (changea, changeb) {
        var pdiff = changea.path.length - changeb.path.length;
        return pdiff === 0 ? changea.sequence - changeb.sequence : pdiff;
    };

   /** Fires an accumulated set of change requests in increasing order of target pathlength
     */
    fluid.model.fireSortedChanges = function (changes, applier) {
        changes.sort(fluid.model.compareByPathLength);
        fluid.requestChanges(applier, changes);
    };

    /**
     * Transforms a model based on a specified expansion rules objects.
     * Rules objects take the form of:
     *   {
     *       "target.path": "value.el.path" || {
     *          transform: {
     *              type: "transform.function.path",
     *               ...
     *           }
     *       }
     *   }
     *
     * @param {Object} source the model to transform
     * @param {Object} rules a rules object containing instructions on how to transform the model
     * @param {Object} options a set of rules governing the transformations. At present this may contain
     * the values <code>isomorphic: true</code> indicating that the output model is to be governed by the
     * same schema found in the input model, or <code>flatSchema</code> holding a flat schema object which
     * consists of a hash of EL path specifications with wildcards, to the values "array"/"object" defining
     * the schema to be used to construct missing trunk values.
     */
    fluid.model.transformWithRules = function (source, rules, options) {
        options = options || {};

        var getConfig = fluid.model.escapedGetConfig;

        var schemaStrategy = fluid.model.transform.decodeStrategy(source, options, getConfig);

        var transform = {
            source: source,
            target: {
                model: schemaStrategy ? fluid.model.transform.defaultSchemaValue(schemaStrategy(null, "", 0, [""])) : {}
            },
            resolverGetConfig: getConfig,
            collectedFlatSchemaOpts: undefined, // to hold options for flat schema collected during transforms
            queuedChanges: [],
            queuedTransforms: [] // TODO: This is used only by wildcard applier - explain its operation
        };
        fluid.model.transform.makeStrategy(transform, fluid.model.transform.handleTransformStrategy);
        transform.applier = {
            fireChangeRequest: function (changeRequest) {
                changeRequest.sequence = transform.queuedChanges.length;
                transform.queuedChanges.push(changeRequest);
            }
        };
        fluid.bindRequestChange(transform.applier);

        transform.expand(rules);

        var setConfig = fluid.copy(fluid.model.escapedSetConfig);
        // Modify schemaStrategy if we collected flat schema options for the setConfig of finalApplier
        if (transform.collectedFlatSchemaOpts !== undefined) {
            $.extend(transform.collectedFlatSchemaOpts, options.flatSchema);
            schemaStrategy = fluid.model.transform.flatSchemaStrategy(transform.collectedFlatSchemaOpts, getConfig);
        }
        setConfig.strategies = [fluid.model.defaultFetchStrategy, schemaStrategy ? fluid.model.transform.schemaToCreatorStrategy(schemaStrategy)
                : fluid.model.defaultCreatorStrategy];
        transform.finalApplier = options.finalApplier || fluid.makeNewChangeApplier(transform.target, {resolverSetConfig: setConfig});

        if (transform.queuedTransforms.length > 0) {
            transform.typeStack = [];
            transform.pathOp = fluid.model.makePathStack(transform, "path");
            fluid.model.transform.expandWildcards(transform, source);
        }
        fluid.model.fireSortedChanges(transform.queuedChanges, transform.finalApplier);
        return transform.target.model;
    };

    $.extend(fluid.model.transformWithRules, fluid.model.transform);
    fluid.model.transform = fluid.model.transformWithRules;

    /** Utility function to produce a standard options transformation record for a single set of rules **/
    fluid.transformOne = function (rules) {
        return {
            transformOptions: {
                transformer: "fluid.model.transformWithRules",
                config: rules
            }
        };
    };

    /** Utility function to produce a standard options transformation record for multiple rules to be applied in sequence **/
    fluid.transformMany = function (rules) {
        return {
            transformOptions: {
                transformer: "fluid.model.transform.sequence",
                config: rules
            }
        };
    };

})(jQuery, fluid_2_0);
;/*
Copyright 2010 University of Toronto
Copyright 2010-2011 OCAD University
Copyright 2013 Raising the Floor - International

Licensed under the Educational Community License (ECL), Version 2.0 or the New
BSD license. You may not use this file except in compliance with one these
Licenses.

You may obtain a copy of the ECL 2.0 License and BSD License at
https://github.com/fluid-project/infusion/raw/master/Infusion-LICENSE.txt
*/

var fluid_2_0 = fluid_2_0 || {};
var fluid = fluid || fluid_2_0;

(function ($, fluid) {
    "use strict";

    fluid.registerNamespace("fluid.model.transform");
    fluid.registerNamespace("fluid.transforms");

    /**********************************
     * Standard transformer functions *
     **********************************/

    fluid.defaults("fluid.transforms.value", {
        gradeNames: "fluid.standardTransformFunction",
        invertConfiguration: "fluid.transforms.value.invert"
    });

    fluid.transforms.value = fluid.identity;

    fluid.transforms.value.invert = function (transformSpec, transformer) {
        var togo = fluid.copy(transformSpec);
        // TODO: this will not behave correctly in the face of compound "value" which contains
        // further transforms
        togo.inputPath = fluid.model.composePaths(transformer.outputPrefix, transformSpec.outputPath);
        togo.outputPath = fluid.model.composePaths(transformer.inputPrefix, transformSpec.inputPath);
        return togo;
    };

    // Export the use of the "value" transform under the "identity" name for FLUID-5293
    fluid.transforms.identity = fluid.transforms.value;
    fluid.defaults("fluid.transforms.identity", {
        gradeNames: "fluid.transforms.value"
    });

    fluid.defaults("fluid.transforms.literalValue", {
        gradeNames: "fluid.standardOutputTransformFunction"
    });

    fluid.transforms.literalValue = function (transformSpec) {
        return transformSpec.value;
    };


    fluid.defaults("fluid.transforms.arrayValue", {
        gradeNames: "fluid.standardTransformFunction"
    });

    fluid.transforms.arrayValue = fluid.makeArray;


    fluid.defaults("fluid.transforms.count", {
        gradeNames: "fluid.standardTransformFunction"
    });

    fluid.transforms.count = function (value) {
        return fluid.makeArray(value).length;
    };


    fluid.defaults("fluid.transforms.round", {
        gradeNames: "fluid.standardTransformFunction"
    });

    fluid.transforms.round = function (value) {
        return Math.round(value);
    };


    fluid.defaults("fluid.transforms.delete", {
        gradeNames: "fluid.transformFunction"
    });

    fluid.transforms["delete"] = function (transformSpec, transformer) {
        var outputPath = fluid.model.composePaths(transformer.outputPrefix, transformSpec.outputPath);
        transformer.applier.requestChange(outputPath, null, "DELETE");
    };


    fluid.defaults("fluid.transforms.firstValue", {
        gradeNames: "fluid.transformFunction"
    });

    fluid.transforms.firstValue = function (transformSpec, transformer) {
        if (!transformSpec.values || !transformSpec.values.length) {
            fluid.fail("firstValue transformer requires an array of values at path named \"values\", supplied", transformSpec);
        }
        for (var i = 0; i < transformSpec.values.length; i++) {
            var value = transformSpec.values[i];
            // TODO: problem here - all of these transforms will have their side-effects (setValue) even if only one is chosen
            var expanded = transformer.expand(value);
            if (expanded !== undefined) {
                return expanded;
            }
        }
    };

    fluid.defaults("fluid.transforms.linearScale", {
        gradeNames: [ "fluid.multiInputTransformFunction", "fluid.standardOutputTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.linearScale.invert",
        inputVariables: {
            value: null,
            factor: 1,
            offset: 0
        }
    });

    /* simple linear transformation */
    fluid.transforms.linearScale = function (inputs) {
        var value = inputs.value();
        var factor = inputs.factor();
        var offset = inputs.offset();

        if (typeof(value) !== "number" || typeof(factor) !== "number" || typeof(offset) !== "number") {
            return undefined;
        }
        return value * factor + offset;
    };

    /* TODO: This inversion doesn't work if the value and factors are given as paths in the source model */
    fluid.transforms.linearScale.invert = function  (transformSpec, transformer) {
        var togo = fluid.copy(transformSpec);

        if (togo.factor) {
            togo.factor = (togo.factor === 0) ? 0 : 1 / togo.factor;
        }
        if (togo.offset) {
            togo.offset = - togo.offset * (togo.factor !== undefined ? togo.factor : 1);
        }
        // TODO: This rubbish should be done by the inversion machinery by itself. We shouldn't have to repeat it in every
        // inversion rule
        togo.valuePath = fluid.model.composePaths(transformer.outputPrefix, transformSpec.outputPath);
        togo.outputPath = fluid.model.composePaths(transformer.inputPrefix, transformSpec.valuePath);
        return togo;
    };

    fluid.defaults("fluid.transforms.binaryOp", {
        gradeNames: [ "fluid.multiInputTransformFunction", "fluid.standardOutputTransformFunction" ],
        inputVariables: {
            left: null,
            right: null
        }
    });

    fluid.transforms.binaryLookup = {
        "===": function (a, b) { return a === b; },
        "!==": function (a, b) { return a !== b; },
        "<=": function (a, b) { return a <= b; },
        "<": function (a, b) { return a < b; },
        ">=": function (a, b) { return a >= b; },
        ">": function (a, b) { return a > b; },
        "+": function (a, b) { return a + b; },
        "-": function (a, b) { return a - b; },
        "*": function (a, b) { return a * b; },
        "/": function (a, b) { return a / b; },
        "%": function (a, b) { return a % b; },
        "&&": function (a, b) { return a && b; },
        "||": function (a, b) { return a || b; }
    };

    fluid.transforms.binaryOp = function (inputs, transformSpec, transformer) {
        var left = inputs.left();
        var right = inputs.right();

        var operator = fluid.model.transform.getValue(undefined, transformSpec.operator, transformer);

        var fun = fluid.transforms.binaryLookup[operator];
        return (fun === undefined || left === undefined || right === undefined) ?
            undefined : fun(left, right);
    };

    fluid.defaults("fluid.transforms.condition", {
        gradeNames: [ "fluid.multiInputTransformFunction", "fluid.standardOutputTransformFunction" ],
        inputVariables: {
            "true": null,
            "false": null,
            "condition": null
        }
    });

    fluid.transforms.condition = function (inputs) {
        var condition = inputs.condition();
        if (condition === null) {
            return undefined;
        }

        return inputs[condition ? "true" : "false"]();
    };


    fluid.defaults("fluid.transforms.valueMapper", {
        gradeNames: ["fluid.transformFunction", "fluid.lens"],
        invertConfiguration: "fluid.transforms.valueMapper.invert",
        collectInputPaths: "fluid.transforms.valueMapper.collect"
    });
    
    
    // unsupported, NON-API function
    fluid.model.transform.compareMatches = function (speca, specb) {
        return specb.matchValue - speca.matchValue;
    };

    // unsupported, NON-API function
    fluid.model.transform.matchValueMapperFull = function (outerValue, transformSpec, transformer) {
        var o = transformSpec.options;
        if (o.length === 0) {
            fluid.fail("valueMapper supplied empty list of options: ", transformSpec);
        }
        var matchPower = [];
        for (var i = 0; i < o.length; ++i) {
            var option = o[i];
            var value = fluid.firstDefined(fluid.model.transform.getValue(option.inputPath, undefined, transformer),
                outerValue);
            var matchValue = fluid.model.transform.matchValue(option.undefinedInputValue ? undefined :
                (option.inputValue === undefined ? transformSpec.defaultInputValue : option.inputValue), value, transformSpec.partialMatches || option.partialMatches);
            matchPower[i] = {index: i, matchValue: matchValue};
        }
        matchPower.sort(fluid.model.transform.compareMatches);
        return (matchPower[0].matchValue <= 0 || o.length > 1 && matchPower[0].matchValue === matchPower[1].matchValue) ? -1 : matchPower[0].index;
    };

    fluid.transforms.valueMapper = function (transformSpec, transformer) {
        if (!transformSpec.options) {
            fluid.fail("valueMapper requires a list or hash of options at path named \"options\", supplied ", transformSpec);
        }
        var value = fluid.model.transform.getValue(transformSpec.inputPath, undefined, transformer);
        var deref = fluid.isArrayable(transformSpec.options) ? // long form with list of records
            function (testVal) {
                var index = fluid.model.transform.matchValueMapperFull(testVal, transformSpec, transformer);
                return index === -1 ? null : transformSpec.options[index];
            } :
            function (testVal) {
                return transformSpec.options[testVal];
            };

        var indexed = deref(value);
        if (!indexed) {
            // if no branch matches, try again using this value - WARNING, this seriously
            // threatens invertibility
            indexed = deref(transformSpec.defaultInputValue);
        }
        if (!indexed) {
            return;
        }

        var outputPath = indexed.outputPath === undefined ? transformSpec.defaultOutputPath : indexed.outputPath;
        transformer.outputPrefixOp.push(outputPath);
        var outputValue;
        if (fluid.isPrimitive(indexed)) {
            outputValue = indexed;
        } else {
            // if undefinedOutputValue is set, outputValue should be undefined
            if (indexed.undefinedOutputValue) {
                outputValue = undefined;
            } else {
                // get value from outputValue or outputValuePath. If none is found set the outputValue to be that of defaultOutputValue (or undefined)
                outputValue = fluid.model.transform.resolveParam(indexed, transformer, "outputValue", undefined);
                outputValue = (outputValue === undefined) ? transformSpec.defaultOutputValue : outputValue;
            }
        }
        // output if outputPath or defaultOutputPath have been specified and the relevant child hasn't done the outputting
        if (typeof(outputPath) === "string" && outputValue !== undefined) {
            fluid.model.transform.setValue(undefined, outputValue, transformer, transformSpec.merge);
            outputValue = undefined;
        }
        transformer.outputPrefixOp.pop();
        return outputValue;
    };

    fluid.transforms.valueMapper.invert = function (transformSpec, transformer) {
        var options = [];
        var togo = {
            type: "fluid.transforms.valueMapper",
            options: options
        };
        var isArray = fluid.isArrayable(transformSpec.options);
        var findCustom = function (name) {
            return fluid.find(transformSpec.options, function (option) {
                if (option[name]) {
                    return true;
                }
            });
        };
        var anyCustomOutput = findCustom("outputPath");
        var anyCustomInput = findCustom("inputPath");
        if (!anyCustomOutput) {
            togo.inputPath = fluid.model.composePaths(transformer.outputPrefix, transformSpec.defaultOutputPath);
        }
        if (!anyCustomInput) {
            togo.defaultOutputPath = fluid.model.composePaths(transformer.inputPrefix, transformSpec.inputPath);
        }
        var def = fluid.firstDefined;
        fluid.each(transformSpec.options, function (option, key) {
            var outOption = {};
            var origInputValue = def(isArray ? option.inputValue : key, transformSpec.defaultInputValue);
            if (origInputValue === undefined) {
                fluid.fail("Failure inverting configuration for valueMapper - inputValue could not be resolved for record " + key + ": ", transformSpec);
            }
            outOption.outputValue = fluid.model.transform.literaliseValue(origInputValue);
            var origOutputValue = def(option.outputValue, transformSpec.defaultOutputValue);
            outOption.inputValue = fluid.model.transform.getValue(option.outputValuePath, origOutputValue, transformer);
            if (anyCustomOutput) {
                outOption.inputPath = fluid.model.composePaths(transformer.outputPrefix, def(option.outputPath, transformSpec.outputPath));
            }
            if (anyCustomInput) {
                outOption.outputPath = fluid.model.composePaths(transformer.inputPrefix, def(option.inputPath, transformSpec.inputPath));
            }
            if (option.outputValuePath) {
                outOption.inputValuePath = option.outputValuePath;
            }
            options.push(outOption);
        });
        return togo;
    };

    fluid.transforms.valueMapper.collect = function (transformSpec, transformer) {
        var togo = [];
        fluid.model.transform.accumulateInputPath(transformSpec.inputPath, transformer, togo);
        fluid.each(transformSpec.options, function (option) {
            fluid.model.transform.accumulateInputPath(option.inputPath, transformer, togo);
        });
        return togo;
    };

    /* -------- arrayToSetMembership and setMembershipToArray ---------------- */

    fluid.defaults("fluid.transforms.arrayToSetMembership", {
        gradeNames: ["fluid.standardInputTransformFunction", "fluid.lens"],
        invertConfiguration: "fluid.transforms.arrayToSetMembership.invert"
    });


    fluid.transforms.arrayToSetMembership = function (value, transformSpec, transformer) {
        var options = transformSpec.options;

        if (!value || !fluid.isArrayable(value)) {
            fluid.fail("arrayToSetMembership didn't find array at inputPath nor passed as value.", transformSpec);
        }
        if (!options) {
            fluid.fail("arrayToSetMembership requires an options block set");
        }

        if (transformSpec.presentValue === undefined) {
            transformSpec.presentValue = true;
        }

        if (transformSpec.missingValue === undefined) {
            transformSpec.missingValue = false;
        }

        fluid.each(options, function (outPath, key) {
            // write to output path given in options the value <presentValue> or <missingValue> depending on whether key is found in user input
            var outVal = ($.inArray(key, value) !== -1) ? transformSpec.presentValue : transformSpec.missingValue;
            fluid.model.transform.setValue(outPath, outVal, transformer);
        });
        // TODO: Why does this transform make no return?
    };

    fluid.transforms.arrayToSetMembership.invert = function (transformSpec, transformer) {
        var togo = fluid.copy(transformSpec);
        delete togo.inputPath;
        togo.type = "fluid.transforms.setMembershipToArray";
        togo.outputPath = fluid.model.composePaths(transformer.inputPrefix, transformSpec.inputPath);
        var newOptions = {};
        fluid.each(transformSpec.options, function (path, oldKey) {
            var newKey = fluid.model.composePaths(transformer.outputPrefix, path);
            newOptions[newKey] = oldKey;
        });
        togo.options = newOptions;
        return togo;
    };

    fluid.defaults("fluid.transforms.setMembershipToArray", {
        gradeNames: ["fluid.standardOutputTransformFunction"]
    });

    fluid.transforms.setMembershipToArray = function (transformSpec, transformer) {
        var options = transformSpec.options;

        if (!options) {
            fluid.fail("setMembershipToArray requires an options block specified");
        }

        if (transformSpec.presentValue === undefined) {
            transformSpec.presentValue = true;
        }

        if (transformSpec.missingValue === undefined) {
            transformSpec.missingValue = false;
        }

        var outputArr = [];
        fluid.each(options, function (arrVal, inPath) {
            var val = fluid.model.transform.getValue(inPath, undefined, transformer);
            if (val === transformSpec.presentValue) {
                outputArr.push(arrVal);
            }
        });
        return outputArr;
    };

    /* -------- objectToArray and arrayToObject -------------------- */

    /**
     * Transforms the given array to an object.
     * Uses the transformSpec.options.key values from each object within the array as new keys.
     *
     * For example, with transformSpec.key = "name" and an input object like this:
     *
     * {
     *   b: [
     *     { name: b1, v: v1 },
     *     { name: b2, v: v2 }
     *   ]
     * }
     *
     * The output will be:
     * {
     *   b: {
     *     b1: {
     *       v: v1
     *     }
     *   },
     *   {
     *     b2: {
     *       v: v2
     *     }
     *   }
     * }
     */
    fluid.model.transform.applyPaths = function (operation, pathOp, paths) {
        for (var i = 0; i < paths.length; ++i) {
            if (operation === "push") {
                pathOp.push(paths[i]);
            } else {
                pathOp.pop();
            }
        }
    };

    fluid.model.transform.expandInnerValues = function (inputPath, outputPath, transformer, innerValues) {
        var inputPrefixOp = transformer.inputPrefixOp;
        var outputPrefixOp = transformer.outputPrefixOp;
        var apply = fluid.model.transform.applyPaths;

        apply("push", inputPrefixOp, inputPath);
        apply("push", outputPrefixOp, outputPath);
        var expanded = {};
        fluid.each(innerValues, function (innerValue) {
            var expandedInner = transformer.expand(innerValue);
            if (!fluid.isPrimitive(expandedInner)) {
                $.extend(true, expanded, expandedInner);
            } else {
                expanded = expandedInner;
            }
        });
        apply("pop", outputPrefixOp, outputPath);
        apply("pop", inputPrefixOp, inputPath);

        return expanded;
    };


    fluid.defaults("fluid.transforms.arrayToObject", {
        gradeNames: ["fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.arrayToObject.invert"
    });

    fluid.transforms.arrayToObject = function (arr, transformSpec, transformer) {
        if (transformSpec.key === undefined) {
            fluid.fail("arrayToObject requires a 'key' option.", transformSpec);
        }
        if (!fluid.isArrayable(arr)) {
            fluid.fail("arrayToObject didn't find array at inputPath.", transformSpec);
        }
        var newHash = {};
        var pivot = transformSpec.key;

        fluid.each(arr, function (v, k) {
            // check that we have a pivot entry in the object and it's a valid type:
            var newKey = v[pivot];
            var keyType = typeof(newKey);
            if (keyType !== "string" && keyType !== "boolean" && keyType !== "number") {
                fluid.fail("arrayToObject encountered untransformable array due to missing or invalid key", v);
            }
            // use the value of the key element as key and use the remaining content as value
            var content = fluid.copy(v);
            delete content[pivot];
            // fix sub Arrays if needed:
            if (transformSpec.innerValue) {
                content = fluid.model.transform.expandInnerValues([transformer.inputPrefix, transformSpec.inputPath, k.toString()],
                    [newKey], transformer, transformSpec.innerValue);
            }
            newHash[newKey] = content;
        });
        return newHash;
    };

    fluid.transforms.arrayToObject.invert = function (transformSpec, transformer) {
        var togo = fluid.copy(transformSpec);
        togo.type = "fluid.transforms.objectToArray";
        togo.inputPath = fluid.model.composePaths(transformer.outputPrefix, transformSpec.outputPath);
        togo.outputPath = fluid.model.composePaths(transformer.inputPrefix, transformSpec.inputPath);
        // invert transforms from innerValue as well:
        // TODO: The Model Transformations framework should be capable of this, but right now the
        // issue is that we use a "private contract" to operate the "innerValue" slot. We need to
        // spend time thinking of how this should be formalised
        if (togo.innerValue) {
            var innerValue = togo.innerValue;
            for (var i = 0; i < innerValue.length; ++i) {
                innerValue[i] = fluid.model.transform.invertConfiguration(innerValue[i]);
            }
        }
        return togo;
    };


    fluid.defaults("fluid.transforms.objectToArray", {
        gradeNames: "fluid.standardTransformFunction"
    });

    /**
     * Transforms an object into array of objects.
     * This performs the inverse transform of fluid.transforms.arrayToObject.
     */
    fluid.transforms.objectToArray = function (hash, transformSpec, transformer) {
        if (transformSpec.key === undefined) {
            fluid.fail("objectToArray requires a 'key' option.", transformSpec);
        }

        var newArray = [];
        var pivot = transformSpec.key;

        fluid.each(hash, function (v, k) {
            var content = {};
            content[pivot] = k;
            if (transformSpec.innerValue) {
                v = fluid.model.transform.expandInnerValues([transformSpec.inputPath, k], [transformSpec.outputPath, newArray.length.toString()],
                    transformer, transformSpec.innerValue);
            }
            $.extend(true, content, v);
            newArray.push(content);
        });
        return newArray;
    };

    fluid.defaults("fluid.transforms.limitRange", {
        gradeNames: "fluid.standardTransformFunction"
    });

    fluid.transforms.limitRange = function (value, transformSpec) {
        var min = transformSpec.min;
        if (min !== undefined) {
            var excludeMin = transformSpec.excludeMin || 0;
            min += excludeMin;
            if (value < min) {
                value = min;
            }
        }
        var max = transformSpec.max;
        if (max !== undefined) {
            var excludeMax = transformSpec.excludeMax || 0;
            max -= excludeMax;
            if (value > max) {
                value = max;
            }
        }
        return value;
    };

    fluid.defaults("fluid.transforms.free", {
        gradeNames: "fluid.transformFunction"
    });

    fluid.transforms.free = function (transformSpec) {
        var args = fluid.makeArray(transformSpec.args);
        return fluid.invokeGlobalFunction(transformSpec.func, args);
    };

})(jQuery, fluid_2_0);
;/*
Copyright 2010-2011 Lucendo Development Ltd.
Copyright 2010-2011 OCAD University

Licensed under the Educational Community License (ECL), Version 2.0 or the New
BSD license. You may not use this file except in compliance with one these
Licenses.

You may obtain a copy of the ECL 2.0 License and BSD License at
https://github.com/fluid-project/infusion/raw/master/Infusion-LICENSE.txt
*/

/** This file contains functions which depend on the presence of a DOM document
 *  and which depend on the contents of Fluid.js **/

var fluid_2_0 = fluid_2_0 || {};

(function ($, fluid) {
    "use strict";

    // The base grade for fluid.viewComponent and fluid.viewRelayComponent - will be removed again once the old ChangeApplier is eliminated
    fluid.defaults("fluid.commonViewComponent", {
        gradeNames: ["fluid.littleComponent", "autoInit"],
        initFunction: "fluid.initView",
        argumentMap: {
            container: 0,
            options: 1
        },
        members: { // Used to allow early access to DOM binder via IoC, but to also avoid triggering evaluation of selectors
            dom: "@expand:fluid.initDomBinder({that}, {that}.options.selectors)"
        }
    });

    fluid.defaults("fluid.viewComponent", {
        gradeNames: ["fluid.commonViewComponent", "fluid.standardComponent", "autoInit"]
    });

    // a version of the standard grade fluid.viewComponent that uses the new FLUID-5024 ChangeApplier and model relay system - this will be the default
    // in Fluid 2.0 and be renamed back to fluid.viewComponent
    fluid.defaults("fluid.viewRelayComponent", {
        gradeNames: ["fluid.commonViewComponent", "fluid.standardRelayComponent", "autoInit"]
    });

    // unsupported, NON-API function
    fluid.dumpSelector = function (selectable) {
        return typeof (selectable) === "string" ? selectable :
            selectable.selector ? selectable.selector : "";
    };

    // unsupported, NON-API function
    // NOTE: this function represents a temporary strategy until we have more integrated IoC debugging.
    // It preserves the current framework behaviour for the 1.4 release, but provides a more informative
    // diagnostic - in fact, it is perfectly acceptable for a component's creator to return no value and
    // the failure is really in assumptions in fluid.initComponent. Revisit this issue for 1.5
    fluid.diagnoseFailedView = function (componentName, that, options, args) {
        if (!that && (fluid.hasGrade(options, "fluid.viewComponent") || fluid.hasGrade(options, "fluid.viewRelayComponent"))) {
            var container = fluid.wrap(args[1]);
            var message1 = "Instantiation of autoInit component with type " + componentName + " failed, since ";
            if (!container) {
                fluid.fail(message1 + " container argument is empty");
            }
            else if (container.length === 0) {
                fluid.fail(message1 + "selector \"", fluid.dumpSelector(args[1]), "\" did not match any markup in the document");
            } else {
                fluid.fail(message1 + " component creator function did not return a value");
            }
        }
    };

    fluid.checkTryCatchParameter = function () {
        var location = window.location || { search: "", protocol: "file:" };
        var GETparams = location.search.slice(1).split("&");
        return fluid.find(GETparams, function (param) {
            if (param.indexOf("notrycatch") === 0) {
                return true;
            }
        }) === true;
    };

    fluid.notrycatch = fluid.checkTryCatchParameter();


    /**
     * Wraps an object in a jQuery if it isn't already one. This function is useful since
     * it ensures to wrap a null or otherwise falsy argument to itself, rather than the
     * often unhelpful jQuery default of returning the overall document node.
     *
     * @param {Object} obj the object to wrap in a jQuery
     * @param {jQuery} userJQuery the jQuery object to use for the wrapping, optional - use the current jQuery if absent
     */
    fluid.wrap = function (obj, userJQuery) {
        userJQuery = userJQuery || $;
        return ((!obj || obj.jquery) ? obj : userJQuery(obj));
    };

    /**
     * If obj is a jQuery, this function will return the first DOM element within it. Otherwise, the object will be returned unchanged.
     *
     * @param {jQuery} obj the jQuery instance to unwrap into a pure DOM element
     */
    fluid.unwrap = function (obj) {
        return obj && obj.jquery && obj.length === 1 ? obj[0] : obj;
    };

    /**
     * Fetches a single container element and returns it as a jQuery.
     *
     * @param {String||jQuery||element} containerSpec an id string, a single-element jQuery, or a DOM element specifying a unique container
     * @param {Boolean} fallible <code>true</code> if an empty container is to be reported as a valid condition
     * @return a single-element jQuery of container
     */
    fluid.container = function (containerSpec, fallible, userJQuery) {
        if (userJQuery) {
            containerSpec = fluid.unwrap(containerSpec);
        }
        var container = fluid.wrap(containerSpec, userJQuery);
        if (fallible && (!container || container.length === 0)) {
            return null;
        }

        if (!container || !container.jquery || container.length !== 1) {
            if (typeof (containerSpec) !== "string") {
                containerSpec = container.selector;
            }
            var count = container.length !== undefined ? container.length : 0;
            fluid.fail((count > 1 ? "More than one (" + count + ") container elements were"
                    : "No container element was") + " found for selector " + containerSpec);
        }
        if (!fluid.isDOMNode(container[0])) {
            fluid.fail("fluid.container was supplied a non-jQueryable element");
        }

        return container;
    };

    /**
     * Creates a new DOM Binder instance, used to locate elements in the DOM by name.
     *
     * @param {Object} container the root element in which to locate named elements
     * @param {Object} selectors a collection of named jQuery selectors
     */
    fluid.createDomBinder = function (container, selectors) {
        // don't put on a typename to avoid confusing primitive visitComponentChildren
        var cache = {}, that = {id: fluid.allocateGuid()};
        var userJQuery = container.constructor;

        function cacheKey(name, thisContainer) {
            return fluid.allocateSimpleId(thisContainer) + "-" + name;
        }

        function record(name, thisContainer, result) {
            cache[cacheKey(name, thisContainer)] = result;
        }

        that.locate = function (name, localContainer) {
            var selector, thisContainer, togo;

            selector = selectors[name];
            thisContainer = localContainer ? localContainer : container;
            if (!thisContainer) {
                fluid.fail("DOM binder invoked for selector " + name + " without container");
            }

            if (!selector) {
                return thisContainer;
            }

            if (typeof (selector) === "function") {
                togo = userJQuery(selector.call(null, fluid.unwrap(thisContainer)));
            } else {
                togo = userJQuery(selector, thisContainer);
            }
            if (togo.get(0) === document) {
                togo = [];
            }
            if (!togo.selector) {
                togo.selector = selector;
                togo.context = thisContainer;
            }
            togo.selectorName = name;
            record(name, thisContainer, togo);
            return togo;
        };
        that.fastLocate = function (name, localContainer) {
            var thisContainer = localContainer ? localContainer : container;
            var key = cacheKey(name, thisContainer);
            var togo = cache[key];
            return togo ? togo : that.locate(name, localContainer);
        };
        that.clear = function () {
            cache = {};
        };
        that.refresh = function (names, localContainer) {
            var thisContainer = localContainer ? localContainer : container;
            if (typeof names === "string") {
                names = [names];
            }
            if (thisContainer.length === undefined) {
                thisContainer = [thisContainer];
            }
            for (var i = 0; i < names.length; ++i) {
                for (var j = 0; j < thisContainer.length; ++j) {
                    that.locate(names[i], thisContainer[j]);
                }
            }
        };
        that.resolvePathSegment = that.locate;

        return that;
    };

    /** Expect that jQuery selector query has resulted in a non-empty set of
     * results. If none are found, this function will fail with a diagnostic message,
     * with the supplied message prepended.
     */
    fluid.expectFilledSelector = function (result, message) {
        if (result && result.length === 0 && result.jquery) {
            fluid.fail(message + ": selector \"" + result.selector + "\" with name " + result.selectorName +
                       " returned no results in context " + fluid.dumpEl(result.context));
        }
    };

    /**
     * The central initialiation method called as the first act of every Fluid
     * component. This function automatically merges user options with defaults,
     * attaches a DOM Binder to the instance, and configures events.
     *
     * @param {String} componentName The unique "name" of the component, which will be used
     * to fetch the default options from store. By recommendation, this should be the global
     * name of the component's creator function.
     * @param {jQueryable} container A specifier for the single root "container node" in the
     * DOM which will house all the markup for this component.
     * @param {Object} userOptions The configuration options for this component.
     */
     // 4th argument is NOT SUPPORTED, see comments for initLittleComponent
    fluid.initView = function (componentName, containerSpec, userOptions, localOptions) {
        var container = fluid.container(containerSpec, true);
        fluid.expectFilledSelector(container, "Error instantiating component with name \"" + componentName);
        if (!container) {
            return null;
        }
        // Need to ensure container is set early, without relying on an IoC mechanism - rethink this with asynchrony
        var receiver = function (that) {
            that.container = container;
        };
        var that = fluid.initLittleComponent(componentName, userOptions, localOptions || {gradeNames: ["fluid.viewComponent"]}, receiver);

        if (!that.dom) {
            fluid.initDomBinder(that);
        }
        // TODO: cannot afford a mutable container - put this into proper workflow
        var userJQuery = that.options.jQuery; // Do it a second time to correct for jQuery injection
        // if (userJQuery) {
        //    container = fluid.container(containerSpec, true, userJQuery);
        // }
        fluid.log("Constructing view component " + componentName + " with container " + container.constructor.expando +
            (userJQuery ? " user jQuery " + userJQuery.expando : "") + " env: " + $.expando);

        return that;
    };

    /**
     * Creates a new DOM Binder instance for the specified component and mixes it in.
     *
     * @param {Object} that the component instance to attach the new DOM Binder to
     */
    fluid.initDomBinder = function (that, selectors) {
        that.dom = fluid.createDomBinder(that.container, selectors || that.options.selectors || {});
        that.locate = that.dom.locate;
        return that.dom;
    };

    // DOM Utilities.

    /**
     * Finds the nearest ancestor of the element that passes the test
     * @param {Element} element DOM element
     * @param {Function} test A function which takes an element as a parameter and return true or false for some test
     */
    fluid.findAncestor = function (element, test) {
        element = fluid.unwrap(element);
        while (element) {
            if (test(element)) {
                return element;
            }
            element = element.parentNode;
        }
    };

    fluid.findForm = function (node) {
        return fluid.findAncestor(node, function (element) {
            return element.nodeName.toLowerCase() === "form";
        });
    };

    /** A utility with the same signature as jQuery.text and jQuery.html, but without the API irregularity
     * that treats a single argument of undefined as different to no arguments */
    // in jQuery 1.7.1, jQuery pulled the same dumb trick with $.text() that they did with $.val() previously,
    // see comment in fluid.value below
    fluid.each(["text", "html"], function (method) {
        fluid[method] = function (node, newValue) {
            node = $(node);
            return newValue === undefined ? node[method]() : node[method](newValue);
        };
    });

    /** A generalisation of jQuery.val to correctly handle the case of acquiring and
     * setting the value of clustered radio button/checkbox sets, potentially, given
     * a node corresponding to just one element.
     */
    fluid.value = function (nodeIn, newValue) {
        var node = fluid.unwrap(nodeIn);
        var multiple = false;
        if (node.nodeType === undefined && node.length > 1) {
            node = node[0];
            multiple = true;
        }
        if ("input" !== node.nodeName.toLowerCase() || !/radio|checkbox/.test(node.type)) {
            // resist changes to contract of jQuery.val() in jQuery 1.5.1 (see FLUID-4113)
            return newValue === undefined ? $(node).val() : $(node).val(newValue);
        }
        var name = node.name;
        if (name === undefined) {
            fluid.fail("Cannot acquire value from node " + fluid.dumpEl(node) + " which does not have name attribute set");
        }
        var elements;
        if (multiple) {
            elements = nodeIn;
        } else {
            elements = node.ownerDocument.getElementsByName(name);
            var scope = fluid.findForm(node);
            elements = $.grep(elements, function (element) {
                if (element.name !== name) {
                    return false;
                }
                return !scope || fluid.dom.isContainer(scope, element);
            });
        }
        if (newValue !== undefined) {
            if (typeof(newValue) === "boolean") {
                newValue = (newValue ? "true" : "false");
            }
          // jQuery gets this partially right, but when dealing with radio button array will
          // set all of their values to "newValue" rather than setting the checked property
          // of the corresponding control.
            $.each(elements, function () {
                this.checked = (newValue instanceof Array ?
                    $.inArray(this.value, newValue) !== -1 : newValue === this.value);
            });
        } else { // this part jQuery will not do - extracting value from <input> array
            var checked = $.map(elements, function (element) {
                return element.checked ? element.value : null;
            });
            return node.type === "radio" ? checked[0] : checked;
        }
    };


    fluid.BINDING_ROOT_KEY = "fluid-binding-root";

    /** Recursively find any data stored under a given name from a node upwards
     * in its DOM hierarchy **/

    fluid.findData = function (elem, name) {
        while (elem) {
            var data = $.data(elem, name);
            if (data) {
                return data;
            }
            elem = elem.parentNode;
        }
    };

    fluid.bindFossils = function (node, data, fossils) {
        $.data(node, fluid.BINDING_ROOT_KEY, {data: data, fossils: fossils});
    };

    fluid.boundPathForNode = function (node, fossils) {
        node = fluid.unwrap(node);
        var key = node.name || node.id;
        var record = fossils[key];
        return record ? record.EL : null;
    };

   /** "Automatically" apply to whatever part of the data model is
     * relevant, the changed value received at the given DOM node*/
    fluid.applyBoundChange = function (node, newValue, applier) {
        node = fluid.unwrap(node);
        if (newValue === undefined) {
            newValue = fluid.value(node);
        }
        if (node.nodeType === undefined && node.length > 0) {
            node = node[0];
        } // assume here that they share name and parent
        var root = fluid.findData(node, fluid.BINDING_ROOT_KEY);
        if (!root) {
            fluid.fail("Bound data could not be discovered in any node above " + fluid.dumpEl(node));
        }
        var name = node.name;
        var fossil = root.fossils[name];
        if (!fossil) {
            fluid.fail("No fossil discovered for name " + name + " in fossil record above " + fluid.dumpEl(node));
        }
        if (typeof(fossil.oldvalue) === "boolean") { // deal with the case of an "isolated checkbox"
            newValue = newValue[0] ? true : false;
        }
        var EL = root.fossils[name].EL;
        if (applier) {
            applier.fireChangeRequest({path: EL, value: newValue, source: "DOM:" + node.id});
        } else {
            fluid.set(root.data, EL, newValue);
        }
    };


    /**
     * Returns a jQuery object given the id of a DOM node. In the case the element
     * is not found, will return an empty list.
     */
    fluid.jById = function (id, dokkument) {
        dokkument = dokkument && dokkument.nodeType === 9 ? dokkument : document;
        var element = fluid.byId(id, dokkument);
        var togo = element ? $(element) : [];
        togo.selector = "#" + id;
        togo.context = dokkument;
        return togo;
    };

    /**
     * Returns an DOM element quickly, given an id
     *
     * @param {Object} id the id of the DOM node to find
     * @param {Document} dokkument the document in which it is to be found (if left empty, use the current document)
     * @return The DOM element with this id, or null, if none exists in the document.
     */
    fluid.byId = function (id, dokkument) {
        dokkument = dokkument && dokkument.nodeType === 9 ? dokkument : document;
        var el = dokkument.getElementById(id);
        if (el) {
        // Use element id property here rather than attribute, to work around FLUID-3953
            if (el.id !== id) {
                fluid.fail("Problem in document structure - picked up element " +
                    fluid.dumpEl(el) + " for id " + id +
                    " without this id - most likely the element has a name which conflicts with this id");
            }
            return el;
        } else {
            return null;
        }
    };

    /**
     * Returns the id attribute from a jQuery or pure DOM element.
     *
     * @param {jQuery||Element} element the element to return the id attribute for
     */
    fluid.getId = function (element) {
        return fluid.unwrap(element).id;
    };

    /**
     * Allocate an id to the supplied element if it has none already, by a simple
     * scheme resulting in ids "fluid-id-nnnn" where nnnn is an increasing integer.
     */

    fluid.allocateSimpleId = function (element) {
        var simpleId = "fluid-id-" + fluid.allocateGuid();
        if (!element || fluid.isPrimitive(element)) {
            return simpleId;
        }
        element = fluid.unwrap(element);
        if (!element.id) {
            element.id = simpleId;
        }
        return element.id;
    };

    fluid.defaults("fluid.ariaLabeller", {
        gradeNames: ["fluid.viewComponent", "autoInit"],
        labelAttribute: "aria-label",
        liveRegionMarkup: "<div class=\"liveRegion fl-hidden-accessible\" aria-live=\"polite\"></div>",
        liveRegionId: "fluid-ariaLabeller-liveRegion",
        invokers: {
            generateLiveElement: {
                funcName: "fluid.ariaLabeller.generateLiveElement",
                args: "{that}"
            },
            update: {
                funcName: "fluid.ariaLabeller.update",
                args: ["{that}", "{arguments}.0"]
            }
        },
        listeners: {
            onCreate: {
                func: "{that}.update",
                args: [null]
            }
        }
    });
    
    fluid.ariaLabeller.update = function (that, newOptions) {
        newOptions = newOptions || that.options;
        that.container.attr(that.options.labelAttribute, newOptions.text);
        if (newOptions.dynamicLabel) {
            var live = fluid.jById(that.options.liveRegionId);
            if (live.length === 0) {
                live = that.generateLiveElement();
            }
            live.text(newOptions.text);
        }
    };

    fluid.ariaLabeller.generateLiveElement = function (that) {
        var liveEl = $(that.options.liveRegionMarkup);
        liveEl.prop("id", that.options.liveRegionId);
        $("body").append(liveEl);
        return liveEl;
    };

    var LABEL_KEY = "aria-labelling";

    fluid.getAriaLabeller = function (element) {
        element = $(element);
        var that = fluid.getScopedData(element, LABEL_KEY);
        return that;
    };

    /** Manages an ARIA-mediated label attached to a given DOM element. An
     * aria-labelledby attribute and target node is fabricated in the document
     * if they do not exist already, and a "little component" is returned exposing a method
     * "update" that allows the text to be updated. */

    fluid.updateAriaLabel = function (element, text, options) {
        options = $.extend({}, options || {}, {text: text});
        var that = fluid.getAriaLabeller(element);
        if (!that) {
            that = fluid.ariaLabeller(element, options);
            fluid.setScopedData(element, LABEL_KEY, that);
        } else {
            that.update(options);
        }
        return that;
    };

    /** "Global Dismissal Handler" for the entire page. Attaches a click handler to the
     * document root that will cause dismissal of any elements (typically dialogs) which
     * have registered themselves. Dismissal through this route will automatically clean up
     * the record - however, the dismisser themselves must take care to deregister in the case
     * dismissal is triggered through the dialog interface itself. This component can also be
     * automatically configured by fluid.deadMansBlur by means of the "cancelByDefault" option */

    var dismissList = {};

    $(document).click(function (event) {
        var target = fluid.resolveEventTarget(event);
        while (target) {
            if (dismissList[target.id]) {
                return;
            }
            target = target.parentNode;
        }
        fluid.each(dismissList, function (dismissFunc, key) {
            dismissFunc(event);
            delete dismissList[key];
        });
    });
    // TODO: extend a configurable equivalent of the above dealing with "focusin" events

    /** Accepts a free hash of nodes and an optional "dismissal function".
     * If dismissFunc is set, this "arms" the dismissal system, such that when a click
     * is received OUTSIDE any of the hierarchy covered by "nodes", the dismissal function
     * will be executed.
     */
    fluid.globalDismissal = function (nodes, dismissFunc) {
        fluid.each(nodes, function (node) {
          // Don't bother to use the real id if it is from a foreign document - we will never receive events
          // from it directly in any case - and foreign documents may be under the control of malign fiends
          // such as tinyMCE who allocate the same id to everything
            var id = fluid.unwrap(node).ownerDocument === document? fluid.allocateSimpleId(node) : fluid.allocateGuid();
            if (dismissFunc) {
                dismissList[id] = dismissFunc;
            }
            else {
                delete dismissList[id];
            }
        });
    };

    /** Provides an abstraction for determing the current time.
     * This is to provide a fix for FLUID-4762, where IE6 - IE8
     * do not support Date.now().
     */
    fluid.now = function () {
        return Date.now ? Date.now() : (new Date()).getTime();
    };


    /** Sets an interation on a target control, which morally manages a "blur" for
     * a possibly composite region.
     * A timed blur listener is set on the control, which waits for a short period of
     * time (options.delay, defaults to 150ms) to discover whether the reason for the
     * blur interaction is that either a focus or click is being serviced on a nominated
     * set of "exclusions" (options.exclusions, a free hash of elements or jQueries).
     * If no such event is received within the window, options.handler will be called
     * with the argument "control", to service whatever interaction is required of the
     * blur.
     */

    fluid.deadMansBlur = function (control, options) {
        // TODO: This should be rewritten as a proper component
        var that = {options: $.extend(true, {}, fluid.defaults("fluid.deadMansBlur"), options)};
        that.blurPending = false;
        that.lastCancel = 0;
        that.canceller = function (event) {
            fluid.log("Cancellation through " + event.type + " on " + fluid.dumpEl(event.target));
            that.lastCancel = fluid.now();
            that.blurPending = false;
        };
        that.noteProceeded = function () {
            fluid.globalDismissal(that.options.exclusions);
        };
        that.reArm = function () {
            fluid.globalDismissal(that.options.exclusions, that.proceed);
        };
        that.addExclusion = function (exclusions) {
            fluid.globalDismissal(exclusions, that.proceed);
        };
        that.proceed = function (event) {
            fluid.log("Direct proceed through " + event.type + " on " + fluid.dumpEl(event.target));
            that.blurPending = false;
            that.options.handler(control);
        };
        fluid.each(that.options.exclusions, function (exclusion) {
            exclusion = $(exclusion);
            fluid.each(exclusion, function (excludeEl) {
                $(excludeEl).bind("focusin", that.canceller).
                    bind("fluid-focus", that.canceller).
                    click(that.canceller).mousedown(that.canceller);
    // Mousedown is added for FLUID-4212, as a result of Chrome bug 6759, 14204
            });
        });
        if (!that.options.cancelByDefault) {
            $(control).bind("focusout", function (event) {
                fluid.log("Starting blur timer for element " + fluid.dumpEl(event.target));
                var now = fluid.now();
                fluid.log("back delay: " + (now - that.lastCancel));
                if (now - that.lastCancel > that.options.backDelay) {
                    that.blurPending = true;
                }
                setTimeout(function () {
                    if (that.blurPending) {
                        that.options.handler(control);
                    }
                }, that.options.delay);
            });
        }
        else {
            that.reArm();
        }
        return that;
    };

    fluid.defaults("fluid.deadMansBlur", {
        delay: 150,
        backDelay: 100
    });

})(jQuery, fluid_2_0);
;/*
Copyright 2010-2011 OCAD University
Copyright 2010-2011 Lucendo Development Ltd.

Licensed under the Educational Community License (ECL), Version 2.0 or the New
BSD license. You may not use this file except in compliance with one these
Licenses.

You may obtain a copy of the ECL 2.0 License and BSD License at
https://github.com/fluid-project/infusion/raw/master/Infusion-LICENSE.txt
*/

var fluid_2_0 = fluid_2_0 || {};

(function ($, fluid) {
    "use strict";

    /** Framework-global caching state for fluid.fetchResources **/

    var resourceCache = {};

    var pendingClass = {};

    /** Accepts a hash of structures with free keys, where each entry has either
     * href/url or nodeId set - on completion, callback will be called with the populated
     * structure with fetched resource text in the field "resourceText" for each
     * entry. Each structure may contain "options" holding raw options to be forwarded
     * to jQuery.ajax().
     */

    fluid.fetchResources = function(resourceSpecs, callback, options) {
        var that = fluid.initLittleComponent("fluid.fetchResources", options);
        that.resourceSpecs = resourceSpecs;
        that.callback = callback;
        that.operate = function() {
            fluid.fetchResources.fetchResourcesImpl(that);
        };
        fluid.each(resourceSpecs, function(resourceSpec, key) {
            resourceSpec.recurseFirer = fluid.makeEventFirer({name: "I/O completion for resource \"" + key + "\""});
            resourceSpec.recurseFirer.addListener(that.operate);
            if (resourceSpec.url && !resourceSpec.href) {
                resourceSpec.href = resourceSpec.url;
            }
        });
        if (that.options.amalgamateClasses) {
            fluid.fetchResources.amalgamateClasses(resourceSpecs, that.options.amalgamateClasses, that.operate);
        }
        that.operate();
        return that;
    };

    /*
     * This function is unsupported: It is not really intended for use by implementors.
     */
    // Add "synthetic" elements of *this* resourceSpec list corresponding to any
    // still pending elements matching the PROLEPTICK CLASS SPECIFICATION supplied
    fluid.fetchResources.amalgamateClasses = function(specs, classes, operator) {
        fluid.each(classes, function(clazz) {
            var pending = pendingClass[clazz];
            fluid.each(pending, function(pendingrec, canon) {
                specs[clazz+"!"+canon] = pendingrec;
                pendingrec.recurseFirer.addListener(operator);
            });
        });
    };

    /*
     * This function is unsupported: It is not really intended for use by implementors.
     */
    fluid.fetchResources.timeSuccessCallback = function(resourceSpec) {
        if (resourceSpec.timeSuccess && resourceSpec.options && resourceSpec.options.success) {
            var success = resourceSpec.options.success;
            resourceSpec.options.success = function() {
                var startTime = new Date();
                var ret = success.apply(null, arguments);
                fluid.log("External callback for URL " + resourceSpec.href + " completed - callback time: " +
                        (new Date().getTime() - startTime.getTime()) + "ms");
                return ret;
            };
        }
    };

    // TODO: Integrate punch-through from old Engage implementation
    function canonUrl(url) {
        return url;
    }

    fluid.fetchResources.clearResourceCache = function(url) {
        if (url) {
            delete resourceCache[canonUrl(url)];
        }
        else {
            fluid.clear(resourceCache);
        }
    };

    /*
     * This function is unsupported: It is not really intended for use by implementors.
     */
    fluid.fetchResources.handleCachedRequest = function(resourceSpec, response) {
        var canon = canonUrl(resourceSpec.href);
        var cached = resourceCache[canon];
        if (cached.$$firer$$) {
            fluid.log("Handling request for " + canon + " from cache");
            var fetchClass = resourceSpec.fetchClass;
            if (fetchClass && pendingClass[fetchClass]) {
                fluid.log("Clearing pendingClass entry for class " + fetchClass);
                delete pendingClass[fetchClass][canon];
            }
            resourceCache[canon] = response;
            cached.fire(response);
        }
    };

    /*
     * This function is unsupported: It is not really intended for use by implementors.
     */
    fluid.fetchResources.completeRequest = function(thisSpec) {
        thisSpec.queued = false;
        thisSpec.completeTime = new Date();
        fluid.log("Request to URL " + thisSpec.href + " completed - total elapsed time: " +
            (thisSpec.completeTime.getTime() - thisSpec.initTime.getTime()) + "ms");
        thisSpec.recurseFirer.fire();
    };

    /*
     * This function is unsupported: It is not really intended for use by implementors.
     */
    fluid.fetchResources.makeResourceCallback = function(thisSpec) {
        return {
            success: function(response) {
                thisSpec.resourceText = response;
                thisSpec.resourceKey = thisSpec.href;
                if (thisSpec.forceCache) {
                    fluid.fetchResources.handleCachedRequest(thisSpec, response);
                }
                fluid.fetchResources.completeRequest(thisSpec);
            },
            error: function(response, textStatus, errorThrown) {
                thisSpec.fetchError = {
                    status: response.status,
                    textStatus: response.textStatus,
                    errorThrown: errorThrown
                };
                fluid.fetchResources.completeRequest(thisSpec);
            }

        };
    };


    /*
     * This function is unsupported: It is not really intended for use by implementors.
     */
    fluid.fetchResources.issueCachedRequest = function(resourceSpec, options) {
        var canon = canonUrl(resourceSpec.href);
        var cached = resourceCache[canon];
        if (!cached) {
            fluid.log("First request for cached resource with url " + canon);
            cached = fluid.makeEventFirer({name: "cache notifier for resource URL " + canon});
            cached.$$firer$$ = true;
            resourceCache[canon] = cached;
            var fetchClass = resourceSpec.fetchClass;
            if (fetchClass) {
                if (!pendingClass[fetchClass]) {
                    pendingClass[fetchClass] = {};
                }
                pendingClass[fetchClass][canon] = resourceSpec;
            }
            options.cache = false; // TODO: Getting weird "not modified" issues on Firefox
            $.ajax(options);
        }
        else {
            if (!cached.$$firer$$) {
                options.success(cached);
            }
            else {
                fluid.log("Request for cached resource which is in flight: url " + canon);
                cached.addListener(function(response) {
                    options.success(response);
                });
            }
        }
    };

    /*
     * This function is unsupported: It is not really intended for use by implementors.
     */
    // Compose callbacks in such a way that the 2nd, marked "external" will be applied
    // first if it exists, but in all cases, the first, marked internal, will be
    // CALLED WITHOUT FAIL
    fluid.fetchResources.composeCallbacks = function (internal, external) {
        return external ? (internal ?
        function () {
            try {
                external.apply(null, arguments);
            }
            catch (e) {
                fluid.log("Exception applying external fetchResources callback: " + e);
            }
            internal.apply(null, arguments); // call the internal callback without fail
        } : external ) : internal;
    };

    // unsupported, NON-API function
    fluid.fetchResources.composePolicy = function(target, source) {
        return fluid.fetchResources.composeCallbacks(target, source);
    };

    fluid.defaults("fluid.fetchResources.issueRequest", {
        mergePolicy: {
            success: fluid.fetchResources.composePolicy,
            error: fluid.fetchResources.composePolicy,
            url: "reverse"
        }
    });

    // unsupported, NON-API function
    fluid.fetchResources.issueRequest = function(resourceSpec, key) {
        var thisCallback = fluid.fetchResources.makeResourceCallback(resourceSpec);
        var options = {
            url:     resourceSpec.href,
            success: thisCallback.success,
            error:   thisCallback.error,
            dataType: resourceSpec.dataType || "text"
        };
        fluid.fetchResources.timeSuccessCallback(resourceSpec);
        options = fluid.merge(fluid.defaults("fluid.fetchResources.issueRequest").mergePolicy,
                      options, resourceSpec.options);
        resourceSpec.queued = true;
        resourceSpec.initTime = new Date();
        fluid.log("Request with key " + key + " queued for " + resourceSpec.href);

        if (resourceSpec.forceCache) {
            fluid.fetchResources.issueCachedRequest(resourceSpec, options);
        }
        else {
            $.ajax(options);
        }
    };

    fluid.fetchResources.fetchResourcesImpl = function(that) {
        var complete = true;
        var allSync = true;
        var resourceSpecs = that.resourceSpecs;
        for (var key in resourceSpecs) {
            var resourceSpec = resourceSpecs[key];
            if (!resourceSpec.options || resourceSpec.options.async) {
                allSync = false;
            }
            if (resourceSpec.href && !resourceSpec.completeTime) {
                if (!resourceSpec.queued) {
                    fluid.fetchResources.issueRequest(resourceSpec, key);
                }
                if (resourceSpec.queued) {
                    complete = false;
                }
            }
            else if (resourceSpec.nodeId && !resourceSpec.resourceText) {
                var node = document.getElementById(resourceSpec.nodeId);
                // upgrade this to somehow detect whether node is "armoured" somehow
                // with comment or CDATA wrapping
                resourceSpec.resourceText = fluid.dom.getElementText(node);
                resourceSpec.resourceKey = resourceSpec.nodeId;
            }
        }
        if (complete && that.callback && !that.callbackCalled) {
            that.callbackCalled = true;
            if ($.browser.mozilla && !allSync) {
                // Defer this callback to avoid debugging problems on Firefox
                setTimeout(function() {
                    that.callback(resourceSpecs);
                }, 1);
            }
            else {
                that.callback(resourceSpecs);
            }
        }
    };

    // TODO: This framework function is a stop-gap before the "ginger world" is capable of
    // asynchronous instantiation. It currently performs very poor fidelity expansion of a
    // component's options to discover "resources" only held in the static environment
    fluid.fetchResources.primeCacheFromResources = function(componentName) {
        var resources = fluid.defaults(componentName).resources;
        var expanded = (fluid.expandOptions ? fluid.expandOptions : fluid.identity)(fluid.copy(resources));
        fluid.fetchResources(expanded);
    };

    /** Utilities invoking requests for expansion **/
    fluid.registerNamespace("fluid.expander");

    /*
     * This function is unsupported: It is not really intended for use by implementors.
     */
    fluid.expander.makeDefaultFetchOptions = function (successdisposer, failid, options) {
        return $.extend(true, {dataType: "text"}, options, {
            success: function(response, environmentdisposer) {
                var json = JSON.parse(response);
                environmentdisposer(successdisposer(json));
            },
            error: function(response, textStatus) {
                fluid.log("Error fetching " + failid + ": " + textStatus);
            }
        });
    };

    /*
     * This function is unsupported: It is not really intended for use by implementors.
     */
    fluid.expander.makeFetchExpander = function (options) {
        return { expander: {
            type: "fluid.expander.deferredFetcher",
            href: options.url,
            options: fluid.expander.makeDefaultFetchOptions(options.disposer, options.url, options.options),
            resourceSpecCollector: "{resourceSpecCollector}",
            fetchKey: options.fetchKey
        }};
    };

    fluid.expander.deferredFetcher = function(deliverer, source, expandOptions) {
        var expander = source.expander;
        var spec = fluid.copy(expander);
        // fetch the "global" collector specified in the external environment to receive
        // this resourceSpec
        var collector = fluid.expand(expander.resourceSpecCollector, expandOptions);
        delete spec.type;
        delete spec.resourceSpecCollector;
        delete spec.fetchKey;
        var environmentdisposer = function(disposed) {
            deliverer(disposed);
        };
        // replace the callback which is there (taking 2 arguments) with one which
        // directly responds to the request, passing in the result and OUR "disposer" -
        // which once the user has processed the response (say, parsing JSON and repackaging)
        // finally deposits it in the place of the expander in the tree to which this reference
        // has been stored at the point this expander was evaluated.
        spec.options.success = function(response) {
            expander.options.success(response, environmentdisposer);
        };
        var key = expander.fetchKey || fluid.allocateGuid();
        collector[key] = spec;
        return fluid.NO_VALUE;
    };


})(jQuery, fluid_2_0);
;// -*- mode: javascript; tab-width: 2; indent-tabs-mode: nil; -*-

//------------------------------------------------------------------------------
// DSP API - JavaScript shim
//
// Copyright (C) 2012 Marcus Geelnard
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
//------------------------------------------------------------------------------

"use strict";


//------------------------------------------------------------------------------
// interface DSP
//------------------------------------------------------------------------------

(function () {

    var g = typeof (window) !== "undefined" ? window : typeof (self) !== "undefined" ? self : global;

    (function () {
      if (g.DSP) return;

      var DSP = {};

      DSP.add = function (dst, x, y) {
        var k;
        if (y instanceof Float32Array)
          for (k = Math.min(dst.length, x.length, y.length) - 1; k >= 0; --k)
            dst[k] = x[k] + y[k];
        else
          for (k = Math.min(dst.length, x.length) - 1; k >= 0; --k)
            dst[k] = x[k] + y;
      };

      DSP.sub = function (dst, x, y) {
        var k;
        if (y instanceof Float32Array)
          for (k = Math.min(dst.length, x.length, y.length) - 1; k >= 0; --k)
            dst[k] = x[k] - y[k];
        else
          for (k = Math.min(dst.length, x.length) - 1; k >= 0; --k)
            dst[k] = x[k] - y;
      };

      DSP.mul = function (dst, x, y) {
        var k;
        if (y instanceof Float32Array)
          for (k = Math.min(dst.length, x.length, y.length) - 1; k >= 0; --k)
            dst[k] = x[k] * y[k];
        else
          for (k = Math.min(dst.length, x.length) - 1; k >= 0; --k)
            dst[k] = x[k] * y;
      };

      DSP.mulCplx = function (dstReal, dstImag, xReal, xImag, yReal, yImag) {
        var k, xr, xi, yr, yi;
        if (yReal instanceof Float32Array)
          for (k = Math.min(dstReal.length, dstImag.length, xReal.length, xImag.length, yReal.length, yImag.length) - 1; k >= 0; --k) {
            xr = xReal[k], xi = xImag[k], yr = yReal[k], yi = yImag[k];
            dstReal[k] = xr * yr - xi * yi;
            dstImag[k] = xr * yi + xi * yr;
          }
        else
          for (k = Math.min(dstReal.length, dstImag.length, xReal.length, xImag.length) - 1; k >= 0; --k) {
            xr = xReal[k], xi = xImag[k];
            dstReal[k] = xr * yReal - xi * yImag;
            dstImag[k] = xr * yImag + xi * yReal;
          }
      };

      DSP.div = function (dst, x, y) {
        var k;
        if (y instanceof Float32Array)
          for (k = Math.min(dst.length, x.length, y.length) - 1; k >= 0; --k)
            dst[k] = x[k] / y[k];
        else
          for (k = Math.min(dst.length, x.length) - 1; k >= 0; --k)
            dst[k] = x[k] / y;
      };

      DSP.divCplx = function (dstReal, dstImag, xReal, xImag, yReal, yImag) {
        var k, xr, xi, yr, yi, denom;
        if (yReal instanceof Float32Array)
          for (k = Math.min(dstReal.length, dstImag.length, xReal.length, xImag.length, yReal.length, yImag.length) - 1; k >= 0; --k) {
            xr = xReal[k], xi = xImag[k], yr = yReal[k], yi = yImag[k];
            denom = 1 / (yr * yr + yi * yi);
            dstReal[k] = (xr * yr + xi * yi) * denom;
            dstImag[k] = (xi * yr - xr * yi) * denom;
          }
        else {
          denom = 1 / (yReal * yReal + yImag * yImag);
          for (k = Math.min(dstReal.length, dstImag.length, xReal.length, xImag.length) - 1; k >= 0; --k) {
            xr = xReal[k], xi = xImag[k];
            dstReal[k] = (xr * yReal + xi * yImag) * denom;
            dstImag[k] = (xi * yReal - xr * yImag) * denom;
          }
        }
      };

      DSP.madd = function (dst, x, y, z) {
        var k;
        if (z instanceof Float32Array)
          for (k = Math.min(dst.length, x.length, y.length, z.length) - 1; k >= 0; --k)
            dst[k] = x[k] + y[k] * z[k];
        else
          for (k = Math.min(dst.length, x.length) - 1; k >= 0; --k)
            dst[k] = x[k] + y[k] * z;
      };

      DSP.abs = function (dst, x) {
        for (var k = Math.min(dst.length, x.length) - 1; k >= 0; --k)
          dst[k] = Math.abs(x[k]);
      };

      DSP.absCplx = function (dst, real, imag) {
        for (var k = Math.min(dst.length, real.length, imag.length) - 1; k >= 0; --k)
          dst[k] = Math.sqrt(real[k] * real[k] + imag[k] * imag[k]);
      };

      DSP.acos = function (dst, x) {
        for (var k = Math.min(dst.length, x.length) - 1; k >= 0; --k)
          dst[k] = Math.acos(x[k]);
      };

      DSP.asin = function (dst, x) {
        for (var k = Math.min(dst.length, x.length) - 1; k >= 0; --k)
          dst[k] = Math.asin(x[k]);
      };

      DSP.atan = function (dst, x) {
        for (var k = Math.min(dst.length, x.length) - 1; k >= 0; --k)
          dst[k] = Math.atan(x[k]);
      };

      DSP.atan2 = function (dst, y, x) {
        for (var k = Math.min(dst.length, x.length, y.length) - 1; k >= 0; --k)
          dst[k] = Math.atan2(y[k], x[k]);
      };

      DSP.ceil = function (dst, x) {
        for (var k = Math.min(dst.length, x.length) - 1; k >= 0; --k)
          dst[k] = Math.ceil(x[k]);
      };

      DSP.cos = function (dst, x) {
        for (var k = Math.min(dst.length, x.length) - 1; k >= 0; --k)
          dst[k] = Math.cos(x[k]);
      };

      DSP.exp = function (dst, x) {
        for (var k = Math.min(dst.length, x.length) - 1; k >= 0; --k)
          dst[k] = Math.exp(x[k]);
      };

      DSP.floor = function (dst, x) {
        for (var k = Math.min(dst.length, x.length) - 1; k >= 0; --k)
          dst[k] = Math.floor(x[k]);
      };

      DSP.log = function (dst, x) {
        for (var k = Math.min(dst.length, x.length) - 1; k >= 0; --k)
          dst[k] = Math.log(x[k]);
      };

      DSP.max = function (x) {
        var ret = -Infinity;
        for (var k = x.length - 1; k >= 0; --k) {
          var val = x[k];
          if (val > ret)
            ret = val;
        }
        return ret;
      };

      DSP.min = function (x) {
        var ret = Infinity;
        for (var k = x.length - 1; k >= 0; --k) {
          var val = x[k];
          if (val < ret)
            ret = val;
        }
        return ret;
      };

      DSP.pow = function (dst, x, y) {
        var k;
        if (y instanceof Float32Array)
          for (k = Math.min(dst.length, x.length, y.length) - 1; k >= 0; --k)
            dst[k] = Math.pow(x[k], y[k]);
        else {
          // Optimize for special cases
          if (y == 2)
            for (k = Math.min(dst.length, x.length) - 1; k >= 0; --k) {
              var val = x[k];
              dst[k] = val * val;
            }
          else if (y == 3)
            for (k = Math.min(dst.length, x.length) - 1; k >= 0; --k) {
              var val = x[k];
              dst[k] = val * val * val;
            }
          else if (y == 4)
            for (k = Math.min(dst.length, x.length) - 1; k >= 0; --k) {
              var val = x[k];
              val = val * val;
              dst[k] = val * val;
            }
          else if (y == -1)
            for (k = Math.min(dst.length, x.length) - 1; k >= 0; --k)
              dst[k] = 1 / x[k]
          else if (y == -2)
            for (k = Math.min(dst.length, x.length) - 1; k >= 0; --k) {
              var val = 1 / x[k];
              dst[k] = val * val;
            }
          else
            for (k = Math.min(dst.length, x.length) - 1; k >= 0; --k)
              dst[k] = Math.pow(x[k], y);
        }
      };

      DSP.random = function (dst, low, high) {
        if (!low)
          low = 0;
        if (isNaN(parseFloat(high)))
          high = 1;
        var scale = high - low;
        for (var k = dst.length - 1; k >= 0; --k)
          dst[k] = Math.random() * scale + low;
      };

      DSP.round = function (dst, x) {
        for (var k = Math.min(dst.length, x.length) - 1; k >= 0; --k)
          dst[k] = Math.round(x[k]);
      };

      DSP.sin = function (dst, x) {
        for (var k = Math.min(dst.length, x.length) - 1; k >= 0; --k)
          dst[k] = Math.sin(x[k]);
      };

      DSP.sqrt = function (dst, x) {
        for (var k = Math.min(dst.length, x.length) - 1; k >= 0; --k)
          dst[k] = Math.sqrt(x[k]);
      };

      DSP.tan = function (dst, x) {
        for (var k = Math.min(dst.length, x.length) - 1; k >= 0; --k)
          dst[k] = Math.tan(x[k]);
      };

      DSP.clamp = function (dst, x, xMin, xMax) {
        for (var k = Math.min(dst.length, x.length) - 1; k >= 0; --k) {
          var val = x[k];
          dst[k] = val < xMin ? xMin : val > xMax ? xMax : val;
        }
      };

      DSP.fract = function (dst, x) {
        for (var k = Math.min(dst.length, x.length) - 1; k >= 0; --k) {
          var val = x[k];
          dst[k] = val - Math.floor(val);
        }
      };

      DSP.ramp = function (dst, first, last) {
        var maxIdx = dst.length - 1;
        if (maxIdx >= 0)
          dst[0] = first;
        if (maxIdx > 0) {
          var step = (last - first) / maxIdx;
          for (var k = 1; k <= maxIdx; ++k)
            dst[k] = first + step * k;
        }
      };

      DSP.sign = function (dst, x) {
        for (var k = Math.min(dst.length, x.length) - 1; k >= 0; --k)
          dst[k] = x[k] < 0 ? -1 : 1;
      };

      DSP.sum = function (x) {
        var ret = 0;
        for (var k = x.length - 1; k >= 0; --k)
          ret += x[k];
        return ret;
      };

      DSP.sampleLinear = function (dst, x, t, repeat) {
        var xLen = x.length, maxIdx = xLen - 1;
        if (repeat)
          for (var k = Math.min(dst.length, t.length) - 1; k >= 0; --k) {
            var t2 = t[k];
            t2 = t2 - Math.floor(t2/xLen) * xLen;
            var idx = Math.floor(t2);
            var w = t2 - idx;
            var p1 = x[idx];
            var p2 = x[idx < maxIdx ? idx + 1 : 0];
            dst[k] = p1 + w * (p2 - p1);
          }
        else
          for (var k = Math.min(dst.length, t.length) - 1; k >= 0; --k) {
            var t2 = t[k];
            t2 = t2 < 0 ? 0 : t2 > maxIdx ? maxIdx : t2;
            var idx = Math.floor(t2);
            var w = t2 - idx;
            var p1 = x[idx];
            var p2 = x[idx < maxIdx ? idx + 1 : maxIdx];
            dst[k] = p1 + w * (p2 - p1);
          }
      };

      DSP.sampleCubic = function (dst, x, t, repeat) {
        var xLen = x.length, maxIdx = xLen - 1;
        if (repeat)
          for (var k = Math.min(dst.length, t.length) - 1; k >= 0; --k) {
            var t2 = t[k];
            t2 = t2 - Math.floor(t2/xLen) * xLen;
            var idx = Math.floor(t2);
            var w = t2 - idx;
            var w2 = w * w;
            var w3 = w2 * w;
            var h2 = -2*w3 + 3*w2;
            var h1 = 1 - h2;
            var h4 = w3 - w2;
            var h3 = h4 - w2 + w;
            var p1 = x[idx > 0 ? idx - 1 : maxIdx];
            var p2 = x[idx];
            var p3 = x[idx < maxIdx ? idx + 1 : 0];
            var p4 = x[idx < maxIdx - 1 ? idx + 2 : (idx + 2 - Math.floor((idx + 2)/xLen) * xLen)];
            dst[k] = h1 * p2 + h2 * p3 + 0.5 * (h3 * (p3 - p1) + h4 * (p4 - p2));
          }
        else
          for (var k = Math.min(dst.length, t.length) - 1; k >= 0; --k) {
            var t2 = t[k];
            t2 = t2 < 0 ? 0 : t2 > maxIdx ? maxIdx : t2;
            var idx = Math.floor(t2);
            var w = t2 - idx;
            var w2 = w * w;
            var w3 = w2 * w;
            var h2 = -2*w3 + 3*w2;
            var h1 = 1 - h2;
            var h4 = w3 - w2;
            var h3 = h4 - w2 + w;
            var p1 = x[idx > 0 ? idx - 1 :  0];
            var p2 = x[idx];
            var p3 = x[idx < maxIdx ? idx + 1 : maxIdx];
            var p4 = x[idx < maxIdx - 1 ? idx + 2 : maxIdx];
            dst[k] = h1 * p2 + h2 * p3 + 0.5 * (h3 * (p3 - p1) + h4 * (p4 - p2));
          }
      };

      DSP.pack = function (dst, offset, stride, src1, src2, src3, src4) {
        var dstCount = Math.floor((dst.length - offset) / stride);
        var count = Math.min(dstCount, src1.length);
        if (src2)
          if (src3)
            if (src4)
              for (var k = 0; k < count; ++k) {
                dst[offset] = src1[k];
                dst[offset + 1] = src2[k];
                dst[offset + 2] = src3[k];
                dst[offset + 3] = src4[k];
                offset += stride;
              }
            else
              for (var k = 0; k < count; ++k) {
                dst[offset] = src1[k];
                dst[offset + 1] = src2[k];
                dst[offset + 2] = src3[k];
                offset += stride;
              }
          else
            for (var k = 0; k < count; ++k) {
              dst[offset] = src1[k];
              dst[offset + 1] = src2[k];
              offset += stride;
            }
        else
          for (var k = 0; k < count; ++k) {
            dst[offset] = src1[k];
            offset += stride;
          }
      };

      DSP.unpack = function (src, offset, stride, dst1, dst2, dst3, dst4) {
        var srcCount = Math.floor((src.length - offset) / stride);
        var count = Math.min(srcCount, dst1.length);
        if (dst2)
          if (dst3)
            if (dst4)
              for (var k = 0; k < count; ++k) {
                dst1[k] = src[offset];
                dst2[k] = src[offset + 1];
                dst3[k] = src[offset + 2];
                dst4[k] = src[offset + 3];
                offset += stride;
              }
            else
              for (var k = 0; k < count; ++k) {
                dst1[k] = src[offset];
                dst2[k] = src[offset + 1];
                dst3[k] = src[offset + 2];
                offset += stride;
              }
          else
            for (var k = 0; k < count; ++k) {
              dst1[k] = src[offset];
              dst2[k] = src[offset + 1];
              offset += stride;
            }
        else
          for (var k = 0; k < count; ++k) {
            dst1[k] = src[offset];
            offset += stride;
          }
      };

      g.DSP = DSP;
    })();


    //------------------------------------------------------------------------------
    // interface Filter
    //------------------------------------------------------------------------------

    (function () {
      if (g.Filter) return;

      var Filter = function (bSize, aSize) {
        if (isNaN(parseFloat(bSize)) || !isFinite(bSize))
          bSize = 1;
        if (!aSize)
          aSize = 0;
        this.b = new Float32Array(bSize);
        this.b[0] = 1;
        this.a = new Float32Array(aSize);
        this._bHist = new Float32Array(bSize);
        this._aHist = new Float32Array(aSize);
      };

      Filter.prototype.filter = function (dst, x) {
        // Put commonly accessed objects and properties in local variables
        var a = this.a, aLen = a.length,
            b = this.b, bLen = b.length,
            aHist = this._aHist, bHist = this._bHist,
            xLen = x.length, dstLen = dst.length;

        // FIXME: Optimize for long FIR filters

        // Perform run-in part using the history (slow)
        var bHistRunIn = bLen - 1;
        var aHistRunIn = aLen;
        var k;
        for (k = 0; (bHistRunIn || aHistRunIn) && k < xLen; ++k) {
          var m, noHistLen;

          // FIR part
          noHistLen = bLen - bHistRunIn;
          bHistRunIn && bHistRunIn--;
          var res = b[0] * x[k];
          for (m = 1; m < noHistLen; ++m)
            res += b[m] * x[k - m];
          for (; m < bLen; ++m)
            res += b[m] * bHist[m - noHistLen];

          // Recursive part
          noHistLen = aLen - aHistRunIn;
          aHistRunIn && aHistRunIn--;
          for (m = 0; m < noHistLen; ++m)
            res -= a[m] * dst[k - 1 - m];
          for (; m < aLen; ++m)
            res -= a[m] * aHist[m - noHistLen];

          dst[k] = res;
        }

        // Perform history-free part (fast)
        if (bLen == 3 && aLen == 2) {
          // Optimized special case: biquad filter
          var b0 = b[0], b1 = b[1], b2 = b[2], a1 = a[0], a2 = a[1];
          var x0 = x[k-1], x1 = x[k-2], x2;
          var y0 = dst[k-1], y1 = dst[k-2], y2;
          for (; k < xLen; ++k) {
            x2 = x1;
            x1 = x0;
            x0 = x[k];
            y2 = y1;
            y1 = y0;
            y0 = b0 * x0 + b1 * x1 + b2 * x2 - a1 * y1 - a2 * y2;
            dst[k] = y0;
          }
        }
        else {
          // Generic case
          for (; k < xLen; ++k) {
            var m;

            // FIR part
            var res = b[0] * x[k];
            for (m = 1; m < bLen; ++m)
              res += b[m] * x[k - m];

            // Recursive part
            for (m = 0; m < aLen; ++m)
              res -= a[m] * dst[k - 1 - m];

            dst[k] = res;
          }
        }

        // Update history state
        var histCopy = Math.min(bLen - 1, xLen);
        for (k = bLen - 2; k >= histCopy; --k)
          bHist[k] = bHist[k - histCopy];
        for (k = 0; k < histCopy; ++k)
          bHist[k] = x[xLen - 1 - k];
        histCopy = Math.min(aLen, dstLen);
        for (k = aLen - 1; k >= histCopy; --k)
          aHist[k] = aHist[k - histCopy];
        for (k = 0; k < histCopy; ++k)
          aHist[k] = dst[xLen - 1 - k];
      };

      Filter.prototype.clearHistory = function () {
        for (var k = this._bHist.length - 1; k >= 0; --k)
          this._bHist[k] = 0;
        for (var k = this._aHist.length - 1; k >= 0; --k)
          this._aHist[k] = 0;
      };

      g.Filter = Filter;
    })();


    //------------------------------------------------------------------------------
    // interface FFT
    //
    // NOTE: This is essentially a hand-translation of the C language Kiss FFT
    // library, copyright by Mark Borgerding, relicensed with permission from the
    // author.
    //
    // The algorithm implements mixed radix FFT and supports transforms of any size
    // (not just powers of 2). For optimal performance, use sizes that can be
    // factorized into factors 2, 3, 4 and 5.
    //------------------------------------------------------------------------------

    (function () {
      if (g.FFT) return;

      var butterfly2 = function (outRe, outIm, outIdx, stride, twRe, twIm, m) {
        var scratch0Re, scratch0Im,
            out0Re, out0Im, out1Re, out1Im,
            tRe, tIm;

        var tw1 = 0,
            idx0 = outIdx,
            idx1 = outIdx + m;

        var idx0End = idx0 + m;
        while (idx0 < idx0End) {
          // out0 = out[idx0] / 2
          out0Re = outRe[idx0] * 0.5;
          out0Im = outIm[idx0] * 0.5;
          // out1 = out[idx1] / 2
          out1Re = outRe[idx1] * 0.5;
          out1Im = outIm[idx1] * 0.5;

          // scratch0 = out1 * tw[tw1]
          tRe = twRe[tw1]; tIm = twIm[tw1];
          scratch0Re = out1Re * tRe - out1Im * tIm;
          scratch0Im = out1Re * tIm + out1Im * tRe;

          // out[idx1] = out0 - scratch0
          outRe[idx1] = out0Re - scratch0Re;
          outIm[idx1] = out0Im - scratch0Im;

          // out[idx0] = out0 + scratch0
          outRe[idx0] = out0Re + scratch0Re;
          outIm[idx0] = out0Im + scratch0Im;

          tw1 += stride;
          ++idx0; ++idx1;
        }
      };

      var butterfly3 = function (outRe, outIm, outIdx, stride, twRe, twIm, m) {
        var scratch0Re, scratch0Im, scratch1Re, scratch1Im,
            scratch2Re, scratch2Im, scratch3Re, scratch3Im,
            out0Re, out0Im, out1Re, out1Im, out2Re, out2Im,
            tRe, tIm;

        var tw1 = 0,
            tw2 = 0,
            stride2 = 2 * stride,
            idx0 = outIdx,
            idx1 = outIdx + m,
            idx2 = outIdx + 2 * m;

        var epi3Im = twIm[stride*m];

        var div3 = 1 / 3;
        var idx0End = idx0 + m;
        while (idx0 < idx0End) {
          // out0 = out[idx0] / 3
          out0Re = outRe[idx0] * div3;
          out0Im = outIm[idx0] * div3;
          // out1 = out[idx1] / 3
          out1Re = outRe[idx1] * div3;
          out1Im = outIm[idx1] * div3;
          // out2 = out[idx2] / 3
          out2Re = outRe[idx2] * div3;
          out2Im = outIm[idx2] * div3;

          // scratch1 = out1 * tw[tw1]
          tRe = twRe[tw1]; tIm = twIm[tw1];
          scratch1Re = out1Re * tRe - out1Im * tIm;
          scratch1Im = out1Re * tIm + out1Im * tRe;

          // scratch2 = out2 * tw[tw2]
          tRe = twRe[tw2]; tIm = twIm[tw2];
          scratch2Re = out2Re * tRe - out2Im * tIm;
          scratch2Im = out2Re * tIm + out2Im * tRe;

          // scratch3 = scratch1 + scratch2
          scratch3Re = scratch1Re + scratch2Re;
          scratch3Im = scratch1Im + scratch2Im;

          // scratch0 = scratch1 - scratch2
          scratch0Re = scratch1Re - scratch2Re;
          scratch0Im = scratch1Im - scratch2Im;

          // out1 = out0 - scratch3 / 2
          out1Re = out0Re - scratch3Re * 0.5;
          out1Im = out0Im - scratch3Im * 0.5;

          // scratch0 *= epi3.i
          scratch0Re *= epi3Im;
          scratch0Im *= epi3Im;

          // out[idx0] = out0 + scratch3
          outRe[idx0] = out0Re + scratch3Re;
          outIm[idx0] = out0Im + scratch3Im;

          outRe[idx2] = out1Re + scratch0Im;
          outIm[idx2] = out1Im - scratch0Re;

          outRe[idx1] = out1Re - scratch0Im;
          outIm[idx1] = out1Im + scratch0Re;

          tw1 += stride; tw2 += stride2;
          ++idx0; ++idx1; ++idx2;
        }
      };

      var butterfly4 = function (outRe, outIm, outIdx, stride, twRe, twIm, m, inverse) {
        var scratch0Re, scratch0Im, scratch1Re, scratch1Im, scratch2Re, scratch2Im,
            scratch3Re, scratch3Im, scratch4Re, scratch4Im, scratch5Re, scratch5Im,
            out0Re, out0Im, out1Re, out1Im, out2Re, out2Im, out3Re, out3Im,
            tRe, tIm;

        var tw1 = 0,
            tw2 = 0,
            tw3 = 0,
            stride2 = 2 * stride,
            stride3 = 3 * stride,
            idx0 = outIdx,
            idx1 = outIdx + m,
            idx2 = outIdx + 2 * m,
            idx3 = outIdx + 3 * m;

        var div4 = 1 / 4;
        var idx0End = idx0 + m;
        while (idx0 < idx0End) {
          // out0 = out[idx0] / 4
          out0Re = outRe[idx0] * div4;
          out0Im = outIm[idx0] * div4;
          // out1 = out[idx1] / 4
          out1Re = outRe[idx1] * div4;
          out1Im = outIm[idx1] * div4;
          // out2 = out[idx2] / 4
          out2Re = outRe[idx2] * div4;
          out2Im = outIm[idx2] * div4;
          // out3 = out[idx3] / 4
          out3Re = outRe[idx3] * div4;
          out3Im = outIm[idx3] * div4;

          // scratch0 = out1 * tw[tw1]
          tRe = twRe[tw1]; tIm = twIm[tw1];
          scratch0Re = out1Re * tRe - out1Im * tIm;
          scratch0Im = out1Re * tIm + out1Im * tRe;

          // scratch1 = out2 * tw[tw2]
          tRe = twRe[tw2]; tIm = twIm[tw2];
          scratch1Re = out2Re * tRe - out2Im * tIm;
          scratch1Im = out2Re * tIm + out2Im * tRe;

          // scratch2 = out3 * tw[tw3]
          tRe = twRe[tw3]; tIm = twIm[tw3];
          scratch2Re = out3Re * tRe - out3Im * tIm;
          scratch2Im = out3Re * tIm + out3Im * tRe;

          // scratch5 = out0 - scratch1
          scratch5Re = out0Re - scratch1Re;
          scratch5Im = out0Im - scratch1Im;

          // out0 += scratch1
          out0Re += scratch1Re;
          out0Im += scratch1Im;

          // scratch3 = scratch0 + scratch2
          scratch3Re = scratch0Re + scratch2Re;
          scratch3Im = scratch0Im + scratch2Im;

          // scratch4 = scratch0 - scratch2
          scratch4Re = scratch0Re - scratch2Re;
          scratch4Im = scratch0Im - scratch2Im;

          // out[idx2] = out0 - scratch3
          outRe[idx2] = out0Re - scratch3Re;
          outIm[idx2] = out0Im - scratch3Im;

          // out[idx0] = out0 + scratch3
          outRe[idx0] = out0Re + scratch3Re;
          outIm[idx0] = out0Im + scratch3Im;

          if (inverse) {
            outRe[idx1] = scratch5Re - scratch4Im;
            outIm[idx1] = scratch5Im + scratch4Re;
            outRe[idx3] = scratch5Re + scratch4Im;
            outIm[idx3] = scratch5Im - scratch4Re;
          }
          else {
            outRe[idx1] = scratch5Re + scratch4Im;
            outIm[idx1] = scratch5Im - scratch4Re;
            outRe[idx3] = scratch5Re - scratch4Im;
            outIm[idx3] = scratch5Im + scratch4Re;
          }

          tw1 += stride; tw2 += stride2; tw3 += stride3;
          ++idx0; ++idx1; ++idx2; ++idx3;
        }
      };

      var butterfly5 = function (outRe, outIm, outIdx, stride, twRe, twIm, m) {
        var scratch0Re, scratch0Im, scratch1Re, scratch1Im, scratch2Re, scratch2Im,
            scratch3Re, scratch3Im, scratch4Re, scratch4Im, scratch5Re, scratch5Im,
            scratch6Re, scratch6Im, scratch7Re, scratch7Im, scratch8Re, scratch8Im,
            scratch9Re, scratch9Im, scratch10Re, scratch10Im, scratch11Re, scratch11Im,
            scratch12Re, scratch12Im,
            out0Re, out0Im, out1Re, out1Im, out2Re, out2Im, out3Re, out3Im, out4Re, out4Im,
            tRe, tIm;

        var tw1 = 0,
            tw2 = 0,
            tw3 = 0,
            tw4 = 0,
            stride2 = 2 * stride,
            stride3 = 3 * stride,
            stride4 = 4 * stride;

        var idx0 = outIdx,
            idx1 = outIdx + m,
            idx2 = outIdx + 2 * m,
            idx3 = outIdx + 3 * m,
            idx4 = outIdx + 4 * m;

        // ya = tw[stride*m];
        var yaRe = twRe[stride * m],
            yaIm = twIm[stride * m];
        // yb = tw[stride*2*m];
        var ybRe = twRe[stride * 2 * m],
            ybIm = twIm[stride * 2 * m];

        var div5 = 1 / 5;
        var idx0End = idx0 + m;
        while (idx0 < idx0End) {
          // out0 = out[idx0] / 5
          out0Re = outRe[idx0] * div5;
          out0Im = outIm[idx0] * div5;
          // out1 = out[idx1] / 5
          out1Re = outRe[idx1] * div5;
          out1Im = outIm[idx1] * div5;
          // out2 = out[idx2] / 5
          out2Re = outRe[idx2] * div5;
          out2Im = outIm[idx2] * div5;
          // out3 = out[idx3] / 5
          out3Re = outRe[idx3] * div5;
          out3Im = outIm[idx3] * div5;
          // out4 = out[idx4] / 5
          out4Re = outRe[idx4] * div5;
          out4Im = outIm[idx4] * div5;

          // scratch0 = out0;
          scratch0Re = out0Re;
          scratch0Im = out0Im;

          // scratch1 = out1 * tw[tw1]
          tRe = twRe[tw1]; tIm = twIm[tw1];
          scratch1Re = out1Re * tRe - out1Im * tIm;
          scratch1Im = out1Re * tIm + out1Im * tRe;
          // scratch2 = out2 * tw[tw2]
          tRe = twRe[tw2]; tIm = twIm[tw2];
          scratch2Re = out2Re * tRe - out2Im * tIm;
          scratch2Im = out2Re * tIm + out2Im * tRe;
          // scratch3 = out3 * tw[tw3]
          tRe = twRe[tw3]; tIm = twIm[tw3];
          scratch3Re = out3Re * tRe - out3Im * tIm;
          scratch3Im = out3Re * tIm + out3Im * tRe;
          // scratch4 = out4 * tw[tw4]
          tRe = twRe[tw4]; tIm = twIm[tw4];
          scratch4Re = out4Re * tRe - out4Im * tIm;
          scratch4Im = out4Re * tIm + out4Im * tRe;

          // scratch7 = scratch1 + scratch4
          scratch7Re = scratch1Re + scratch4Re;
          scratch7Im = scratch1Im + scratch4Im;
          // scratch10 = scratch1 - scratch4
          scratch10Re = scratch1Re - scratch4Re;
          scratch10Im = scratch1Im - scratch4Im;
          // scratch8 = scratch2 + scratch2
          scratch8Re = scratch2Re + scratch3Re;
          scratch8Im = scratch2Im + scratch3Im;
          // scratch9 = scratch2 - scratch3
          scratch9Re = scratch2Re - scratch3Re;
          scratch9Im = scratch2Im - scratch3Im;

          // out[idx0] = out0 + scratch7 + scratch8
          outRe[idx0] = out0Re + scratch7Re + scratch8Re;
          outIm[idx0] = out0Im + scratch7Im + scratch8Im;

          scratch5Re = scratch0Re + scratch7Re * yaRe + scratch8Re * ybRe;
          scratch5Im = scratch0Im + scratch7Im * yaRe + scratch8Im * ybRe;

          scratch6Re = scratch10Im * yaIm + scratch9Im * ybIm;
          scratch6Im = -scratch10Re * yaIm - scratch9Re * ybIm;

          // out[idx1] = scratch5 - scratch6
          outRe[idx1] = scratch5Re - scratch6Re;
          outIm[idx1] = scratch5Im - scratch6Im;
          // out[idx4] = scratch5 + scratch6
          outRe[idx4] = scratch5Re + scratch6Re;
          outIm[idx4] = scratch5Im + scratch6Im;

          scratch11Re = scratch0Re + scratch7Re * ybRe + scratch8Re * yaRe;
          scratch11Im = scratch0Im + scratch7Im * ybRe + scratch8Im * yaRe;

          scratch12Re = -scratch10Im * ybIm + scratch9Im * yaIm;
          scratch12Im = scratch10Re * ybIm - scratch9Re * yaIm;

          // out[idx2] = scratch11 + scratch12
          outRe[idx2] = scratch11Re + scratch12Re;
          outIm[idx2] = scratch11Im + scratch12Im;
          // out[idx3] = scratch11 - scratch12
          outRe[idx3] = scratch11Re - scratch12Re;
          outIm[idx3] = scratch11Im - scratch12Im;

          tw1 += stride; tw2 += stride2; tw3 += stride3; tw4 += stride4;
          ++idx0; ++idx1; ++idx2; ++idx3; ++idx4;
        }
      };

      var butterflyN = function (outRe, outIm, outIdx, stride, twRe, twIm, m, p, size) {
        var u, q1, q, idx0;
        var out0Re, out0Im, aRe, aIm, tRe, tIm;

        // FIXME: Allocate statically
        var scratchRe = new Float32Array(p);
        var scratchIm = new Float32Array(p);

        var pInv = 1 / p;
        for (u = 0; u < m; ++u) {
          idx0 = outIdx + u;
          for (q1 = 0; q1 < p; ++q1) {
            // scratch[q1] = out[idx0] / p
            scratchRe[q1] = outRe[idx0] * pInv;
            scratchIm[q1] = outIm[idx0] * pInv;
            idx0 += m;
          }

          idx0 = outIdx + u;
          var tw1Incr = stride * u;
          for (q1 = 0; q1 < p; ++q1) {
            // out0 = scratch[0]
            out0Re = scratchRe[0];
            out0Im = scratchIm[0];

            var tw1 = 0;
            for (q = 1; q < p; ++q) {
              tw1 += tw1Incr;
              if (tw1 >= size)
                tw1 -= size;

              // out0 += scratch[q] * tw[tw1]
              aRe = scratchRe[q], aIm = scratchIm[q];
              tRe = twRe[tw1], tIm = twIm[tw1];
              out0Re += aRe * tRe - aIm * tIm;
              out0Im += aRe * tIm + aIm * tRe;
            }

            // out[idx0] = out0
            outRe[idx0] = out0Re;
            outIm[idx0] = out0Im;

            idx0 += m;
            tw1Incr += stride;
          }
        }
      };

      var work = function (outRe, outIm, outIdx, fRe, fIm, fIdx, stride, inStride, factors, factorsIdx, twRe, twIm, size, inverse) {
        var p = factors[factorsIdx++];  // Radix
        var m = factors[factorsIdx++];  // Stage's FFT length / p

        var outIdxBeg = outIdx;
        var outIdxEnd = outIdx + p * m;

        var fIdxIncr = stride * inStride;
        if (m == 1) {
          do {
            outRe[outIdx] = fRe[fIdx];
            outIm[outIdx] = fIm[fIdx];
            fIdx += fIdxIncr;
            ++outIdx;
          }
          while (outIdx != outIdxEnd);
        }
        else {
          do {
            // DFT of size m*p performed by doing p instances of smaller DFTs of
            // size m, each one takes a decimated version of the input.
            work(outRe, outIm, outIdx, fRe, fIm, fIdx, stride * p, inStride, factors, factorsIdx, twRe, twIm, size, inverse);
            fIdx += fIdxIncr;
            outIdx += m;
          }
          while (outIdx != outIdxEnd);
        }

        outIdx = outIdxBeg;

        // Recombine the p smaller DFTs
        switch (p) {
          case 2:  butterfly2(outRe, outIm, outIdx, stride, twRe, twIm, m); break;
          case 3:  butterfly3(outRe, outIm, outIdx, stride, twRe, twIm, m); break;
          case 4:  butterfly4(outRe, outIm, outIdx, stride, twRe, twIm, m, inverse); break;
          case 5:  butterfly5(outRe, outIm, outIdx, stride, twRe, twIm, m); break;
          default: butterflyN(outRe, outIm, outIdx, stride, twRe, twIm, m, p, size); break;
        }
      };

      /*  facBuf is populated by p1,m1,p2,m2, ...
          where
          p[i] * m[i] = m[i-1]
          m0 = n                  */
      var factor = function (n, facBuf) {
        // Factor out powers of 4, powers of 2, then any remaining primes
        var p = 4;
        var floorSqrt = Math.floor(Math.sqrt(n));
        var idx = 0;
        do {
          while (n % p) {
            switch (p) {
              case 4:  p = 2; break;
              case 2:  p = 3; break;
              default: p += 2; break;
            }
            if (p > floorSqrt)
              p = n;
          }
          n = Math.floor(n / p);
          facBuf[idx++] = p;
          facBuf[idx++] = n;
        }
        while (n > 1);
      };

      var FFT = function (size) {
        if (!size)
          size = 256;
        this.size = size;

        // Allocate arrays for twiddle factors
        this._twiddlesFwdRe = new Float32Array(size);
        this._twiddlesFwdIm = new Float32Array(size);
        this._twiddlesInvRe = this._twiddlesFwdRe;
        this._twiddlesInvIm = new Float32Array(size);

        // Init twiddle factors (both forward & reverse)
        for (var i = 0; i < size; ++i) {
            var phase = -2*Math.PI*i / size;
            var cosPhase = Math.cos(phase), sinPhase = Math.sin(phase);
            this._twiddlesFwdRe[i] = cosPhase;
            this._twiddlesFwdIm[i] = sinPhase;
            this._twiddlesInvIm[i] = -sinPhase;
        }

        // Allocate arrays for radix plan
        this._factors = new Int32Array(2 * 32);  // MAXFACTORS = 32

        // Init radix factors (mixed radix breakdown)
        factor(size, this._factors);
      };

      FFT.prototype.forwardCplx = function (dstReal, dstImag, xReal, xImag) {
        var twRe = this._twiddlesFwdRe;
        var twIm = this._twiddlesFwdIm;
        work(dstReal, dstImag, 0, xReal, xImag, 0, 1, 1, this._factors, 0, twRe, twIm, this.size, false);
      };

      FFT.prototype.forward = function (dstReal, dstImag, x) {
        // FIXME: Optimize this case (real input signal)
        this.forwardCplx(dstReal, dstImag, x, new Float32Array(this.size));
      };

      FFT.prototype.inverseCplx = function (dstReal, dstImag, xReal, xImag) {
        var twRe = this._twiddlesInvRe;
        var twIm = this._twiddlesInvIm;
        work(dstReal, dstImag, 0, xReal, xImag, 0, 1, 1, this._factors, 0, twRe, twIm, this.size, true);
      };

      FFT.prototype.inverse = function (dst, xReal, xImag) {
        // FIXME: Optimize this case (real output signal)
        this.inverseCplx(dst, new Float32Array(this.size), xReal, xImag);
      };

      g.FFT = FFT;
    })();

    if (typeof module !== "undefined" && module.exports) {
        module.exports = {
            DSP: g.DSP,
            Filter: g.Filter,
            FFT: g.FFT
        };
    }
})();
;
/** Random.js library.
 * 
 * The code is licensed as LGPL.
*/

/* 
   A C-program for MT19937, with initialization improved 2002/1/26.
   Coded by Takuji Nishimura and Makoto Matsumoto.
 
   Before using, initialize the state by using init_genrand(seed)  
   or init_by_array(init_key, key_length).
 
   Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
   All rights reserved.                          
 
   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.

     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.

     3. The names of its contributors may not be used to endorse or promote 
        products derived from this software without specific prior written 
        permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


   Any feedback is very welcome.
   http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html
   email: m-mat @ math.sci.hiroshima-u.ac.jp (remove space)
 */

var Random = function(seed) {
	seed = (seed === undefined) ? (new Date()).getTime() : seed;
	if (typeof(seed) !== 'number'                             // ARG_CHECK
		|| Math.ceil(seed) != Math.floor(seed)) {             // ARG_CHECK
		throw new TypeError("seed value must be an integer"); // ARG_CHECK
	}                                                         // ARG_CHECK
	
	
	/* Period parameters */  
	this.N = 624;
	this.M = 397;
	this.MATRIX_A = 0x9908b0df;   /* constant vector a */
	this.UPPER_MASK = 0x80000000; /* most significant w-r bits */
	this.LOWER_MASK = 0x7fffffff; /* least significant r bits */

	this.mt = new Array(this.N); /* the array for the state vector */
	this.mti=this.N+1; /* mti==N+1 means mt[N] is not initialized */

	//this.init_genrand(seed);
	this.init_by_array([seed], 1);
};

/* initializes mt[N] with a seed */
Random.prototype.init_genrand = function(s) {
	this.mt[0] = s >>> 0;
	for (this.mti=1; this.mti<this.N; this.mti++) {
		var s = this.mt[this.mti-1] ^ (this.mt[this.mti-1] >>> 30);
		this.mt[this.mti] = (((((s & 0xffff0000) >>> 16) * 1812433253) << 16) + (s & 0x0000ffff) * 1812433253)
		+ this.mti;
		/* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
		/* In the previous versions, MSBs of the seed affect   */
		/* only MSBs of the array mt[].                        */
		/* 2002/01/09 modified by Makoto Matsumoto             */
		this.mt[this.mti] >>>= 0;
		/* for >32 bit machines */
	}
};

/* initialize by an array with array-length */
/* init_key is the array for initializing keys */
/* key_length is its length */
/* slight change for C++, 2004/2/26 */
Random.prototype.init_by_array = function(init_key, key_length) {
	var i, j, k;
	this.init_genrand(19650218);
	i=1; j=0;
	k = (this.N>key_length ? this.N : key_length);
	for (; k; k--) {
		var s = this.mt[i-1] ^ (this.mt[i-1] >>> 30);
		this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1664525) << 16) + ((s & 0x0000ffff) * 1664525)))
		+ init_key[j] + j; /* non linear */
		this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */
		i++; j++;
		if (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }
		if (j>=key_length) j=0;
	}
	for (k=this.N-1; k; k--) {
		var s = this.mt[i-1] ^ (this.mt[i-1] >>> 30);
		this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1566083941) << 16) + (s & 0x0000ffff) * 1566083941))
		- i; /* non linear */
		this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */
		i++;
		if (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }
	}

	this.mt[0] = 0x80000000; /* MSB is 1; assuring non-zero initial array */ 
};
 
/* generates a random number on [0,0xffffffff]-interval */
Random.prototype.genrand_int32 = function() {
	var y;
	var mag01 = new Array(0x0, this.MATRIX_A);
	/* mag01[x] = x * MATRIX_A  for x=0,1 */

	if (this.mti >= this.N) { /* generate N words at one time */
		var kk;

		if (this.mti == this.N+1)   /* if init_genrand() has not been called, */
			this.init_genrand(5489); /* a default initial seed is used */

		for (kk=0;kk<this.N-this.M;kk++) {
			y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);
			this.mt[kk] = this.mt[kk+this.M] ^ (y >>> 1) ^ mag01[y & 0x1];
		}
		for (;kk<this.N-1;kk++) {
			y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);
			this.mt[kk] = this.mt[kk+(this.M-this.N)] ^ (y >>> 1) ^ mag01[y & 0x1];
		}
		y = (this.mt[this.N-1]&this.UPPER_MASK)|(this.mt[0]&this.LOWER_MASK);
		this.mt[this.N-1] = this.mt[this.M-1] ^ (y >>> 1) ^ mag01[y & 0x1];

		this.mti = 0;
	}

	y = this.mt[this.mti++];

	/* Tempering */
	y ^= (y >>> 11);
	y ^= (y << 7) & 0x9d2c5680;
	y ^= (y << 15) & 0xefc60000;
	y ^= (y >>> 18);

	return y >>> 0;
};
 
/* generates a random number on [0,0x7fffffff]-interval */
Random.prototype.genrand_int31 = function() {
	return (this.genrand_int32()>>>1);
};

/* generates a random number on [0,1]-real-interval */
Random.prototype.genrand_real1 = function() {
	return this.genrand_int32()*(1.0/4294967295.0); 
	/* divided by 2^32-1 */ 
};

/* generates a random number on [0,1)-real-interval */
Random.prototype.random = function() {
	if (this.pythonCompatibility) {
		if (this.skip) {
			this.genrand_int32();
		}
		this.skip = true;
	}
	return this.genrand_int32()*(1.0/4294967296.0); 
	/* divided by 2^32 */
};

/* generates a random number on (0,1)-real-interval */
Random.prototype.genrand_real3 = function() {
	return (this.genrand_int32() + 0.5)*(1.0/4294967296.0); 
	/* divided by 2^32 */
};

/* generates a random number on [0,1) with 53-bit resolution*/
Random.prototype.genrand_res53 = function() { 
	var a=this.genrand_int32()>>>5, b=this.genrand_int32()>>>6; 
	return(a*67108864.0+b)*(1.0/9007199254740992.0); 
};

/* These real versions are due to Isaku Wada, 2002/01/09 added */


/**************************************************************************/
Random.prototype.LOG4 = Math.log(4.0);
Random.prototype.SG_MAGICCONST = 1.0 + Math.log(4.5);

Random.prototype.exponential = function (lambda) {
	if (arguments.length != 1) {                         // ARG_CHECK                     
		throw new SyntaxError("exponential() must "     // ARG_CHECK
				+ " be called with 'lambda' parameter"); // ARG_CHECK
	}                                                   // ARG_CHECK
	
	var r = this.random();
	return -Math.log(r) / lambda;
};

Random.prototype.gamma = function (alpha, beta) {
	if (arguments.length != 2) {                         // ARG_CHECK                     
		throw new SyntaxError("gamma() must be called"  // ARG_CHECK
				+ " with alpha and beta parameters"); // ARG_CHECK
	}                                                   // ARG_CHECK
	
	/* Based on Python 2.6 source code of random.py.
	 */
	
	if (alpha > 1.0) {
		var ainv = Math.sqrt(2.0 * alpha - 1.0);
		var bbb = alpha - this.LOG4;
		var ccc = alpha + ainv;
		
		while (true) {
			var u1 = this.random();
			if ((u1 < 1e-7) || (u > 0.9999999)) {
				continue;
			}
			var u2 = 1.0 - this.random();
			var v = Math.log(u1 / (1.0 - u1)) / ainv;
			var x = alpha * Math.exp(v);
			var z = u1 * u1 * u2;
			var r = bbb + ccc * v - x;
			if ((r + this.SG_MAGICCONST - 4.5 * z >= 0.0) || (r >= Math.log(z))) {
				return x * beta;
			}
		}
	} else if (alpha == 1.0) {
		var u = this.random();
		while (u <= 1e-7) {
			u = this.random();
		}
		return - Math.log(u) * beta;
	} else {
		while (true) {
			var u = this.random();
			var b = (Math.E + alpha) / Math.E;
			var p = b * u;
			if (p <= 1.0) {
				var x = Math.pow(p, 1.0 / alpha);
			} else {
				var x = - Math.log((b - p) / alpha);
			}
			var u1 = this.random();
			if (p > 1.0) {
				if (u1 <= Math.pow(x, (alpha - 1.0))) {
					break;
				}
			} else if (u1 <= Math.exp(-x)) {
				break;
			}
		}
		return x * beta;
	}
	
};

Random.prototype.normal = function (mu, sigma) {
	if (arguments.length != 2) {                          // ARG_CHECK                     
		throw new SyntaxError("normal() must be called"  // ARG_CHECK
				+ " with mu and sigma parameters");      // ARG_CHECK
	}                                                    // ARG_CHECK
	
	var z = this.lastNormal;
	this.lastNormal = NaN;
	if (!z) {
		var a = this.random() * 2 * Math.PI;
		var b = Math.sqrt(-2.0 * Math.log(1.0 - this.random()));
		z = Math.cos(a) * b;
		this.lastNormal = Math.sin(a) * b;
	} 
	return mu + z * sigma;
};

Random.prototype.pareto = function (alpha) {
	if (arguments.length != 1) {                         // ARG_CHECK                     
		throw new SyntaxError("pareto() must be called" // ARG_CHECK
				+ " with alpha parameter");             // ARG_CHECK
	}                                                   // ARG_CHECK
	
	var u = this.random();
	return 1.0 / Math.pow((1 - u), 1.0 / alpha);
};

Random.prototype.triangular = function (lower, upper, mode) {
	// http://en.wikipedia.org/wiki/Triangular_distribution
	if (arguments.length != 3) {                         // ARG_CHECK                     
		throw new SyntaxError("triangular() must be called" // ARG_CHECK
		+ " with lower, upper and mode parameters");    // ARG_CHECK
	}                                                   // ARG_CHECK
	
	var c = (mode - lower) / (upper - lower);
	var u = this.random();
	
	if (u <= c) {
		return lower + Math.sqrt(u * (upper - lower) * (mode - lower));
	} else {
		return upper - Math.sqrt((1 - u) * (upper - lower) * (upper - mode));
	}
};

Random.prototype.uniform = function (lower, upper) {
	if (arguments.length != 2) {                         // ARG_CHECK                     
		throw new SyntaxError("uniform() must be called" // ARG_CHECK
		+ " with lower and upper parameters");    // ARG_CHECK
	}                                                   // ARG_CHECK
	return lower + this.random() * (upper - lower);
};

Random.prototype.weibull = function (alpha, beta) {
	if (arguments.length != 2) {                         // ARG_CHECK                     
		throw new SyntaxError("weibull() must be called" // ARG_CHECK
		+ " with alpha and beta parameters");    // ARG_CHECK
	}                                                   // ARG_CHECK
	var u = 1.0 - this.random();
	return alpha * Math.pow(-Math.log(u), 1.0 / beta);
};
;/*! Flocking 0.1, Copyright 2011-2014 Colin Clark | flockingjs.org */

/*
* Flocking - Creative audio synthesis for the Web!
* http://github.com/colinbdclark/flocking
*
* Copyright 2011-2014, Colin Clark
* Dual licensed under the MIT and GPL Version 2 licenses.
*/

/*global require, Float32Array, window, AudioContext, webkitAudioContext*/
/*jshint white: false, newcap: true, regexp: true, browser: true,
    forin: false, nomen: true, bitwise: false, maxerr: 100,
    indent: 4, plusplus: false, curly: true, eqeqeq: true,
    freeze: true, latedef: true, noarg: true, nonew: true, quotmark: double, undef: true,
    unused: true, strict: true, asi: false, boss: false, evil: false, expr: false,
    funcscope: false*/

var fluid = fluid || require("infusion"),
    flock = fluid.registerNamespace("flock");

(function () {
    "use strict";

    var $ = fluid.registerNamespace("jQuery");

    flock.fluid = fluid;

    flock.init = function (options) {
        var enviroOpts = !options ? undefined : {
            audioSettings: options
        };

        var enviro = flock.enviro.shared = flock.enviro(enviroOpts);

        return enviro;
    };

    flock.OUT_UGEN_ID = "flocking-out";
    flock.MAX_CHANNELS = 32;
    flock.MIN_BUSES = 2;
    flock.MAX_INPUT_BUSES = 32;
    flock.MIN_INPUT_BUSES = 1; // TODO: This constraint should be removed.
    flock.ALL_CHANNELS = flock.MAX_INPUT_BUSES;

    flock.PI = Math.PI;
    flock.TWOPI = 2.0 * Math.PI;
    flock.HALFPI = Math.PI / 2.0;
    flock.LOG01 = Math.log(0.1);
    flock.LOG001 = Math.log(0.001);
    flock.ROOT2 = Math.sqrt(2);

    flock.rates = {
        AUDIO: "audio",
        CONTROL: "control",
        SCHEDULED: "scheduled",
        DEMAND: "demand",
        CONSTANT: "constant"
    };

    flock.sampleFormats = {
        FLOAT32NE: "float32NE"
    };

    fluid.registerNamespace("flock.debug");
    flock.debug.failHard = true;

    flock.browser = function () {
        if (typeof navigator === "undefined") {
            return {};
        }

        // This is a modified version of jQuery's browser detection code,
        // which they removed from jQuery 2.0.
        // Some of us still have to live in the messy reality of the web.
        var ua = navigator.userAgent.toLowerCase(),
            browser = {},
            match,
            matched;

        match = /(chrome)[ \/]([\w.]+)/.exec(ua) ||
            /(webkit)[ \/]([\w.]+)/.exec(ua) ||
            /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua) ||
            /(msie) ([\w.]+)/.exec(ua) ||
            ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) || [];

        matched = {
            browser: match[1] || "",
            version: match[2] || "0"
        };

        if (matched.browser) {
            browser[matched.browser] = true;
            browser.version = matched.version;
        }

        // Chrome is Webkit, but Webkit is also Safari.
        if (browser.chrome) {
            browser.webkit = true;
        } else if (browser.webkit) {
            browser.safari = true;
        }

        return browser;
    };

    // TODO: Move to components in the static environment and into the appropriate platform files.
    fluid.registerNamespace("flock.platform");
    flock.platform.isBrowser = typeof window !== "undefined";
    flock.platform.hasRequire = typeof require !== "undefined";
    flock.platform.os = flock.platform.isBrowser ? window.navigator.platform : fluid.require("os").platform();
    flock.platform.isLinux = flock.platform.os.indexOf("Linux") > -1;
    flock.platform.isAndroid = flock.platform.isLinux && flock.platform.os.indexOf("arm") > -1;
    flock.platform.isIOS = flock.platform.os === "iPhone" || flock.platform.os === "iPad" || flock.platform.os === "iPod";
    flock.platform.isMobile = flock.platform.isAndroid || flock.platform.isIOS;
    flock.platform.browser = flock.browser();
    flock.platform.isWebAudio = typeof AudioContext !== "undefined" || typeof webkitAudioContext !== "undefined";
    flock.platform.audioEngine = flock.platform.isBrowser ? (flock.platform.isWebAudio ? "webAudio" : "moz") : "nodejs";
    fluid.staticEnvironment.audioEngine = fluid.typeTag("flock.platform." + flock.platform.audioEngine);

    flock.defaultBufferSizeForPlatform = function () {
        if (flock.platform.isMobile) {
            return 8192;
        }

        return 1024;
    };

    flock.shim = {
        URL: flock.platform.isBrowser ? (window.URL || window.webkitURL || window.msURL) : undefined
    };

    flock.requireModule = function (moduleName, globalName) {
        if (flock.platform.isBrowser) {
            return window[globalName || moduleName];
        }

        if (!flock.platform.hasRequire) {
            return undefined;
        }

        var resolvedName = flock.requireModule.paths[moduleName] || moduleName;
        var togo = require(resolvedName);

        return globalName ? togo[globalName] : togo;
    };

    flock.requireModule.paths = {
        dspapi: "../third-party/dspapi/js/dspapi.js",
        Random: "../third-party/simjs/js/random-0.26.js"
    };

    /*************
     * Utilities *
     *************/

    flock.noOp = function () {};

    flock.isIterable = function (o) {
        var type = typeof o;
        return o && o.length !== undefined && type !== "string" && type !== "function";
    };

    flock.hasTag = function (obj, tag) {
        if (!obj || !tag) {
            return false;
        }
        return obj.tags && obj.tags.indexOf(tag) > -1;
    };

    // TODO: Chrome profiler marks this function as unoptimized.
    // This should probably be factored into separate functions for
    // new and existing arrays. (e.g. "generate" vs. "fill")
    flock.generate = function (bufOrSize, generator) {
        var buf = typeof bufOrSize === "number" ? new Float32Array(bufOrSize) : bufOrSize,
            isFunc = typeof generator === "function",
            i;

        for (i = 0; i < buf.length; i++) {
            buf[i] = isFunc ? generator(i, buf) : generator;
        }

        return buf;
    };

    flock.generate.silence = function (bufOrSize) {
        if (typeof bufOrSize === "number") {
            return new Float32Array(bufOrSize);
        }

        var buf = bufOrSize,
            i;
        for (i = 0; i < buf.length; i++) {
            buf[i] = 0.0;
        }
        return buf;
    };

    /**
     * Performs an in-place reversal of all items in the array.
     *
     * @arg {Iterable} b a buffer or array to reverse
     * @return {Iterable} the buffer, reversed
     */
    flock.reverse = function (b) {
        if (!b || !flock.isIterable(b) || b.length < 2) {
            return b;
        }

        // A native implementation of reverse() exists for regular JS arrays
        // and is partially implemented for TypedArrays. Use it if possible.
        if (typeof b.reverse === "function") {
            return b.reverse();
        }

        var t;
        for (var l = 0, r = b.length - 1; l < r; l++, r--) {
            t = b[l];
            b[l] = b[r];
            b[r] = t;
        }

        return b;
    };

    /**
     * Randomly selects an index from the specified array.
     */
    flock.randomIndex = function (arr) {
        var max = arr.length - 1;
        return Math.round(Math.random() * max);
    };

    /**
     * Randomly selects an item from an array-like object.
     *
     * @param {Array-like object} arr the array to choose from
     * @param {Function} a selection strategy; defaults to flock.randomIndex
     * @return a randomly selected list item
     */
    flock.arrayChoose = function (arr, strategy) {
        strategy = strategy || flock.randomIndex;
        arr = fluid.makeArray(arr);
        var idx = strategy(arr);
        return arr[idx];
    };

    /**
     * Randomly selects an item from an array or object.
     *
     * @param {Array-like object|Object} collection the object to choose from
     * @return a randomly selected item from collection
     */
    flock.choose = function (collection, strategy) {
        var key, val;

        if (flock.isIterable(collection)) {
            val = flock.arrayChoose(collection, strategy);
            return val;
        }

        key = flock.arrayChoose(collection.keys, strategy);
        val = collection[key];
        return val;
    };

    /**
     * Normalizes the specified buffer in place to the specified value.
     *
     * @param {Arrayable} buffer the buffer to normalize
     * @param {Number} normal the value to normalize the buffer to
     * @param {Arrayable} a buffer to output values into; if omitted, buffer will be modified in place
     * @return the buffer, normalized in place
     */
    flock.normalize = function (buffer, normal, output) {
        output = output || buffer;

        var maxVal = 0.0,
            i,
            current,
            val;

        normal = normal === undefined ? 1.0 : normal;
        // Find the maximum value in the buffer.
        for (i = 0; i < buffer.length; i++) {
            current = Math.abs(buffer[i]);
            if (current > maxVal) {
                maxVal = current;
            }
        }

        // And then normalize the buffer in place.
        if (maxVal > 0.0) {
            for (i = 0; i < buffer.length; i++) {
                val = buffer[i];
                output[i] = (val / maxVal) * normal;
            }
        }

        return output;
    };

    flock.generateFourierTable = function (size, scale, numHarms, phase, amps) {
        phase *= flock.TWOPI;

        return flock.generate(size, function (i) {
            var harm,
                amp,
                w,
                val = 0.0;

            for (harm = 0; harm < numHarms; harm++) {
                amp = amps ? amps[harm] : 1.0;
                w = (harm + 1) * (i * scale);
                val += amp * Math.cos(w + phase);
            }

            return val;
        });
    };

    flock.generateNormalizedFourierTable = function (size, scale, numHarms, phase, ampGenFn) {
        var amps = flock.generate(numHarms, function (harm) {
            return ampGenFn(harm + 1); //  Harmonics are indexed from 1 instead of 0.
        });

        var table = flock.generateFourierTable(size, scale, numHarms, phase, amps);
        return flock.normalize(table);
    };

    flock.fillTable = function (sizeOrTable, fillFn) {
        var len = typeof (sizeOrTable) === "number" ? sizeOrTable : sizeOrTable.length;
        return fillFn(sizeOrTable, flock.TWOPI / len);
    };

    flock.tableGenerators = {
        sin: function (size, scale) {
            return flock.generate(size, function (i) {
                return Math.sin(i * scale);
            });
        },

        tri: function (size, scale) {
            return flock.generateNormalizedFourierTable(size, scale, 1000, 1.0, function (harm) {
                // Only odd harmonics,
                // amplitudes decreasing by the inverse square of the harmonic number
                return harm % 2 === 0 ? 0.0 : 1.0 / (harm * harm);
            });
        },

        saw: function (size, scale) {
            return flock.generateNormalizedFourierTable(size, scale, 10, -0.25, function (harm) {
                // All harmonics,
                // amplitudes decreasing by the inverse of the harmonic number
                return 1.0 / harm;
            });
        },

        square: function (size, scale) {
            return flock.generateNormalizedFourierTable(size, scale, 10, -0.25, function (harm) {
                // Only odd harmonics,
                // amplitudes decreasing by the inverse of the harmonic number
                return harm % 2 === 0 ? 0.0 : 1.0 / harm;
            });
        },

        hann: function (size) {
            // Hanning envelope: sin^2(i) for i from 0 to pi
            return flock.generate(size, function (i) {
                var y = Math.sin(Math.PI * i / size);
                return y * y;
            });
        },

        sinWindow: function (size) {
            return flock.generate(size, function (i) {
                return Math.sin(Math.PI * i / size);
            });
        }
    };

    flock.range = function (buf) {
        var range = {
            max: Number.NEGATIVE_INFINITY,
            min: Infinity
        };
        var i, val;

        for (i = 0; i < buf.length; i++) {
            val = buf[i];
            if (val > range.max) {
                range.max = val;
            }
            if (val < range.min) {
                range.min = val;
            }
        }

        return range;
    };

    flock.scale = function (buf) {
        if (!buf) {
            return;
        }

        var range = flock.range(buf),
            mul = (range.max - range.min) / 2,
            sub = (range.max + range.min) / 2,
            i;

        for (i = 0; i < buf.length; i++) {
            buf[i] = (buf[i] - sub) / mul;
        }

        return buf;
    };

    flock.copyBuffer = function (buffer, start, end) {
        if (end === undefined) {
            end = buffer.length;
        }

        var len = end - start,
            target = new Float32Array(len),
            i,
            j;

        for (i = start, j = 0; i < end; i++, j++) {
            target[j] = buffer[i];
        }

        return target;
    };

    flock.parseMidiString = function (midiStr) {
        if (!midiStr || midiStr.length < 2) {
            return NaN;
        }

        midiStr = midiStr.toLowerCase();

        var secondChar = midiStr.charAt(1),
            splitIdx = secondChar === "#" || secondChar === "b" ? 2 : 1,
            note = midiStr.substring(0, splitIdx),
            octave = Number(midiStr.substring(splitIdx)),
            pitchClass = flock.midiFreq.noteNames[note],
            midiNum = octave * 12 + pitchClass;

        return midiNum;
    };

    flock.midiFreq = function (midi, a4Freq, a4NoteNum, notesPerOctave) {
        a4Freq = a4Freq === undefined ? 440 : a4Freq;
        a4NoteNum = a4NoteNum === undefined ? 69 : a4NoteNum;
        notesPerOctave = notesPerOctave || 12;

        if (typeof midi === "string") {
            midi = flock.parseMidiString(midi);
        }

        return a4Freq * Math.pow(2, (midi - a4NoteNum) * 1 / notesPerOctave);
    };

    flock.midiFreq.noteNames = {
        "b#": 0,
        "c": 0,
        "c#": 1,
        "db": 1,
        "d": 2,
        "d#": 3,
        "eb": 3,
        "e": 4,
        "e#": 5,
        "f": 5,
        "f#": 6,
        "gb": 6,
        "g": 7,
        "g#": 8,
        "ab": 8,
        "a": 9,
        "a#": 10,
        "bb": 10,
        "b": 11,
        "cb": 11
    };

    flock.interpolate = {
        /**
         * Performs simple truncation.
         */
        none: function (idx, table) {
            idx = idx % table.length;

            return table[idx | 0];
        },

        /**
         * Performs linear interpolation.
         */
        linear: function (idx, table) {
            var len = table.length;
            idx = idx % len;

            var i1 = idx | 0,
                i2 = (i1 + 1) % len,
                frac = idx - i1,
                y1 = table[i1],
                y2 = table[i2];

            return y1 + frac * (y2 - y1);
        },

        /**
         * Performs Hermite cubic interpolation.
         *
         * Based on Laurent De Soras' implementation at:
         * http://www.musicdsp.org/showArchiveComment.php?ArchiveID=93
         *
         * @param idx {Number} an index into the table
         * @param table {Arrayable} the table from which values around idx should be drawn and interpolated
         * @return {Number} an interpolated value
         */
        hermite: function (idx, table) {
            var len = table.length,
                intPortion = Math.floor(idx),
                i0 = intPortion % len,
                frac = idx - intPortion,
                im1 = i0 > 0 ? i0 - 1 : len - 1,
                i1 = (i0 + 1) % len,
                i2 = (i0 + 2) % len,
                xm1 = table[im1],
                x0 = table[i0],
                x1 = table[i1],
                x2 = table[i2],
                c = (x1 - xm1) * 0.5,
                v = x0 - x1,
                w = c + v,
                a = w + v + (x2 - x0) * 0.5,
                bNeg = w + a,
                val = (((a * frac) - bNeg) * frac + c) * frac + x0;

            return val;
        }
    };

    flock.interpolate.cubic = flock.interpolate.hermite;

    flock.log = {
        warn: function (msg) {
            fluid.log(fluid.logLevel.WARN, msg);
        },

        debug: function (msg) {
            fluid.log(fluid.logLevel.INFO, msg);
        }
    };

    flock.fail = function (msg) {
        if (flock.debug.failHard) {
            throw new Error(msg);
        } else {
            fluid.log(fluid.logLevel.FAIL, msg);
        }
    };

    flock.pathParseError = function (root, path, token) {
        var msg = "Error parsing path '" + path + "'. Segment '" + token +
            "' could not be resolved. Root object was: " + fluid.prettyPrintJSON(root);

        flock.fail(msg);
    };

    flock.get = function (root, path) {
        if (!root) {
            return fluid.getGlobalValue(path);
        }

        if (arguments.length === 1 && typeof root === "string") {
            return fluid.getGlobalValue(root);
        }

        if (!path || path === "") {
            return;
        }

        var tokenized = path === "" ? [] : String(path).split("."),
            valForSeg = root[tokenized[0]],
            i;

        for (i = 1; i < tokenized.length; i++) {
            if (valForSeg === null || valForSeg === undefined) {
                flock.pathParseError(root, path, tokenized[i - 1]);
                return;
            }
            valForSeg = valForSeg[tokenized[i]];
        }

        return valForSeg;
    };

    flock.set = function (root, path, value) {
        if (!root || !path || path === "") {
            return;
        }

        var tokenized = String(path).split("."),
            l = tokenized.length,
            prop = tokenized[0],
            i,
            type;

        for (i = 1; i < l; i++) {
            root = root[prop];
            type = typeof root;
            if (type !== "object") {
                flock.fail("Error while setting a value at path '" + path +
                    "'. A non-container object was found at segment '" + prop + "'. Value: " + root);

                return;
            }
            prop = tokenized[i];
            if (root[prop] === undefined) {
                root[prop] = {};
            }
        }
        root[prop] = value;

        return value;
    };

    flock.invoke = function (root, path, args) {
        var fn = typeof root === "function" ? root : flock.get(root, path);
        if (typeof fn !== "function") {
            flock.fail("Path '" + path + "' does not resolve to a function.");
            return;
        }
        return fn.apply(null, args);
    };


    flock.input = {};

    flock.input.shouldExpand = function (inputName) {
        return flock.parse.specialInputs.indexOf(inputName) < 0;
    };

    // TODO: Replace this with a regular expression;
    // this produces too much garbage!
    flock.input.pathExpander = function (path) {
        var segs = fluid.model.parseEL(path),
            separator = "inputs",
            len = segs.length,
            penIdx = len - 1,
            togo = [],
            i;

        for (i = 0; i < penIdx; i++) {
            var seg = segs[i];
            var nextSeg = segs[i + 1];

            togo.push(seg);

            if (nextSeg === "model" || nextSeg === "options") {
                togo = togo.concat(segs.slice(i + 1, penIdx));
                break;
            }

            if (!isNaN(Number(nextSeg))) {
                continue;
            }

            togo.push(separator);
        }

        togo.push(segs[penIdx]);

        return togo.join(".");
    };

    flock.input.expandPaths = function (paths) {
        var expanded = {},
            path,
            expandedPath,
            value;

        for (path in paths) {
            expandedPath = flock.input.pathExpander(path);
            value = paths[path];
            expanded[expandedPath] = value;
        }

        return expanded;
    };

    flock.input.expandPath = function (path) {
        return (typeof path === "string") ? flock.input.pathExpander(path) : flock.input.expandPaths(path);
    };

    flock.input.getValueForPath = function (root, path) {
        path = flock.input.expandPath(path);
        var input = flock.get(root, path);

        // If the unit generator is a valueType ugen, return its value, otherwise return the ugen itself.
        return flock.hasTag(input, "flock.ugen.valueType") ? input.inputs.value : input;
    };

    flock.input.getValuesForPathArray = function (root, paths) {
        var values = {},
            i,
            path;

        for (i = 0; i < paths.length; i++) {
            path = paths[i];
            values[path] = flock.input.get(root, path);
        }

        return values;
    };

    flock.input.getValuesForPathObject = function (root, pathObj) {
        var key;

        for (key in pathObj) {
            pathObj[key] = flock.input.get(root, key);
        }

        return pathObj;
    };

    /**
     * Gets the value of the ugen at the specified path.
     *
     * @param {String} path the ugen's path within the synth graph
     * @return {Number|UGen} a scalar value in the case of a value ugen, otherwise the ugen itself
     */
    flock.input.get = function (root, path) {
        return typeof path === "string" ? flock.input.getValueForPath(root, path) :
            flock.isIterable(path) ? flock.input.getValuesForPathArray(root, path) :
            flock.input.getValuesForPathObject(root, path);
    };

    flock.input.resolveValue = function (root, path, val, target, inputName, previousInput, valueParser) {
        // Check to see if the value is actually a "get expression"
        // (i.e. an EL path wrapped in ${}) and resolve it if necessary.
        if (typeof val === "string") {
            var extracted = fluid.extractEL(val, flock.input.valueExpressionSpec);
            if (extracted) {
                var resolved = flock.input.getValueForPath(root, extracted);
                if (resolved === undefined) {
                    flock.log.debug("The value expression '" + val + "' resolved to undefined. " +
                    "If this isn't expected, check to ensure that your path is valid.");
                }

                return resolved;
            }
        }

        return flock.input.shouldExpand(inputName) && valueParser ?
            valueParser(val, path, target, previousInput) : val;
    };

    flock.input.valueExpressionSpec = {
        ELstyle: "${}"
    };

    flock.input.setValueForPath = function (root, path, val, baseTarget, valueParser) {
        path = flock.input.expandPath(path);

        var previousInput = flock.get(root, path),
            lastDotIdx = path.lastIndexOf("."),
            inputName = path.slice(lastDotIdx + 1),
            target = lastDotIdx > -1 ? flock.get(root, path.slice(0, path.lastIndexOf(".inputs"))) :
                baseTarget,
            resolvedVal = flock.input.resolveValue(root, path, val, target, inputName, previousInput, valueParser);

        flock.set(root, path, resolvedVal);

        if (target && target.onInputChanged) {
            target.onInputChanged(inputName);
        }

        return resolvedVal;
    };

    flock.input.setValuesForPaths = function (root, valueMap, baseTarget, valueParser) {
        var resultMap = {},
            path,
            val,
            result;

        for (path in valueMap) {
            val = valueMap[path];
            result = flock.input.set(root, path, val, baseTarget, valueParser);
            resultMap[path] = result;
        }

        return resultMap;
    };

    /**
     * Sets the value of the ugen at the specified path.
     *
     * @param {String} path the ugen's path within the synth graph
     * @param {Number || UGenDef} val a scalar value (for Value ugens) or a UGenDef object
     * @return {UGen} the newly created UGen that was set at the specified path
     */
    flock.input.set = function (root, path, val, baseTarget, valueParser) {
        return typeof path === "string" ?
            flock.input.setValueForPath(root, path, val, baseTarget, valueParser) :
            flock.input.setValuesForPaths(root, path, baseTarget, valueParser);
    };


    fluid.defaults("flock.nodeList", {
        gradeNames: ["fluid.littleComponent", "autoInit"],
        members: {
            nodes: [],
            namedNodes: {}
        }
    });

    flock.nodeList.preInit = function (that) {
        that.head = function (node) {
            that.nodes.unshift(node);
            if (node.nickName) {
                that.namedNodes[node.nickName] = node;
            }
            return 0;
        };

        that.before = function (refNode, node) {
            var refIdx = that.nodes.indexOf(refNode);
            that.insert(refIdx, node);
            return refIdx;
        };

        that.after = function (refNode, node) {
            var refIdx = that.nodes.indexOf(refNode),
                atIdx = refIdx + 1;
            that.insert(atIdx, node);
            return atIdx;
        };

        that.insert = function (idx, node) {
            if (idx < 0) {
                return that.head(node);
            }

            that.nodes.splice(idx, 0, node);
            if (node.nickName) {
                that.namedNodes[node.nickName] = node;
            }
            return idx;
        };

        that.tail = function (node) {
            that.nodes.push(node);
            if (node.nickName) {
                that.namedNodes[node.nickName] = node;
            }
            return that.nodes.length;
        };

        that.remove = function (node) {
            var idx = that.nodes.indexOf(node);
            if (idx < 0) {
                return idx;
            }

            that.nodes.splice(idx, 1);
            delete that.namedNodes[node.nickName];
            return idx;
        };

        that.replace = function (newNode, oldNode) {
            var idx = that.nodes.indexOf(oldNode);
            if (idx < 0) {
                return that.head(newNode);
            }

            that.nodes[idx] = newNode;
            delete that.namedNodes[oldNode.nickName];

            if (newNode.nickName) {
                that.namedNodes[newNode.nickName] = newNode;
            }
            return idx;
        };

        that.clearAll = function () {
            while (that.nodes.length > 0) {
                that.nodes.pop();
            }
        };
    };


    /***********************
     * Synths and Playback *
     ***********************/

    fluid.defaults("flock.enviro", {
        gradeNames: ["fluid.standardRelayComponent", "flock.nodeList", "autoInit"],

        members: {
            audioSettings: "@expand:flock.enviro.clampAudioSettings({that}.options.audioSettings)",
            buses: {
                expander: {
                    funcName: "flock.enviro.createAudioBuffers",
                    args: ["{that}.audioSettings.numBuses", "{that}.audioSettings.blockSize"]
                }
            },
            buffers: {},
            bufferSources: {}
        },

        model: {
            isPlaying: false,

            // TODO: Buses should probably be managed by their own component.
            nextAvailableBus: {
                input: 0,
                interconnect: 0
            }
        },

        audioSettings: {
            rates: {
                audio: 48000, // This is only a hint. Some audio backends (such as the Web Audio API)
                              // may define the sample rate themselves.
                control: undefined, // Control rate is calculated dynamically based on the audio rate and the block size.
                scheduled: undefined, // The scheduled rate is a user-specified parameter.
                demand: 0,
                constant: 0
            },
            blockSize: 64,
            chans: 2,
            numInputBuses: 2,
            numBuses: 8,
            // This buffer size determines the overall latency of Flocking's audio output.
            // TODO: Replace this with IoC awesomeness.
            bufferSize: flock.defaultBufferSizeForPlatform(),
        },

        components: {
            asyncScheduler: {
                type: "flock.scheduler.async"
            },

            audioStrategy: {
                type: "flock.audioStrategy.platform",
                options: {
                    audioSettings: "{enviro}.audioSettings"
                }
            }
        },

        invokers: {
            acquireNextBus: {
                funcName: "flock.enviro.acquireNextBus",
                args: [
                    "{arguments}.0", // The type of bus, either "input" or "interconnect".
                    "{that}.buses",
                    "{that}.applier",
                    "{that}.model",
                    "{that}.audioSettings"
                ]
            }
        },

        listeners: {
            onCreate: {
                funcName: "flock.enviro.calculateControlRate",
                args: ["{that}.audioSettings"]
            }
        }
    });

    flock.enviro.clampAudioSettings = function (s) {
        s.numInputBuses = Math.min(s.numInputBuses, flock.MAX_INPUT_BUSES);
        s.numInputBuses = Math.max(s.numInputBuses, flock.MIN_INPUT_BUSES);
        s.chans = Math.min(s.chans, flock.MAX_CHANNELS);
        s.numBuses = Math.max(s.numBuses, s.chans);
        s.numBuses = Math.max(s.numBuses, flock.MIN_BUSES);

        return s;
    };

    // TODO: This should be modelized.
    flock.enviro.calculateControlRate = function (audioSettings) {
        audioSettings.rates.control = audioSettings.rates.audio / audioSettings.blockSize;
        return audioSettings;
    };

    flock.enviro.acquireNextBus = function (type, buses, applier, m, s) {
        var busNum = m.nextAvailableBus[type];

        if (busNum === undefined) {
            flock.fail("An invalid bus type was specified when invoking " +
                "flock.enviro.acquireNextBus(). Type was: " + type);
            return;
        }

        // Input buses start immediately after the output buses.
        var offsetBusNum = busNum + s.chans,
            offsetBusMax = s.chans + s.numInputBuses;

        // Interconnect buses are after the input buses.
        if (type === "interconnect") {
            offsetBusNum += s.numInputBuses;
            offsetBusMax = buses.length;
        }

        if (offsetBusNum >= offsetBusMax) {
            flock.fail("Unable to aquire a bus. There are insufficient buses available. " +
                "Please use an existing bus or configure additional buses using the enviroment's " +
                "numBuses and numInputBuses parameters.");
            return;
        }

        applier.change("nextAvailableBus." + type, ++busNum);

        return offsetBusNum;
    };

    flock.enviro.preInit = function (that) {

        /**
         * Starts generating samples from all synths.
         */
        that.start = function () {
            if (that.model.isPlaying) {
                return;
            }

            that.audioStrategy.start();
            that.model.isPlaying = true;
        };

        /**
         * Deprecated. Use start() instead.
         */
        that.play = that.start;

        /**
         * Stops generating samples from all synths.
         */
        that.stop = function () {
            if (!that.model.isPlaying) {
                return;
            }

            that.audioStrategy.stop();
            that.model.isPlaying = false;
        };

        // TODO: This should be factored as an event.
        that.reset = function () {
            that.stop();
            that.asyncScheduler.clearAll();
            that.applier.change("nextAvailableBus.input", 0);
            that.applier.change("nextAvailableBus.interconnect", 0);
            that.audioStrategy.reset();
            that.clearAll();
        };

        that.registerBuffer = function (bufDesc) {
            if (bufDesc.id) {
                that.buffers[bufDesc.id] = bufDesc;
            }
        };

        that.releaseBuffer = function (bufDesc) {
            if (!bufDesc) {
                return;
            }

            var id = typeof bufDesc === "string" ? bufDesc : bufDesc.id;
            delete that.buffers[id];
        };
    };

    flock.enviro.finalInit = function (that) {

        that.gen = function () {
            var evaluator = that.audioStrategy.nodeEvaluator;
            evaluator.clearBuses();
            evaluator.gen();
        };

    };

    flock.enviro.createAudioBuffers = function (numBufs, blockSize) {
        var bufs = [],
            i;
        for (i = 0; i < numBufs; i++) {
            bufs[i] = new Float32Array(blockSize);
        }
        return bufs;
    };


    fluid.defaults("flock.audioStrategy", {
        gradeNames: ["fluid.standardRelayComponent"],

        components: {
            nodeEvaluator: {
                type: "flock.enviro.nodeEvaluator",
                options: {
                    numBuses: "{enviro}.options.audioSettings.numBuses",
                    blockSize: "{enviro}.options.audioSettings.blockSize",
                    members: {
                        buses: "{enviro}.buses",
                        nodes: "{enviro}.nodes"
                    }
                }
            }
        }
    });

    /*****************
     * Node Evalutor *
     *****************/

    fluid.defaults("flock.enviro.nodeEvaluator", {
        gradeNames: ["fluid.littleComponent", "autoInit"]
    });

    flock.enviro.nodeEvaluator.finalInit = function (that) {
        that.clearBuses = function () {
            var numBuses = that.options.numBuses,
                busLen = that.options.blockSize,
                i,
                bus,
                j;

            for (i = 0; i < numBuses; i++) {
                bus = that.buses[i];
                for (j = 0; j < busLen; j++) {
                    bus[j] = 0;
                }
            }
        };

        that.gen = function () {
            var nodes = that.nodes,
                i,
                node;

            for (i = 0; i < nodes.length; i++) {
                node = nodes[i];
                node.gen(node.model.blockSize);
            }
        };
    };


    fluid.defaults("flock.autoEnviro", {
        gradeNames: ["fluid.littleComponent", "autoInit"]
    });

    flock.autoEnviro.preInit = function () {
        if (!flock.enviro.shared) {
            flock.init();
        }
    };


    fluid.defaults("flock.node", {
        gradeNames: ["flock.autoEnviro", "fluid.modelComponent", "autoInit"]
    });

    fluid.defaults("flock.ugenNodeList", {
        gradeNames: ["flock.nodeList", "autoInit"]
    });

    flock.ugenNodeList.finalInit = function (that) {

        /**
         * Inserts a unit generator and all its inputs into the node list, starting at the specified index.
         * Note that the node itself will not be insert into the list at this index--its inputs must
         * must be ahead of it in the list.
         *
         * @param {Number} idx the index to start adding the new node and its inputs at
         * @param {UGen} node the node to add, along with its inputs
         * @return {Number} the index at which the specified node was inserted
         */
        that.insertTree = function (idx, node) {
            var inputs = node.inputs,
                key,
                input;

            for (key in inputs) {
                input = inputs[key];
                if (flock.isUGen(input)) {
                    idx = that.insertTree(idx, input);
                    idx++;
                }
            }

            return that.insert(idx, node);
        };

        /**
         * Removes the specified unit generator and all its inputs from the node list.
         *
         * @param {UGen} node the node to remove along with its inputs
         * @return {Number} the index at which the node was removed
         */
        that.removeTree = function (node) {
            var inputs = node.inputs,
                key,
                input;

            for (key in inputs) {
                input = inputs[key];
                if (typeof input !== "number") {
                    that.removeTree(input);
                }
            }

            return that.remove(node);
        };

        /**
         * Replaces one node and all its inputs with a new node and its inputs.
         *
         * @param {UGen} newNode the node to add to the list
         * @param {UGen} oldNode the node to remove from the list
         * @return {Number} idx the index at which the new node was added
         */
        that.replaceTree = function (newNode, oldNode) {
            if (!oldNode) {
                 // Can't use .tail() because it won't recursively add inputs.
                return that.insertTree(that.nodes.length, newNode);
            }

            var idx = that.removeTree(oldNode);
            that.insertTree(idx, newNode);

            return idx;
        };

        /**
         * Swaps one node in the list for another in place, attaching the previous unit generator's
         * inputs to the new one. If a list of inputsToReattach is specified, only these inputs will
         * be swapped.
         *
         * Note that this function will directly modify the nodes in question.
         *
         * @param {UGen} newNode the node to add to the list, swapping it in place for the old one
         * @param {UGen} oldNode the node remove from the list
         * @param {Array} inputsToReattach a list of inputNames to attach to the new node from the old one
         * @return the index at which the new node was inserted
         */
        that.swapTree = function (newNode, oldNode, inputsToReattach) {
            var inputName;

            if (!inputsToReattach) {
                newNode.inputs = oldNode.inputs;
            } else {
                for (inputName in oldNode.inputs) {
                    if (inputsToReattach.indexOf(inputName) < 0) {
                        that.removeTree(oldNode.inputs[inputName]);
                    } else {
                        newNode.inputs[inputName] = oldNode.inputs[inputName];
                    }
                }

                for (inputName in newNode.inputs) {
                    if (inputsToReattach.indexOf(inputName) < 0) {
                        that.replaceTree(newNode.inputs[inputName], oldNode.inputs[inputName]);
                    }
                }
            }

            return that.replace(newNode, oldNode);
        };
    };

    fluid.defaults("flock.synth", {
        gradeNames: [
            "fluid.eventedComponent",
            "fluid.modelComponent",
            "flock.node",
            "flock.ugenNodeList",
            "autoInit"
        ],

        rate: flock.rates.AUDIO,

        invokers: {
            /**
             * Plays the synth. This is a convenience method that will add the synth to the tail of the
             * environment's node graph and then play the environmnent.
             *
             * @param {Number} dur optional duration to play this synth in seconds
             */
            play: {
                funcName: "flock.synth.play",
                args: ["{that}", "{that}.enviro"]
            },

            /**
             * Stops the synth if it is currently playing.
             * This is a convenience method that will remove the synth from the environment's node graph.
             */
            pause: {
                funcName: "flock.synth.pause",
                args: ["{that}", "{that}.enviro"]
            }
        },

        listeners: {
            onDestroy: {
                "func": "{that}.pause"
            }
        }
    });

    flock.synth.play = function (that, en) {
        if (en.nodes.indexOf(that) === -1) {
            en.head(that);
        }

        if (!en.model.isPlaying) {
            en.play();
        }
    };

    flock.synth.pause = function (that, en) {
        en.remove(that);
    };

    /**
     * Synths represent a collection of signal-generating units, wired together to form an instrument.
     * They are created with a synthDef object, a declarative structure describing the synth's unit generator graph.
     */
    flock.synth.finalInit = function (that) {
        that.rate = that.options.rate;
        that.enviro = that.enviro || flock.enviro.shared;
        that.audioSettings = $.extend(true, {}, that.enviro.audioSettings, that.options.audioSettings);
        that.model.blockSize = that.rate === flock.rates.AUDIO ? that.audioSettings.blockSize : 1;

        /**
         * Generates one block of audio rate signal by evaluating this synth's unit generator graph.
         */
        // TODO: This function is marked as unoptimized by the Chrome profiler.
        that.gen = function () {
            var m = that.model,
                nodes = that.nodes,
                i,
                node;

            for (i = 0; i < nodes.length; i++) {
                node = nodes[i];
                if (node.gen !== undefined) {
                    node.gen(node.model.blockSize);
                }

                m.value = node.model.value;
            }
        };

        /**
         * Gets the value of the ugen at the specified path.
         *
         * @param {String} path the ugen's path within the synth graph
         * @return {Number|UGen} a scalar value in the case of a value ugen, otherwise the ugen itself
         */
        that.get = function (path) {
            return flock.input.get(that.namedNodes, path);
        };


        /**
         * Sets the value of the ugen at the specified path.
         *
         * @param {String} path the ugen's path within the synth graph
         * @param {Number || UGenDef} val a scalar value (for Value ugens) or a UGenDef object
         * @return {UGen} the newly created UGen that was set at the specified path
         */
        that.set = function (path, val, swap) {
            return flock.input.set(that.namedNodes, path, val, undefined, function (ugenDef, path, target, prev) {
                return flock.synth.ugenValueParser(that, ugenDef, prev, swap);
            });
        };

        /**
         * Gets or sets the value of a ugen at the specified path
         *
         * @param {String} path the ugen's path within the synth graph
         * @param {Number || UGenDef || Array} val an optional value to to set--a scalar value, a UGenDef object, or an array of UGenDefs
         * @param {Boolean || Object} swap specifies if the existing inputs should be swapped onto the new value
         * @return {Number || UGenDef || Array} the value that was set or retrieved
         */
        that.input = function (path, val, swap) {
            return !path ? undefined : typeof path === "string" ?
                arguments.length < 2 ? that.get(path) : that.set(path, val, swap) :
                flock.isIterable(path) ? that.get(path) : that.set(path, val, swap);
        };

        that.init = function () {
            var o = that.options,
                // At demand or schedule rates, override the rate of all non-constant ugens.
                overrideRate = o.rate === flock.rates.SCHEDULED || o.rate === flock.rates.DEMAND;

            if (!o.synthDef) {
                fluid.log(fluid.logLevel.IMPORTANT,
                    "Warning: Instantiating a flock.synth instance with an empty synth def.");
            }

            // Parse the synthDef into a graph of unit generators.
            that.out = flock.parse.synthDef(o.synthDef, {
                rate: o.rate,
                overrideRate: overrideRate,
                visitors: that.tail,
                buffers: that.enviro.buffers,
                buses: that.enviro.buses,
                audioSettings: that.audioSettings
            });

            // Add this synth to the tail of the synthesis environment if appropriate.
            if (o.addToEnvironment !== false) {
                that.enviro.tail(that);
            }
        };

        that.init();
        return that;
    };

    flock.synth.ugenValueParser = function (that, ugenDef, prev, swap) {
        if (ugenDef === null || ugenDef === undefined) {
            return prev;
        }

        var parsed = flock.parse.ugenDef(ugenDef, {
            audioSettings: that.audioSettings,
            buses: that.enviro.buses,
            buffers: that.enviro.buffers
        });

        var newUGens = flock.isIterable(parsed) ? parsed : (parsed !== undefined ? [parsed] : []),
            oldUGens = flock.isIterable(prev) ? prev : (prev !== undefined ? [prev] : []);

        var replaceLen = Math.min(newUGens.length, oldUGens.length),
            replaceFn = swap ? that.swapTree : that.replaceTree,
            i,
            atIdx,
            j;

        // TODO: Improve performance by handling arrays inline instead of repeated function calls.
        for (i = 0; i < replaceLen; i++) {
            atIdx = replaceFn(newUGens[i], oldUGens[i]);
        }

        for (j = i; j < newUGens.length; j++) {
            atIdx++;
            that.insertTree(atIdx, newUGens[j]);
        }

        for (j = i; j < oldUGens.length; j++) {
            that.removeTree(oldUGens[j]);
        }

        return parsed;
    };

    /**
     * Makes a new synth.
     * Deprecated. Use flock.synth instead. This is provided for semi-backwards-compatibility with
     * previous version of Flocking where flock.synth had a multi-argument signature.
     */
    flock.synth.make = function (def, options) {
        options = options || {};
        options.synthDef = def;
        return flock.synth(options);
    };

    fluid.defaults("flock.synth.value", {
        gradeNames: ["flock.synth", "autoInit"],

        rate: "demand",

        addToEnvironment: false
    });

    flock.synth.value.finalInit = function (that) {
        that.value = function () {
            that.gen(1);
            return that.model.value;
        };
    };


    fluid.defaults("flock.synth.frameRate", {
        gradeNames: ["flock.synth.value", "autoInit"],

        rate: "scheduled",

        fps: 60,

        audioSettings: {
            rates: {
                scheduled: "{that}.options.fps"
            }
        }
    });


    fluid.defaults("flock.synth.group", {
        gradeNames: ["fluid.eventedComponent", "flock.node", "flock.nodeList", "autoInit"],
        rate: flock.rates.AUDIO
    });

    flock.synth.group.finalInit = function (that) {
        that.rate = that.options.rate;
        that.enviro = that.enviro || flock.enviro.shared;

        flock.synth.group.makeDispatchedMethods(that, [
            "input", "get", "set", "gen", "play", "pause"
        ]);

        that.init = function () {
            if (that.options.addToEnvironment !== false) {
                that.enviro.tail(that);
            }
        };

        that.init();
    };

    flock.synth.group.makeDispatcher = function (nodes, msg) {
        return function () {
            var i,
                node,
                val;
            for (i = 0; i < nodes.length; i++) {
                node = nodes[i];
                val = node[msg].apply(node, arguments);
            }

            return val;
        };
    };

    flock.synth.group.makeDispatchedMethods = function (that, methodNames) {
        var name,
            i;

        for (i = 0; i < methodNames.length; i++) {
            name = methodNames[i];
            that[name] = flock.synth.group.makeDispatcher(that.nodes, name, flock.synth.group.dispatch);
        }

        return that;
    };


    fluid.defaults("flock.synth.polyphonic", {
        gradeNames: ["flock.synth.group", "autoInit"],
        noteSpecs: {
            on: {
                "env.gate": 1
            },
            off: {
                "env.gate": 0
            }
        },
        maxVoices: 16,
        initVoicesLazily: true,
        amplitudeKey: "env.sustain",
        amplitudeNormalizer: "static" // "dynamic", "static", Function, falsey
    });

    flock.synth.polyphonic.finalInit = function (that) {
        that.activeVoices = {};
        that.freeVoices = [];

        that.noteChange = function (voice, eventName, changeSpec) {
            var noteEventSpec = that.options.noteSpecs[eventName];
            changeSpec = $.extend({}, noteEventSpec, changeSpec);
            voice.input(changeSpec);
        };

        that.noteOn = function (noteName, changeSpec) {
            var voice = that.nextFreeVoice();
            if (that.activeVoices[noteName]) {
                that.noteOff(noteName);
            }
            that.activeVoices[noteName] = voice;
            that.noteChange(voice, "on", changeSpec);

            return voice;
        };

        that.noteOff = function (noteName, changeSpec) {
            var voice = that.activeVoices[noteName];
            if (!voice) {
                return null;
            }
            that.noteChange(voice, "off", changeSpec);
            delete that.activeVoices[noteName];
            that.freeVoices.push(voice);

            return voice;
        };

        that.createVoice = function () {
            var voice = flock.synth({
                synthDef: that.options.synthDef,
                addToEnvironment: false
            });

            var normalizer = that.options.amplitudeNormalizer,
                ampKey = that.options.amplitudeKey,
                normValue;

            if (normalizer) {
                if (typeof normalizer === "function") {
                    normalizer(voice, ampKey);
                } else if (normalizer === "static") {
                    normValue = 1.0 / that.options.maxVoices;
                    voice.input(ampKey, normValue);
                }
                // TODO: Implement dynamic voice normalization.
            }
            that.nodes.push(voice);

            return voice;
        };

        that.pooledVoiceAllocator = function () {
            return that.freeVoices.pop();
        };

        that.lazyVoiceAllocator = function () {
            return that.freeVoices.length > 1 ?
                that.freeVoices.pop() : Object.keys(that.activeVoices).length > that.options.maxVoices ?
                null : that.createVoice();
        };

        that.init = function () {
            if (!that.options.initVoicesLazily) {
                var i;
                for (i = 0; i < that.options.maxVoices; i++) {
                    that.freeVoices[i] = that.createVoice();
                }
                that.nextFreeVoice = that.pooledVoiceAllocator;
            } else {
                that.nextFreeVoice = that.lazyVoiceAllocator;
            }
        };

        that.init();
        return that;
    };

    /**
     * flock.band provides an IoC-friendly interface for a collection of named synths.
     */
    // TODO: Unit tests.
    fluid.defaults("flock.band", {
        gradeNames: ["fluid.eventedComponent", "autoInit"],

        invokers: {
            play: {
                func: "{that}.events.onPlay.fire"
            },

            pause: {
                func: "{that}.events.onPause.fire"
            },

            set: {
                func: "{that}.events.onSet.fire"
            }
        },

        events: {
            onPlay: null,
            onPause: null,
            onSet: null
        },

        distributeOptions: {
            source: "{that}.options.synthListeners",
            removeSource: true,
            target: "{that flock.synth}.options.listeners"
        },

        synthListeners: {
            "{band}.events.onPlay": {
                func: "{that}.play"
            },

            "{band}.events.onPause": {
                func: "{that}.pause"
            }
        }
    });

    /*******************************
     * Error Handling Conveniences *
     *******************************/

    flock.bufferDesc = function () {
        throw new Error("flock.bufferDesc is not defined. Did you forget to include the flocking-buffers.js file?");
    };
}());
;/*
* Flocking Audio Buffers
* http://github.com/colinbdclark/flocking
*
* Copyright 2013-14, Colin Clark
* Dual licensed under the MIT and GPL Version 2 licenses.
*/

/*global require, AudioBuffer*/
/*jshint white: false, newcap: true, regexp: true, browser: true,
    forin: false, nomen: true, bitwise: false, maxerr: 100,
    indent: 4, plusplus: false, curly: true, eqeqeq: true,
    freeze: true, latedef: true, noarg: true, nonew: true, quotmark: double, undef: true,
    unused: true, strict: true, asi: false, boss: false, evil: false, expr: false,
    funcscope: false*/

var fluid = fluid || require("infusion"),
    flock = fluid.registerNamespace("flock");

(function () {
    "use strict";

    // Based on Brian Cavalier and John Hann's Tiny Promises library.
    // https://github.com/unscriptable/promises/blob/master/src/Tiny2.js
    function Promise() {
        var resolve = function (result) {
            complete("resolve", result);
            promise.state = "fulfilled";
        };

        var reject = function (err) {
            complete("reject", err);
            promise.state = "rejected";
        };

        var then = function (resolve, reject) {
            if (callbacks) {
                callbacks.push({
                    resolve: resolve,
                    reject: reject
                });
            } else {
                var fn = promise.state === "fulfilled" ? resolve : reject;
                fn(promise.value);
            }

            return this;
        };

        var callbacks = [],
            promise = {
                state: "pending",
                value: undefined,
                resolve: resolve,
                reject: reject,
                then: then,
                safe: {
                    then: function safeThen(resolve, reject) {
                        promise.then(resolve, reject);
                        return this;
                    }
                }
            };


        function complete(type, result) {
            var rejector = function (resolve, reject) {
                reject(result);
                return this;
            };

            var resolver = function (resolve) {
                resolve(result);
                return this;
            };

            promise.value = result;
            promise.then = type === "reject" ? rejector : resolver;
            promise.resolve = promise.reject = function () {
                throw new Error("Promise already completed");
            };

            invokeCallbacks(type, result);
        }

        function invokeCallbacks (type, result) {
            var i,
                cb;

            for (i = 0; i < callbacks.length; i++) {
                cb = callbacks[i];

                if (cb[type]) {
                    cb[type](result);
                }
            }

            callbacks = null;
        }

        return promise;
    }

    fluid.defaults("flock.promise", {
        gradeNames: ["fluid.eventedComponent", "autoInit"],

        members: {
            promise: {
                expander: {
                    funcName: "flock.promise.make"
                }
            }
        }
    });

    flock.promise.make = function () {
        return new Promise();
    };

    // TODO: This is actually part of the interpreter's expansion process
    // and should be clearly named as such.
    flock.bufferDesc = function (data) {
        var fn = flock.platform.isWebAudio && data instanceof AudioBuffer ?
            flock.bufferDesc.fromAudioBuffer : flock.isIterable(data) ?
            flock.bufferDesc.fromChannelArray : flock.bufferDesc.expand;

        return fn(data);
    };

    flock.bufferDesc.inferFormat = function (bufDesc) {
        var format = bufDesc.format,
            data = bufDesc.data;

        format.sampleRate = format.sampleRate || 44100;
        format.numSampleFrames = format.numSampleFrames || data.channels[0].length;
        format.duration = format.numSampleFrames / format.sampleRate;

        return bufDesc;
    };

    flock.bufferDesc.fromChannelArray = function (arr, sampleRate) {
        var bufDesc = {
            container: {},

            format: {
                numChannels: 1,
                sampleRate: sampleRate
            },

            data: {
                channels: [arr]
            }
        };

        return flock.bufferDesc.inferFormat(bufDesc);
    };

    flock.bufferDesc.expand = function (bufDesc) {
        bufDesc.container = bufDesc.container || {};
        bufDesc.format = bufDesc.format || {};

        bufDesc.format.numChannels = bufDesc.format.numChannels || bufDesc.data.channels.length;

        if (bufDesc.data && bufDesc.data.channels) {
            // Special case for an unwrapped single-channel array.
            if (bufDesc.format.numChannels === 1 && bufDesc.data.channels.length !== 1) {
                bufDesc.data.channels = [bufDesc.data.channels];
            }

            if (bufDesc.format.numChannels !== bufDesc.data.channels.length) {
                throw new Error("The specified number of channels does not match " +
                    "the actual channel data. " +
                    "numChannels was: " + bufDesc.format.numChannels +
                    " but the sample data contains " + bufDesc.data.channels.length + " channels.");
            }
        }

        return flock.bufferDesc.inferFormat(bufDesc);
    };

    flock.bufferDesc.fromAudioBuffer = function (audioBuffer) {
        var desc = {
            container: {},
            format: {
                sampleRate: audioBuffer.sampleRate,
                numChannels: audioBuffer.numberOfChannels,
                numSampleFrames: audioBuffer.length,
                duration: audioBuffer.duration
            },
            data: {
                channels: []
            }
        },
        i;

        for (i = 0; i < audioBuffer.numberOfChannels; i++) {
            desc.data.channels.push(audioBuffer.getChannelData(i));
        }

        return desc;
    };


    /**
     * Represents a source for fetching buffers.
     */
    fluid.defaults("flock.bufferSource", {
        gradeNames: ["fluid.eventedComponent", "fluid.modelComponent", "autoInit"],

        model: {
            state: "start",
            src: null
        },

        components: {
            bufferPromise: {
                createOnEvent: "onRefreshPromise",
                type: "flock.promise",
                options: {
                    listeners: {
                        onCreate: {
                            "this": "{that}.promise",
                            method: "then",
                            args: ["{bufferSource}.events.afterFetch.fire", "{bufferSource}.events.onError.fire"]
                        }
                    }
                }
            }
        },

        invokers: {
            get: {
                funcName: "flock.bufferSource.get",
                args: ["{that}", "{arguments}.0"]
            },

            set: {
                funcName: "flock.bufferSource.set",
                args: ["{that}", "{arguments}.0"]
            },

            error: {
                funcName: "flock.bufferSource.error",
                args: ["{that}", "{arguments}.0"]
            }
        },

        listeners: {
            onCreate: {
                funcName: "{that}.events.onRefreshPromise.fire"
            },

            onRefreshPromise: {
                funcName: "{that}.applier.requestChange",
                args: ["state", "start"]
            },

            onFetch: {
                funcName: "{that}.applier.requestChange",
                args: ["state", "in-progress"]
            },

            afterFetch: [
                {
                    funcName: "{that}.applier.requestChange",
                    args: ["state", "fetched"]
                },
                {
                    funcName: "{that}.events.onBufferUpdated.fire", // TODO: Replace with boiling?
                    args: ["{arguments}.0"]
                }
            ],

            onBufferUpdated: {
                // TODO: Hardcoded reference to shared environment.
                funcName: "flock.enviro.shared.registerBuffer",
                args: ["{arguments}.0"]
            },

            onError: {
                funcName: "{that}.applier.requestChange",
                args: ["state", "error"]
            }
        },

        events: {
            onRefreshPromise: null,
            onError: null,
            onFetch: null,
            afterFetch: null,
            onBufferUpdated: null
        }
    });

    flock.bufferSource.get = function (that, bufDef) {
        if (that.model.state === "in-progress" || (bufDef.src === that.model.src && !bufDef.replace)) {
            // We've already fetched the buffer or are in the process of doing so.
            return that.bufferPromise.promise;
        }

        if (bufDef.src) {
            if ((that.model.state === "fetched" || that.model.state === "errored") &&
                (that.model.src !== bufDef.src || bufDef.replace)) {
                that.events.onRefreshPromise.fire();
            }

            if (that.model.state === "start") {
                that.model.src = bufDef.src;
                that.events.onFetch.fire(bufDef);
                flock.audio.decode({
                    src: bufDef.src,
                    success: function (bufDesc) {
                        if (bufDef.id) {
                            bufDesc.id = bufDef.id;
                        }

                        that.set(bufDesc);
                    },
                    error: that.error
                });
            }
        }

        return that.bufferPromise.promise;
    };

    flock.bufferSource.set = function (that, bufDesc) {
        var state = that.model.state;
        if (state === "start" || state === "in-progress") {
            that.bufferPromise.promise.resolve(bufDesc);
        }

        return that.bufferPromise.promise;
    };

    flock.bufferSource.error = function (that, msg) {
        that.bufferPromise.promise.reject(msg);

        return that.bufferPromise.promise;
    };

    /**
     * A Buffer Loader is responsible for loading a collection
     * of buffers asynchronously, and will fire an event when they
     * are all ready.
     */
    fluid.defaults("flock.bufferLoader", {
        gradeNames: ["fluid.eventedComponent", "autoInit"],

        members: {
            buffers: []
        },

        // A list of BufferDef objects to resolve.
        bufferDefs: [],

        events: {
            afterBuffersLoaded: null
        },

        listeners: {
            onCreate: {
                funcName: "flock.bufferLoader.loadBuffers",
                args: ["{that}.options.bufferDefs", "{that}.buffers", "{that}.events.afterBuffersLoaded.fire"]
            }
        }
    });

    flock.bufferLoader.idFromURL = function (url) {
        var lastSlash = url.lastIndexOf("/"),
            idStart = lastSlash > -1 ? lastSlash + 1 : 0,
            ext = url.lastIndexOf("."),
            idEnd = ext > -1 ? ext : url.length;

        return url.substring(idStart, idEnd);
    };

    flock.bufferLoader.idsFromURLs = function (urls) {
        return fluid.transform(urls, flock.bufferLoader.idFromURL);
    };

    flock.bufferLoader.expandFileSequence = function (fileURLs) {
        fileURLs = fileURLs || [];

        var bufDefs = [],
            i,
            url,
            id;

        for (i = 0; i < fileURLs.length; i++) {
            url = fileURLs[i];
            id = flock.bufferLoader.idFromURL(url);
            bufDefs.push({
                id: id,
                url: url
            });
        }

        return bufDefs;
    };

    flock.bufferLoader.loadBuffers = function (bufferDefs, decodedBuffers, afterBuffersLoaded) {
        bufferDefs = fluid.makeArray(bufferDefs);

        // TODO: This is a sign that flock.parse.bufferForDef is still terribly broken.
        var bufferTarget = {
            setBuffer: function (decoded) {
                decodedBuffers.push(decoded);

                if (decodedBuffers.length === bufferDefs.length) {
                    afterBuffersLoaded(decodedBuffers);
                }
            }
        };

        for (var i = 0; i < bufferDefs.length; i++) {
            var bufDef = bufferDefs[i];
            if (bufDef.id === undefined && bufDef.url !== undefined) {
                bufDef.id = flock.bufferLoader.idFromURL(bufDef.url);
            }

            // TODO: Hardcoded reference to the shared environment.
            flock.parse.bufferForDef(bufferDefs[i], bufferTarget, flock.enviro.shared);
        }
    };

}());
;/*
* Flocking Parser
* http://github.com/colinbdclark/flocking
*
* Copyright 2011-2014, Colin Clark
* Dual licensed under the MIT and GPL Version 2 licenses.
*/

/*global require, Float32Array*/
/*jshint white: false, newcap: true, regexp: true, browser: true,
    forin: false, nomen: true, bitwise: false, maxerr: 100,
    indent: 4, plusplus: false, curly: true, eqeqeq: true,
    freeze: true, latedef: true, noarg: true, nonew: true, quotmark: double, undef: true,
    unused: true, strict: true, asi: false, boss: false, evil: false, expr: false,
    funcscope: false*/

var fluid = fluid || require("infusion"),
    flock = fluid.registerNamespace("flock");

(function () {
    "use strict";

    var $ = fluid.registerNamespace("jQuery");
    fluid.registerNamespace("flock.parse");

    flock.parse.synthDef = function (ugenDef, options) {
        if (!ugenDef) {
            ugenDef = [];
        }

        if (!flock.parse.synthDef.hasOutUGen(ugenDef)) {
            // We didn't get an out ugen specified, so we need to make one.
            ugenDef = {
                id: flock.OUT_UGEN_ID,
                ugen: "flock.ugen.valueOut",
                inputs: {
                    sources: ugenDef
                }
            };

            if (options.rate === flock.rates.AUDIO) {
                ugenDef.ugen = "flock.ugen.out";
                ugenDef.inputs.bus = 0;
                ugenDef.inputs.expand = options.audioSettings.chans;
            }
        }

        return flock.parse.ugenForDef(ugenDef, options);
    };

    flock.parse.synthDef.hasOutUGen = function (synthDef) {
        // TODO: This is hostile to third-party extension.
        return !flock.isIterable(synthDef) && (
            synthDef.id === flock.OUT_UGEN_ID ||
            synthDef.ugen === "flock.ugen.out" ||
            synthDef.ugen === "flock.ugen.valueOut"
        );
    };

    flock.parse.makeUGen = function (ugenDef, parsedInputs, options) {
        var rates = options.audioSettings.rates,
            blockSize = options.audioSettings.blockSize;

        // Assume audio rate if no rate was specified by the user.
        if (!ugenDef.rate) {
            ugenDef.rate = flock.rates.AUDIO;
        }

        var sampleRate;
        // Set the ugen's sample rate value according to the rate the user specified.
        if (ugenDef.options && ugenDef.options.sampleRate !== undefined) {
            sampleRate = ugenDef.options.sampleRate;
        } else {
            sampleRate = rates[ugenDef.rate];
        }

        // TODO: Infusion options merging!
        ugenDef.options = $.extend(true, {}, ugenDef.options, {
            sampleRate: sampleRate,
            rate: ugenDef.rate,
            audioSettings: {
                rates: rates,
                blockSize: blockSize
            }
        });
        // TODO: When we switch to Infusion options merging, these should have a mergePolicy of preserve.
        ugenDef.options.audioSettings.buffers = options.buffers;
        ugenDef.options.audioSettings.buses = options.buses;

        var outputBufferSize = ugenDef.rate === flock.rates.AUDIO ? blockSize : 1,
            outputBuffers;

        if (flock.hasTag(ugenDef.options, "flock.ugen.multiChannelOutput")) {
            var numOutputs = ugenDef.options.numOutputs || 1;
            outputBuffers = [];

            for (var i = 0; i < numOutputs; i++) {
                outputBuffers.push(new Float32Array(outputBufferSize));
            }
        } else {
            outputBuffers = new Float32Array(outputBufferSize);
        }

        return flock.invoke(undefined, ugenDef.ugen, [
            parsedInputs,
            outputBuffers,
            ugenDef.options
        ]);
    };


    flock.parse.reservedWords = ["id", "ugen", "rate", "inputs", "options"];
    flock.parse.specialInputs = ["value", "buffer", "list", "table", "envelope"];

    flock.parse.expandUGenDef = function (ugenDef) {
        var inputs = {},
            prop;

        // Copy any non-reserved properties from the top-level ugenDef object into the inputs property.
        for (prop in ugenDef) {
            if (flock.parse.reservedWords.indexOf(prop) === -1) {
                inputs[prop] = ugenDef[prop];
                delete ugenDef[prop];
            }
        }
        ugenDef.inputs = inputs;

        return ugenDef;
    };

    flock.parse.ugenDefForConstantValue = function (value) {
        return {
            ugen: "flock.ugen.value",
            rate: flock.rates.CONSTANT,
            inputs: {
                value: value
            }
        };
    };

    flock.parse.expandValueDef = function (ugenDef) {
        var type = typeof (ugenDef);
        if (type === "number") {
            return flock.parse.ugenDefForConstantValue(ugenDef);
        }

        if (type === "object") {
            return ugenDef;
        }

        throw new Error("Invalid value type found in ugen definition. UGenDef was: " +
            fluid.prettyPrintJSON(ugenDef));
    };

    flock.parse.rateMap = {
        "ar": flock.rates.AUDIO,
        "kr": flock.rates.CONTROL,
        "sr": flock.rates.SCHEDULED,
        "dr": flock.rates.DEMAND,
        "cr": flock.rates.CONSTANT
    };

    flock.parse.expandRate = function (ugenDef, options) {
        ugenDef.rate = flock.parse.rateMap[ugenDef.rate] || ugenDef.rate;
        if (options.overrideRate && ugenDef.rate !== flock.rates.CONSTANT) {
            ugenDef.rate = options.rate;
        }

        return ugenDef;
    };

    flock.parse.ugenDef = function (ugenDefs, options) {
        var parseFn = flock.isIterable(ugenDefs) ? flock.parse.ugensForDefs : flock.parse.ugenForDef;
        var parsed = parseFn(ugenDefs, options);
        return parsed;
    };

    flock.parse.ugenDef.mergeOptions = function (ugenDef) {
        // TODO: Infusion options merging.
        var defaults = fluid.defaults(ugenDef.ugen) || {};

        // TODO: Insane!
        defaults = fluid.copy(defaults);
        defaults.options = defaults.ugenOptions;
        delete defaults.ugenOptions;
        //

        return $.extend(true, {}, defaults, ugenDef);
    };

    flock.parse.ugensForDefs = function (ugenDefs, options) {
        var parsed = [],
            i;
        for (i = 0; i < ugenDefs.length; i++) {
            parsed[i] = flock.parse.ugenForDef(ugenDefs[i], options);
        }
        return parsed;
    };

    /**
     * Creates a unit generator for the specified unit generator definition spec.
     *
     * ugenDefs are plain old JSON objects describing the characteristics of the desired unit generator, including:
     *      - ugen: the type of unit generator, as string (e.g. "flock.ugen.sinOsc")
     *      - rate: the rate at which the ugen should be run, either "audio", "control", or "constant"
     *      - id: an optional unique name for the unit generator, which will make it available as a synth input
     *      - inputs: a JSON object containing named key/value pairs for inputs to the unit generator
     *           OR
     *      - inputs keyed by name at the top level of the ugenDef
     *
     * @param {UGenDef} ugenDef the unit generator definition to parse
     * @param {Object} options an options object containing:
     *           {Object} audioSettings the environment's audio settings
     *           {Array} buses the environment's global buses
     *           {Array} buffers the environment's global buffers
     *           {Array of Functions} visitors an optional list of visitor functions to invoke when the ugen has been created
     * @return the parsed unit generator object
     */
    flock.parse.ugenForDef = function (ugenDef, options) {
        options = $.extend(true, {
            audioSettings: flock.enviro.shared.options.audioSettings,
            buses: flock.enviro.shared.buses,
            buffers: flock.enviro.shared.buffers
        }, options);

        var o = options,
            visitors = o.visitors,
            rates = o.audioSettings.rates;

        // If we receive a plain scalar value, expand it into a value ugenDef.
        ugenDef = flock.parse.expandValueDef(ugenDef);

        // We received an array of ugen defs.
        if (flock.isIterable(ugenDef)) {
            return flock.parse.ugensForDefs(ugenDef, options);
        }

        if (!ugenDef.inputs) {
            ugenDef = flock.parse.expandUGenDef(ugenDef);
        }

        flock.parse.expandRate(ugenDef, options);
        ugenDef = flock.parse.ugenDef.mergeOptions(ugenDef, options);

        var inputDefs = ugenDef.inputs,
            inputs = {},
            inputDef;

        // TODO: This notion of "special inputs" should be refactored as a pluggable system of
        // "input expanders" that are responsible for processing input definitions of various sorts.
        // In particular, buffer management should be here so that we can initialize bufferDefs more
        // proactively and remove this behaviour from flock.ugen.buffer.
        for (inputDef in inputDefs) {
            var inputDefVal = inputDefs[inputDef];

            if (inputDefVal === null) {
                continue; // Skip null inputs.
            }

            // Create ugens for all inputs except special inputs.
            inputs[inputDef] = flock.input.shouldExpand(inputDef, ugenDef) ?
                flock.parse.ugenForDef(inputDefVal, options) : // Parse the ugendef and create a ugen instance.
                inputDefVal; // Don't instantiate a ugen, just pass the def on as-is.
        }

        if (!ugenDef.ugen) {
            throw new Error("Unit generator definition lacks a 'ugen' property; " +
                "can't initialize the synth graph. Value: " + fluid.prettyPrintJSON(ugenDef));
        }

        var ugen = flock.parse.makeUGen(ugenDef, inputs, options);
        if (ugenDef.id) {
            ugen.id = ugenDef.id;
            ugen.nickName = ugenDef.id; // TODO: Normalize nicknames and ids.
        }

        ugen.options.ugenDef = ugenDef;

        if (visitors) {
            visitors = fluid.makeArray(visitors);
            fluid.each(visitors, function (visitor) {
                visitor(ugen, ugenDef, rates);
            });
        }

        return ugen;
    };

    flock.parse.expandBufferDef = function (bufDef) {
        return typeof bufDef === "string" ? {id: bufDef} :
            (flock.isIterable(bufDef) || bufDef.data || bufDef.format) ?
            flock.bufferDesc(bufDef) : bufDef;
    };

    flock.parse.bufferForDef = function (bufDef, ugen, enviro) {
        bufDef = flock.parse.expandBufferDef(bufDef);

        if (bufDef.data && bufDef.data.channels) {
            bufDef = flock.bufferDesc(bufDef);
            flock.parse.bufferForDef.resolveBuffer(bufDef, ugen, enviro);
        } else {
            flock.parse.bufferForDef.resolveDef(bufDef, ugen, enviro);
        }
    };

    flock.parse.bufferForDef.findSource = function (defOrDesc, enviro) {
        var source;

        if (enviro && defOrDesc.id) {
            source = enviro.bufferSources[defOrDesc.id];
            if (!source) {
                source = enviro.bufferSources[defOrDesc.id] = flock.bufferSource();
            }
        } else {
            source = flock.bufferSource();
        }

        return source;
    };

    flock.parse.bufferForDef.bindToPromise = function (p, source, ugen) {
        // TODO: refactor this.
        var success = function (bufDesc) {
            source.events.onBufferUpdated.addListener(success);
            if (ugen) {
                ugen.setBuffer(bufDesc);
            }
        };

        var error = function (msg) {
            if (!msg && source.model.src && source.model.src.indexOf(".aif")) {
                msg = "if this is an AIFF file, you might need to include" +
                " flocking-audiofile-compatibility.js in some browsers.";
            }
            throw new Error("Error while resolving buffer " + source.model.src + ": " + msg);
        };

        p.then(success, error);
    };

    flock.parse.bufferForDef.resolveDef = function (bufDef, ugen, enviro) {
        var source = flock.parse.bufferForDef.findSource(bufDef, enviro),
            p;

        bufDef.src = bufDef.url || bufDef.src;
        if (bufDef.selector && typeof(document) !== "undefined") {
            bufDef.src = document.querySelector(bufDef.selector).files[0];
        }

        p = source.get(bufDef);
        flock.parse.bufferForDef.bindToPromise(p, source, ugen);
    };


    flock.parse.bufferForDef.resolveBuffer = function (bufDesc, ugen, enviro) {
        var source = flock.parse.bufferForDef.findSource(bufDesc, enviro),
            p = source.set(bufDesc);

        flock.parse.bufferForDef.bindToPromise(p, source, ugen);
    };

}());
;/*
 * Flocking Audio File Utilities
 * http://github.com/colinbdclark/flocking
 *
 * Copyright 2011-2014, Colin Clark
 * Dual licensed under the MIT and GPL Version 2 licenses.
 */

/*global require, ArrayBuffer, Uint8Array, File, FileReader */
/*jshint white: false, newcap: true, regexp: true, browser: true,
forin: false, nomen: true, bitwise: false, maxerr: 100,
indent: 4, plusplus: false, curly: true, eqeqeq: true,
freeze: true, latedef: true, noarg: true, nonew: true, quotmark: double, undef: true,
unused: true, strict: true, asi: false, boss: false, evil: false, expr: false,
funcscope: false*/

var fluid = fluid || require("infusion"),
    flock = fluid.registerNamespace("flock");

(function () {

    "use strict";

    /**
     * Applies the specified function in the next round of the event loop.
     */
    // TODO: Replace this and the code that depends on it with a good Promise implementation.
    flock.applyDeferred = function (fn, args, delay) {
        if (!fn) {
            return;
        }

        delay = typeof (delay) === "undefined" ? 0 : delay;
        setTimeout(function () {
            fn.apply(null, args);
        }, delay);
    };


    /*********************
     * Network utilities *
     *********************/

    fluid.registerNamespace("flock.net");

    /**
     * Loads an ArrayBuffer into memory using XMLHttpRequest.
     */
    flock.net.readBufferFromUrl = function (options) {
        var src = options.src,
            xhr = new XMLHttpRequest();

        xhr.onreadystatechange = function () {
            if (xhr.readyState === 4) {
                if (xhr.status === 200) {
                    options.success(xhr.response, flock.file.parseFileExtension(src));
                } else {
                    if (!options.error) {
                        throw new Error(xhr.statusText);
                    }

                    options.error(xhr.statusText);
                }
            }
        };

        xhr.open(options.method || "GET", src, true);
        xhr.responseType = options.responseType || "arraybuffer";
        xhr.send(options.data);
    };


    /*****************
     * File Utilties *
     *****************/

    fluid.registerNamespace("flock.file");

    flock.file.mimeTypes = {
        "audio/wav": "wav",
        "audio/x-wav": "wav",
        "audio/wave": "wav",
        "audio/x-aiff": "aiff",
        "audio/aiff": "aiff",
        "sound/aiff": "aiff"
    };

    flock.file.typeAliases = {
        "aif": "aiff",
        "wave": "wav"
    };

    flock.file.parseFileExtension = function (fileName) {
        var lastDot = fileName.lastIndexOf("."),
            ext,
            alias;

        // TODO: Better error handling in cases where we've got unrecognized file extensions.
        //       i.e. we should try to read the header instead of relying on extensions.
        if (lastDot < 0) {
            return undefined;
        }

        ext = fileName.substring(lastDot + 1);
        ext = ext.toLowerCase();
        alias =  flock.file.typeAliases[ext];

        return alias || ext;
    };

    flock.file.parseMIMEType = function (mimeType) {
        return flock.file.mimeTypes[mimeType];
    };

    /**
     * Converts a binary string to an ArrayBuffer, suitable for use with a DataView.
     *
     * @param {String} s the raw string to convert to an ArrayBuffer
     *
     * @return {Uint8Array} the converted buffer
     */
    flock.file.stringToBuffer = function (s) {
        var len = s.length,
            b = new ArrayBuffer(len),
            v = new Uint8Array(b),
            i;
        for (i = 0; i < len; i++) {
            v[i] = s.charCodeAt(i);
        }
        return v.buffer;
    };

    /**
     * Asynchronously parses the specified data URL into an ArrayBuffer.
     */
    flock.file.readBufferFromDataUrl = function (options) {
        var url = options.src,
            delim = url.indexOf(","),
            header = url.substring(0, delim),
            data = url.substring(delim + 1),
            base64Idx = header.indexOf(";base64"),
            isBase64 =  base64Idx > -1,
            mimeTypeStartIdx = url.indexOf("data:") + 5,
            mimeTypeEndIdx = isBase64 ? base64Idx : delim,
            mimeType = url.substring(mimeTypeStartIdx, mimeTypeEndIdx);

        if (isBase64) {
            data = atob(data);
        }

        flock.applyDeferred(function () {
            var buffer = flock.file.stringToBuffer(data);
            options.success(buffer, flock.file.parseMIMEType(mimeType));
        });
    };

    /**
     * Asynchronously reads the specified File into an ArrayBuffer.
     */
    flock.file.readBufferFromFile = function (options) {
        var reader  = new FileReader();
        reader.onload = function (e) {
            options.success(e.target.result, flock.file.parseFileExtension(options.src.name));
        };
        reader.readAsArrayBuffer(options.src);

        return reader;
    };


    fluid.registerNamespace("flock.audio");

    /**
     * Asychronously loads an ArrayBuffer into memory.
     *
     * Options:
     *  - src: the URL to load the array buffer from
     *  - method: the HTTP method to use (if applicable)
     *  - data: the data to be sent as part of the request (it's your job to query string-ize this if it's an HTTP request)
     *  - success: the success callback, which takes the ArrayBuffer response as its only argument
     *  - error: a callback that will be invoked if an error occurs, which takes the error message as its only argument
     */
    flock.audio.loadBuffer = function (options) {
        var src = options.src || options.url;
        if (!src) {
            return;
        }

        if (src instanceof ArrayBuffer) {
            flock.applyDeferred(options.success, [src, options.type]);
        }

        var reader = flock.audio.loadBuffer.readerForSource(src);

        reader(options);
    };

    flock.audio.loadBuffer.readerForSource = function (src) {
        return (typeof (File) !== "undefined" && src instanceof File) ? flock.file.readBufferFromFile :
            src.indexOf("data:") === 0 ? flock.file.readBufferFromDataUrl : flock.net.readBufferFromUrl;
    };


    /**
     * Loads and decodes an audio file. By default, this is done asynchronously in a Web Worker.
     * This decoder currently supports WAVE and AIFF file formats.
     */
    flock.audio.decode = function (options) {
        var success = options.success;

        var wrappedSuccess = function (rawData, type) {
            var strategies = flock.audio.decoderStrategies,
                strategy = strategies[type] || strategies["default"];

            if (options.decoder) {
                strategy = typeof (options.decoder) === "string" ?
                     fluid.getGlobalValue(options.decoder) : options.decoder;
            }

            strategy({
                rawData: rawData,
                type: type,
                success: success,
                error: options.error,
                sampleRate: options.sampleRate ||
                    (flock.enviro.shared ? flock.enviro.shared.audioSettings.rates.audio : undefined)
            });
        };

        options.success = wrappedSuccess;
        flock.audio.loadBuffer(options);
    };

    /**
     * Asynchronously decodes the specified ArrayBuffer rawData using
     * the browser's Web Audio Context.
     */
    flock.audio.decode.webAudio = function (o) {
        var ctx = flock.enviro.shared.audioStrategy.context,
            success = function (audioBuffer) {
                var bufDesc = flock.bufferDesc.fromAudioBuffer(audioBuffer);
                o.success(bufDesc);
            };

        ctx.decodeAudioData(o.rawData, success, o.error);
    };

    flock.audio.decoderStrategies = {
        "default": flock.audio.decode.webAudio
    };

    flock.audio.registerDecoderStrategy = function (type, strategy) {
        if (!type) {
            return;
        }

        if (typeof type === "object") {
            for (var key in type) {
                flock.audio.decoderStrategies[key] = type[key];
            }

            return;
        }

        if (typeof strategy === "string") {
            strategy = fluid.getGlobalValue(strategy);
        }

        flock.audio.decoderStrategies[type] = strategy;
    };

}());
;/*
* Flocking Scheduler
* http://github.com/colinbdclark/flocking
*
* Copyright 2013-2014, Colin Clark
* Dual licensed under the MIT and GPL Version 2 licenses.
*/

/*global require, self*/
/*jshint white: false, newcap: true, regexp: true, browser: true,
    forin: false, nomen: true, bitwise: false, maxerr: 100,
    indent: 4, plusplus: false, curly: true, eqeqeq: true,
    freeze: true, latedef: true, noarg: true, nonew: true, quotmark: double, undef: true,
    unused: true, strict: true, asi: false, boss: false, evil: false, expr: false,
    funcscope: false*/

var fluid = fluid || require("infusion"),
    flock = fluid.registerNamespace("flock");

(function () {
    "use strict";

    // TODO: This duplicates code in flocking-core and should be factored differently.
    flock.shim = {
        URL: typeof window !== "undefined" ? window.URL || window.webkitURL || window.msURL : undefined
    };

    flock.worker = function (code) {
        var type = typeof code,
            url,
            blob;

        if (type === "function") {
            code = "(" + code.toString() + ")();";
        } else if (type !== "string") {
            throw new Error("A flock.worker must be initialized with a String or a Function.");
        }

        if (window.Blob) {
            blob = new Blob([code], {
                type: "text/javascript"
            });
            url = flock.shim.URL.createObjectURL(blob);
        } else {
            url = "data:text/javascript;base64," + window.btoa(code);
        }
        return new Worker(url);
    };


    fluid.registerNamespace("flock.scheduler");


    /**********
     * Clocks *
     **********/

    fluid.defaults("flock.scheduler.intervalClock", {
        gradeNames: ["fluid.eventedComponent", "autoInit"],
        events: {
            tick: null
        }
    });

    flock.scheduler.intervalClock.finalInit = function (that) {
        that.scheduled = {};

        that.schedule = function (interval) {
            var id = setInterval(function () {
                that.events.tick.fire(interval);
            }, interval);
            that.scheduled[interval] = id;
        };

        that.clear = function (interval) {
            var id = that.scheduled[interval];
            clearInterval(id);
            delete that.scheduled[interval];
        };

        that.clearAll = function () {
            for (var interval in that.scheduled) {
                that.clear(interval);
            }
        };

        that.end = that.clearAll;
    };


    fluid.defaults("flock.scheduler.scheduleClock", {
        gradeNames: ["fluid.eventedComponent", "autoInit"],
        events: {
            tick: null
        }
    });

    flock.scheduler.scheduleClock.finalInit = function (that) {
        that.scheduled = [];

        that.schedule = function (timeFromNow) {
            var id;
            id = setTimeout(function () {
                that.clear(id);
                that.events.tick.fire(timeFromNow);
            }, timeFromNow);
            that.scheduled.push(id);
        };

        that.clear = function (id, idx) {
            idx = idx === undefined ? that.scheduled.indexOf(id) : idx;
            if (idx > -1) {
                that.scheduled.splice(idx, 1);
            }
            clearTimeout(id);
        };

        that.clearAll = function () {
            for (var i = 0; i < that.scheduled.length; i++) {
                var id = that.scheduled[i];
                clearTimeout(id);
            }
            that.scheduled.length = 0;
        };

        that.end = that.clearAll;
    };


    fluid.defaults("flock.scheduler.webWorkerClock", {
        gradeNames: ["fluid.modelComponent", "fluid.eventedComponent", "autoInit"],
        model: {
            messages: {
                schedule: {
                    msg: "schedule"
                },
                clear: {
                    msg: "clear"
                },
                clearAll: {
                    msg: "clearAll"
                },
                end: {
                    msg: "end"
                }
            }
        },
        events: {
            tick: null
        },
        clockType: "intervalClock"
    });

    flock.scheduler.webWorkerClock.finalInit = function (that) {
        that.worker = new flock.worker(flock.scheduler.webWorkerClock.workerImpl);

        // Start the worker-side clock.
        that.worker.postMessage({
            msg: "start",
            value: that.options.clockType
        });

        // Listen for tick messages from the worker and fire accordingly.
        that.worker.addEventListener("message", function (e) {
            that.events.tick.fire(e.data.value);
        }, false);

        that.postToWorker = function (msgName, value) {
            var msg = that.model.messages[msgName];
            if (value !== undefined) {
                msg.value = value;
            }
            that.worker.postMessage(msg);
        };

        that.schedule = function (time) {
            that.postToWorker("schedule", time);
        };

        that.clear = function (time) {
            that.postToWorker("clear", time);
        };

        that.clearAll = function () {
            that.postToWorker("clearAll");
        };

        that.end = function () {
            that.postToWorker("end");
        };
    };


    // This code is only intended to run from within a Worker, via flock.worker.
    flock.scheduler.webWorkerClock.workerImpl = function () {
        "use strict"; // jshint ignore:line

        var flock = flock || {};
        flock.worker = flock.worker || {};

        flock.worker.clock = function () {
            var that = {};

            that.tick = function (interval) {
                self.postMessage({
                    msg: "tick",
                    value: interval
                });
            };

            return that;
        };

        flock.worker.intervalClock = function () {
            var that = flock.worker.clock();
            that.scheduled = {};

            // TODO: Copy-pasted from flock.scheduler.intervalClock.
            that.schedule = function (interval) {
                var id = setInterval(function () {
                    that.tick(interval);
                }, interval);
                that.scheduled[interval] = id;
            };

            // TODO: Copy-pasted from flock.scheduler.intervalClock.
            that.clear = function (interval) {
                var id = that.scheduled[interval];
                clearInterval(id);
                delete that.scheduled[interval];
            };

            // TODO: Copy-pasted from flock.scheduler.intervalClock.
            that.clearAll = function () {
                for (var interval in that.scheduled) {
                    that.clear(interval);
                }
            };

            return that;
        };

        flock.worker.scheduleClock = function () {
            var that = flock.worker.clock();
            that.scheduled = [];

            // TODO: Copy-pasted from flock.scheduler.scheduleClock.
            that.schedule = function (timeFromNow) {
                var id;
                id = setTimeout(function () {
                    that.clear(id);
                    that.tick(timeFromNow);
                }, timeFromNow);
                that.scheduled.push(id);
            };

            // TODO: Copy-pasted from flock.scheduler.scheduleClock.
            that.clear = function (id, idx) {
                idx = idx === undefined ? that.scheduled.indexOf(id) : idx;
                if (idx > -1) {
                    that.scheduled.splice(idx, 1);
                }
                clearTimeout(id);
            };

            // TODO: Copy-pasted from flock.scheduler.scheduleClock.
            that.clearAll = function () {
                for (var i = 0; i < that.scheduled.length; i++) {
                    var id = that.scheduled[i];
                    clearTimeout(id);
                }
                that.scheduled.length = 0;
            };

            return that;
        };

        self.addEventListener("message", function (e) {
            if (e.data.msg === "start") {
                flock.clock = flock.worker[e.data.value]();
            } else if (e.data.msg === "end") {
                if (flock.clock) {
                    flock.clock.clearAll();
                    self.close();
                }
            } else if (flock.clock) {
                flock.clock[e.data.msg](e.data.value);
            }
        }, false);
    };

    fluid.defaults("flock.scheduler.webWorkerIntervalClock", {
        gradeNames: ["flock.scheduler.webWorkerClock", "autoInit"],
        clockType: "intervalClock"
    });

    fluid.defaults("flock.scheduler.webWorkerScheduleClock", {
        gradeNames: ["flock.scheduler.webWorkerClock", "autoInit"],
        clockType: "scheduleClock"
    });


    /**************
     * Schedulers *
     **************/

    flock.scheduler.makeOneShotValueListener = function (value, fn, removeFn) {
        var listener = function (time) {
            if (time === value) {
                fn(time);
                removeFn(listener);
            }
        };

        return listener;
    };

    flock.scheduler.makeRepeatingValueListener = function (value, fn) {
        return function (time) {
            if (time === value) {
                fn(time);
            }
        };
    };


    fluid.defaults("flock.scheduler.async", {
        gradeNames: ["fluid.eventedComponent", "autoInit"],
        components: {
            timeConverter: {
                type: "flock.convert.seconds"
            },
            intervalClock: {
                type: "flock.scheduler.webWorkerIntervalClock"
            },
            scheduleClock: {
                type: "flock.scheduler.webWorkerScheduleClock"
            }
        }
    });

    // TODO: Duplication!
    flock.scheduler.async.finalInit = function (that) {
        that.intervalListeners = {};
        that.scheduleListeners = [];

        that.addIntervalListener = function (interval, fn) {
            var listener = flock.scheduler.makeRepeatingValueListener(interval, fn);
            listener.wrappedListener = fn;
            that.intervalListeners[interval] = that.intervalListeners[interval] || [];
            that.intervalListeners[interval].push(listener);
            that.intervalClock.events.tick.addListener(listener);

            return listener;
        };

        that.addScheduleListener = function (time, fn) {
            var listener = flock.scheduler.makeOneShotValueListener(time, fn, that.clear);
            listener.wrappedListener = fn;
            that.scheduleListeners.push(listener);
            that.scheduleClock.events.tick.addListener(listener);

            return listener;
        };

        that.scheduleChange = function (time, changeSpec, addListenerFn, clock) {
            var ms = that.timeConverter.value(time),
                fn = flock.scheduler.async.prepareSchedulerFn(changeSpec, that.events),
                listener = addListenerFn(ms, fn);

            clock.schedule(ms);
            return listener;
        };

        that.repeat = function (interval, changeSpec) {
            return that.scheduleChange(interval, changeSpec, that.addIntervalListener, that.intervalClock);
        };

        that.once = function (time, changeSpec) {
            return that.scheduleChange(time, changeSpec, that.addScheduleListener, that.scheduleClock);
        };

        that.sequence = function (times, changeSpec) {
            var listeners = [],
                listener;

            for (var i = 0; i < times.length; i++) {
                listener = that.once(times[i], changeSpec);
                listeners.push(listener);
            }

            return listeners;
        };

        that.schedule = function (schedules) {
            schedules = flock.isIterable(schedules) ? schedules : [schedules];

            var i,
                schedule;

            for (i = 0; i < schedules.length; i++) {
                schedule = schedules[i];
                flock.invoke(that, schedule.interval, [schedule.time, schedule.change]);
            }
        };

        that.clear = function (listener) {
            if (!listener) {
                return;
            }

            // TODO: Rather inefficient.
            var idx = that.scheduleListeners.indexOf(listener),
                interval;
            if (idx > -1) {
                that.scheduleClock.events.tick.removeListener(listener);
                that.scheduleListeners.splice(idx, 1);
                return;
            }

            that.intervalClock.events.tick.removeListener(listener);
            for (interval in that.intervalListeners) {
                idx = that.intervalListeners[interval].indexOf(listener);
                if (idx > -1) {
                    that.intervalListeners[interval].splice(idx, 1);
                }
            }
        };

        that.clearRepeat = function (interval) {
            that.intervalClock.clear(interval);

            var listeners = that.intervalListeners[interval],
                i,
                listener;

            if (!listeners) {
                return;
            }

            for (i = 0; i < listeners.length; i++) {
                listener = listeners[i];
                that.intervalClock.events.tick.removeListener(listener);
            }
            listeners.length = 0;

            return listener;
        };

        that.clearAll = function () {
            that.intervalClock.clearAll();
            for (var interval in that.intervalListeners) {
                that.clearRepeat(interval);
            }

            that.scheduleClock.clearAll();
            for (var listener in that.scheduleListeners) {
                that.clear(listener);
            }
        };

        that.end = function () {
            that.intervalClock.end();
            that.scheduleClock.end();
        };

        if (that.options.score) {
            that.schedule(that.options.score);
        }
    };

    flock.scheduler.async.prepareSchedulerFn = function (changeSpec, events) {
        var type = typeof changeSpec,
            fn;

        if (type === "function") {
            // The user has scheduled a raw function pointer.
            fn = changeSpec;
        } else if (type === "string") {
            // An event was scheduled by name.
            fn = events[changeSpec].fire;
        } else {
            // A change spec object was scheduled.
            fn = flock.scheduler.async.evaluateChangeSpec(changeSpec);
        }

        return fn;
    };

    flock.scheduler.async.evaluateChangeSpec = function (changeSpec) {
        var synths = {},
            staticChanges = {};

        // Find all synthDefs and create demand rate synths for them.
        for (var path in changeSpec.values) {
            var change = changeSpec.values[path];
            if (change.synthDef) {
                synths[path] = flock.synth.value(change);
            } else {
                staticChanges[path] = change;
            }
        }

        // Create a scheduler listener that evaluates the changeSpec and updates the synth.
        return function () {
            for (var path in synths) {
                var synth = synths[path];
                staticChanges[path] = synth.value();
            }

            // TODO: Hardcoded to the shared environment.
            var targetSynth = typeof changeSpec.synth === "string" ?
                flock.enviro.shared.namedNodes[changeSpec.synth] : changeSpec.synth;
            targetSynth.set(staticChanges);
        };
    };

    fluid.defaults("flock.scheduler.async.tempo", {
        gradeNames: ["flock.scheduler.async", "autoInit"],

        bpm: 60,

        components: {
            timeConverter: {
                type: "flock.convert.beats",
                options: {
                    bpm: "{tempo}.options.bpm"
                }
            }
        }
    });


    /*******************
     * Time Conversion *
     *******************/

    fluid.registerNamespace("flock.convert");

    flock.convert.makeStatelessConverter = function (convertFn) {
        return function () {
            return {
                value: convertFn
            };
        };
    };

    flock.convert.ms = flock.convert.makeStatelessConverter(fluid.identity);

    flock.convert.seconds = flock.convert.makeStatelessConverter(function (secs) {
        return secs * 1000;
    });

    fluid.defaults("flock.convert.beats", {
        gradeNames: ["fluid.littleComponent", "autoInit"],
        bpm: 60
    });

    flock.convert.beats.finalInit = function (that) {
        that.value = function (beats) {
            var bpm = that.options.bpm;
            return bpm <= 0 ? 0 : (beats / bpm) * 60000;
        };
    };
}());
;/*
* Flocking WebAudio Strategy
* http://github.com/colinbdclark/flocking
*
* Copyright 2013-2014, Colin Clark
* Dual licensed under the MIT and GPL Version 2 licenses.
*/

/*global require, MediaStreamTrack, jQuery*/
/*jshint white: false, newcap: true, regexp: true, browser: true,
    forin: false, nomen: true, bitwise: false, maxerr: 100,
    indent: 4, plusplus: false, curly: true, eqeqeq: true,
    freeze: true, latedef: true, noarg: true, nonew: true, quotmark: double, undef: true,
    unused: true, strict: true, asi: false, boss: false, evil: false, expr: false,
    funcscope: false*/

var fluid = fluid || require("infusion"),
    flock = fluid.registerNamespace("flock");

(function () {
    "use strict";

    fluid.registerNamespace("flock.webAudio");

    flock.webAudio.createNode = function (context, type, args, params) {
        // Second argument is a NodeSpec object.
        if (typeof type !== "string") {
            args = type.args;
            params = type.params;
            type = type.node;
        }

        args = args === undefined || args === null ? [] :
            fluid.isArrayable(args) ? args : [args];

        var creatorName = "create" + type,
            nodeStrIdx = creatorName.indexOf("Node");

        // Trim off "Node" if it is present.
        if (nodeStrIdx > -1) {
            creatorName = creatorName.substring(0, nodeStrIdx);
        }

        var node = context[creatorName].apply(context, args);
        flock.webAudio.initializeNodeInputs(node, params);

        return node;
    };

    // TODO: Add support for other types of AudioParams.
    flock.webAudio.initializeNodeInputs = function (node, paramSpec) {
        if (!node || !paramSpec) {
            return;
        }

        for (var inputName in paramSpec) {
            node[inputName].value = paramSpec[inputName];
        }

        return node;
    };


    // TODO: Remove this when Chrome implements navigator.getMediaDevices().
    fluid.registerNamespace("flock.webAudio.chrome");

    flock.webAudio.chrome.getSources = function (callback) {
        return MediaStreamTrack.getSources(function (infoSpecs) {
            var normalized = fluid.transform(infoSpecs, function (infoSpec) {
                infoSpec.deviceId = infoSpec.id;
                return infoSpec;
            });

            callback(normalized);
        });
    };

    flock.webAudio.mediaStreamFailure = function () {
        flock.fail("Media Capture and Streams are not supported on this browser.");
    };

    var webAudioShims = {
        AudioContext: window.AudioContext || window.webkitAudioContext,

        getUserMediaImpl: navigator.getUserMedia || navigator.webkitGetUserMedia ||
            navigator.mozGetUserMedia || navigator.msGetUserMedia || flock.webAudio.mediaStreamFailure,

        getUserMedia: function () {
            flock.shim.getUserMediaImpl.apply(navigator, arguments);
        },

        getMediaDevicesImpl: navigator.getMediaDevices ? navigator.getMediaDevices :
            typeof window.MediaStreamTrack !== "undefined" ?
            flock.webAudio.chrome.getSources : flock.webAudio.mediaStreamFailure,

        getMediaDevice: function () {
            flock.shim.getMediaDevicesImpl.apply(navigator, arguments);
        }
    };

    jQuery.extend(flock.shim, webAudioShims);


    /**
     * Web Audio API Audio Strategy
     */
    fluid.defaults("flock.audioStrategy.web", {
        gradeNames: ["flock.audioStrategy", "autoInit"],

        members: {
            context: "{contextWrapper}.context",
            sampleRate: "{that}.context.sampleRate",
            chans: {
                expander: {
                    funcName: "flock.audioStrategy.web.calculateChannels",
                    args: ["{contextWrapper}.context", "{enviro}.options.audioSettings.chans"]
                }
            },
            jsNode: {
                expander: {
                    funcName: "flock.audioStrategy.web.createScriptProcessor",
                    args: [
                        "{contextWrapper}.context",
                        "{enviro}.options.audioSettings.bufferSize",
                        "{enviro}.options.audioSettings.numInputBuses",
                        "{that}.chans"
                    ]
                }
            }
        },

        model: {
            isGenerating: false,
            shouldInitIOS: flock.platform.isIOS,
            krPeriods: {
                expander: {
                    funcName: "flock.audioStrategy.web.calcNumKrPeriods",
                    args: "{enviro}.options.audioSettings"
                }
            }
        },

        invokers: {
            start: {
                func: "{that}.events.onStart.fire"
            },

            stop: {
                func: "{that}.events.onStop.fire"
            },

            reset: {
                func: "{that}.events.onReset.fire"
            }
        },

        components: {
            contextWrapper: {
                type: "flock.webAudio.contextWrapper"
            },

            nativeNodeManager: {
                type: "flock.webAudio.nativeNodeManager"
            },

            inputDeviceManager: {
                type: "flock.webAudio.inputDeviceManager"
            }
        },

        events: {
            onStart: null,
            onStop: null,
            onReset: null
        },

        listeners: {
            onCreate: [
                {
                    funcName: "flock.audioStrategy.web.setChannelState",
                    args: ["{that}.chans", "{contextWrapper}.context.destination"]
                },
                {
                    funcName: "flock.audioStrategy.web.pushAudioSettings",
                    args: ["{that}.sampleRate", "{that}.chans", "{enviro}.options.audioSettings"]
                },
                {
                    funcName: "flock.audioStrategy.web.bindWriter",
                    args: [
                        "{that}.jsNode",
                        "{nodeEvaluator}",
                        "{nativeNodeManager}",
                        "{that}.model",
                        "{enviro}.options.audioSettings"
                    ]
                }
            ],

            onStart: [
                {
                    func: "{that}.applier.change",
                    args: ["isGenerating", true]
                },
                {
                    // TODO: Replace this with some progressive enhancement action.
                    funcName: "flock.audioStrategy.web.iOSStart",
                    args: ["{that}.model", "{that}.applier", "{contextWrapper}.context", "{that}.jsNode"]
                },
                {
                    func: "{nativeNodeManager}.connect"
                }
            ],

            onStop: [
                {
                    func: "{that}.applier.change",
                    args: ["isGenerating", false]
                },
                {
                    func: "{nativeNodeManager}.disconnect"
                }
            ],

            onReset: [
                {
                    func: "{that}.stop"
                },
                {
                    func: "{nativeNodeManager}.removeAllInputs"
                },
                {
                    func: "{that}.applier.change",
                    args: ["playState.written", 0]
                }
            ]
        }
    });

    flock.audioStrategy.web.calculateChannels = function (context, chans) {
        // TODO: Remove this conditional when Safari adds support for multiple channels.
        return flock.platform.browser.safari ?  context.destination.channelCount :
            Math.min(chans, context.destination.maxChannelCount);
    };

    // TODO: Refactor into a shared environment-level model property.
    flock.audioStrategy.web.pushAudioSettings = function (sampleRate, chans, audioSettings) {
        audioSettings.rates.audio = sampleRate;
        audioSettings.chans = chans;
    };

    flock.audioStrategy.web.setChannelState = function (chans, destinationNode) {
        // Safari will throw an InvalidStateError DOM Exception 11 when
        // attempting to set channelCount on the audioContext's destination.
        // TODO: Remove this conditional when Safari adds support for multiple channels.
        if (!flock.platform.browser.safari) {
            destinationNode.channelCount = chans;
            destinationNode.channelCountMode = "explicit";
            destinationNode.channelInterpretation = "discrete";
        }
    };

    flock.audioStrategy.web.calcNumKrPeriods = function (s) {
        return s.bufferSize / s.blockSize;
    };

    flock.audioStrategy.web.createScriptProcessor = function (ctx, bufferSize, numInputs, chans) {
        var jsNodeName = ctx.createScriptProcessor ? "createScriptProcessor" : "createJavaScriptNode",
            jsNode = ctx[jsNodeName](bufferSize, numInputs, chans);

        jsNode.channelCountMode = "explicit";

        return jsNode;
    };

    flock.audioStrategy.web.bindWriter = function (jsNode, nodeEvaluator, nativeNodeManager, model, audioSettings) {
        jsNode.model = model;
        jsNode.evaluator = nodeEvaluator;
        jsNode.audioSettings = audioSettings;
        jsNode.inputNodes = nativeNodeManager.inputNodes;
        jsNode.onaudioprocess = flock.audioStrategy.web.writeSamples;
    };

    /**
     * Writes samples to the audio strategy's ScriptProcessorNode.
     *
     * This function must be bound as a listener to the node's
     * onaudioprocess event. It expects to be called in the context
     * of a "this" instance containing the following properties:
     *  - model: the strategy's model object
     *  - inputNodes: a list of native input nodes to be read into input buses
     *  - nodeEvaluator: a nodeEvaluator instance
     *  - audioSettings: the enviornment's audio settings
     */
    flock.audioStrategy.web.writeSamples = function (e) {
        var m = this.model,
            numInputNodes = this.inputNodes.length,
            evaluator = this.evaluator,
            s = this.audioSettings,
            inBufs = e.inputBuffer,
            outBufs = e.outputBuffer,
            krPeriods = m.krPeriods,
            buses = evaluator.buses,
            blockSize = s.blockSize,
            chans = s.chans,
            inChans = inBufs.numberOfChannels,
            chan,
            i,
            samp;

        // If there are no nodes providing samples, write out silence.
        if (evaluator.nodes.length < 1) {
            for (chan = 0; chan < chans; chan++) {
                flock.generate.silence(outBufs.getChannelData(chan));
            }
            return;
        }

        // TODO: Make a formal distinction between input buses,
        // output buses, and interconnect buses in the environment!
        for (i = 0; i < krPeriods; i++) {
            var offset = i * blockSize;

            evaluator.clearBuses();

            // Read this ScriptProcessorNode's input buffers
            // into the environment.
            if (numInputNodes > 0) {
                for (chan = 0; chan < inChans; chan++) {
                    var inBuf = inBufs.getChannelData(chan),
                        inBusNumber = chans + chan, // Input buses are located after output buses.
                        targetBuf = buses[inBusNumber];

                    for (samp = 0; samp < blockSize; samp++) {
                        targetBuf[samp] = inBuf[samp + offset];
                    }
                }
            }

            evaluator.gen();

            // Output the environment's signal
            // to this ScriptProcessorNode's output channels.
            for (chan = 0; chan < chans; chan++) {
                var sourceBuf = buses[chan],
                    outBuf = outBufs.getChannelData(chan);

                // And output each sample.
                for (samp = 0; samp < blockSize; samp++) {
                    outBuf[samp + offset] = sourceBuf[samp];
                }
            }
        }
    };

    flock.audioStrategy.web.iOSStart = function (model, applier, ctx, jsNode) {
        // Work around a bug in iOS Safari where it now requires a noteOn()
        // message to be invoked before sound will work at all. Just connecting a
        // ScriptProcessorNode inside a user event handler isn't sufficient.
        if (model.shouldInitIOS) {
            var s = ctx.createBufferSource();
            s.connect(jsNode);
            s.start(0);
            s.stop(0);
            s.disconnect(0);
            applier.change("shouldInitIOS", false);
        }
    };


    /**
     * An Infusion component wrapper for a Web Audio API AudioContext instance.
     */
    // TODO: Refactor this into an "audio system" component (with cross-platform base grade)
    // that serves as the canonical source for shared audio settings such as
    // sample rate, number of channels, etc.
    fluid.defaults("flock.webAudio.contextWrapper", {
        gradeNames: ["fluid.eventedComponent", "autoInit"],

        members: {
            context: "@expand:flock.webAudio.contextWrapper.create()"
        },

        listeners: {
            onCreate: [
                {
                    funcName: "flock.webAudio.contextWrapper.registerSingleton",
                    args: ["{that}"]
                }
            ]
        }
    });

    flock.webAudio.contextWrapper.create = function () {
        var singleton = fluid.staticEnvironment.webAudioContextWrapper;
        return singleton ? singleton.context : new flock.shim.AudioContext();
    };

    flock.webAudio.contextWrapper.registerSingleton = function (that) {
        fluid.staticEnvironment.webAudioContextWrapper = that;
    };


    /**
     * Manages a collection of input nodes and an output node,
     * with a JS node in between.
     *
     * Note: this component is slated for removal when Web Audio
     * "islands" are implemented.
     */
    fluid.defaults("flock.webAudio.nativeNodeManager", {
        gradeNames: ["fluid.eventedComponent", "autoInit"],

        audioSettings: "{enviro}.options.audioSettings",

        members: {
            outputNode: undefined,
            inputNodes: [],
            merger: {
                expander: {
                    funcName: "flock.webAudio.nativeNodeManager.createInputMerger",
                    args: [
                        "{contextWrapper}.context",
                        "{enviro}.options.audioSettings.numInputBuses",
                        "{web}.jsNode"
                    ]
                }
            }
        },

        invokers: {
            connect: {
                funcName: "flock.webAudio.nativeNodeManager.connect",
                args: [
                    "{that}.merger",
                    "{web}.jsNode",
                    "{that}.outputNode",
                    "{contextWrapper}.context.destination"
                ]
            },

            createNode: {
                funcName: "flock.webAudio.createNode",
                args: [
                    "{contextWrapper}.context",
                    "{arguments}.0", // Node type.
                    "{arguments}.1", // Constructor args.
                    "{arguments}.2"  // AudioParam connections.
                ]
            },

            createInputNode: {
                funcName: "flock.webAudio.nativeNodeManager.createInputNode",
                args: [
                    "{that}",
                    "{arguments}.0", // Node type.
                    "{arguments}.1", // Constructor args.
                    "{arguments}.2", // AudioParam connections.
                    "{arguments}.3"  // {optional} The input bus number to insert it at.
                ]
            },

            createMediaStreamInput: {
                funcName: "flock.webAudio.nativeNodeManager.createInputNode",
                args: [
                    "{that}",
                    "MediaStreamSource",
                    "{arguments}.0", // The MediaStream,
                    undefined,
                    "{arguments}.1"  // {optional} The input bus number to insert it at.
                ]
            },

            createMediaElementInput: {
                funcName: "flock.webAudio.nativeNodeManager.createInputNode",
                args: [
                    "{that}",
                    "MediaElementSource",
                    "{arguments}.0", // The HTMLMediaElement
                    undefined,
                    "{arguments}.1"  // {optional} The input bus number to insert it at.
                ]
            },

            createOutputNode: {
                funcName: "flock.webAudio.nativeNodeManager.createOutputNode",
                args: [
                    "{that}",
                    "{arguments}.0", // Node type.
                    "{arguments}.1", // Constructor args.
                    "{arguments}.2"  // AudioParam connections.
                ]
            },

            disconnect: {
                funcName: "flock.webAudio.nativeNodeManager.disconnect",
                args: ["{that}.merger", "{web}.jsNode", "{that}.outputNode"]
            },

            insertInput: {
                funcName: "flock.webAudio.nativeNodeManager.insertInput",
                args: [
                    "{that}",
                    "{enviro}",
                    "{arguments}.0", // The node to insert.
                    "{arguments}.1"  // {optional} The bus number to insert it at.
                ]
            },

            removeInput: {
                funcName: "flock.webAudio.nativeNodeManager.removeInput",
                args: ["{arguments}.0", "{that}.inputNodes"]
            },

            removeAllInputs: {
                funcName: "flock.webAudio.nativeNodeManager.removeAllInputs",
                args: "{that}.inputNodes"
            },

            insertOutput: {
                funcName: "flock.webAudio.nativeNodeManager.insertOutput",
                args: ["{that}", "{arguments}.0"]
            },

            removeOutput: {
                funcName: "flock.webAudio.nativeNodeManager.removeOutput",
                args: ["{web}.jsNode"]
            }
        },

        listeners: {
            onCreate: {
                func: "{that}.insertOutput",
                args: "{web}.jsNode"
            }
        }
    });

    flock.webAudio.nativeNodeManager.createInputNode = function (that, type, args, params, busNum) {
        var node = that.createNode(type, args, params);
        return that.insertInput(node, busNum);
    };

    flock.webAudio.nativeNodeManager.createOutputNode = function (that, type, args, params) {
        var node = that.createNode(type, args, params);
        return that.insertOutput(node);
    };

    flock.webAudio.nativeNodeManager.createInputMerger = function (ctx, numInputBuses, jsNode) {
        var merger = ctx.createChannelMerger(numInputBuses);
        merger.channelInterpretation = "discrete";
        merger.connect(jsNode);

        return merger;
    };

    flock.webAudio.nativeNodeManager.connect = function (merger, jsNode, outputNode, destination) {
        merger.connect(jsNode);
        outputNode.connect(destination);
        if (jsNode !== outputNode) {
            jsNode.connect(outputNode);
        }
    };

    flock.webAudio.nativeNodeManager.disconnect = function (merger, jsNode, outputNode) {
        merger.disconnect(0);
        jsNode.disconnect(0);
        outputNode.disconnect(0);
    };

    flock.webAudio.nativeNodeManager.removeAllInputs = function (inputNodes) {
        for (var i = 0; i < inputNodes.length; i++) {
            var node = inputNodes[i];
            node.disconnect(0);
        }
        inputNodes.length = 0;
    };

    flock.webAudio.nativeNodeManager.insertInput = function (that, enviro, node, busNum) {
        var maxInputs = that.options.audioSettings.numInputBuses;
        if (that.inputNodes.length >= maxInputs) {
            flock.fail("There are too many input nodes connected to Flocking. " +
                "The maximum number of input buses is currently set to " + maxInputs + ". " +
                "Either remove an existing input node or increase Flockings numInputBuses option.");

            return;
        }

        busNum = busNum === undefined ? enviro.acquireNextBus("input") : busNum;
        var idx = busNum - enviro.audioSettings.chans;

        that.inputNodes.push(node);
        node.connect(that.merger, 0, idx);

        return busNum;
    };

    flock.webAudio.nativeNodeManager.removeInput = function (node, inputNodes) {
        var idx = inputNodes.indexOf(node);
        if (idx > -1) {
            inputNodes.splice(idx, 1);
        }

        node.disconnect(0);
    };

    flock.webAudio.nativeNodeManager.insertOutput = function (that, node) {
        if (that.outputNode) {
            that.outputNode.disconnect(0);
        }

        that.outputNode = node;

        return node;
    };

    flock.webAudio.nativeNodeManager.removeOutput = function (jsNode) {
        // Replace the current output node with the jsNode.
        flock.webAudio.nativeNodeManager.insertOutput(jsNode);
    };


    /**
     * Manages audio input devices using the Web Audio API.
     */
    // Add a means for disconnecting audio input nodes.
    fluid.defaults("flock.webAudio.inputDeviceManager", {
        gradeNames: ["fluid.eventedComponent", "autoInit"],

        members: {
            context: "{contextWrapper}.context"
        },

        invokers: {
            /**
             * Opens the specified audio device.
             * If no device is specified, the default device is opened.
             *
             * @param {Object} deviceSpec a device spec containing, optionally, an 'id' or 'label' parameter
             */
            openAudioDevice: {
                funcName: "flock.webAudio.inputDeviceManager.openAudioDevice",
                args: [
                    "{arguments}.0",
                    "{that}.openAudioDeviceWithId",
                    "{that}.openFirstAudioDeviceWithLabel",
                    "{that}.openAudioDeviceWithConstraints"
                ]
            },

            /**
             * Opens an audio device with the specified WebRTC constraints.
             * If no constraints are specified, the default audio device is opened.
             *
             * @param {Object} constraints a WebRTC-compatible constraints object
             */
            openAudioDeviceWithConstraints: {
                funcName: "flock.webAudio.inputDeviceManager.openAudioDeviceWithConstraints",
                args: [
                    "{that}.context",
                    "{enviro}",
                    "{nativeNodeManager}.createMediaStreamInput",
                    "{arguments}.0"
                ]
            },

            /**
             * Opens an audio device with the specified WebRTC device id.
             *
             * @param {string} id a device identifier
             */
            openAudioDeviceWithId: {
                funcName: "flock.webAudio.inputDeviceManager.openAudioDeviceWithId",
                args: ["{arguments}.0", "{that}.openAudioDeviceWithConstraints"]
            },

            /**
             * Opens the first audio device found with the specified label.
             * The label must be an exact, case-insensitive match.
             *
             * @param {string} label a device label
             */
            openFirstAudioDeviceWithLabel: {
                funcName: "flock.webAudio.inputDeviceManager.openFirstAudioDeviceWithLabel",
                args: ["{arguments}.0", "{that}.openAudioDeviceWithId"]
            }
        }
    });

    flock.webAudio.inputDeviceManager.openAudioDevice = function (sourceSpec, idOpener, labelOpener, specOpener) {
        if (sourceSpec) {
            if (sourceSpec.id) {
                return idOpener(sourceSpec.id);
            } else if (sourceSpec.label) {
                return labelOpener(sourceSpec.label);
            }
        }

        return specOpener();
    };


    flock.webAudio.inputDeviceManager.openAudioDeviceWithId = function (id, deviceOpener) {
        var options = {
            audio: {
                optional: [
                    {
                        sourceId: id
                    }
                ]
            }
        };

        deviceOpener(options);
    };

    flock.webAudio.inputDeviceManager.openFirstAudioDeviceWithLabel = function (label, deviceOpener) {
        if (!label) {
            return;
        }

        // TODO: Can't access device labels until the user agrees
        // to allow access to the current device.
        flock.shim.getMediaDevices(function (deviceInfoSpecs) {
            var matches = deviceInfoSpecs.filter(function (device) {
                if (device.label.toLowerCase() === label.toLowerCase()) {
                    return true;
                }
            });

            if (matches.length > 0) {
                deviceOpener(matches[0].deviceId);
            } else {
                fluid.log(fluid.logLevel.IMPORTANT,
                    "An audio device named '" + label + "' could not be found.");
            }
        });
    };

    flock.webAudio.inputDeviceManager.openAudioDeviceWithConstraints = function (context, enviro, openMediaStream, options) {
        options = options || {
            audio: true
        };

        // Acquire an input bus ahead of time so we can synchronously
        // notify the client where its output will be.
        var busNum = enviro.acquireNextBus("input");

        function error (err) {
            fluid.log(fluid.logLevel.IMPORTANT,
                "An error occurred while trying to access the user's microphone. " +
                err);
        }

        function success (mediaStream) {
            openMediaStream(mediaStream, busNum);
        }


        flock.shim.getUserMedia(options, success, error);

        return busNum;
    };

    fluid.demands("flock.audioStrategy.platform", "flock.platform.webAudio", {
        funcName: "flock.audioStrategy.web"
    });

}());
;/*
* Flocking Unit Generators
* http://github.com/colinbdclark/flocking
*
* Copyright 2011-2014, Colin Clark
* Dual licensed under the MIT and GPL Version 2 licenses.
*/

/*global require, Float32Array, Random*/
/*jshint white: false, newcap: true, regexp: true, browser: true,
    forin: false, nomen: true, bitwise: false, maxerr: 100,
    indent: 4, plusplus: false, curly: true, eqeqeq: true,
    freeze: true, latedef: true, noarg: true, nonew: true, quotmark: double, undef: true,
    unused: true, strict: true, asi: false, boss: false, evil: false, expr: false,
    funcscope: false*/

var fluid = fluid || require("infusion"),
    flock = fluid.registerNamespace("flock");

(function () {
    "use strict";

    var $ = fluid.registerNamespace("jQuery"),
        DSP = flock.requireModule("dspapi", "DSP"),
        Filter = flock.requireModule("dspapi", "Filter");

    /*************
     * Utilities *
     *************/

    flock.isUGen = function (obj) {
        return obj && obj.tags && obj.tags.indexOf("flock.ugen") > -1;
    };

    // TODO: Check API; write unit tests.
    flock.aliasUGen = function (sourcePath, aliasName, inputDefaults, defaultOptions) {
        var root = flock.get(sourcePath);
        flock.set(root, aliasName, function (inputs, output, options) {
            options = $.extend(true, {}, defaultOptions, options);
            return root(inputs, output, options);
        });
        fluid.defaults(sourcePath + "." + aliasName, inputDefaults);
    };

    // TODO: Check API; write unit tests.
    flock.aliasUGens = function (sourcePath, aliasesSpec) {
        var aliasName,
            settings;

        for (aliasName in aliasesSpec) {
            settings = aliasesSpec[aliasName];
            flock.aliasUGen(sourcePath, aliasName, {inputs: settings.inputDefaults}, settings.options);
        }
    };

    flock.krMul = function (numSamps, output, mulInput) {
        var mul = mulInput.output[0],
            i;

        for (i = 0; i < numSamps; i++) {
            output[i] = output[i] * mul;
        }
    };

    flock.mul = function (numSamps, output, mulInput) {
        var mul = mulInput.output,
            i;

        for (i = 0; i < numSamps; i++) {
            output[i] = output[i] * mul[i];
        }
    };

    flock.krAdd = function (numSamps, output, mulInput, addInput) {
        var add = addInput.output[0],
            i;

        for (i = 0; i < numSamps; i++) {
            output[i] = output[i] + add;
        }
    };

    flock.add = function (numSamps, output, mulInput, addInput) {
        var add = addInput.output,
            i;

        for (i = 0; i < numSamps; i++) {
            output[i] = output[i] + add[i];
        }
    };

    flock.krMulAdd = function (numSamps, output, mulInput, addInput) {
        var mul = mulInput.output[0],
            add = addInput.output,
            i;

        for (i = 0; i < numSamps; i++) {
            output[i] = output[i] * mul + add[i];
        }
    };

    flock.mulKrAdd = function (numSamps, output, mulInput, addInput) {
        var mul = mulInput.output,
            add = addInput.output[0],
            i;

        for (i = 0; i < numSamps; i++) {
            output[i] = output[i] * mul[i] + add;
        }
    };

    flock.krMulKrAdd = function (numSamps, output, mulInput, addInput) {
        var mul = mulInput.output[0],
            add = addInput.output[0],
            i;

        for (i = 0; i < numSamps; i++) {
            output[i] = output[i] * mul + add;
        }
    };

    flock.mulAdd = function (numSamps, output, mulInput, addInput) {
        var mul = mulInput.output,
            add = addInput.output,
            i;

        for (i = 0; i < numSamps; i++) {
            output[i] = output[i] * mul[i] + add[i];
        }
    };

    flock.onMulAddInputChanged = function (that) {
        var mul = that.inputs.mul,
            add = that.inputs.add,
            fn;

        // If we have no mul or add inputs, bail immediately.
        if (!mul && !add) {
            that.mulAdd = flock.noOp;
            return;
        }

        if (!mul) { // Only add.
            fn = add.rate !== flock.rates.AUDIO ? flock.krAdd : flock.add;
        } else if (!add) { // Only mul.
            fn = mul.rate !== flock.rates.AUDIO ? flock.krMul : flock.mul;
        } else { // Both mul and add.
            fn = mul.rate !== flock.rates.AUDIO ?
                (add.rate !== flock.rates.AUDIO ? flock.krMulKrAdd : flock.krMulAdd) :
                (add.rate !== flock.rates.AUDIO ? flock.mulKrAdd : flock.mulAdd);
        }

        that.mulAdd = function (numSamps) {
            fn(numSamps, that.output, mul, add);
        };
    };

    /*******************
     * Unit Generators *
     *******************/

    flock.ugen = function (inputs, output, options) {
        options = options || {};

        var that = {
            rate: options.rate || flock.rates.AUDIO,
            inputs: inputs,
            output: output,
            options: options,
            model: options.model || {
                unscaledValue: 0.0,
                value: 0.0
            },
            multiInputs: {},
            tags: ["flock.ugen"]
        };
        that.lastOutputIdx = that.output.length - 1;

        that.get = function (path) {
            return flock.input.get(that.inputs, path);
        };

        /**
         * Sets the value of the input at the specified path.
         *
         * @param {String} path the inputs's path relative to this ugen
         * @param {Number || UGenDef} val a scalar value (for Value ugens) or a UGenDef object
         * @return {UGen} the newly-created UGen that was set at the specified path
         */
        that.set = function (path, val) {
            return flock.input.set(that.inputs, path, val, that, function (ugenDef) {
                if (ugenDef === null || ugenDef === undefined) {
                    return;
                }

                return flock.parse.ugenDef(ugenDef, {
                    audioSettings: that.options.audioSettings,
                    buses: that.options.audioSettings.buses,
                    buffers: that.options.audioSettings.buffers
                });
            });
        };

        /**
         * Gets or sets the named unit generator input.
         *
         * @param {String} path the input path
         * @param {UGenDef} val [optional] a scalar value, ugenDef, or array of ugenDefs that will be assigned to the specified input name
         * @return {Number|UGen} a scalar value in the case of a value ugen, otherwise the ugen itself
         */
        that.input = function (path, val) {
            return !path ? undefined : typeof (path) === "string" ?
                arguments.length < 2 ? that.get(path) : that.set(path, val) :
                flock.isIterable(path) ? that.get(path) : that.set(path, val);
        };

        // TODO: Move this into a grade.
        that.calculateStrides = function () {
            var m = that.model,
                strideNames = that.options.strideInputs,
                inputs = that.inputs,
                i,
                name,
                input;

            m.strides = m.strides || {};

            if (!strideNames) {
                return;
            }

            for (i = 0; i < strideNames.length; i++) {
                name = strideNames[i];
                input = inputs[name];

                if (input) {
                    m.strides[name] = input.rate === flock.rates.AUDIO ? 1 : 0;
                } else {
                    fluid.log(fluid.logLevel.WARN, "An invalid input ('" +
                        name + "') was found on a unit generator: " + that);
                }
            }
        };

        that.collectMultiInputs = function () {
            var multiInputNames = that.options.multiInputNames,
                multiInputs = that.multiInputs,
                i,
                inputName,
                inputChannelCache,
                input;

            for (i = 0; i < multiInputNames.length; i++) {
                inputName = multiInputNames[i];
                inputChannelCache = multiInputs[inputName];

                if (!inputChannelCache) {
                    inputChannelCache = multiInputs[inputName] = [];
                } else {
                    // Clear the current array of buffers.
                    inputChannelCache.length = 0;
                }

                input = that.inputs[inputName];
                flock.ugen.collectMultiInputs(input, inputChannelCache);
            }
        };

        // Base onInputChanged() implementation.
        that.onInputChanged = function (inputName) {
            var multiInputNames = that.options.multiInputNames;

            flock.onMulAddInputChanged(that);
            if (that.options.strideInputs) {
                that.calculateStrides();
            }

            if (multiInputNames && (!inputName || multiInputNames.indexOf(inputName))) {
                that.collectMultiInputs();
            }
        };

        that.init = function () {
            var tags = fluid.makeArray(that.options.tags),
                m = that.model,
                o = that.options,
                i,
                s,
                valueDef;

            for (i = 0; i < tags.length; i++) {
                that.tags.push(tags[i]);
            }

            s = o.audioSettings = o.audioSettings || flock.enviro.shared.audioSettings;
            m.sampleRate = o.sampleRate || s.rates[that.rate];
            m.nyquistRate = m.sampleRate;
            m.blockSize = that.rate === flock.rates.AUDIO ? s.blockSize : 1;
            m.sampleDur = 1.0 / m.sampleRate;

            // Assigns an interpolator function to the UGen.
            // This is inactive by default, but can be used in custom gen() functions.
            that.interpolate = flock.interpolate.none;
            if (o.interpolation) {
                var fn = flock.interpolate[o.interpolation];
                if (!fn) {
                    fluid.log(fluid.logLevel.IMPORTANT,
                        "An invalid interpolation type of '" + o.interpolation +
                        "' was specified. Defaulting to none.");
                } else {
                    that.interpolate = fn;
                }
            }

            if (that.rate === flock.rates.DEMAND && that.inputs.freq) {
                valueDef = flock.parse.ugenDefForConstantValue(1.0);
                that.inputs.freq = flock.parse.ugenDef(valueDef);
            }
        };

        that.init();
        return that;
    };

    // The term "multi input" is a bit ambiguous,
    // but it provides a very light (and possibly poor) abstraction for two different cases:
    //   1. inputs that consist of an array of multiple unit generators
    //   2. inputs that consist of a single unit generator that has multiple ouput channels
    // In either case, each channel of each input unit generator will be gathered up into
    // an array of "proxy ugen" objects and keyed by the input name, making easy to iterate
    // over sources of input quickly.
    // A proxy ugen consists of a simple object conforming to this contract:
    //   {rate: <rate of parent ugen>, output: <Float32Array>}
    flock.ugen.collectMultiInputs = function (inputs, inputChannelCache) {
        if (!flock.isIterable(inputs)) {
            inputs = inputs = fluid.makeArray(inputs);
        }

        for (var i = 0; i < inputs.length; i++) {
            var input = inputs[i];
            flock.ugen.collectChannelsForInput(input, inputChannelCache);
        }

        return inputChannelCache;
    };

    flock.ugen.collectChannelsForInput = function (input, inputChannelCache) {
        var isMulti = flock.hasTag(input, "flock.ugen.multiChannelOutput"),
            channels = isMulti ? input.output : [input.output],
            i;

        for (i = 0; i < channels.length; i++) {
            inputChannelCache.push({
                rate: input.rate,
                output: channels[i]
            });
        }

        return inputChannelCache;
    };

    flock.ugen.lastOutputValue = function (numSamps, out) {
        return out[numSamps - 1];
    };


    flock.ugen.value = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.value = function () {
            return that.model.value;
        };

        that.dynamicGen = function (numSamps) {
            var out = that.output,
                m = that.model;

            for (var i = 0; i < numSamps; i++) {
                out[i] = m.unscaledValue;
            }

            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.onInputChanged = function () {
            var inputs = that.inputs,
                m = that.model;

            m.value = m.unscaledValue = inputs.value;

            if (that.rate !== "constant") {
                that.gen = that.dynamicGen;
            } else {
                that.gen = undefined;
            }

            flock.onMulAddInputChanged(that);
            that.dynamicGen(1);
        };

        that.onInputChanged();
        return that;
    };

    fluid.defaults("flock.ugen.value", {
        rate: "control",

        inputs: {
            value: 1.0,
            mul: null,
            add: null
        },

        ugenOptions: {
            model: {
                unscaledValue: 1.0,
                value: 1.0
            },

            tags: ["flock.ugen.valueType"]
        }
    });


    flock.ugen.silence = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.onInputChanged = function () {
            for (var i = 0; i < that.output.length; i++) {
                that.output[i] = 0.0;
            }
        };

        that.onInputChanged();
        return that;
    };

    fluid.defaults("flock.ugen.silence", {
        rate: "constant"
    });


    flock.ugen.passThrough = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.gen = function (numSamps) {
            var m = that.model,
                source = that.inputs.source.output,
                out = that.output,
                i,
                val;

            for (i = 0; i < source.length; i++) {
                out[i] = val = source[i];
            }

            for (; i < numSamps; i++) {
                out[i] = val = 0.0;
            }

            m.unscaledValue = val;
            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.onInputChanged();
        return that;
    };

    fluid.defaults("flock.ugen.passThrough", {
        rate: "audio",

        inputs: {
            source: null,
            mul: null,
            add: null
        }
    });


    /**
     * Changes from the <code>initial</code> input to the <code>target</code> input
     * at the specified <code>time</code>. An optional <code>crossfade</code> duration
     * may be specified to linearly crossfade between the two inputs.
     *
     * Can be used to schedule sample-accurate changes.
     * Note that the <code>target</code> input will be evaluated from the beginning,
     * even if its value isn't yet output.
     *
     */
    flock.ugen.change = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.gen = function (numSamps) {
            var m = that.model,
                initial = that.inputs.initial.output,
                initialInc = m.strides.initial,
                target = that.inputs.target.output,
                targetInc = m.strides.target,
                out = that.output,
                samplesLeft = m.samplesLeft,
                crossfadeLevel = m.crossfadeLevel,
                val;

            for (var i = 0, j = 0, k = 0; i < numSamps; i++, j += initialInc, k += targetInc) {
                if (samplesLeft > 0) {
                    // We haven't hit the scheduled time yet.
                    val = initial[j];
                    samplesLeft--;
                } else if (crossfadeLevel > 0.0) {
                    // We've hit the scheduled time, but we still need to peform the crossfade.
                    val = (initial[j] * crossfadeLevel) + (target[k] * (1.0 - crossfadeLevel));
                    crossfadeLevel -= m.crossfadeStepSize;
                } else {
                    // We're done.
                    val = target[k];
                }

                out[i] = val;
            }

            m.samplesLeft = samplesLeft;
            m.crossfadeLevel = crossfadeLevel;
            m.value = m.unscaledValue = val;
        };

        that.onInputChanged = function (inputName) {
            var m = that.model,
                inputs = that.inputs;

            if (inputName === "time" || !inputName) {
                m.samplesLeft = Math.round(inputs.time.output[0] * m.sampleRate);
            }

            if (inputName === "crossfade" || !inputName) {
                m.crossfadeStepSize = 1.0 / Math.round(inputs.crossfade.output[0] * m.sampleRate);
                m.crossfadeLevel = inputs.crossfade.output[0] > 0.0 ? 1.0 : 0.0;
            }

            that.calculateStrides();
        };

        that.onInputChanged();

        return that;
    };

    fluid.defaults("flock.ugen.change", {
        rate: "audio",

        inputs: {
            /**
             * An input unit generator to output initially.
             * Can be audio, control, or constant rate.
             */
            initial: 0.0,

            /**
             * The unit generator to output after the specified time.
             * Can be audio, control, or constant rate.
             */
            target: 0.0,

            /**
             * The sample-accurate time (in seconds) at which the
             * the change should occur.
             */
            time: 0.0,

            /**
             * The duration of the optional linear crossfade between
             * the two values.
             */
            crossfade: 0.0
        },

        ugenOptions: {
            model: {
                samplesLeft: 0.0,
                crossfadeStepSize: 0,
                crossfadeLevel: 0.0,
                unscaledValue: 0.0,
                value: 0.0
            },
            strideInputs: ["initial", "target"]
        }
    });


    flock.ugen.valueChangeTrigger = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.gen = function (numSamps) {
            var m = that.model,
                source = that.inputs.source.output,
                out = that.output,
                i,
                j,
                val;

            for (i = 0, j = 0; i < numSamps; i++, j += m.strides.source) {
                val = source[j];
                out[i] = val !== m.prevVal ? 1.0 : 0.0;
                m.prevVal = val;
            }

            m.value = m.unscaledValue = val;
        };

        that.onInputChanged = function (inputName) {
            that.calculateStrides();

            if (inputName === "source") {
                // Force a trigger to be output whenever the input is changed,
                // even if it's the same value as was previously held.
                that.model.prevVal = null;
            }
        };

        that.calculateStrides();
        return that;
    };

    fluid.defaults("flock.ugen.valueChangeTrigger", {
        rate: "control",

        inputs: {
            source: 0.0
        },
        ugenOptions: {
            model: {
                unscaledValue: 0.0,
                value: 0.0,
                prevVal: 0.0
            },

            strideInputs: ["source"]
        }
    });


    flock.ugen.inputChangeTrigger = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.gen = function (numSamps) {
            var m = that.model,
                source = that.inputs.source.output,
                sourceInc = m.strides.source,
                duration = that.inputs.duration.output,
                durationInc = m.strides.duration,
                prevDur = m.prevDur,
                out = that.output,
                i,
                j,
                k,
                val,
                dur;

            for (i = j = k = 0; i < numSamps; i++, j += sourceInc, k += durationInc) {
                val = source[j];
                dur = duration[k];

                if (dur !== prevDur) {
                    m.prevDur = dur;
                    m.remainingOpenSamples = val > 0 ? (dur > 0 ? m.sampleRate * dur : 1) : 0;
                }

                if (m.remainingOpenSamples > 0) {
                    out[i] = val;
                    m.remainingOpenSamples--;
                } else {
                    out[i] = 0.0;
                }
            }

            m.value = m.unscaledValue = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.onInputChanged = function (inputName) {
            that.calculateStrides();

            if (inputName === "source") {
                that.model.prevDur = null;
            }
        };

        that.calculateStrides();
        return that;
    };

    fluid.defaults("flock.ugen.inputChangeTrigger", {
        rate: "control",

        inputs: {
            source: 0,
            duration: 0
        },

        ugenOptions: {
            model: {
                unscaledValue: 0.0,
                value: 0.0,
                prevDuration: 0,
                remainingOpenSamples: 0
            },

            strideInputs: ["source", "duration"]
        }
    });

    flock.ugen.triggerCallback = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.gen = function (numSamps) {
            var m = that.model,
                o = that.options,
                out = that.output,
                inputs = that.inputs,
                triggerInc = m.strides.trigger,
                sourceInc = m.strides.source,
                trig = inputs.trigger.output,
                source = inputs.source.output,
                cbSpec = o.callback,
                fn = cbSpec.func,
                args = cbSpec.args,
                cbThis = cbSpec.this,
                lastArgIdx = m.lastArgIdx,
                prevTrig = m.prevTrig,
                i,
                j,
                k,
                currTrig,
                sourceVal;

            for (i = j = k = 0; i < numSamps; i++, j += triggerInc, k += sourceInc) {
                currTrig = trig[j];
                sourceVal = source[k];

                if (currTrig > 0.0 && prevTrig <= 0.0 && fn) {
                    // Insert the current source value into the arguments list
                    // and then invoke the specified callback function.
                    args[lastArgIdx] = sourceVal;
                    fn.apply(cbThis, args);
                }

                out[i] = sourceVal;
                prevTrig = currTrig;
            }

            m.prevTrig = prevTrig;
            m.value = m.unscaledValue = sourceVal;
        };

        that.onInputChanged = function () {
            var o = that.options,
                m = that.model,
                cbSpec = o.callback,
                funcName = cbSpec.funcName;

            if (funcName) {
                cbSpec.func = fluid.getGlobalValue(funcName);
            } else if (cbSpec.this && cbSpec.method) {
                if (typeof cbSpec.this !== "string") {
                    throw new Error("flock.ugen.triggerCallback doesn't support raw 'this' objects." +
                        "Use a global key path instead.");
                }
                cbSpec.this = typeof cbSpec.this === "string" ?
                    fluid.getGlobalValue(cbSpec.this) : cbSpec.this;
                cbSpec.func = fluid.get(cbSpec.this, cbSpec.method);
            }

            m.lastArgIdx = cbSpec.args.length;
            that.calculateStrides();
        };

        that.onInputChanged();
        return that;
    };

    fluid.defaults("flock.ugen.triggerCallback", {
        rate: "audio",
        inputs: {
            source: 0,
            trigger: 0
        },
        ugenOptions: {
            model: {
                unscaledValue: 0.0,
                value: 0.0,
                funcName: undefined,
                lastArgIdx: 0
            },
            callback: {
                "this": undefined,
                method: undefined,
                func: undefined,
                args: []
            },
            strideInputs: ["source", "trigger"]
        }
    });

    flock.ugen.math = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);
        that.expandedSource = new Float32Array(that.options.audioSettings.blockSize);

        that.krSourceKrInputGen = function () {
            var m = that.model,
                op = that.activeInput,
                input = that.inputs[op],
                out = that.output,
                sourceBuf = flock.generate(that.expandedSource, that.inputs.source.output[0]);

            DSP[op](out, sourceBuf, input.output[0]);
            m.value = m.unscaledValue = out[out.length - 1];
        };

        that.krSourceArInputGen = function () {
            var m = that.model,
                op = that.activeInput,
                input = that.inputs[op],
                out = that.output,
                sourceBuf = flock.generate(that.expandedSource, that.inputs.source.output[0]);

            DSP[op](out, sourceBuf, input.output);
            m.value = m.unscaledValue = out[out.length - 1];
        };

        that.arSourceKrInputGen = function () {
            var m = that.model,
                op = that.activeInput,
                input = that.inputs[op],
                out = that.output,
                sourceBuf = that.inputs.source.output;

            DSP[op](out, sourceBuf, input.output[0]);
            m.value = m.unscaledValue = out[out.length - 1];
        };

        that.arSourceArInputGen = function () {
            var m = that.model,
                op = that.activeInput,
                input = that.inputs[op],
                out = that.output;

            DSP[op](that.output, that.inputs.source.output, input.output);
            m.value = m.unscaledValue = out[out.length - 1];
        };

        that.onInputChanged = function () {
            // Find the first input and use it. Multiple inputters, beware.
            // TODO: Support multiple operations.
            var inputs = Object.keys(that.inputs),
                i,
                input,
                isInputAudioRate;

            for (i = 0; i < inputs.length; i++) {
                input = inputs[i];
                if (input !== "source") {
                    that.activeInput = input;
                    isInputAudioRate = that.inputs[input].rate === "audio";
                    that.gen = that.inputs.source.rate === "audio" ?
                        (isInputAudioRate ? that.arSourceArInputGen : that.arSourceKrInputGen) :
                        (isInputAudioRate ? that.krSourceArInputGen : that.krSourceKrInputGen);
                    break;
                }
            }
        };

        that.init = function () {
            if (typeof (DSP) === "undefined") {
                throw new Error("DSP is undefined. Please include dspapi.js to use the flock.math unit generator.");
            }
            that.onInputChanged();
        };

        that.init();
        return that;
    };

    fluid.defaults("flock.ugen.math", {
        rate: "audio",
        inputs: {
            // Any Web Array Math operator is supported as an input.
            source: null
        }
    });


    flock.ugen.sum = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.copyGen = function (numSamps) {
            var m = that.model,
                out = that.output,
                source = that.inputs.sources.output,
                i;

            for (i = 0; i < numSamps; i++) {
                out[i] = source[i];
            }

            m.value = m.unscaledValue = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.sumGen = function (numSamps) {
            var m = that.model,
                sources = that.inputs.sources,
                out = that.output,
                i,
                sourceIdx,
                sum;

            for (i = 0; i < numSamps; i++) {
                sum = 0;
                for (sourceIdx = 0; sourceIdx < sources.length; sourceIdx++) {
                    sum += sources[sourceIdx].output[i];
                }
                out[i] = sum;
            }

            m.value = m.unscaledValue = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.onInputChanged = function () {
            if (typeof (that.inputs.sources.length) === "number") {
                // We have an array of sources that need to be summed.
                that.gen = that.sumGen;
            } else {
                that.gen = that.copyGen;
            }
        };

        that.onInputChanged();
        return that;
    };

    fluid.defaults("flock.ugen.sum", {
        rate: "audio",
        inputs: {
            sources: null
        }
    });


    /***************
     * Oscillators *
     ***************/

    flock.ugen.osc = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.gen = function (numSamps) {
            var m = that.model,
                inputs = that.inputs,
                freq = inputs.freq.output,
                phaseOffset = inputs.phase.output,
                table = inputs.table,
                tableLen = m.tableLen,
                tableIncHz = m.tableIncHz,
                tableIncRad = m.tableIncRad,
                out = that.output,
                phase = m.phase,
                i,
                j,
                k,
                idx,
                val;

            for (i = 0, j = 0, k = 0; i < numSamps; i++, j += m.strides.phase, k += m.strides.freq) {
                idx = phase + phaseOffset[j] * tableIncRad;
                if (idx >= tableLen) {
                    idx -= tableLen;
                } else if (idx < 0) {
                    idx += tableLen;
                }
                out[i] = val = that.interpolate(idx, table);
                phase += freq[k] * tableIncHz;
                if (phase >= tableLen) {
                    phase -= tableLen;
                } else if (phase < 0) {
                    phase += tableLen;
                }
            }

            m.phase = phase;
            m.unscaledValue = val;
            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.onInputChanged = function (inputName) {
            flock.ugen.osc.onInputChanged(that);

            // Precalculate table-related values.
            if (!inputName || inputName === "table") {
                var m = that.model,
                    table = that.inputs.table;

                if (table.length < 1) {
                    table = that.inputs.table = flock.ugen.osc.emptyTable;
                }

                m.tableLen = table.length;
                m.tableIncHz = m.tableLen / m.sampleRate;
                m.tableIncRad =  m.tableLen / flock.TWOPI;
            }
        };

        that.onInputChanged();
        return that;
    };

    flock.ugen.osc.emptyTable = new Float32Array([0, 0, 0]);

    flock.ugen.osc.onInputChanged = function (that) {
        that.calculateStrides();
        flock.onMulAddInputChanged(that);
    };

    fluid.defaults("flock.ugen.osc", {
        rate: "audio",
        inputs: {
            freq: 440.0,
            phase: 0.0,
            table: [],
            mul: null,
            add: null
        },
        ugenOptions: {
            interpolation: "linear",
            model: {
                phase: 0.0,
                unscaledValue: 0.0,
                value: 0.0
            },
            strideInputs: [
                "freq",
                "phase"
            ]
        },
        tableSize: 8192
    });

    flock.ugen.osc.define = function (name, tableFillFn) {
        var lastSegIdx = name.lastIndexOf("."),
            namespace = name.substring(0, lastSegIdx),
            oscName = name.substring(lastSegIdx + 1),
            namespaceObj = flock.get(namespace);

        namespaceObj[oscName] = function (inputs, output, options) {
            // TODO: Awkward options pre-merging. Refactor osc API.
            var defaults = fluid.defaults("flock.ugen.osc"),
                merged = fluid.merge(null, defaults, options),
                s = merged.tableSize;
            inputs.table = flock.fillTable(s, tableFillFn);
            return flock.ugen.osc(inputs, output, options);
        };

        fluid.defaults(name, fluid.defaults("flock.ugen.osc"));
    };

    flock.ugen.osc.define("flock.ugen.sinOsc", flock.tableGenerators.sin);
    flock.ugen.osc.define("flock.ugen.triOsc", flock.tableGenerators.tri);
    flock.ugen.osc.define("flock.ugen.sawOsc", flock.tableGenerators.saw);
    flock.ugen.osc.define("flock.ugen.squareOsc", flock.tableGenerators.square);


    flock.ugen.sin = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.gen = function (numSamps) {
            var m = that.model,
                freq = that.inputs.freq.output,
                phaseOffset = that.inputs.phase.output,
                out = that.output,
                phase = m.phase,
                sampleRate = m.sampleRate,
                i,
                j,
                k,
                val;

            for (i = 0, j = 0, k = 0; i < numSamps; i++, j += m.strides.phase, k += m.strides.freq) {
                out[i] = val = Math.sin(phase + phaseOffset[j]);
                phase += freq[k] / sampleRate * flock.TWOPI;
            }

            m.phase = phase;
            m.unscaledValue = val;
            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.onInputChanged = function () {
            flock.ugen.osc.onInputChanged(that);
        };

        that.onInputChanged();
        return that;
    };

    fluid.defaults("flock.ugen.sin", {
        rate: "audio",
        inputs: {
            freq: 440.0,
            phase: 0.0,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                phase: 0.0,
                unscaledValue: 0.0,
                value: 0.0
            },
            strideInputs: [
                "freq",
                "phase"
            ]
        }
    });


    flock.ugen.lfSaw = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.gen = function (numSamps) {
            var m = that.model,
                freq = that.inputs.freq.output,
                out = that.output,
                scale = m.scale,
                phaseOffset = that.inputs.phase.output[0], // Phase is control rate
                phase = m.phase, // TODO: Prime synth graph on instantiation.
                i,
                j,
                val;

            for (i = 0, j = 0; i < numSamps; i++, j += m.strides.freq) {
                out[i] = val = phase + phaseOffset;
                phase += freq[j] * scale;
                if (phase >= 1.0) {
                    phase -= 2.0;
                } else if (phase <= -1.0) {
                    phase += 2.0;
                }
            }

            m.phase = phase;
            m.unscaledValue = val;
            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.onInputChanged = function () {
            var m = that.model;
            m.freqInc = that.inputs.freq.rate === flock.rates.AUDIO ? 1 : 0;
            m.phase = 0.0;
            that.calculateStrides();
            flock.onMulAddInputChanged(that);
        };

        that.init = function () {
            that.model.scale = 2 * (1 / that.options.sampleRate);
            that.onInputChanged();
        };

        that.init();
        return that;
    };

    fluid.defaults("flock.ugen.lfSaw", {
        rate: "audio",
        inputs: {
            freq: 440,
            phase: 0.0,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                phase: 0.0,
                freqInc: 1,
                unscaledValue: 0.0,
                value: 0.0
            },
            strideInputs: ["freq"]
        }
    });


    flock.ugen.lfPulse = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.gen = function (numSamps) {
            var inputs = that.inputs,
                m = that.model,
                freq = inputs.freq.output,
                freqInc = m.freqInc,
                width = inputs.width.output[0], // TODO: Are we handling width correctly here?
                out = that.output,
                scale = m.scale,
                phase = m.phase !== undefined ? m.phase : inputs.phase.output[0], // TODO: Unnecessary if we knew the synth graph had been primed.
                i,
                j,
                val;

            for (i = 0, j = 0; i < numSamps; i++, j += freqInc) {
                if (phase >= 1.0) {
                    phase -= 1.0;
                    out[i] = val = width < 0.5 ? 1.0 : -1.0;
                } else {
                    out[i] = val = phase < width ? 1.0 : -1.0;
                }
                phase += freq[j] * scale;
            }

            m.phase = phase;
            m.unscaledValue = val;
            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.onInputChanged = function () {
            that.model.freqInc = that.inputs.freq.rate === flock.rates.AUDIO ? 1 : 0;
            flock.onMulAddInputChanged(that);
        };

        that.init = function () {
            that.model.scale = 1 / that.options.sampleRate;
            that.onInputChanged();
        };

        that.init();
        return that;
    };

    fluid.defaults("flock.ugen.lfPulse", {
        rate: "audio",
        inputs: {
            freq: 440,
            phase: 0.0,
            width: 0.5,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                phase: 0.0,
                freqInc: 1,
                unscaledValue: 0.0,
                value: 0.0
            }
        }
    });


    flock.ugen.impulse = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.gen = function (numSamps) {
            var inputs = that.inputs,
                m = that.model,
                out = that.output,
                freq = inputs.freq.output,
                freqInc = m.strides.freq,
                phaseOffset = inputs.phase.output[0],
                phase = m.phase,
                scale = m.scale,
                i,
                j,
                val;

            phase += phaseOffset;

            for (i = 0, j = 0; i < numSamps; i++, j += freqInc) {
                if (phase >= 1.0) {
                    phase -= 1.0;
                    val = 1.0;
                } else {
                    val = 0.0;
                }
                out[i] = val;
                phase += freq[j] * scale;
            }

            m.phase = phase - phaseOffset;
            m.unscaledValue = val;
            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.onInputChanged = function () {
            that.calculateStrides();
            flock.onMulAddInputChanged(that);
        };

        that.init = function () {
            that.model.scale = 1.0 / that.model.sampleRate;
            that.onInputChanged();
        };

        that.init();
        return that;
    };

    fluid.defaults("flock.ugen.impulse", {
        rate: "audio",
        inputs: {
            freq: 440,
            phase: 0.0,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                phase: 0.0,
                scale: 0.0,
                unscaledValue: 0.0,
                value: 0.0
            },
            strideInputs: ["freq"]
        }
    });


    flock.ugen.t2a = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.gen = function () {
            var m = that.model,
                trig = that.inputs.source.output[0],
                offset = that.inputs.offset.output[0] | 0,
                out = that.output,
                val;

            // Clear the output buffer.
            for (var i = 0; i < out.length; i++) {
                out[i] = val = 0.0;
            }

            // Write the trigger value to the audio stream if it's open.
            if (trig > 0.0 && m.prevTrig <= 0.0) {
                out[offset] = val = trig;
            }

            m.prevTrig = trig;
            m.value = m.unscaledValue = val;
        };

        return that;
    };

    fluid.defaults("flock.ugen.t2a", {
        rate: "audio",
        inputs: {
            source: null,
            offset: 0
        },
        ugenOptions: {
            model: {
                prevTrig: 0.0,
                unscaledValue: 0.0,
                value: 0.0
            }
        }
    });


    flock.ugen.latch = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.arGen = function (numSamps) {
            var m = that.model,
                inputs = that.inputs,
                source = inputs.source.output,
                trig = inputs.trigger,
                sourceInc = m.strides.source,
                out = that.output,
                i, j,
                currTrig,
                val;

            if (m.holdVal === undefined) {
                m.holdVal = source[0];
            }

            for (i = 0, j = 0; i < numSamps; i++, j += sourceInc) {
                currTrig = trig.output[i];
                out[i] = val = (currTrig > 0.0 && m.prevTrig <= 0.0) ? m.holdVal = source[j] : m.holdVal;
                m.prevTrig = currTrig;
            }

            m.unscaledValue = val;
            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.krGen = function (numSamps) {
            var m = that.model,
                out = that.output,
                currTrig = that.inputs.trigger.output[0],
                i;

            if (m.holdVal === undefined || currTrig > 0.0 && m.prevTrig <= 0.0) {
                m.holdVal = that.inputs.source.output[0];
            }
            m.prevTrig = currTrig;

            for (i = 0; i < numSamps; i++) {
                out[i] = m.holdVal;
            }

            m.unscaledValue = m.holdVal;
            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.onInputChanged = function () {
            that.calculateStrides();
            that.gen = that.inputs.trigger.rate === flock.rates.AUDIO ? that.arGen : that.krGen;
            flock.onMulAddInputChanged(that);
        };

        that.onInputChanged();
        return that;
    };

    fluid.defaults("flock.ugen.latch", {
        rate: "audio",
        inputs: {
            source: null,
            trigger: 0.0,
            mul: null,
            add: null
        },
        ugenOptions: {
            strideInputs: ["source"],
            model: {
                prevTrig: 0.0,
                unscaledValue: 0.0,
                value: 0.0
            }
        }
    });


    /****************
     * Buffer UGens *
     ****************/

    /**
     * Mixes buffer-related functionality into a unit generator.
     */
    flock.ugen.buffer = function (that) {
        that.onBufferInputChanged = function (inputName) {
            var m = that.model,
                inputs = that.inputs;

            if (m.bufDef !== inputs.buffer || inputName === "buffer") {
                m.bufDef = inputs.buffer;
                flock.parse.bufferForDef(m.bufDef, that, flock.enviro.shared); // TODO: Shared enviro reference.
            }
        };

        that.setBuffer = function (bufDesc) {
            that.buffer = bufDesc;
            if (that.onBufferReady) {
                that.onBufferReady(bufDesc);
            }
        };

        that.initBuffer = function () {
            // Start with a zeroed buffer, since the buffer input may be loaded asynchronously.
            that.buffer = that.model.bufDef = flock.bufferDesc({
                format: {
                    sampleRate: that.options.audioSettings.rates.audio
                },
                data: {
                    channels: [new Float32Array(that.output.length)]
                }
            });
        };
    };


    flock.ugen.playBuffer = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.defaultKrTriggerGen = function (numSamps) {
            var m = that.model,
                out = that.output,
                chan = that.inputs.channel.output[0],
                source = that.buffer.data.channels[chan],
                bufIdx = m.idx,
                loop = that.inputs.loop.output[0],
                trigVal = inputs.trigger.output[0],
                i,
                samp;

            if (trigVal > 0.0 && m.prevTrig <= 0.0) {
                bufIdx = 0;
            }
            m.prevTrig = trigVal;

            for (i = 0; i < numSamps; i++) {
                if (bufIdx > m.lastIdx) {
                    if (loop > 0.0 && trigVal > 0.0) {
                        bufIdx = 0;
                    } else {
                        out[i] = samp = 0.0;
                        continue;
                    }
                }

                samp = that.interpolate(bufIdx, source);
                out[i] = samp;
                bufIdx++;
            }

            m.idx = bufIdx;
            m.unscaledValue = samp;
            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.otherwiseGen = function (numSamps) {
            var m = that.model,
                out = that.output,
                chan = that.inputs.channel.output[0],
                speed = that.inputs.speed.output,
                source = that.buffer.data.channels[chan],
                trig = inputs.trigger.output,
                bufIdx = m.idx,
                loop = that.inputs.loop.output[0],
                start = (that.inputs.start.output[0] * m.lastIdx) | 0,
                end = (that.inputs.end.output[0] * m.lastIdx) | 0,
                i,
                j,
                k,
                trigVal,
                speedVal,
                samp;

            for (i = 0, j = 0, k = 0; i < numSamps; i++, j += m.strides.trigger, k += m.strides.speed) {
                trigVal = trig[j];
                speedVal = speed[k];

                if (trigVal > 0.0 && m.prevTrig <= 0.0) {
                    bufIdx = flock.ugen.playBuffer.resetIndex(speedVal, start, end);
                } else if (bufIdx < start || bufIdx > end) {
                    if (loop > 0.0 && trigVal > 0.0) {
                        bufIdx = flock.ugen.playBuffer.resetIndex(speedVal, start, end);
                    } else {
                        out[i] = samp = 0.0;
                        continue;
                    }
                }
                m.prevTrig = trig[j];

                samp = that.interpolate(bufIdx, source);
                out[i] = samp;
                bufIdx += m.stepSize * speedVal;
            }

            m.idx = bufIdx;
            m.unscaledValue = samp;
            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.onInputChanged = function (inputName) {
            var inputs = that.inputs,
                speed = inputs.speed,
                start = inputs.start,
                end = inputs.end,
                trig = inputs.trigger;

            that.onBufferInputChanged(inputName);

            // TODO: Optimize for non-regular speed constant rate input.
            that.gen = (speed.rate === flock.rates.CONSTANT && speed.output[0] === 1.0) &&
                (start.rate === flock.rates.CONSTANT && start.output[0] === 0.0) &&
                (end.rate === flock.rates.CONSTANT && end.output[0] === 1.0) &&
                (trig.rate !== flock.rates.AUDIO) ?
                that.defaultKrTriggerGen : that.otherwiseGen;

            that.calculateStrides();
            flock.onMulAddInputChanged(that);
        };

        that.onBufferReady = function () {
            var m = that.model,
                end = that.inputs.end.output[0],
                chan = that.inputs.channel.output[0],
                buf = that.buffer.data.channels[chan],
                len = buf.length;

            m.idx = (end * len) | 0;
            m.lastIdx = len - 1;
            m.stepSize = that.buffer.format.sampleRate / m.sampleRate;
        };

        that.init = function () {
            flock.ugen.buffer(that);
            that.initBuffer();
            that.onInputChanged();
        };

        that.init();
        return that;
    };

    flock.ugen.playBuffer.resetIndex = function (speed, start, end) {
        return speed > 0 ? start : end;
    };

    fluid.defaults("flock.ugen.playBuffer", {
        rate: "audio",
        inputs: {
            channel: 0,
            loop: 0.0,
            speed: 1.0,
            start: 0.0,
            end: 1.0,
            trigger: 1.0,
            buffer: null,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                finished: false,
                unscaledValue: 0.0,
                value: 0.0,
                idx: 0,
                stepSize: 0,
                prevTrig: 0,
                channel: undefined
            },
            strideInputs: ["trigger", "speed"],
            interpolation: "linear"
        }
    });

    /**
     * Reads values out of a buffer at the specified phase index.
     * This unit generator is typically used with flock.ugen.phasor or similar unit generator to
     * scan through the buffer at a particular rate.
     *
     * Inputs:
     *  - buffer: a bufDef representing the buffer to read from
     *  - channel: the channel of the buffer to read from
     *  - phase: the phase of the buffer to read (this should be a value between 0..1)
     */
    // TODO: This should be refactored based on the model of bufferPhaseStep below.
    flock.ugen.readBuffer = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.gen = function (numSamps) {
            var m = that.model,
                phaseS = m.strides.phase,
                out = that.output,
                chan = that.inputs.channel.output[0],
                phase = that.inputs.phase.output,
                source = that.buffer.data.channels[chan],
                sourceLen = source.length,
                i,
                bufIdx,
                j,
                val;

            for (i = j = 0; i < numSamps; i++, j += phaseS) {
                bufIdx = phase[j] * sourceLen;
                val = that.interpolate(bufIdx, source);
                out[i] = val;
            }

            m.unscaledValue = val;
            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.onInputChanged = function (inputName) {
            that.onBufferInputChanged(inputName);
            that.calculateStrides();
            flock.onMulAddInputChanged(that);
        };

        that.init = function () {
            flock.ugen.buffer(that);
            that.initBuffer();
            that.onInputChanged();
        };

        that.init();
        return that;
    };

    fluid.defaults("flock.ugen.readBuffer", {
        rate: "audio",

        inputs: {
            buffer: null,
            channel: 0,
            phase: 0,
            mul: null,
            add: null
        },

        ugenOptions: {
            model: {
                channel: undefined,
                unscaledValue: 0.0,
                value: 0.0
            },
            strideInputs: [
                "phase"
            ],
            interpolation: "linear"
        }
    });

    /**
     * Outputs the duration of the specified buffer. Runs at either constant or control rate.
     * Use control rate only when the underlying buffer may change dynamically.
     *
     * Inputs:
     *  buffer: a bufDef object specifying the buffer to track
     */
    flock.ugen.bufferDuration = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.krGen = function (numSamps) {
            var m = that.model,
                out = that.output,
                chan = that.inputs.channel.output[0],
                source = that.buffer.data.channels[chan],
                rate = that.buffer.format.sampleRate,
                i;

            for (i = 0; i < numSamps; i++) {
                out[i] = source.length / rate;
            }

            m.unscaledValue = m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.onInputChanged = function (inputName) {
            that.onBufferInputChanged(inputName);
        };

        that.onBufferReady = function () {
            that.krGen(1);
        };

        that.init = function () {
            var r = that.rate;
            that.gen = (r === flock.rates.CONTROL || r === flock.rates.AUDIO) ? that.krGen : undefined;
            that.output[0] = 0.0;
            flock.ugen.buffer(that);
            that.initBuffer();
            that.onInputChanged();
        };

        that.init();
        return that;
    };

    fluid.defaults("flock.ugen.bufferDuration", {
        rate: "constant",
        inputs: {
            buffer: null,
            channel: 0
        },
        ugenOptions: {
            model: {
                unscaledValue: 0.0,
                value: 0.0
            }
        }
    });

    /**
     * Outputs the length of the specified buffer in samples. Runs at either constant or control rate.
     * Use control rate only when the underlying buffer may change dynamically.
     *
     * Inputs:
     *  buffer: a bufDef object specifying the buffer to track
     */
    flock.ugen.bufferLength = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.krGen = function (numSamps) {
            var m = that.model,
                out = that.output,
                chan = that.inputs.channel.output[0],
                source = that.buffer.data.channels[chan],
                len = source.length,
                i;

            for (i = 0; i < numSamps; i++) {
                out[i] = len;
            }

            m.value = m.unscaledValue = len;
        };

        that.onInputChanged = function (inputName) {
            that.onBufferInputChanged(inputName);
        };

        that.onBufferReady = function () {
            that.krGen(1);
        };

        that.init = function () {
            var r = that.rate;
            that.gen = (r === flock.rates.CONTROL || r === flock.rates.AUDIO) ? that.krGen : undefined;
            that.output[0] = 0.0;
            flock.ugen.buffer(that);
            that.initBuffer();
            that.onInputChanged();
        };

        that.init();
        return that;
    };

    fluid.defaults("flock.ugen.bufferLength", {
        rate: "constant",
        inputs: {
            buffer: null,
            channel: 0
        },
        ugenOptions: {
            model: {
                unscaledValue: 0.0,
                value: 0.0
            }
        }
    });

    /**
     * Outputs a phase step value for playing the specified buffer at its normal playback rate.
     * This unit generator takes into account any differences between the sound file's sample rate and
     * the environment's audio rate.
     *
     * Inputs:
     *  buffer: a bufDef object specifying the buffer to track
     */
    flock.ugen.bufferPhaseStep = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.krGen = function (numSamps) {
            var m = that.model,
                out = that.output,
                val = m.unscaledValue,
                i;

            for (i = 0; i < numSamps; i++) {
                out[i] = val;
            }

            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.onInputChanged = function (inputName) {
            that.onBufferInputChanged(inputName);
            flock.onMulAddInputChanged(that);
        };

        that.onBufferReady = function (buffer) {
            var m = that.model,
                chan = that.inputs.channel.output[0],
                source = buffer.data.channels[chan],
                enviroRate = that.options.audioSettings.rates.audio,
                bufferRate = that.buffer.format.sampleRate || enviroRate;

            m.scale = bufferRate / enviroRate;
            that.output[0] = m.unscaledValue = 1 / (source.length * m.scale);
        };

        that.init = function () {
            var r = that.rate;
            that.gen = (r === flock.rates.CONTROL || r === flock.rates.AUDIO) ? that.krGen : undefined;
            that.output[0] = 0.0;
            flock.ugen.buffer(that);
            that.initBuffer();
            that.onInputChanged();
        };

        that.init();
        return that;
    };

    fluid.defaults("flock.ugen.bufferPhaseStep", {
        rate: "constant",
        inputs: {
            buffer: null,
            channel: 0
        },
        ugenOptions: {
            model: {
                scale: 1.0,
                unscaledValue: 0.0,
                value: 0.0
            }
        }
    });

    /**
     * Constant-rate unit generator that outputs the environment's current audio sample rate.
     */
    flock.ugen.sampleRate = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options),
            m = that.model;

        that.output[0] = m.value = m.unscaledValue = that.options.audioSettings.rates.audio;

        return that;
    };

    fluid.defaults("flock.ugen.sampleRate", {
        rate: "constant",
        inputs: {}
    });


    /*********
     * Noise *
     *********/

    flock.ugen.dust = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.gen = function (numSamps) {
            var m = that.model,
                out = that.output,
                density = inputs.density.output[0], // Density is kr.
                threshold,
                scale,
                rand,
                val,
                i;

            if (density !== m.density) {
                m.density = density;
                threshold = m.threshold = density * m.sampleDur;
                scale = m.scale = threshold > 0.0 ? 1.0 / threshold : 0.0;
            } else {
                threshold = m.threshold;
                scale = m.scale;
            }

            for (i = 0; i < numSamps; i++) {
                rand = Math.random();
                val = (rand < threshold) ? rand * scale : 0.0;
                out[i] = val;
            }

            m.unscaledValue = val;
            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.onInputChanged();
        return that;
    };

    fluid.defaults("flock.ugen.dust", {
        rate: "audio",
        inputs: {
            density: 1.0,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                density: 0.0,
                scale: 0.0,
                threshold: 0.0,
                unscaledValue: 0.0,
                value: 0.0
            }
        }
    });


    flock.ugen.whiteNoise = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.gen = function (numSamps) {
            var m = that.model,
                out = that.output,
                i,
                val;

            for (i = 0; i < numSamps; i++) {
                out[i] = val = Math.random();
            }

            m.unscaledValue = val;
            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.onInputChanged();
        return that;
    };

    fluid.defaults("flock.ugen.whiteNoise", {
        rate: "audio",
        inputs: {
            mul: null,
            add: null
        }
    });


    /**
     * Implements Larry Tramiel's first Pink Noise algorithm
     * described at http://home.earthlink.net/~ltrammell/tech/pinkalg.htm,
     * based on a version by David Lowenfels posted to musicdsp:
     * http://www.musicdsp.org/showone.php?id=220.
     */
    flock.ugen.pinkNoise = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.gen = function (numSamps) {
            var m = that.model,
                state = m.state,
                a = that.a,
                p = that.p,
                offset = m.offset,
                out = that.output,
                i,
                j,
                rand,
                val;

            for (i = 0; i < numSamps; i++) {
                val = 0;
                for (j = 0; j < state.length; j++) {
                    rand = Math.random();
                    state[j] = p[j] * (state[j] - rand) + rand;
                    val += a[j] * state[j];
                }
                val = val * 2 - offset;
                out[i] = val;
            }

            m.unscaledValue = val;
            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.init = function () {
            that.a = new Float32Array(that.options.coeffs.a);
            that.p = new Float32Array(that.options.coeffs.p);
            that.model.state = new Float32Array(that.a.length);

            for (var i = 0; i < that.a.length; i++) {
                that.model.offset += that.a[i];
            }

            that.onInputChanged();
        };

        that.init();
        return that;
    };

    fluid.defaults("flock.ugen.pinkNoise", {
        rate: "audio",
        inputs: {
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                state: 0.0,
                unscaledValue: 0.0,
                value: 0.0,
                offset: 0
            },
            coeffs: {
                a: [0.02109238, 0.07113478, 0.68873558],
                p: [0.3190, 0.7756, 0.9613]
            }
        }
    });

    flock.ugen.lfNoise = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.gen = function (numSamps) {
            var m = that.model,
                freq = inputs.freq.output[0], // Freq is kr.
                remain = numSamps,
                out = that.output,
                currSamp = 0,
                sampsForLevel,
                i;

            freq = freq > 0.001 ? freq : 0.001;
            do {
                if (m.counter <= 0) {
                    m.counter = m.sampleRate / freq;
                    m.counter = m.counter > 1 ? m.counter : 1;
                    if (that.options.interpolation === "linear") {
                        m.start = m.unscaledValue = m.end;
                        m.end = Math.random();
                        m.ramp = m.ramp = (m.end - m.start) / m.counter;
                    } else {
                        m.start = m.unscaledValue = Math.random();
                        m.ramp = 0;
                    }
                }
                sampsForLevel = remain < m.counter ? remain : m.counter;
                remain -= sampsForLevel;
                m.counter -= sampsForLevel;
                for (i = 0; i < sampsForLevel; i++) {
                    out[currSamp] = m.unscaledValue;
                     // TODO: This reuse of "unscaledValue" will cause the model to be out of sync
                     // with the actual output of the unit generator.
                    m.unscaledValue += m.ramp;
                    currSamp++;
                }

            } while (remain);

            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.input = function () {
            that.model.end = Math.random();
            that.onInputChanged();
        };

        that.input();
        return that;
    };

    fluid.defaults("flock.ugen.lfNoise", {
        rate: "audio",
        inputs: {
            freq: 440,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                counter: 0,
                level: 0,
                unscaledValue: 0.0,
                value: 0.0
            }
        }
    });

    /*****************************************************
     * Random distributions using Sim.js' Random library *
     *****************************************************/

    // TODO: Unit tests.
    flock.ugen.random = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.gen = function (numSamps) {
            var m = that.model,
                generator = that.generator,
                out = that.output,
                i,
                val;

            for (i = 0; i < numSamps; i++) {
                out[i] = val = generator.uniform(-1, 1);
            }

            m.unscaledValue = val;
            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.onInputChanged = function (inputName) {
            if (inputName === "seed") {
                that.initGenerator();
            }
            flock.onMulAddInputChanged(that);
        };

        that.initGenerator = function () {
            var seed = that.inputs.seed;
            that.generator = seed ? new Random(seed) : new Random();
        };

        that.init = function () {
            that.initGenerator();
            that.calculateStrides();
            that.onInputChanged();
        };

        that.init();
        return that;
    };

    fluid.defaults("flock.ugen.random", {
        rate: "audio",
        inputs: {
            seed: null,
            mul: null,
            add: null
        }
    });

    // TODO: Unit tests.
    flock.ugen.random.exponential = function (inputs, output, options) {
        var that = flock.ugen.random(inputs, output, options);

        that.gen = function (numSamps) {
            var m = that.model,
                generator = that.generator,
                out = that.output,
                lambda = that.inputs.lambda.output,
                lambdaInc = that.model.strides.lambda,
                i,
                j,
                val;

            for (i = j = 0; i < numSamps; i++, j += lambdaInc) {
                out[i] = val = generator.exponential(lambda[j]);
            }

            m.unscaledValue = val;
            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        return that;
    };

    fluid.defaults("flock.ugen.random.exponential", {
        rate: "audio",
        inputs: {
            seed: null,
            lambda: 1,
            mul: null,
            add: null
        },

        ugenOptions: {
            strideInputs: ["lambda"]
        }
    });

    // TODO: Unit tests.
    flock.ugen.random.gamma = function (inputs, output, options) {
        var that = flock.ugen.random(inputs, output, options);

        that.gen = function (numSamps) {
            var m = that.model,
                inputs = that.inputs,
                generator = that.generator,
                out = that.output,
                alphaInc = m.strides.alpha,
                alpha = inputs.alpha.output,
                betaInc = m.strides.beta,
                beta = inputs.beta.output,
                i,
                j,
                k,
                val;

            for (i = j = k = 0; i < numSamps; i++, j += alphaInc, k += betaInc) {
                out[i] = val = generator.gamma(alpha[j], beta[k]);
            }

            m.unscaledValue = val;
            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        return that;
    };

    fluid.defaults("flock.ugen.random.gamma", {
        rate: "audio",
        inputs: {
            seed: null,
            alpha: 1,
            beta: 2,
            mul: null,
            add: null
        },

        ugenOptions: {
            strideInputs: ["alpha", "beta"]
        }
    });

    // TODO: Unit tests.
    flock.ugen.random.normal = function (inputs, output, options) {
        var that = flock.ugen.random(inputs, output, options);

        that.gen = function (numSamps) {
            var m = that.model,
                out = that.output,
                inputs = that.inputs,
                generator = that.generator,
                muInc = m.strides.mu,
                mu = inputs.mu.output,
                sigmaInc = m.strides.sigma,
                sigma = inputs.sigma.output,
                i,
                j,
                k,
                val;

            for (i = j = k = 0; i < numSamps; i++, j += muInc, k += sigmaInc) {
                out[i] = val = generator.normal(mu[j], sigma[k]);
            }

            m.unscaledValue = val;
            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        return that;
    };

    fluid.defaults("flock.ugen.random.normal", {
        rate: "audio",
        inputs: {
            seed: null,
            mu: 0,
            sigma: 1,
            mul: null,
            add: null
        },

        ugenOptions: {
            strideInputs: ["mu", "sigma"]
        }
    });

    // TODO: Unit tests.
    flock.ugen.random.pareto = function (inputs, output, options) {
        var that = flock.ugen.random(inputs, output, options);

        that.gen = function (numSamps) {
            var m = that.model,
                generator = that.generator,
                out = that.output,
                alphaInc = that.model.strides.alpha,
                alpha = that.inputs.alpha.output,
                i,
                j,
                val;

            for (i = j = 0; i < numSamps; i++, j += alphaInc) {
                out[i] = val = generator.pareto(alpha[j]);
            }

            m.unscaledValue = val;
            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        return that;
    };

    fluid.defaults("flock.ugen.random.pareto", {
        rate: "audio",
        inputs: {
            seed: null,
            alpha: 5,
            mul: null,
            add: null
        },

        ugenOptions: {
            strideInputs: ["alpha"]
        }
    });

    // TODO: Unit tests.
    flock.ugen.random.triangular = function (inputs, output, options) {
        var that = flock.ugen.random(inputs, output, options);

        that.gen = function (numSamps) {
            var m = that.model,
                generator = that.generator,
                out = that.output,
                modeInc = that.model.strides.mode,
                mode = that.inputs.mode.output,
                i,
                j,
                val;

            for (i = j = 0; i < numSamps; i++, j += modeInc) {
                out[i] = val = generator.triangular(-1, 1, mode[j]);
            }

            m.unscaledValue = val;
            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        return that;
    };

    fluid.defaults("flock.ugen.random.triangular", {
        rate: "audio",
        inputs: {
            seed: null,
            mode: 0.5,
            mul: null,
            add: null
        },

        ugenOptions: {
            strideInputs: ["mode"]
        }
    });

    // TODO: Unit tests.
    flock.ugen.random.weibull = function (inputs, output, options) {
        var that = flock.ugen.random(inputs, output, options);

        that.gen = function (numSamps) {
            var m = that.model,
                inputs = that.inputs,
                generator = that.generator,
                out = that.output,
                alphaInc = m.strides.alpha,
                alpha = inputs.alpha.output,
                betaInc = m.strides.beta,
                beta = inputs.beta.output,
                i,
                j,
                k,
                val;

            for (i = j = k = 0; i < numSamps; i++, j += alphaInc, k += betaInc) {
                out[i] = val = generator.weibull(alpha[j], beta[k]);
            }

            m.unscaledValue = val;
            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        return that;
    };

    fluid.defaults("flock.ugen.random.weibull", {
        rate: "audio",
        inputs: {
            seed: null,
            alpha: 1,
            beta: 1,
            mul: null,
            add: null
        },

        ugenOptions: {
            strideInputs: ["alpha", "beta"]
        }
    });


    /**
     * Loops through a linear ramp from start to end, incrementing the output by step.
     * Equivalent to SuperCollider's or CSound's Phasor unit generator.
     *
     * Inputs:
     *  start: the value to start ramping from
     *  end: the value to ramp to
     *  step: the value to increment per sample
     *  reset: the value to return to when the loop is reset by a trigger signal
     *  trigger: a trigger signal that, when it cross the zero line, will reset the loop back to the reset point
     */
    flock.ugen.phasor = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.gen = function (numSamps) {
            var m = that.model,
                inputs = that.inputs,
                out = that.output,
                step = inputs.step.output,
                trig = inputs.trigger.output,
                i,
                j,
                k;

            // TODO: Add sample priming to the ugen graph to remove this conditional.
            if (m.unscaledValue === undefined) {
                m.unscaledValue = inputs.start.output[0];
            }

            for (i = 0, j = 0, k = 0; i < numSamps; i++, j += m.strides.trigger, k += m.strides.step) {
                if ((trig[j] > 0.0 && m.prevTrig <= 0.0)) {
                    m.unscaledValue = inputs.reset.output[0];
                }
                m.prevTrig = trig[j];

                if (m.unscaledValue >= inputs.end.output[0]) {
                    m.unscaledValue = inputs.start.output[0];
                }

                out[i] = m.unscaledValue;
                m.unscaledValue += step[k]; // TODO: Model out of sync with last output sample.
            }

            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.onInputChanged();

        return that;
    };

    fluid.defaults("flock.ugen.phasor", {
        rate: "control",
        inputs: {
            start: 0.0,
            end: 1.0,
            reset: 0.0,
            step: 0.1,
            trigger: 0.0,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                unscaledValue: undefined,
                value: 0.0
            },

            strideInputs: [
                "trigger",
                "step"
            ]
        }
    });


    flock.ugen.amplitude = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.gen = function (numSamps) {
            var m = that.model,
                source = that.inputs.source.output,
                out = that.output,
                prevAtt = m.attackTime,
                nextAtt = that.inputs.attack.output[0],
                prevRel = m.releaseTime,
                nextRel = that.inputs.release.output[0],
                prevVal = m.prevVal,
                attCoef = m.attackCoef,
                relCoef = m.releaseCoef,
                i,
                val,
                coef;

            // Convert 60 dB attack and release times to coefficients if they've changed.
            if (nextAtt !== prevAtt) {
                m.attackTime = nextAtt;
                attCoef = m.attackCoef =
                    nextAtt === 0.0 ? 0.0 : Math.exp(flock.LOG01 / (nextAtt * m.sampleRate));
            }

            if (nextRel !== prevRel) {
                m.releaseTime = nextRel;
                relCoef = m.releaseCoef =
                    (nextRel === 0.0) ? 0.0 : Math.exp(flock.LOG01 / (nextRel * m.sampleRate));
            }

            for (i = 0; i < numSamps; i++) {
                val = Math.abs(source[i]);
                coef = val < prevVal ? relCoef : attCoef;
                out[i] = prevVal = val + (prevVal - val) * coef;
            }

            m.unscaledValue = m.prevVal = prevVal;
            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.onInputChanged();
        return that;
    };

    fluid.defaults("flock.ugen.amplitude", {
        rate: "audio",
        inputs: {
            source: null,
            attack: 0.01,
            release: 0.01,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                prevVal: 0.0,
                unscaledValue: 0.0,
                value: 0.0
            }
        }
    });

    flock.ugen.normalize = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.gen = function () {
            var m = that.model,
                out = that.output,
                max = that.inputs.max.output[0], // Max is kr.
                source = that.inputs.source.output;

            // Note, this normalizes the source input ugen's output buffer directly in place.
            flock.normalize(source, max, out);
            m.value = m.unscaledValue = out[out.length - 1];
        };

        that.onInputChanged();
        return that;
    };

    fluid.defaults("flock.ugen.normalize", {
        rate: "audio",
        inputs: {
            max: 1.0,
            source: null
        }
    });

    /**
     * A gate that allows the source input signal to pass whenever the sideChain input
     * signal is greater than the threshold.
     *
     * If sideChain isn't specifed, the source signal itself is used to open the gate.
     * By default, the gate will output 0.0 if it is closed, but setting the holdLastValue
     * option to true enables it to hold the value of the gate when it was last open.
     *
     * Inputs:
     *     source: the signal that will be outputted whenever the gate is open.
     *     sideChain: (optional) a side chain signal that will
     *         cause the gate to open and close
     *     threshold: the minimum value at which the gate will open
     * Options:
     *      holdLastValue: determines whether the gate should hold its last open value or output silence
     */
    flock.ugen.gate = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.gen = function (numSamps) {
            var m = that.model,
                strides = m.strides,
                out = that.output,
                inputs = that.inputs,
                source = inputs.source.output,
                sideChain = inputs.sideChain.output,
                sideChainInc = strides.sideChain,
                threshold = inputs.threshold.output,
                thresholdInc = strides.threshold,
                holdLast = that.options.holdLastValue,
                lastValue = m.lastValue,
                i,
                j,
                k,
                val;

            for (i = j = k = 0; i < numSamps; i++, j += sideChainInc, k += thresholdInc) {
                if (sideChain[j] >= threshold[k]) {
                    out[i] = val = lastValue = source[i];
                } else {
                    // TODO: Don't check holdLast on each sample.
                    out[i] = val = holdLast ? lastValue : 0;
                }
            }

            m.lastValue = lastValue;
            m.unscaledValue = val;
            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.onInputChanged = function () {
            if (!that.inputs.sideChain) {
                that.inputs.sideChain = that.inputs.source;
            }

            flock.onMulAddInputChanged(that);
            that.calculateStrides();
        };

        that.onInputChanged();
        return that;
    };

    fluid.defaults("flock.ugen.gate", {
        rate: "audio",
        inputs: {
            source: null,
            sideChain: null,
            threshold: Number.MIN_VALUE,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                unscaledValue: 0.0,
                value: 0.0,
                lastValue: 0.0
            },
            holdLastValue: false,
            strideInputs: ["sideChain", "threshold"]
        }
    });


    /**
     * An equal power stereo panner.
     *
     * This unit generator scales the left and right channels
     * with a quarter-wave sin/cos curve so that the levels at the centre
     * are more balanced than a linear pan, reducing the impression that
     * the sound is fading into the distance as it reaches the centrepoint.
     *
     * Inputs:
     *   source: the source (mono) unit signal
     *   pan: a value between -1 (hard left) and 1 (hard right)
     */
    flock.ugen.pan2 = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.gen = function (numSamps) {
            var m = that.model,
                outputs = that.output,
                left = outputs[0],
                right = outputs[1],
                inputs = that.inputs,
                source = inputs.source.output,
                pan = inputs.pan.output,
                i,
                j,
                sourceVal,
                panVal;

            for (i = 0, j = 0; i < numSamps; i++, j += m.strides.pan) {
                sourceVal = source[i];
                panVal = pan[j] * 0.5 + 0.5;

                // TODO: Replace this with a lookup table.
                right[i] = sourceVal * Math.sin(panVal * flock.HALFPI);
                left[i] = sourceVal * Math.cos(panVal * flock.HALFPI);
            }

            // TODO: Add multichannel support for mul/add.
            var lastIdx = numSamps - 1;
            m.value[0] = outputs[0][lastIdx];
            m.value[1] = outputs[1][lastIdx];
        };

        that.init = function () {
            that.onInputChanged();
            that.model.unscaledValue = that.model.value;
        };

        that.init();
        return that;
    };

    fluid.defaults("flock.ugen.pan2", {
        rate: "audio",

        inputs: {
            source: null,
            pan: 0 // -1 (hard left)..0 (centre)..1 (hard right)
        },

        ugenOptions: {
            model: {
                unscaledValue: [0.0, 0.0],
                value: [0.0, 0.0]
            },
            tags: ["flock.ugen.multiChannelOutput"],
            strideInputs: [
                "pan"
            ],
            numOutputs: 2
        }
    });

    /*******************
     * Bus-Level UGens *
     *******************/

    flock.ugen.out = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        // TODO: Implement a "straight out" gen function for cases where the number
        // of sources matches the number of output buses (i.e. where no expansion is necessary).
        // TODO: This function is marked as unoptimized by the Chrome profiler.
        that.gen = function (numSamps) {
            var m = that.model,
                sources = that.multiInputs.sources,
                buses = that.options.audioSettings.buses,
                bufStart = that.inputs.bus.output[0],
                expand = that.inputs.expand.output[0],
                numSources,
                numOutputBuses,
                i,
                j,
                source,
                rate,
                bus,
                inc,
                outIdx;

            numSources = sources.length;
            numOutputBuses = Math.max(expand, numSources);

            if (numSources < 1) {
                return;
            }

            for (i = 0; i < numOutputBuses; i++) {
                source = sources[i % numSources];
                rate = source.rate;
                bus = buses[bufStart + i];
                inc = rate === flock.rates.AUDIO ? 1 : 0;
                outIdx = 0;

                for (j = 0; j < numSamps; j++, outIdx += inc) {
                    // TODO: Support control rate interpolation.
                    // TODO: Don't attempt to write to buses beyond the available number.
                    //       Provide an error at onInputChanged time if the unit generator is configured
                    //       with more sources than available buffers.
                    bus[j] = bus[j] + source.output[outIdx];
                }
            }

            // TODO: Consider how we should handle "value" when the number
            // of input channels for "sources" can be variable.
            // In the meantime, we just output the last source's last sample.
            m.value = m.unscaledValue = source.output[outIdx];
            that.mulAdd(numSamps); // TODO: Does this even work?
        };

        that.init = function () {
            that.sourceBuffers = [];
            that.onInputChanged();
        };

        that.init();
        return that;
    };

    fluid.defaults("flock.ugen.out", {
        rate: "audio",
        inputs: {
            sources: null,
            bus: 0,
            expand: 2
        },
        ugenOptions: {
            tags: ["flock.ugen.outputType"],
            multiInputNames: ["sources"]
        }
    });

    // Note: this unit generator currently only outputs values at control rate.
    // TODO: Unit tests.
    flock.ugen.valueOut = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.arraySourceGen = function () {
            var m = that.model,
                sources = that.inputs.sources,
                i;

            for (i = 0; i < sources.length; i++) {
                m.value[i] = sources[i].output[0];
            }
        };

        that.ugenSourceGen = function () {
            that.model.value = that.model.unscaledValue = that.inputs.sources.output[0];
        };

        that.onInputChanged = function () {
            var m = that.model,
                sources = that.inputs.sources;

            if (flock.isIterable(sources)) {
                that.gen = that.arraySourceGen;
                m.value = new Float32Array(sources.length);
                m.unscaledValue = m.value;
            } else {
                that.gen = that.ugenSourceGen;
            }
        };

        that.onInputChanged();
        return that;
    };

    fluid.defaults("flock.ugen.valueOut", {
        rate: "control",

        inputs: {
            sources: null
        },

        ugenOptions: {
            model: {
                unscaledValue: null,
                value: null
            },

            tags: ["flock.ugen.outputType", "flock.ugen.valueType"]
        }
    });

    // TODO: fix naming.
    flock.ugen["in"] = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.singleBusGen = function (numSamps) {
            var m = that.model,
                out = that.output;

            flock.ugen.in.readBus(numSamps, out, that.inputs.bus,
                that.options.audioSettings.buses);

            m.unscaledValue = flock.ugen.lastOutputValue(numSamps, out);
            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.multiBusGen = function (numSamps) {
            var m = that.model,
                busesInput = that.inputs.bus,
                enviroBuses = that.options.audioSettings.buses,
                out = that.output,
                i,
                j,
                busIdx,
                val;

            for (i = 0; i < numSamps; i++) {
                val = 0; // Clear previous output values before summing a new set.
                for (j = 0; j < busesInput.length; j++) {
                    busIdx = busesInput[j].output[0] | 0;
                    val += enviroBuses[busIdx][i];
                }
                out[i] = val;
            }

            m.unscaledValue = val;
            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.onInputChanged = function () {
            that.gen = flock.isIterable(that.inputs.bus) ? that.multiBusGen : that.singleBusGen;
            flock.onMulAddInputChanged(that);
        };

        that.onInputChanged();
        return that;
    };

    flock.ugen.in.readBus = function (numSamps, out, busInput, buses) {
        var busNum = busInput.output[0] | 0,
            bus = buses[busNum],
            i;

        for (i = 0; i < numSamps; i++) {
            out[i] = bus[i];
        }
    };

    fluid.defaults("flock.ugen.in", {
        rate: "audio",
        inputs: {
            bus: 0,
            mul: null,
            add: null
        }
    });


    flock.ugen.audioIn = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.gen = function (numSamps) {
            var m = that.model,
                out = that.output,
                bus = that.bus,
                i,
                val;

            for (i = 0; i < numSamps; i++) {
                out[i] = val = bus[i];
            }

            m.unscaledValue = val;
            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.onInputChanged = function () {
            flock.onMulAddInputChanged(that);
        };

        that.init = function () {
            // TODO: Direct reference to the shared environment.
            var busNum = flock.enviro.shared.audioStrategy.inputDeviceManager.openAudioDevice(options);
            that.bus = that.options.audioSettings.buses[busNum];

            that.onInputChanged();
        };

        that.init();
        return that;
    };

    fluid.defaults("flock.ugen.audioIn", {
        rate: "audio",
        inputs: {
            mul: null,
            add: null
        }
    });


    /***********
     * Filters *
     ***********/

    /**
     * A generic FIR and IIR filter engine. You specify the coefficients, and this will do the rest.
     */
     // TODO: Unit tests.
    flock.ugen.filter = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.gen = function () {
            var m = that.model,
                out = that.output,
                inputs = that.inputs,
                q = inputs.q.output[0],
                freq = inputs.freq.output[0];

            if (m.prevFreq !== freq || m.prevQ !== q) {
                that.updateCoefficients(m, freq, q);
            }

            that.filterEngine.filter(out, that.inputs.source.output);

            m.prevQ = q;
            m.prevFreq = freq;
            m.value = m.unscaledValue = out[out.length - 1];
        };

        that.init = function () {
            var recipeOpt = that.options.recipe;
            var recipe = typeof (recipeOpt) === "string" ? flock.get(recipeOpt) : recipeOpt;

            if (!recipe) {
                throw new Error("Can't instantiate a flock.ugen.filter() without specifying a filter coefficient recipe.");
            }

            that.filterEngine = new Filter(recipe.sizes.b, recipe.sizes.a);
            that.model.coeffs = {
                a: that.filterEngine.a,
                b: that.filterEngine.b
            };

            that.updateCoefficients = flock.get(recipe, that.options.type);
            that.onInputChanged();
        };

        that.init();
        return that;
    };

    fluid.defaults("flock.ugen.filter", {
        rate: "audio",

        inputs: {
            freq: 440,
            q: 1.0,
            source: null
        }
    });

    /**
     * An optimized biquad filter unit generator.
     */
    // TODO: Unit tests.
    flock.ugen.filter.biquad = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.gen = function (numSamps) {
            var m = that.model,
                inputs = that.inputs,
                out = that.output,
                co = m.coeffs,
                freq = inputs.freq.output[0],
                q = inputs.q.output[0],
                source = inputs.source.output,
                i,
                w;

            if (m.prevFreq !== freq || m.prevQ !== q) {
                that.updateCoefficients(m, freq, q);
            }

            for (i = 0; i < numSamps; i++) {
                w = source[i] - co.a[0] * m.d0 - co.a[1] * m.d1;
                out[i] = co.b[0] * w + co.b[1] * m.d0 + co.b[2] * m.d1;
                m.d1 = m.d0;
                m.d0 = w;
            }

            m.prevQ = q;
            m.prevFreq = freq;
            m.value = m.unscaledValue = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.onInputChanged = function () {
            var typeOpt = that.options.type;
            that.updateCoefficients = typeof (typeOpt) === "string" ?
                flock.get(typeOpt) : typeOpt;
        };

        that.init = function () {
            that.model.d0 = 0.0;
            that.model.d1 = 0.0;
            that.model.coeffs = {
                a: new Float32Array(2),
                b: new Float32Array(3)
            };
            that.onInputChanged();
        };

        that.init();
        return that;
    };

    fluid.defaults("flock.ugen.filter.biquad", {
        inputs: {
            freq: 440,
            q: 1.0,
            source: null
        }
    });

    flock.ugen.filter.biquad.types = {
        "hp": {
            inputDefaults: {
                freq: 440,
                q: 1.0
            },
            options: {
                type: "flock.coefficients.butterworth.highPass"
            }
        },
        "rhp": {
            inputDefaults: {
                freq: 440,
                q: 1.0
            },
            options: {
                type: "flock.coefficients.rbj.highPass"
            }
        },
        "lp": {
            inputDefaults: {
                freq: 440,
                q: 1.0
            },
            options: {
                type: "flock.coefficients.butterworth.lowPass"
            }
        },
        "rlp": {
            inputDefaults: {
                freq: 440,
                q: 1.0
            },
            options: {
                type: "flock.coefficients.rbj.lowPass"
            }
        },
        "bp": {
            inputDefaults: {
                freq: 440,
                q: 4.0
            },
            options: {
                type: "flock.coefficients.butterworth.bandPass"
            }
        },
        "br": {
            inputDefaults: {
                freq: 440,
                q: 1.0
            },
            options: {
                type: "flock.coefficients.butterworth.bandReject"
            }
        }
    };

    // Convenience methods for instantiating common types of biquad filters.
    flock.aliasUGens("flock.ugen.filter.biquad", flock.ugen.filter.biquad.types);

    flock.coefficients = {
        butterworth: {
            sizes: {
                a: 2,
                b: 3
            },

            lowPass: function (model, freq) {
                var co = model.coeffs;
                var lambda = 1 / Math.tan(Math.PI * freq / model.sampleRate);
                var lambdaSquared = lambda * lambda;
                var rootTwoLambda = flock.ROOT2 * lambda;
                var b0 = 1 / (1 + rootTwoLambda + lambdaSquared);
                co.b[0] = b0;
                co.b[1] = 2 * b0;
                co.b[2] = b0;
                co.a[0] = 2 * (1 - lambdaSquared) * b0;
                co.a[1] = (1 - rootTwoLambda + lambdaSquared) * b0;
            },

            highPass: function (model, freq) {
                var co = model.coeffs;
                var lambda = Math.tan(Math.PI * freq / model.sampleRate);
                // Works around NaN values in cases where the frequency
                // is precisely half the sampling rate, and thus lambda
                // is Infinite.
                if (lambda === Infinity) {
                    lambda = 0;
                }
                var lambdaSquared = lambda * lambda;
                var rootTwoLambda = flock.ROOT2 * lambda;
                var b0 = 1 / (1 + rootTwoLambda + lambdaSquared);

                co.b[0] = b0;
                co.b[1] = -2 * b0;
                co.b[2] = b0;
                co.a[0] = 2 * (lambdaSquared - 1) * b0;
                co.a[1] = (1 - rootTwoLambda + lambdaSquared) * b0;
            },

            bandPass: function (model, freq, q) {
                var co = model.coeffs;
                var bw = freq / q;
                var lambda = 1 / Math.tan(Math.PI * bw / model.sampleRate);
                var theta = 2 * Math.cos(flock.TWOPI * freq / model.sampleRate);
                var b0 = 1 / (1 + lambda);

                co.b[0] = b0;
                co.b[1] = 0;
                co.b[2] = -b0;
                co.a[0] = -(lambda * theta * b0);
                co.a[1] = b0 * (lambda - 1);
            },

            bandReject: function (model, freq, q) {
                var co = model.coeffs;
                var bw = freq / q;
                var lambda = Math.tan(Math.PI * bw / model.sampleRate);
                var theta = 2 * Math.cos(flock.TWOPI * freq / model.sampleRate);
                var b0 = 1 / (1 + lambda);
                var b1 = -theta * b0;

                co.b[0] = b0;
                co.b[1] = b1;
                co.b[2] = b0;
                co.a[0] = b1;
                co.a[1] = (1 - lambda) * b0;
            }
        },

        // From Robert Brisow-Johnston's Filter Cookbook:
        // http://dspwiki.com/index.php?title=Cookbook_Formulae_for_audio_EQ_biquad_filter_coefficients
        rbj: {
            sizes: {
                a: 2,
                b: 3
            },

            lowPass: function (model, freq, q) {
                var co = model.coeffs;
                var w0 = flock.TWOPI * freq / model.sampleRate;
                var cosw0 = Math.cos(w0);
                var sinw0 = Math.sin(w0);
                var alpha = sinw0 / (2 * q);
                var oneLessCosw0 = 1 - cosw0;
                var a0 = 1 + alpha;
                var b0 = (oneLessCosw0 / 2) / a0;

                co.b[0] = b0;
                co.b[1] = oneLessCosw0 / a0;
                co.b[2] = b0;
                co.a[0] = (-2 * cosw0) / a0;
                co.a[1] = (1 - alpha) / a0;
            },

            highPass: function (model, freq, q) {
                var co = model.coeffs;
                var w0 = flock.TWOPI * freq / model.sampleRate;
                var cosw0 = Math.cos(w0);
                var sinw0 = Math.sin(w0);
                var alpha = sinw0 / (2 * q);
                var onePlusCosw0 = 1 + cosw0;
                var a0 = 1 + alpha;
                var b0 = (onePlusCosw0 / 2) / a0;

                co.b[0] = b0;
                co.b[1] = (-onePlusCosw0) / a0;
                co.b[2] = b0;
                co.a[0] = (-2 * cosw0) / a0;
                co.a[1] = (1 - alpha) / a0;
            },

            bandPass: function (model, freq, q) {
                var co = model.coeffs;
                var w0 = flock.TWOPI * freq / model.sampleRate;
                var cosw0 = Math.cos(w0);
                var sinw0 = Math.sin(w0);
                var alpha = sinw0 / (2 * q);
                var a0 = 1 + alpha;
                var qByAlpha = q * alpha;

                co.b[0] = qByAlpha / a0;
                co.b[1] = 0;
                co.b[2] = -qByAlpha / a0;
                co.a[0] = (-2 * cosw0) / a0;
                co.a[1] = (1 - alpha) / a0;
            },

            bandReject: function (model, freq, q) {
                var co = model.coeffs;
                var w0 = flock.TWOPI * freq / model.sampleRate;
                var cosw0 = Math.cos(w0);
                var sinw0 = Math.sin(w0);
                var alpha = sinw0 / (2 * q);
                var a0 = 1 + alpha;
                var ra0 = 1 / a0;
                var b1 = (-2 * cosw0) / a0;
                co.b[0] = ra0;
                co.b[1] = b1;
                co.b[2] = ra0;
                co.a[0] = b1;
                co.a[1] = (1 - alpha) / a0;
            }
        }
    };

    /**
     * A Moog-style 24db resonant low-pass filter.
     *
     * This unit generator is based on the following musicdsp snippet:
     * http://www.musicdsp.org/showArchiveComment.php?ArchiveID=26
     *
     * Inputs:
     *   - source: the source signal to process
     *   - cutoff: the cutoff frequency
     *   - resonance: the filter resonance [between 0 and 4, where 4 is self-oscillation]
     */
    // TODO: Unit tests.
    flock.ugen.filter.moog = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.gen = function (numSamps) {
            var m = that.model,
                inputs = that.inputs,
                out = that.output,
                source = inputs.source.output,
                sourceInc = m.strides.source,
                res = inputs.resonance.output,
                resInc = m.strides.resonance,
                cutoff = inputs.cutoff.output,
                cutoffInc = m.strides.cutoff,
                f = m.f,
                fSq = m.fSq,
                fSqSq = m.fSqSq,
                oneMinusF = m.oneMinusF,
                fb = m.fb,
                i,
                j,
                k,
                l,
                currCutoff,
                currRes,
                val;

            for (i = j = k = l = 0; i < numSamps; i++, j += sourceInc, k += resInc, l += cutoffInc) {
                currCutoff = cutoff[l];
                currRes = res[k];

                if (currCutoff !== m.prevCutoff) {
                    if (currCutoff > m.nyquistRate) {
                        currCutoff = m.nyquistRate;
                    }

                    f = m.f = (currCutoff / m.nyquistRate) * 1.16;
                    fSq = m.fSq = f * f;
                    fSqSq = m.fSqSq = fSq * fSq;
                    oneMinusF = m.oneMinusF = 1 - f;
                    m.prevRes = undefined; // Flag the need to update fb.
                }

                if (currRes !== m.prevRes) {
                    if (currRes > 4) {
                        currRes = 4;
                    } else if (currRes < 0) {
                        currRes = 0;
                    }

                    fb = m.fb = currRes * (1.0 - 0.15 * fSq);
                }

                val = source[j] - (m.out4 * fb);
                val *= 0.35013 * fSqSq;
                m.out1 = val + 0.3 * m.in1 + oneMinusF * m.out1;
                m.in1 = val;
                m.out2 = m.out1 + 0.3 * m.in2 + oneMinusF * m.out2;
                m.in2 = m.out1;
                m.out3 = m.out2 + 0.3 * m.in3 + oneMinusF * m.out3;
                m.in3 = m.out2;
                m.out4 = m.out3 + 0.3 * m.in4 + oneMinusF * m.out4;
                m.in4 = m.out3;
                out[i] = m.out4;
            }

            m.unscaledValue = m.out4;
            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.onInputChanged();
        return that;
    };

    fluid.defaults("flock.ugen.filter.moog", {
        rate: "audio",
        inputs: {
            cutoff: 3000,
            resonance: 3.99,
            source: null
        },
        ugenOptions: {
            model: {
                in1: 0.0,
                in2: 0.0,
                in3: 0.0,
                in4: 0.0,
                out1: 0.0,
                out2: 0.0,
                out3: 0.0,
                out4: 0.0,
                prevCutoff: undefined,
                prevResonance: undefined,
                f: undefined,
                fSq: undefined,
                fSqSq: undefined,
                oneMinusF: undefined,
                fb: undefined,
                unscaledValue: 0.0,
                value: 0.0
            },
            strideInputs: ["source", "cutoff", "resonance"]
        }
    });

    flock.ugen.delay = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.gen = function (numSamps) {
            var m = that.model,
                inputs = that.inputs,
                out = that.output,
                source = inputs.source.output,
                time = inputs.time.output[0],
                delayBuffer = that.delayBuffer,
                i,
                val;

            if (time !== m.time) {
                m.time = time;
                m.delaySamps = time * that.model.sampleRate;
            }

            for (i = 0; i < numSamps; i++) {
                if (m.pos >= m.delaySamps) {
                    m.pos = 0;
                }
                out[i] = val = delayBuffer[m.pos];
                delayBuffer[m.pos] = source[i];
                m.pos++;
            }

            m.unscaledValue = val;
            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.onInputChanged = function (inputName) {
            flock.onMulAddInputChanged(that);

            if (!inputName || inputName === "maxTime") {
                var delayBufferLength = that.model.sampleRate * that.inputs.maxTime.output[0];
                that.delayBuffer = new Float32Array(delayBufferLength);
            }
        };

        that.onInputChanged();
        return that;
    };

    fluid.defaults("flock.ugen.delay", {
        rate: "audio",
        inputs: {
            maxTime: 1.0,
            time: 1.0,
            source: null
        },
        ugenOptions: {
            model: {
                pos: 0,
                unscaledValue: 0.0,
                value: 0.0
            }
        }
    });


    // Simple optimised delay for exactly 1 sample
    flock.ugen.delay1 = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.gen = function (numSamps) {
            var m = that.model,
                inputs = that.inputs,
                out = that.output,
                source = inputs.source.output,
                prevVal = m.prevVal,
                i,
                val;

            for (i = 0; i < numSamps; i++) {
                out[i] = val = prevVal;
                prevVal = source[i];
            }

            m.prevVal = prevVal;
            m.unscaledValue = val;
            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.onInputChanged = function () {
            flock.onMulAddInputChanged(that);
        };

        that.onInputChanged();
        return that;
    };

    fluid.defaults("flock.ugen.delay1", {
        rate: "audio",
        inputs: {
            source: null
        },
        ugenOptions: {
            model: {
                prevVal: 0.0,
                unscaledValue: 0.0,
                value: 0.0
            }
        }
    });


    flock.ugen.freeverb = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);
        that.tunings = that.options.tunings;
        that.allpassTunings = that.options.allpassTunings;

        that.gen = function (numSamps) {
            var m = that.model,
                inputs = that.inputs,
                out = that.output,
                source = inputs.source.output,
                mix = inputs.mix.output[0],
                dry = 1 - mix,
                roomsize = inputs.room.output[0],
                room_scaled = roomsize * 0.28 + 0.7,
                damp = inputs.damp.output[0],
                damp1 = damp * 0.4,
                damp2 = 1.0 - damp1,
                i,
                j,
                val;

            for (i = 0; i < numSamps; i++) {
                // read inputs
                var inp = source[i];
                var inp_scaled = inp * 0.015;

                // read samples from the allpasses
                for (j = 0; j < that.buffers_a.length; j++) {
                    if (++that.bufferindices_a[j] === that.allpassTunings[j]) {
                        that.bufferindices_a[j] = 0;
                    }
                    that.readsamp_a[j] = that.buffers_a[j][that.bufferindices_a[j]];
                }

                // foreach comb buffer, we perform same filtering (only bufferlen differs)
                for (j = 0; j < that.buffers_c.length; j++) {
                    if (++that.bufferindices_c[j] === that.tunings[j]) {
                        that.bufferindices_c[j] = 0;
                    }
                    var bufIdx_c = that.bufferindices_c[j],
                        readsamp_c = that.buffers_c[j][bufIdx_c];
                    that.filterx_c[j] = (damp2 * that.filtery_c[j]) + (damp1 * that.filterx_c[j]);
                    that.buffers_c[j][bufIdx_c] = inp_scaled + (room_scaled * that.filterx_c[j]);
                    that.filtery_c[j] = readsamp_c;
                }

                // each allpass is handled individually,
                // with different calculations made and stored into the delaylines
                var ftemp8 = (that.filtery_c[6] + that.filtery_c[7]);

                that.buffers_a[3][that.bufferindices_a[3]] = ((((0.5 * that.filterx_a[3]) + that.filtery_c[0]) +
                    (that.filtery_c[1] + that.filtery_c[2])) +
                    ((that.filtery_c[3] + that.filtery_c[4]) + (that.filtery_c[5] + ftemp8)));
                that.filterx_a[3] = that.readsamp_a[3];
                that.filtery_a[3] = (that.filterx_a[3] - (((that.filtery_c[0] + that.filtery_c[1]) +
                    (that.filtery_c[2] + that.filtery_c[3])) +
                    ((that.filtery_c[4] + that.filtery_c[5]) + ftemp8)));
                that.buffers_a[2][that.bufferindices_a[2]] = ((0.5 * that.filterx_a[2]) + that.filtery_a[3]);
                that.filterx_a[2] = that.readsamp_a[2];
                that.filtery_a[2] = (that.filterx_a[2] - that.filtery_a[3]);

                that.buffers_a[1][that.bufferindices_a[1]] = ((0.5 * that.filterx_a[1]) + that.filtery_a[2]);
                that.filterx_a[1] = that.readsamp_a[1];
                that.filtery_a[1] = (that.filterx_a[1] - that.filtery_a[2]);

                that.buffers_a[0][that.bufferindices_a[0]] = ((0.5 * that.filterx_a[0]) + that.filtery_a[1]);
                that.filterx_a[0] = that.readsamp_a[0];
                that.filtery_a[0] = (that.filterx_a[0] - that.filtery_a[1]);
                val = ((dry * inp) + (mix * that.filtery_a[0]));
                out[i] = val;
            }

            m.unscaledValue = val;
            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.initDelayLines = function () {
            // Initialise the delay lines
            that.buffers_c = new Array(8);
            that.bufferindices_c = new Int32Array(8);
            that.filterx_c = new Float32Array(8);
            that.filtery_c = new Float32Array(8);
            var spread = that.model.spread;
            var i, j;
            for(i = 0; i < that.buffers_c.length; i++) {
                that.buffers_c[i] = new Float32Array(that.tunings[i]+spread);
                that.bufferindices_c[i] = 0;
                that.filterx_c[i] = 0;
                that.filtery_c[i] = 0;
                for(j = 0; j < that.tunings[i]+spread; j++) {
                    that.buffers_c[i][j] = 0;
                }
            }
            that.buffers_a = new Array(4);
            that.bufferindices_a = new Int32Array(4);
            that.filterx_a = new Float32Array(4);
            that.filtery_a = new Float32Array(4);
            // "readsamp" vars are temporary values read back from the delay lines,
            // not stored but only used in the gen loop
            that.readsamp_a = new Float32Array(4);
            for (i = 0; i < that.buffers_a.length; i++) {
                that.bufferindices_a[i] = 0;
                that.filterx_a[i] = 0;
                that.filtery_a[i] = 0;
                that.readsamp_a[i] = 0;
                // TODO is this what the spread is meant to do?
                for (j = 0; j < that.allpassTunings.length; j++) {
                    that.allpassTunings[j] += spread;
                }
                that.buffers_a[i] = new Float32Array(that.allpassTunings[i]);
                for (j = 0; j < that.allpassTunings[i]; j++) {
                    that.buffers_a[i][j] = 0;
                }
            }
        };

        that.init = function () {
            that.initDelayLines();
            that.onInputChanged();
        };

        that.init();
        return that;
    };

    fluid.defaults("flock.ugen.freeverb", {
        rate: "audio",
        inputs: {
            source: null,
            mix: 0.33,
            room: 0.5,
            damp: 0.5
        },
        ugenOptions: {
            model: {
                spread: 0,
                unscaledValue: 0.0,
                value: 0.0
            },

            tunings: [1116, 1188, 1277, 1356, 1422, 1491, 1557, 1617],
            allpassTunings: [556, 441, 341, 225]
        }
    });


    /**
     * A simple waveshaper-based distortion effect.
     * Uses the polynomial y = (3/2) * x - (1/2) * x^3.
     * http://www.musicdsp.org/showone.php?id=114
     *
     * Inputs:
     *   - source: the input signal to distort
     *   - gain: the gain factor to apply [1.0..Infinity]
     */
    flock.ugen.distortion = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.gen = function (numSamps) {
            var m = that.model,
                out = that.output,
                source = that.inputs.source.output,
                sourceInc = m.strides.source,
                gain = that.inputs.gain.output,
                gainInc = m.strides.gain,
                val,
                dist,
                i,
                j,
                k;

            for (i = j =  k = 0; i < numSamps; i++, j += sourceInc, k += gainInc) {
                val = source[j] * gain[k];
                dist = 1.5 * val - 0.5 * val * val * val;
                out[i] = dist;
            }

            m.unscaledValue = dist;
            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.onInputChanged();

        return that;
    };

    fluid.defaults("flock.ugen.distortion", {
        rate: "audio",
        inputs: {
            source: null,
            gain: 1.0
        },
        ugenOptions: {
            strideInputs: ["source", "gain"]
        }
    });


    /**
     * A simple waveshaper-based distortion effect by Bram de Jonge.
     * http://www.musicdsp.org/showone.php?id=41
     *
     * Inputs:
     *   - source: the input signal
     *   - amount: a value between 1 and Infinity that represents the amount of distortion
     *             to apply.
     */
    flock.ugen.distortion.deJonge = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.gen = function (numSamps) {
            var m = that.model,
                out = that.output,
                source = that.inputs.source.output,
                sourceInc = m.strides.source,
                amount = that.inputs.amount.output,
                amountInc = m.strides.amount,
                x,
                a,
                absX,
                dist,
                i,
                j,
                k;

            for (i = j = k = 0; i < numSamps; i++, j += sourceInc, k += amountInc) {
                x = source[j];
                a = amount[k];
                absX = Math.abs(x);
                dist = x * (absX + a) / ((x * x) + (a - 1) * absX + 1);
                out[i] = dist;
            }

            m.unscaledValue = dist;
            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.onInputChanged();

        return that;
    };

    fluid.defaults("flock.ugen.distortion.deJonge", {
        rate: "audio",
        inputs: {
            source: null,
            amount: 2
        },
        ugenOptions: {
            strideInputs: ["source", "amount"]
        }
    });


    /**
     * A simple waveshaper-based distortion effect by Partice Tarrabia and Bram de Jong.
     * http://www.musicdsp.org/showone.php?id=46
     *
     * Inputs:
     *   - source: the input signal
     *   - amount: a value between -1 and 1 that represents the amount of distortion
     *             to apply.
     */
    flock.ugen.distortion.tarrabiaDeJonge = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.gen = function (numSamps) {
            var m = that.model,
                out = that.output,
                source = that.inputs.source.output,
                sourceInc = m.strides.source,
                amount = that.inputs.amount.output,
                amountInc = m.strides.amount,
                x,
                a,
                dist,
                i,
                sIdx,
                aIdx,
                k;

            for (i = sIdx = aIdx = 0; i < numSamps; i++, sIdx += sourceInc, aIdx += amountInc) {
                x = source[sIdx];
                a = amount[aIdx];

                // Expects an amount value in the range of
                // -1.0 to 1.0, but NaNs are produced with exact 1.0s.
                if (a >= 1.0) {
                    a = 0.9999999999999999;
                } else if (a < -1.0) {
                    a = -1.0;
                }

                k = 2 * a / (1 - a);
                dist = (1 + k) * x / (1 + k * Math.abs(x));
                out[i] = dist;
            }

            m.unscaledValue = dist;
            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.onInputChanged();

        return that;
    };

    fluid.defaults("flock.ugen.distortion.tarrabiaDeJonge", {
        rate: "audio",
        inputs: {
            source: null,
            amount: 10
        },
        ugenOptions: {
            strideInputs: ["source", "amount"]
        }
    });


    /**
     * Waveshaper distortion by Laurent de Soras.
     * http://www.musicdsp.org/showone.php?id=86
     *
     * Inputs:
     *   - source: the signal to distort
     *   - gain: the gain factor to apply [1.0..Infinity]
     */
    flock.ugen.distortion.gloubiBoulga = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.gen = function (numSamps) {
            var m = that.model,
                out = that.output,
                source = that.inputs.source.output,
                sourceInc = m.strides.source,
                gain = that.inputs.gain.output,
                gainInc = m.strides.gain,
                val,
                dist,
                i,
                j,
                k,
                x,
                a,
                expX;

            for (i = j = k = 0; i < numSamps; i++, j += sourceInc, k += gainInc) {
                val = source[j] * gain[k];
                x = val * 0.686306;
                a = 1 + Math.exp(Math.sqrt(Math.abs(x)) * -0.75);
                expX = Math.exp(x);
                dist = (expX - Math.exp(-x * a)) / (expX + Math.exp(-x));
                out[i] = dist;
            }

            m.unscaledValue = dist;
            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.onInputChanged();

        return that;
    };

    fluid.defaults("flock.ugen.distortion.gloubiBoulga", {
        rate: "audio",
        inputs: {
            source: null,
            gain: 1.0
        },
        ugenOptions: {
            strideInputs: ["source", "gain"]
        }
    });


    flock.ugen.decay = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.gen = function (numSamps) {
            var m = that.model,
                inputs = that.inputs,
                out = that.output,
                source = inputs.source.output,
                time = inputs.time.output[0],
                i,
                val;

            if (time !== m.time) {
                m.time = time;
                m.coeff = time === 0.0 ? 0.0 : Math.exp(flock.LOG001 / (time * that.model.sampleRate));
            }

            // TODO: Optimize this conditional.
            if (m.coeff === 0.0) {
                for (i = 0; i < numSamps; i++) {
                    out[i] = val = source[i];
                }
            } else {
                for (i = 0; i < numSamps; i++) {
                    m.lastSamp = source[i] + m.coeff * m.lastSamp;
                    out[i] = val = m.lastSamp;
                }
            }

            m.unscaledValue = val;
            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.onInputChanged();
        return that;
    };

    fluid.defaults("flock.ugen.decay", {
        rate: "audio",
        inputs: {
            source: null,
            time: 1.0
        },
        ugenOptions: {
            model: {
                time: 0,
                lastSamp: 0,
                coeff: 0,
                value: 0.0
            }
        }
    });

    /****************************
     * Granular Synthesis UGens *
     ****************************/

    /**
     * Triggers grains from an audio buffer.
     *
     * Inputs:
     *   - dur: the duration of each grain (control or constant rate only)
     *   - trigger: a trigger signal that, when it move to a positive number, will start a grain
     *   - buffer: a bufferDef object describing the buffer to granulate
     *   - centerPos: the postion within the sound buffer when the grain will reach maximum amplitude
     *   - amp: the peak amplitude of the grain
     *   - speed: the rate at which grain samples are selected from the buffer; 1.0 is normal speed, -1.0 is backwards
     *
     * Options:
     *   - interpolation: "cubic", "linear", or "none"/undefined
     */
    // TODO: Unit tests.
    flock.ugen.triggerGrains = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.gen = function (numSamps) {
            var m = that.model,
                inputs = that.inputs,
                out = that.output,
                chan = inputs.channel.output[0],
                buf = that.buffer.data.channels[chan],
                bufRate = that.buffer.format.sampleRate,
                dur = inputs.dur.output[0],
                amp = inputs.amp.output,
                centerPos = inputs.centerPos.output,
                trigger = inputs.trigger.output,
                speed = inputs.speed.output,
                grainEnv = that.options.grainEnv,
                lastOutIdx = numSamps - 1,
                posIdx = 0,
                trigIdx = 0,
                ampIdx = 0,
                speedIdx = 0,
                i,
                j,
                k,
                grain,
                start,
                samp,
                env;

            // Trigger new grains.
            for (i = 0; i < numSamps; i++) {
                if (trigger[trigIdx] > 0.0 && m.prevTrigger <= 0.0 && m.activeGrains.length < m.maxNumGrains) {
                    grain = m.freeGrains.pop();
                    grain.numSamps = m.sampleRate * dur;
                    grain.centerIdx = (grain.numSamps / 2) * m.stepSize;
                    grain.envScale = that.options.grainEnv.length / grain.numSamps;
                    grain.sampIdx = 0;
                    grain.amp = amp[ampIdx];
                    start = (centerPos[posIdx] * bufRate) - grain.centerIdx;
                    while (start < 0) {
                        start += buf.length;
                    }
                    grain.readPos = start;
                    grain.writePos = i;
                    grain.speed = speed[speedIdx];
                    m.activeGrains.push(grain);
                }

                m.prevTrigger = trigger[trigIdx];
                out[i] = 0.0;

                posIdx += m.strides.centerPos;
                trigIdx += m.strides.trigger;
                ampIdx += m.strides.amp;
                speedIdx += m.strides.speed;
            }

            // Output samples for all active grains.
            for (j = 0; j < m.activeGrains.length;) {
                grain = m.activeGrains[j];
                for (k = grain.writePos; k < Math.min(k + (grain.numSamps - grain.sampIdx), numSamps); k++) {
                    samp = that.interpolate(grain.readPos, buf);
                    env = flock.interpolate.linear(grain.sampIdx * grain.envScale, grainEnv);
                    out[k] += samp * env * grain.amp;
                    grain.readPos = (grain.readPos + (m.stepSize * grain.speed)) % buf.length;
                    grain.sampIdx++;
                }
                if (grain.sampIdx >= grain.numSamps) {
                    m.freeGrains.push(grain);
                    m.activeGrains.splice(j, 1);
                } else {
                    j++;
                    grain.writePos = k % numSamps;
                }
            }

            m.unscaledValue = out[lastOutIdx];
            that.mulAdd(numSamps);
            m.value = out[lastOutIdx];
        };

        that.onBufferReady = function () {
            var m = that.model;
            m.stepSize = that.buffer.format.sampleRate / m.sampleRate;
        };

        that.onInputChanged = function (inputName) {
            that.onBufferInputChanged(inputName);
            that.calculateStrides();
            flock.onMulAddInputChanged(that);
        };

        that.allocateGrains = function (numGrains) {
            numGrains = numGrains || that.model.maxNumGrains;

            for (var i = 0; i < numGrains; i++) {
                that.model.freeGrains.push({
                    numSamps: 0,
                    centerIdx: 0.0,
                    envScale: 0.0,
                    sampIdx: 0,
                    amp: 0.0,
                    readPos: 0.0,
                    writePos: 0,
                    speed: 0.0
                });
            }
        };

        that.init = function () {
            flock.ugen.buffer(that);
            that.allocateGrains();
            that.initBuffer();
            that.onInputChanged();
        };

        that.init();
        return that;
    };

    fluid.defaults("flock.ugen.triggerGrains", {
        rate: "audio",
        inputs: {
            centerPos: 0,
            channel: 0,
            amp: 1.0,
            dur: 0.1,
            speed: 1.0,
            trigger: 0.0,
            buffer: null,
            mul: null,
            add: null
        },
        ugenOptions: {
            grainEnv: flock.fillTable(8192, flock.tableGenerators.hann),
            model: {
                unscaledValue: 0.0,
                value: 0.0,
                maxNumGrains: 512,
                activeGrains: [],
                freeGrains: [],
                env: null,
                strides: {}
            },
            strideInputs: [
                "centerPos",
                "trigger",
                "amp",
                "speed"
            ],
            interpolation: "cubic"
        }
    });


    /**
     * Granulates a source signal using an integral delay line.
     * This implementation is particularly useful for live granulation.
     * Contributed by Mayank Sanganeria.
     *
     * Inputs:
     *   - grainDur: the duration of each grain (control or constant rate only)
     *   - delayDur: the duration of the delay line (control or constant rate only)
     *   - numGrains: the number of grains to generate (control or constant rate only)
     *   - mul: amplitude scale factor
     *   - add: amplide add
     */
    // TODO: Unit tests.
    flock.ugen.granulator = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.gen = function (numSamps) {
            var m = that.model,
                o = that.options,
                inputs = that.inputs,
                out = that.output,
                delayLine = that.delayLine,
                grainDur = inputs.grainDur.output[0],
                delayDur = inputs.delayDur.output[0],
                numGrains = inputs.numGrains.output[0],
                source = inputs.source.output,
                maxDelayDur = o.maxDelayDur,
                grainEnv = o.grainEnv,
                i,
                j,
                val,
                grainIdx,
                delayLineReadIdx,
                samp,
                windowPos,
                amp;

            // Update and clamp the delay line length.
            if (m.delayDur !== delayDur) {
                m.delayDur = delayDur;

                if (delayDur > maxDelayDur) {
                    delayDur = maxDelayDur;
                }

                m.delayLength = (delayDur * m.sampleRate) | 0;
                m.writePos = m.writePos % m.delayLength;
            }

            // Update the grain duration.
            if (m.grainDur !== grainDur) {
                m.grainDur = grainDur;
                m.grainLength = (m.sampleRate * m.grainDur) | 0;
                m.envScale = grainEnv.length / m.grainLength;
            }

            // TODO: This implementation will cause currently-sounding grains
            // to be stopped immediately, rather than being allowed to finish.
            numGrains = numGrains > o.maxNumGrains ? o.maxNumGrains : Math.round(numGrains);

            for (i = 0; i < numSamps; i++) {
                // Write into the delay line and update the write position.
                delayLine[m.writePos] = source[i];
                m.writePos = ++m.writePos % m.delayLength;

                // Clear the previous output.
                val = 0;

                // Now fill with grains
                for (j = 0; j < numGrains; j++) {
                    grainIdx = m.grainIdx[j];
                    delayLineReadIdx = m.delayLineIdx[j];

                    // Randomize the reset position of finished grains.
                    if (grainIdx > m.grainLength) {
                        grainIdx = 0;
                        delayLineReadIdx = (Math.random() * m.delayLength) | 0;
                    }

                    samp = delayLine[delayLineReadIdx];
                    windowPos = grainIdx * m.envScale;
                    amp = flock.interpolate.linear(windowPos, grainEnv);
                    val += samp * amp;

                    // Update positions in the delay line and grain envelope arrays for next time.
                    m.delayLineIdx[j] = ++delayLineReadIdx % m.delayLength;
                    m.grainIdx[j] = ++grainIdx;
                }

                val = val / numGrains;
                out[i] = val;
            }

            m.unscaledValue = val;
            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.initGrains = function () {
            var m = that.model;

            for (var i = 0; i < that.options.maxNumGrains; i++) {
                m.grainIdx[i] = 0;
                m.delayLineIdx[i] = Math.random() * m.delayLength;
            }
        };

        that.init = function () {
            var m = that.model,
                o = that.options,
                delayLineLen = (o.maxDelayDur * m.sampleRate) | 0;

            that.delayLine = new Float32Array(delayLineLen);
            m.delayLength = delayLineLen;
            m.delayLineIdx = new Uint32Array(o.maxNumGrains);
            m.grainIdx = new Uint32Array(o.maxNumGrains);

            that.initGrains();
            that.onInputChanged();
        };

        that.init();

        return that;
    };

    fluid.defaults("flock.ugen.granulator", {
        rate: "audio",

        inputs: {
            source: null,
            grainDur: 0.1,
            delayDur: 1,
            numGrains: 5,
            mul: null,
            add: null
        },

        ugenOptions: {
            maxNumGrains: 512,
            maxDelayDur: 30,
            grainEnv: flock.fillTable(8192, flock.tableGenerators.sinWindow),
            model: {
                unscaledValue: 0.0,
                value: 0.0,
                grainLength: 0,
                writePos: 0
            }
        }
    });


    // TODO: Unit tests.
    flock.ugen.print = function (input, output, options) {
        var that = flock.ugen(input, output, options);

        that.gen = function (numSamps) {
            var inputs = that.inputs,
                out = that.output,
                m = that.model,
                label = m.label,
                chan = inputs.channel,
                // Basic multichannel support. This should be inproved
                // by factoring the multichannel input code out of flock.ugen.out.
                source = chan ? inputs.source.output[chan.output[0]] : inputs.source.output,
                trig = inputs.trigger.output[0],
                freq = inputs.freq.output[0],
                i,
                j,
                val;

            if (trig > 0.0 && m.prevTrig <= 0.0) {
                fluid.log(fluid.logLevel.IMPORTANT, label + source);
            }

            if (m.freq !== freq) {
                m.sampInterval = Math.round(m.sampleRate / freq);
                m.freq = freq;
                m.counter = m.sampInterval;
            }

            for (i = 0, j = 0 ; i < numSamps; i++, j += m.strides.source) {
                if (m.counter >= m.sampInterval) {
                    fluid.log(fluid.logLevel.IMPORTANT, label + source[j]);
                    m.counter = 0;
                }
                m.counter++;
                out[i] = val = source[i];
            }

            m.value = m.unscaledValue = val;
        };

        that.init = function () {
            var o = that.options;
            that.model.label = o.label ? o.label + ": " : "";
            that.onInputChanged();
        };

        that.init();
        return that;
    };

    fluid.defaults("flock.ugen.print", {
        rate: "audio",
        inputs: {
            source: null,
            trigger: 0.0,
            freq: 1.0
        },
        ugenOptions: {
            model: {
                unscaledValue: 0.0,
                value: 0.0,
                counter: 0
            },
            strideInputs: ["source"]
        }
    });


    flock.ugen.sequence = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.gen = function (numSamps) {
            var list = that.inputs.list,
                inputs = that.inputs,
                freq = inputs.freq.output,
                loop = inputs.loop.output[0],
                m = that.model,
                scale = m.scale,
                out = that.output,
                start = inputs.start ? Math.round(inputs.start.output[0]) : 0,
                end = inputs.end ? Math.round(inputs.end.output[0]) : list.length,
                startItem,
                i,
                j;

            if (m.unscaledValue === undefined) {
                startItem = list[start];
                m.unscaledValue = (startItem === undefined) ? 0.0 : startItem;
            }

            if (m.nextIdx === undefined) {
                m.nextIdx = start;
            }

            for (i = 0, j = 0; i < numSamps; i++, j += m.strides.freq) {
                if (m.nextIdx >= end) {
                    if (loop > 0.0) {
                        m.nextIdx = start;
                    } else {
                        out[i] = m.unscaledValue;
                        continue;
                    }
                }

                out[i] = m.unscaledValue = list[m.nextIdx];
                m.phase += freq[j] * scale;

                if (m.phase >= 1.0) {
                    m.phase = 0.0;
                    m.nextIdx++;
                }
            }

            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.onInputChanged = function () {
            that.model.scale = that.rate !== flock.rates.DEMAND ? that.model.sampleDur : 1;

            if (!that.inputs.list) {
                that.inputs.list = [];
            }

            that.calculateStrides();
            flock.onMulAddInputChanged(that);
        };

        that.init = function () {
            that.onInputChanged();
        };

        that.init();
        return that;
    };

    fluid.defaults("flock.ugen.sequence", {
        rate: "control",

        inputs: {
            start: 0,
            freq: 1.0,
            loop: 0.0,
            list: []
        },

        ugenOptions: {
            model: {
                unscaledValue: undefined,
                value: 0.0,
                phase: 0
            },

            strideInputs: ["freq"]
        }
    });

    flock.ugen.midiFreq = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.gen = function (numSamps) {
            var m = that.model,
                a4 = m.a4,
                a4Freq = a4.freq,
                a4NoteNum = a4.noteNum,
                notesPerOctave = m.notesPerOctave,
                noteNum = that.inputs.source.output,
                out = that.output,
                i,
                j,
                val;

            for (i = 0, j = 0; i < numSamps; i++, j += m.strides.source) {
                out[i] = val = flock.midiFreq(noteNum[j], a4Freq, a4NoteNum, notesPerOctave);
            }

            m.unscaledValue = val;
            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.init = function () {
            that.model.octaveScale = 1 / that.model.notesPerOctave;
            that.onInputChanged();
        };

        that.init();
        return that;
    };

    fluid.defaults("flock.ugen.midiFreq", {
        rate: "control",
        inputs: {
            source: null // TODO: This input should be named "note"
        },
        ugenOptions: {
            model: {
                unscaledValue: 0.0,
                value: 0.0,
                a4: {
                    noteNum: 69,
                    freq: 440
                },
                notesPerOctave: 12
            },
            strideInputs: [
                "source"
            ]
        }
    });
}());
;/*
* Flocking Bandlimited UGens
* http://github.com/colinbdclark/flocking
*
* Copyright 2015, Colin Clark
* Dual licensed under the MIT and GPL Version 2 licenses.
*/

/*global require*/
/*jshint white: false, newcap: true, regexp: true, browser: true,
    forin: false, nomen: true, bitwise: false, maxerr: 100,
    indent: 4, plusplus: false, curly: true, eqeqeq: true,
    freeze: true, latedef: true, noarg: true, nonew: true, quotmark: double, undef: true,
    unused: true, strict: true, asi: false, boss: false, evil: false, expr: false,
    funcscope: false*/

var fluid = fluid || require("infusion"),
    flock = fluid.registerNamespace("flock");

(function () {
    "use strict";

    flock.blit = function (p) {
        var val,
            t;

        if (p >= 2.0) {
            val = 0.0;
        } else if (p >= 1.0) {
            t = 2.0 - p;
            val = 0.16666666666666666 * t * t * t;
        } else if (p >= 0.0) {
            t = p * p;
            val = (0.6666666666666666 - t) + (0.5 * t * p);
        } else if (p >= -1.0) {
            t = p * p;
            val = (0.6666666666666666 - t) - (0.5 * t * p);
        } else if (p >= -2.0) {
            t = 2 + p;
            val = 0.16666666666666666 * t * t * t;
        } else {
            val = 0.0;
        }

        return val;
    };

    flock.blit.period = function (sampleRate, freq) {
        var d0 = sampleRate / freq;
        return d0 < 1.0 ? 1.0 : d0;
    };

    flock.blit.updatePeriodState = function (m, freq) {
        m.freq = freq < 0.000001 ? 0.000001 : freq;
        m.d0 = flock.blit.period(m.sampleRate, m.freq);
    };

    /**
     * A band-limited impulse train.
     *
     * This unit generator is based on the BLIT-FDF method documented in:
     * "Efficient Antialiasing Oscillator Algorithms Using Low-Order Fractional Delay Filters"
     * Juhan Nam, Vesa Valimaki, Jonathan S. Able, and Julius O. Smith
     * in IEEE Transactions on Audio, Speech, and Language Processing, Vol. 18, No. 4, May 2010.
     *
     * Inputs:
     *  - freq: the frequency of the impulse train;
     *          this can only be modulated every period,
     *          so there may be a delay before the frequency is updated at low frequencies
     *  - mul: the amplitude of the impulses
     *  - add: the amplitude offset of the impulses
     */
    flock.ugen.blit = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.gen = function (numSamps) {
            var m = that.model,
                out = that.output,
                freq = that.inputs.freq.output[0],
                p = m.phase,
                i,
                val;

            for (i = 0; i < numSamps; i++) {
                p -= 1.0;
                if (p < -2.0) {
                    // We've hit the end of the period.
                    flock.blit.updatePeriodState(m, freq);
                    p += m.d0;
                }

                val = flock.blit(p);
                out[i] = val;
            }

            m.phase = p;
            m.unscaledValue = val;
            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.init = function () {
            that.onInputChanged();
        };

        that.init();
        return that;
    };

    fluid.defaults("flock.ugen.blit", {
        rate: "audio",

        inputs: {
            freq: 440.0,
            mul: null,
            add: null
        },

        ugenOptions: {
            model: {
                phase: -2.0,
                unscaledValue: 0.0,
                value: 0.0
            }
        }
    });

    /**
     * Generates a band-limited sawtooth wavefrom.
     *
     * This unit generator is based on the BLIT-FDF method documented in:
     * "Efficient Antialiasing Oscillator Algorithms Using Low-Order Fractional Delay Filters"
     * Juhan Nam, Vesa Valimaki, Jonathan S. Able, and Julius O. Smith
     * in IEEE Transactions on Audio, Speech, and Language Processing, Vol. 18, No. 4, May 2010.
     *
     * This unit generator is based on an algorithm that integrates bandlimited impulse trains,
     * and as a result can only change frequencies at the end of each waveform period.
     *
     * Inputs:
     *  - freq: the frequency of the saw;
     *          this can only be modulated every period,
     *          so there may be a delay before the frequency is updated at low frequencies
     *  - leakRate: the leak rate of the leaky integrator (between >0.0 and 1.0)
     *  - mul: the amplitude of the impulses
     *  - add: the amplitude offset of the impulses
     */
    flock.ugen.saw = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.gen = function (numSamps) {
            var m = that.model,
                out = that.output,
                freq = that.inputs.freq.output[0],
                leak = 1.0 - that.inputs.leakRate.output[0],
                p = m.phase,
                unscaledValue = m.unscaledValue,
                i;

            // TODO: This can be moved to init() when
            // we have ugen graph priming implemented.
            if (p === undefined) {
                flock.ugen.saw.updatePeriodState(m, freq);
                p = m.d0 / 2;
            }

            for (i = 0; i < numSamps; i++) {
                p -= 1.0;
                if (p < -2.0) {
                    // We've hit the end of the period.
                    flock.ugen.saw.updatePeriodState(m, freq);
                    p += m.d0;
                }

                // Saw is BLIT - dcOffset + (1 - leakRate) * prevVal
                out[i] = unscaledValue = flock.blit(p) - m.dcOffset + leak * unscaledValue;
            }

            m.phase = p;
            m.unscaledValue = unscaledValue;
            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.init = function () {
            that.onInputChanged();
        };

        that.init();
        return that;
    };

    flock.ugen.saw.updatePeriodState = function (m, freq) {
        flock.blit.updatePeriodState(m, freq);
        m.dcOffset = 1.0 / m.d0; // DC offset at steady state is 1 / d0.
    };

    fluid.defaults("flock.ugen.saw", {
        rate: "audio",

        inputs: {
            freq: 440.0,
            leakRate: 0.01,
            mul: null,
            add: null
        },

        ugenOptions: {
            model: {
                phase: undefined,
                dcOffset: undefined,
                unscaledValue: 0.0,
                value: 0.0
            }
        }
    });

    /**
     * Generates a band-limited square wave.
     *
     * This unit generator is based on the BLIT-FDF method documented in:
     * "Efficient Antialiasing Oscillator Algorithms Using Low-Order Fractional Delay Filters"
     * Juhan Nam, Vesa Valimaki, Jonathan S. Able, and Julius O. Smith
     * in IEEE Transactions on Audio, Speech, and Language Processing, Vol. 18, No. 4, May 2010.
     *
     * This unit generator is based on an algorithm that integrates bandlimited impulse trains,
     * and as a result can only change frequencies at the end of each waveform period.
     *
     * Inputs:
     *  - freq: the frequency of the square;
     *          this can only be modulated every period,
     *          so there may be a delay before the frequency is updated at low frequencies
     *  - leakRate: the leak rate of the leaky integrator (between >0.0 and 1.0)
     *  - mul: the amplitude of the impulses
     *  - add: the amplitude offset of the impulses
     */
    flock.ugen.square = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.gen = function (numSamps) {
            var m = that.model,
                out = that.output,
                freq = that.inputs.freq.output[0],
                leak = 1.0 - that.inputs.leakRate.output[0],
                p = m.phase,
                unscaledValue = m.unscaledValue,
                i;

            // TODO: This can be moved to init() when
            // we have ugen graph priming implemented.
            if (p === undefined) {
                flock.ugen.square.updatePeriodState(m, freq);
                p = m.phaseResetValue;
            }

            for (i = 0; i < numSamps; i++) {
                out[i] = unscaledValue = (flock.blit(p) * m.sign) + leak * unscaledValue;

                if (p < -2.0) {
                    flock.ugen.square.updatePeriodState(m, freq);
                    // We've hit the end of the period.
                    p += m.phaseResetValue;
                }

                p -= 1.0;
            }

            m.phase = p;
            m.unscaledValue = unscaledValue;
            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.init = function () {
            that.onInputChanged();
        };

        that.init();
        return that;
    };

    flock.ugen.square.updatePeriodState = function (m, freq) {
        flock.blit.updatePeriodState(m, freq);
        m.phaseResetValue = m.d0 / 2;
        // Flip the sign of the output.
        m.sign *= -1.0;
    };

    fluid.defaults("flock.ugen.square", {
        rate: "audio",

        inputs: {
            freq: 440.0,
            leakRate: 0.01,
            mul: null,
            add: null
        },

        ugenOptions: {
            model: {
                phase: undefined,
                unscaledValue: 0.5,
                value: 0.5,
                sign: 1.0
            }
        }
    });


    /**
     * Generates a band-limited triangle wave.
     *
     * This unit generator is based on the BLIT-FDF method documented in:
     * "Efficient Antialiasing Oscillator Algorithms Using Low-Order Fractional Delay Filters"
     * Juhan Nam, Vesa Valimaki, Jonathan S. Able, and Julius O. Smith
     * in IEEE Transactions on Audio, Speech, and Language Processing, Vol. 18, No. 4, May 2010.
     *
     * This unit generator is based on an algorithm that integrates bandlimited impulse trains,
     * and as a result can only change frequencies at the end of each waveform period.
     *
     * It will noticeably distort at frequencies above 6000 Hz unless you adjust the
     * leakRate accordingly.
     *
     * Inputs:
     *  - freq: the frequency of the square;
     *          this can only be modulated every period,
     *          so there may be a delay before the frequency is updated at low frequencies
     *  - leakRate: the leak rate of the leaky integrator (between >0.0 and 1.0)
     *  - mul: the amplitude of the impulses
     *  - add: the amplitude offset of the impulses
     */
    flock.ugen.tri = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.gen = function (numSamps) {
            var m = that.model,
                out = that.output,
                freq = that.inputs.freq.output[0],
                leak = 1.0 - that.inputs.leakRate.output[0],
                p = m.phase,
                unscaledValue = m.unscaledValue,
                secondPrevVal = m.secondPrevVal,
                i,
                firstIntegrate,
                secondIntegrate;

            // TODO: This can be moved to init() when
            // we have ugen graph priming implemented.
            if (p === undefined) {
                flock.ugen.tri.updatePeriodState(m, freq);
                p = m.d0 / 4;
            }

            for (i = 0; i < numSamps; i++) {
                firstIntegrate = (flock.blit(p) * m.sign) + leak * unscaledValue;
                unscaledValue = firstIntegrate;
                secondIntegrate = firstIntegrate + leak * secondPrevVal;
                secondPrevVal = secondIntegrate;
                out[i] = secondIntegrate * m.ampScale;

                p -= 1.0;
                if (p < -2.0) {
                    flock.ugen.tri.updatePeriodState(m, freq);
                    p += m.phaseResetValue;
                }
            }

            m.phase = p;
            m.unscaledValue = unscaledValue;
            m.secondPrevVal = secondPrevVal;
            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.init = function () {
            that.onInputChanged();
        };

        that.init();
        return that;
    };

    flock.ugen.tri.updatePeriodState = function (m, freq) {
        flock.blit.updatePeriodState(m, freq);
        m.phaseResetValue = m.d0 / 2;
        m.ampScale = 2 / m.d0;
        // Flip the sign of the output.
        m.sign *= -1.0;
    };

    fluid.defaults("flock.ugen.tri", {
        rate: "audio",

        inputs: {
            freq: 440.0,
            leakRate: 0.01,
            mul: null,
            add: null
        },

        ugenOptions: {
            model: {
                phase: undefined,
                value: 0.5,
                unscaledValue: 0.5,
                secondPrevVal: 0.0,
                sign: 1.0,
                ampScale: undefined,
                phaseResetValue: undefined
            }
        }
    });
}());
;/*
* Flocking Envelopes
* http://github.com/colinbdclark/flocking
*
* Copyright 2011-2014, Colin Clark
* Dual licensed under the MIT and GPL Version 2 licenses.
*/

/*global require, DSP*/
/*jshint white: false, newcap: true, regexp: true, browser: true,
    forin: false, nomen: true, bitwise: false, maxerr: 100,
    indent: 4, plusplus: false, curly: true, eqeqeq: true,
    freeze: true, latedef: true, noarg: true, nonew: true, quotmark: double, undef: true,
    unused: true, strict: true, asi: false, boss: false, evil: false, expr: false,
    funcscope: false*/

var fluid = fluid || require("infusion"),
    flock = fluid.registerNamespace("flock");

(function () {
    "use strict";

    var $ = fluid.registerNamespace("jQuery");

    /*********************
     * Envelope Creators *
     *********************/

    flock.envelope = {};

    // Unsupported API.
    flock.envelope.makeCreator = function (name, envelopeOptionsTransformer) {
        return function (options) {
            var defaults = fluid.defaults(name),
                merged = $.extend(true, {}, defaults, options);

            return envelopeOptionsTransformer(merged);
        };
    };

    // Unsupported API.
    flock.envelope.registerCreators = function (inNamespace, creatorSpecs) {
        var path, creatorSpec;

        for (var pathSuffix in creatorSpecs) {
            path = fluid.pathUtil.composePath(inNamespace, pathSuffix);
            creatorSpec = creatorSpecs[pathSuffix];

            fluid.defaults(path, creatorSpec.defaults);
            fluid.setGlobalValue(path, flock.envelope.makeCreator(path, creatorSpec.transformer));
        }
    };

    // Unsupported API.
    flock.envelope.creatorSpecs = {
        line: {
            transformer: function (o) {
                return {
                    levels: [o.start, o.end],
                    times: [o.duration]
                };
            },

            defaults: {
                start: 0.0,
                end: 1.0,
                duration: 1.0
            }
        },

        linear: {
            transformer: function (o) {
                return {
                    levels: [0, o.level, o.level, 0],
                    times: [o.attack, o.sustain, o.release]
                };
            },

            defaults: {
                level: 1.0,
                attack: 0.01,
                sustain: 1.0,
                release: 1.0
            }
        },

        tri: {
            transformer: function (o) {
                return {
                    levels: [0, o.level, 0],
                    times: [o.duration, o.duration]
                };
            },

            defaults: {
                level: 1.0,
                duration: 1.0
            }
        },

        sin: {
            transformer: function (o) {
                return {
                    levels: [0, o.level, 0],
                    times: [o.duration, o.duration],
                    curve: "sin"
                };
            },

            defaults: {
                level: 1.0,
                duration: 1.0
            }
        },

        asr: {
            transformer: function (o) {
                return {
                    levels: [0, o.sustain, 0],
                    times: [o.attack, o.release],
                    sustainPoint: 1,
                    curve: -4.0
                };
            },

            defaults: {
                sustain: 1.0,
                attack: 0.01,
                release: 1.0
            }
        },

        dadsr: {
            transformer: function (o) {
                var levels = [0, 0, o.peak, o.peak * o.sustain, 0];
                DSP.add(levels, levels, o.bias);

                return {
                    levels: levels,
                    times: [o.delay, o.attack, o.decay, o.release],
                    sustainPoint: 3,
                    curve: -4.0
                };
            },

            defaults: {
                delay: 0.1,
                attack: 0.01,
                decay: 0.3,
                sustain: 0.5,
                release: 1.0,
                peak: 1.0,
                bias: 0.0
            }
        },

        adsr: {
            transformer: function (o) {
                var levels = [0, o.peak, o.peak * o.sustain, 0];
                DSP.add(levels, levels, o.bias);

                return {
                    levels: levels,
                    times: [o.attack, o.decay, o.release],
                    sustainPoint: 2,
                    curve: -4.0
                };
            },

            defaults: {
                attack: 0.01,
                decay: 0.3,
                sustain: 0.5,
                release: 1.0,
                peak: 1.0,
                bias: 0.0
            }
        }
    };

    flock.envelope.registerCreators("flock.envelope", flock.envelope.creatorSpecs);

    flock.envelope.validate = function (envelope, failOnError) {
        var levels = envelope.levels,
            report = {};

        if (!envelope.times) {
            report.times = "An array containing at least one time value must be specified.";
        } else if (!levels || levels.length < 2) {
            report.levels = "An array containing at least two levels must be specified.";
        } else {
            flock.envelope.validate.times(envelope.times, levels, report);
            flock.envelope.validate.levels(levels, report);
            flock.envelope.validate.curves(envelope.curve, levels, report);
            flock.envelope.validate.sustainPoint(envelope.sustainPoint, levels, report);
        }

        if (failOnError !== false) {
            for (var errorProp in report) {
                flock.fail(report[errorProp]);
            }
        }

        return report;
    };

    flock.envelope.validate.times = function (times, levels, report) {
        if (times.length !== levels.length - 1) {
            report.times = "The envelope specification should provide one fewer time value " +
                "than the number of level values. times: " + times + " levels: " + levels;
        }

        for (var i = 0; i < times.length; i++) {
            var time = times[i];

            if (isNaN(time)) {
                report.times = "A NaN time value was specified at index " +
                    i + ". times: " + times;
            }

            if (time < 0) {
                report.times = "All times should be positive values. times: " + times;
            }
        }
    };

    flock.envelope.validate.levels = function (levels, report) {
        for (var i = 0; i < levels.length; i++) {
            if (isNaN(levels[i])) {
                report.levels = "A NaN level value was specified at index " +
                    i + ". levels: " + levels;
            }
        }
    };

    flock.envelope.validate.curves = function (curve, levels, report) {
        if (!curve) {
            return report;
        }

        if (flock.isIterable(curve)) {
            if (curve.length !== levels.length - 1) {
                report.curve = "When curve is specified as an array, " +
                    "there should be one fewer curve value " +
                    "than the number of level values. curve: " +
                    curve + " levels: " + levels;
            }

            fluid.each(curve, function (curveName) {
                var lineGen = flock.line.generator(curveName);
                if (!lineGen) {
                    report.curve = "'" + curveName + "' is not a valid curve type. curve: " + curve;
                }
            });
        }

        var lineGen = flock.line.generator(curve);
        if (!lineGen) {
            report.curve = "'" + curve + "' is not a valid curve type.";
        }
    };

    flock.envelope.validate.sustainPoint = function (sustainPoint, levels, report) {
        if (sustainPoint < 0 || sustainPoint >= levels.length) {
            report.sustainPoint = "The specified sustainPoint index is out range for the levels array. " +
                "sustainPoint: " + sustainPoint + " levels: " + levels;
        }
    };

    /**
     * Takes an envelope specification and expands it,
     * producing an envelope object.
     */
    flock.envelope.expand = function (envSpec) {
        var envelope = typeof envSpec === "string" ? fluid.invokeGlobalFunction(envSpec) :
            envSpec.type ? fluid.invokeGlobalFunction(envSpec.type, [envSpec]) : envSpec;

        // Catch a common naming mistake and alias it to the correct name.
        if (envelope.curves && !envelope.curve) {
            envelope.curve = envelope.curves;
        }

        if (!flock.isIterable(envelope.curve)) {
            var numCurves = envelope.levels.length - 1;
            envelope.curve = flock.generate(new Array(numCurves), envelope.curve);
        }

        flock.envelope.validate(envelope, true);

        return envelope;
    };


    /****************************
     * Line Generator Functions *
     ****************************/

    flock.line = {
        // TODO: Unit tests!
        // e.g. flock.line.fill("linear", new Float32Array(64), 0, 1);
        fill: function (type, buffer, start, end, startIdx, endIdx) {
            startIdx = startIdx === undefined ? 0 : startIdx;
            endIdx = endIdx === undefined ? buffer.length : endIdx;

            var numSamps = endIdx - startIdx,
                m = flock.line.fill.model;

            m.unscaledValue = start;
            m.destination = end;
            m.numSegmentSamps = numSamps - 1;

            if (typeof type === "number") {
                m.currentCurve = type;
                type = "curve";
            }

            var generator = flock.line[type];
            if (!generator) {
                flock.fail("No line generator could be found for type " + type);
            }
            generator.init(m);

            return generator.gen(numSamps, startIdx, buffer, m);
        },

        generator: function (curve) {
            var type = typeof curve;

            return type === "string" ? flock.line[curve] :
                type === "number" ? flock.line.curve : flock.line.linear;
        },

        constant: {
            init: function (m) {
                m.stepSize = 0;
            },

            gen: function (numSamps, idx, buffer, m) {
                var val = m.unscaledValue;
                for (var i = idx; i < numSamps + idx; i++) {
                    buffer[i] = val;
                }

                return buffer;
            }
        },

        step: {
            init: function (m) {
                m.arrived = false;
            },

            gen: function (numSamps, idx, buffer, m) {
                for (var i = idx; i < numSamps + idx; i++) {
                    buffer[i] = m.unscaledValue;
                    if (!m.arrived) {
                        m.arrived = true;
                        m.unscaledValue = m.destination;
                    }
                }

                return buffer;
            }
        },

        linear: {
            init: function (m) {
                m.stepSize = (m.destination - m.unscaledValue) / m.numSegmentSamps;
            },

            gen: function (numSamps, idx, buffer, m) {
                var val = m.unscaledValue,
                    stepSize = m.stepSize;

                for (var i = idx; i < numSamps + idx; i++) {
                    buffer[i] = val;
                    val += stepSize;
                }

                m.unscaledValue = val;
                m.stepSize = stepSize;

                return buffer;
            }
        },

        exponential: {
            init: function (m) {
                if (m.unscaledValue === 0) {
                    m.unscaledValue = 0.0000000000000001;
                }
                m.stepSize = m.numSegmentSamps === 0 ? 0 :
                    Math.pow(m.destination / m.unscaledValue, 1.0 / m.numSegmentSamps);
            },

            gen: function (numSamps, idx, buffer, m) {
                var val = m.unscaledValue,
                    stepSize = m.stepSize;

                for (var i = idx; i < numSamps + idx; i++) {
                    buffer[i] = val;
                    val *= stepSize;
                }

                m.unscaledValue = val;
                m.stepSize = stepSize;

                return buffer;
            }
        },

        curve: {
            init: function (m) {
                if (Math.abs(m.currentCurve) < 0.001) {
                    // A curve value this small might as well be linear.
                    return flock.line.linear.init(m);
                } else {
                    var a1 = (m.destination - m.unscaledValue) / (1.0 - Math.exp(m.currentCurve));
                    m.a2 = m.unscaledValue + a1;
                    m.b1 = a1;
                    m.stepSize = Math.exp(m.currentCurve / m.numSegmentSamps);
                }
            },

            gen: function (numSamps, idx, buffer, m) {
                var val = m.unscaledValue,
                    b1 = m.b1;

                for (var i = idx; i < numSamps + idx; i++) {
                    buffer[i] = val;
                    b1 *= m.stepSize;
                    val = m.a2 - b1;
                }

                m.unscaledValue = val;
                m.b1 = b1;

                return buffer;
            }
        },

        sin: {
            init: function (m) {
                var w = Math.PI / m.numSegmentSamps;
                m.a2 = (m.destination + m.unscaledValue) * 0.5;
                m.b1 = 2.0 * Math.cos(w);
                m.y1 = (m.destination - m.unscaledValue) * 0.5;
                m.y2 = m.y1 * Math.sin(flock.HALFPI - w);
                m.unscaledValue = m.a2 - m.y1;
            },

            gen: function (numSamps, idx, buffer, m) {
                var val = m.unscaledValue,
                    y1 = m.y1,
                    y2 = m.y2,
                    y0;

                for (var i = idx; i < numSamps + idx; i++) {
                    buffer[i] = val;
                    y0 = m.b1 * y1 - y2;
                    val = m.a2 - y0;
                    y2 = y1;
                    y1 = y0;
                }

                m.unscaledValue = val;
                m.y1 = y1;
                m.y2 = y2;

                return buffer;
            }
        },

        welsh: {
            init: function (m) {
                var w = flock.HALFPI / m.numSegmentSamps,
                    cosW = Math.cos(w);

                m.b1 = 2.0 * cosW;

                if (m.destination >= m.unscaledValue) {
                    m.a2 = m.unscaledValue;
                    m.y1 = 0.0;
                    m.y2 = -Math.sin(w) * (m.destination - m.unscaledValue);
                } else {
                    m.a2 = m.destination;
                    m.y1 = m.unscaledValue - m.destination;
                    m.y2 = cosW * (m.unscaledValue - m.destination);
                }

                m.unscaledValue = m.a2 + m.y1;
            },

            gen: function (numSamps, idx, buffer, m) {
                var val = m.unscaledValue,
                    y1 = m.y1,
                    y2 = m.y2,
                    y0;

                for (var i = idx; i < numSamps + idx; i++) {
                    buffer[i] = val;
                    y0 = m.b1 * y1 - y2;
                    y2 = y1;
                    y1 = y0;
                    val = m.a2 + y0;
                }

                m.unscaledValue = val;
                m.y1 = y1;
                m.y2 = y2;

                return buffer;
            }
        },

        squared: {
            init: function (m) {
                m.y1 = Math.sqrt(m.unscaledValue);
                m.y2 = Math.sqrt(m.destination);
                m.stepSize = (m.y2 - m.y1) / m.numSegmentSamps;
            },

            gen: function (numSamps, idx, buffer, m) {
                var val = m.unscaledValue,
                    y1 = m.y1;

                for (var i = idx; i < numSamps + idx; i++) {
                    buffer[i] = val;
                    y1 += m.stepSize;
                    val = y1 * y1;
                }

                m.y1 = y1;
                m.unscaledValue = val;

                return buffer;
            }
        },

        cubed: {
            init: function (m) {
                var third = 0.3333333333333333;
                m.y1 = Math.pow(m.unscaledValue, third);
                m.y2 = Math.pow(m.destination, third);
                m.stepSize = (m.y2 - m.y1) / m.numSegmentSamps;
            },

            gen: function (numSamps, idx, buffer, m) {
                var val = m.unscaledValue,
                    y1 = m.y1;

                for (var i = idx; i < numSamps + idx; i++) {
                    buffer[i] = val;
                    y1 += m.stepSize;
                    val = y1 * y1 * y1;
                }

                m.y1 = y1;
                m.unscaledValue = val;

                return buffer;
            }
        }
    };

    // Unsupported API.
    flock.line.fill.model = {
        unscaledValue: 0.0,
        value: 0.0,
        destination: 1.0
    };

    /****************************
     * Envelope Unit Generators *
     ****************************/

    flock.ugen.line = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.gen = function (numSamps) {
            var m = that.model,
                stepSize = m.stepSize,
                numSteps = m.numSteps,
                numLevelVals = numSteps >= numSamps ? numSamps : numSteps,
                numEndVals = numSamps - numLevelVals,
                level = m.level,
                out = that.output,
                i;

            for (i = 0; i < numLevelVals; i++) {
                out[i] = level;
                numSteps--;
                level += stepSize;
            }

            // TODO: Implement a more efficient gen algorithm when the line has finished.
            if (numEndVals > 0) {
                for (i = 0; i < numEndVals; i++) {
                    out[i] = level;
                }
            }

            // TODO: "level" should be deprecated in favour of "unscaledValue"
            m.level = m.unscaledValue = level;
            m.numSteps = numSteps;
            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.onInputChanged = function () {
            var m = that.model;

            // Any change in input value will restart the line.
            m.start = that.inputs.start.output[0];
            m.end = that.inputs.end.output[0];
            m.numSteps = Math.round(that.inputs.duration.output[0] * m.sampleRate);
            if (m.numSteps === 0) {
                m.stepSize = 0.0;
                m.level = m.end;
            } else {
                m.stepSize = (m.end - m.start) / m.numSteps;
                m.level = m.start;
            }

            flock.onMulAddInputChanged(that);
        };

        that.onInputChanged();
        return that;
    };

    fluid.defaults("flock.ugen.line", {
        rate: "control",
        inputs: {
            start: 0.0,
            end: 1.0,
            duration: 1.0,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                start: 0.0,
                end: 1.0,
                numSteps: 0,
                stepSize: 0,
                level: 0.0,
                unscaledValue: 0.0,
                value: 0.0
            }
        }
    });


    flock.ugen.xLine = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.gen = function (numSamps) {
            var m = that.model,
                multiplier = m.multiplier,
                numSteps = m.numSteps,
                numLevelVals = numSteps >= numSamps ? numSamps : numSteps,
                numEndVals = numSamps - numLevelVals,
                level = m.level,
                out = that.output,
                i;

            for (i = 0; i < numLevelVals; i++) {
                out[i] = level;
                numSteps--;
                level *= multiplier;
            }

            // TODO: Implement a more efficient gen algorithm when the line has finished.
            if (numEndVals > 0) {
                for (i = 0; i < numEndVals; i++) {
                    out[i] = level;
                }
            }

            // TODO: "level" should be deprecated in favour of "unscaledValue"
            m.level = m.unscaledValue = level;
            m.numSteps = numSteps;
            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.onInputChanged = function () {
            var m = that.model;

            flock.onMulAddInputChanged(that);

            // Any change in input value will restart the line.
            m.start = that.inputs.start.output[0];
            if (m.start === 0.0) {
                m.start = 1e-101; // Guard against divide by zero.
            }

            m.end = that.inputs.end.output[0];
            m.numSteps = Math.round(that.inputs.duration.output[0] * m.sampleRate);
            m.multiplier = Math.pow(m.end / m.start, 1.0 / m.numSteps);
            m.level = m.start;
        };

        that.onInputChanged();
        return that;
    };

    fluid.defaults("flock.ugen.xLine", {
        rate: "control",
        inputs: {
            start: 0.0,
            end: 1.0,
            duration: 1.0,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                start: 0.0,
                end: 1.0,
                numSteps: 0,
                multiplier: 0,
                level: 0.0,
                unscaledValue: 0.0,
                value: 0.0
            }
        }
    });

    flock.ugen.asr = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.gen = function (numSamps) {
            var m = that.model,
                out = that.output,
                prevGate = m.previousGate,
                gate = that.inputs.gate.output[0],
                level = m.level,
                stage = m.stage,
                currentStep = stage.currentStep,
                stepInc = stage.stepInc,
                numSteps = stage.numSteps,
                targetLevel = m.targetLevel,
                stepsNeedRecalc = false,
                stageTime,
                i;

            // Recalculate the step state if necessary.
            if (prevGate <= 0 && gate > 0) {
                // Starting a new attack stage.
                targetLevel = that.inputs.sustain.output[0];
                stageTime = that.inputs.attack.output[0];
                stepsNeedRecalc = true;
            } else if (gate <= 0 && currentStep >= numSteps) {
                // Starting a new release stage.
                targetLevel = that.inputs.start.output[0];
                stageTime = that.inputs.release.output[0];
                stepsNeedRecalc = true;
            }

            // TODO: Can we get rid of this extra branch without introducing code duplication?
            if (stepsNeedRecalc) {
                numSteps = Math.round(stageTime * m.sampleRate);
                stepInc = (targetLevel - level) / numSteps;
                currentStep = 0;
            }

            // Output the the envelope's sample data.
            for (i = 0; i < numSamps; i++) {
                out[i] = level;
                currentStep++;
                // Hold the last value if the stage is complete, otherwise increment.
                level = currentStep < numSteps ?
                    level + stepInc : currentStep === numSteps ?
                    targetLevel : level;
            }

            // Store instance state.
            // TODO: "level" should be deprecated in favour of "unscaledValue"
            m.level = m.unscaledValue = level;
            m.targetLevel = targetLevel;
            m.previousGate = gate;
            stage.currentStep = currentStep;
            stage.stepInc = stepInc;
            stage.numSteps = numSteps;

            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.init = function () {
            var m = that.model;
            m.level = m.unscaledValue = that.inputs.start.output[0];
            m.targetLevel = that.inputs.sustain.output[0];

            that.onInputChanged();
        };

        that.init();
        return that;
    };

    fluid.defaults("flock.ugen.asr", {
        rate: "control",
        inputs: {
            start: 0.0,
            attack: 0.01,
            sustain: 1.0,
            release: 1.0,
            gate: 0.0,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                level: 0.0,
                targetLevel: 0.0,
                previousGate: 0.0,
                unscaledValue: 0.0,
                value: 0.0,
                stage: {
                    currentStep: 0,
                    stepInc: 0,
                    numSteps: 0
                }
            }
        }
    });

    // Included for backwards compatibility.
    // The name "flock.ugen.env.simpleASR is deprecated.
    // Please use flock.ugen.asr instead.
    // This will be removed before Flocking 1.0.
    flock.ugen.env = {};
    flock.ugen.env.simpleASR  = flock.ugen.asr;
    fluid.defaults("flock.ugen.env.simpleASR", fluid.copy(fluid.defaults("flock.ugen.asr")));

    flock.ugen.envGen = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.krGen = function (numSamps) {
            var m = that.model,
                out = that.output,
                inputs = that.inputs,
                gate = inputs.gate.output[0],
                timeScale = inputs.timeScale.output[0],
                i = 0,
                sampsToGen;

            flock.ugen.envGen.checkGate(that, gate, timeScale);

            while (i < numSamps) {
                sampsToGen = Math.min(numSamps - i, m.numSegmentSamps);
                that.lineGen.gen(sampsToGen, i, out, m);
                i += sampsToGen;
                m.numSegmentSamps -= sampsToGen;

                if (m.numSegmentSamps === 0) {
                    flock.ugen.envGen.nextStage(that, timeScale);
                }
            }

            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.arGen = function (numSamps) {
            var m = that.model,
                out = that.output,
                inputs = that.inputs,
                gate = inputs.gate.output,
                timeScale = inputs.timeScale.output[0],
                i;

            for (i = 0; i < numSamps; i++) {
                flock.ugen.envGen.checkGate(that, gate[i], timeScale);

                that.lineGen.gen(1, i, out, m);
                m.numSegmentSamps--;

                if (m.numSegmentSamps === 0) {
                    flock.ugen.envGen.nextStage(that, timeScale);
                }
            }

            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.onInputChanged = function (inputName) {
            if (!inputName || inputName === "envelope") {
                that.envelope = flock.ugen.envGen.initEnvelope(that, that.inputs.envelope);
            }

            if (!inputName || inputName === "gate") {
                that.gen = that.inputs.gate.rate === flock.rates.AUDIO ? that.arGen : that.krGen;
            }

            flock.onMulAddInputChanged(that);
        };

        that.onInputChanged();

        return that;
    };

    // Unsupported API.
    flock.ugen.envGen.initEnvelope = function (that, envSpec) {
        var m = that.model,
            envelope = flock.envelope.expand(envSpec);

        m.stage = 0;
        m.numStages = envelope.times.length;
        that.lineGen = flock.line.constant;

        flock.ugen.envGen.lineGenForStage(that.inputs.timeScale.output[0], envelope, m);
        m.unscaledValue = envelope.levels[m.stage];

        return envelope;
    };

    // Unsupported API.
    flock.ugen.envGen.checkGate = function (that, gate, timeScale) {
        var m = that.model,
            envelope = that.envelope;

        if (gate !== m.previousGate) {
            if (gate > 0.0 && m.previousGate <= 0.0) {
                // Gate has opened.
                m.stage = 1;
                that.lineGen = flock.ugen.envGen.lineGenForStage(timeScale, envelope, m);
            } else if (gate <= 0.0 && m.previousGate > 0) {
                // Gate has closed.
                m.stage = m.numStages;
                that.lineGen = flock.ugen.envGen.lineGenForStage(timeScale, envelope, m);
            }
        }
        m.previousGate = gate;
    };

    // Unsupported API.
    flock.ugen.envGen.nextStage = function (that, timeScale) {
        var m = that.model,
            envelope = that.envelope;

        // We've hit the end of the current transition.
        if (m.stage === envelope.sustainPoint) {
            // We're at the sustain point.
            // Output a constant value.
            that.lineGen = flock.line.constant;
            m.numSegmentSamps = Infinity;
            m.destination = m.unscaledValue;
        } else {
            // Move on to the next breakpoint stage.
            m.stage++;
            that.lineGen = flock.ugen.envGen.lineGenForStage(timeScale, envelope, m);
        }
    };

    // Unsupported API.
    flock.ugen.envGen.setupStage = function (timeScale, envelope, m) {
        var dest = envelope.levels[m.stage],
            dur,
            durSamps;

        if (m.stage === 0 || m.stage > m.numStages) {
            durSamps = Infinity;
        } else {
            dur = envelope.times[m.stage - 1] * timeScale;
            durSamps = Math.max(1, dur * m.sampleRate);
        }

        m.numSegmentSamps = durSamps;
        m.destination = dest;
    };

    // Unsupported API.
    flock.ugen.envGen.lineGenForStage = function (timeScale, envelope, m) {
        var curve = envelope.curve,
            lineGen,
            curveValue;

        if (m.stage === 0 || m.stage > m.numStages) {
            lineGen = flock.line.constant;
        } else {
            curveValue = curve[m.stage - 1];
            m.currentCurve = curveValue;
            lineGen = flock.line.generator(curveValue);
        }

        flock.ugen.envGen.setupStage(timeScale, envelope, m);
        lineGen.init(m);

        return lineGen;
    };

    fluid.defaults("flock.ugen.envGen", {
        rate: "audio",

        inputs: {
            envelope: "flock.envelope.adsr",
            gate: 0.0,
            timeScale: 1.0,     // Timescale is control-rate (or lower) only.
            mul: null,          // This is equivalent to SC's levelScale parameter.
            add: null           // And this to SC's levelBias.
        },

        ugenOptions: {
            model: {
                previousGate: 0.0,
                stepSize: 0.0,
                destination: 0.0,
                numSegmentSamps: 1.0,
                unscaledValue: 0.0,
                value: 0.0,
                stage: 0.0,
                numStages: 0.0
            }
        }
    });

}());
;/*
* Flocking Browser-Dependent Unit Generators
* http://github.com/colinbdclark/flocking
*
* Copyright 2013-2014, Colin Clark
* Dual licensed under the MIT and GPL Version 2 licenses.
*/

/*global require, Float32Array, window*/
/*jshint white: false, newcap: true, regexp: true, browser: true,
    forin: false, nomen: true, bitwise: false, maxerr: 100,
    indent: 4, plusplus: false, curly: true, eqeqeq: true,
    freeze: true, latedef: true, noarg: true, nonew: true, quotmark: double, undef: true,
    unused: true, strict: true, asi: false, boss: false, evil: false, expr: false,
    funcscope: false*/

var fluid = fluid || require("infusion"),
    flock = fluid.registerNamespace("flock");

(function () {
    "use strict";

    var $ = fluid.registerNamespace("jQuery");

    fluid.registerNamespace("flock.ugen");

    /***************************
     * Browser-dependent UGens *
     ***************************/

    flock.ugen.scope = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.gen = function (numSamps) {
            var m = that.model,
                source = that.inputs.source.output,
                spf = m.spf,
                bufIdx = m.bufIdx,
                buf = m.scope.values,
                i;

            for (i = 0; i < numSamps; i++) {
                buf[bufIdx] = source[i];
                if (bufIdx < spf) {
                    bufIdx += 1;
                } else {
                    bufIdx = 0;
                    that.scopeView.refreshView();
                }
            }

            m.bufIdx = bufIdx;
            m.value = m.unscaledValue = flock.ugen.lastOutputValue(numSamps, source);
        };

        that.onInputChanged = function () {
            // Pass the "source" input directly back as the output from this ugen.
            that.output = that.inputs.source.output;
        };

        that.init = function () {
            that.model.spf = Math.round(that.model.sampleRate / that.options.fps);
            that.model.bufIdx = 0;

            // Set up the scopeView widget.
            that.model.scope = that.options.styles;
            that.model.scope.values = new Float32Array(that.model.spf);
            that.scopeView = flock.view.scope(that.options.canvas, that.model.scope);

            that.onInputChanged();
            that.scopeView.refreshView();
        };

        that.init();
        return that;
    };

    fluid.defaults("flock.ugen.scope", {
        rate: "audio",
        inputs: {
            source: null
        },
        ugenOptions: {
            fps: 60,
            styles: {
                strokeColor: "#777777",
                strokeWidth: 1
            }
        }
    });


    flock.ugen.mouse = {};

    /**
     * Tracks the mouse's position along the specified axis within the boundaries the whole screen.
     * This unit generator will generate a signal between 0.0 and 1.0 based on the position of the mouse;
     * use the mul and add inputs to scale this value to an appropriate control signal.
     */
    flock.ugen.mouse.cursor = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        /**
         * Generates a control rate signal between 0.0 and 1.0 by tracking the mouse's position along the specified axis.
         *
         * @param numSamps the number of samples to generate
         */
        that.exponentialGen = function (numSamps) {
            var m = that.model,
                val = flock.ugen.mouse.cursor.normalize(that.target, m),
                movingAvg = m.movingAvg,
                lag = that.inputs.lag.output[0],
                add = that.inputs.add.output[0],
                mul = that.inputs.mul.output[0],
                lagCoef = m.lagCoef,
                out = that.output,
                i,
                max;

            if (lag !== lagCoef) {
                lagCoef = lag === 0 ? 0.0 : Math.exp(flock.LOG001 / (lag * m.sampleRate));
                m.lagCoef = lagCoef;
            }

            for (i = 0; i < numSamps; i++) {
                max = mul + add;
                val = Math.pow(max  / add, val) * add;
                movingAvg = val + lagCoef * (movingAvg - val); // 1-pole filter averages mouse values.
                out[i] = movingAvg;
            }

            m.movingAvg = movingAvg;
            m.value = m.unscaledValue = movingAvg;
        };

        that.linearGen = function (numSamps) {
            var m = that.model,
                val = flock.ugen.mouse.cursor.normalize(that.target, m),
                movingAvg = m.movingAvg,
                lag = that.inputs.lag.output[0],
                add = that.inputs.add.output[0],
                mul = that.inputs.mul.output[0],
                lagCoef = m.lagCoef,
                out = that.output,
                i;

            if (lag !== lagCoef) {
                lagCoef = lag === 0 ? 0.0 : Math.exp(flock.LOG001 / (lag * m.sampleRate));
                m.lagCoef = lagCoef;
            }

            for (i = 0; i < numSamps; i++) {
                movingAvg = val + lagCoef * (movingAvg - val);
                out[i] = movingAvg * mul + add;
            }

            m.movingAvg = m.unscaledValue = movingAvg;
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.noInterpolationGen = function (numSamps) {
            var m = that.model,
                out = that.output,
                val = flock.ugen.mouse.cursor.normalize(that.target, m),
                i;

            for (i = 0; i < numSamps; i++) {
                out[i] = val * that.inputs.mul.output[0] + that.inputs.add.output[0];
            }

            m.value = m.unscaledValue = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.moveListener = function (e) {
            var m = that.model;
            m.mousePosition = e[m.eventProp];
        };

        that.overListener = function () {
            that.model.isWithinTarget = true;
        };

        that.outListener = function () {
            var m = that.model;
            m.isWithinTarget = false;
            m.mousePosition = 0.0;
        };

        that.downListener = function () {
            that.model.isMouseDown = true;
        };

        that.upListener = function () {
            var m = that.model;
            m.isMouseDown = false;
            m.mousePosition = 0;
        };

        that.moveWhileDownListener = function (e) {
            if (that.model.isMouseDown) {
                that.moveListener(e);
            }
        };

        that.bindEvents = function () {
            var target = that.target,
                moveListener = that.moveListener;

            if (that.options.onlyOnMouseDown) {
                target.mousedown(that.downListener);
                target.mouseup(that.upListener);
                moveListener = that.moveWhileDownListener;
            }

            target.mouseover(that.overListener);
            target.mouseout(that.outListener);
            target.mousemove(moveListener);
        };

        that.onInputChanged = function () {
            flock.onMulAddInputChanged(that);

            var interp = that.options.interpolation;
            that.gen = interp === "none" ? that.noInterpolationGen :
                interp === "exponential" ? that.exponentialGen : that.linearGen;
        };

        that.init = function () {
            var m = that.model,
                options = that.options,
                axis = options.axis,
                target = $(options.target || window);

            if (axis === "x" || axis === "width" || axis === "horizontal") {
                m.eventProp = "clientX";
                m.offsetProp = "left";
                m.dimension = "width";
            } else {
                m.eventProp = "clientY";
                m.offsetProp = "top";
                m.dimension = "height";
            }

            that.target = target;
            m.mousePosition = 0;
            m.movingAvg = 0;

            that.bindEvents();
            that.onInputChanged();
        };

        that.init();
        return that;
    };

    flock.ugen.mouse.cursor.normalize = function (target, m) {
        if (!m.isWithinTarget) {
            return 0.0;
        }

        var size = target[m.dimension](),
            offset = target.offset(),
            pos = m.mousePosition;

        if (offset) {
            pos -= offset[m.offsetProp];
        }

        return pos / size;
    };

    fluid.defaults("flock.ugen.mouse.cursor", {
        rate: "control",
        inputs: {
            lag: 0.5,
            add: 0.0,
            mul: 1.0
        },

        ugenOptions: {
            axis: "x",
            interpolation: "linear",
            model: {
                mousePosition: 0,
                movingAvg: 0,
                value: 0.0
            }
        }
    });


    flock.ugen.mouse.click = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.gen = function (numSamps) {
            var out = that.output,
                m = that.model,
                i;

            for (i = 0; i < numSamps; i++) {
                out[i] = m.unscaledValue;
            }

            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.mouseDownListener = function () {
            that.model.unscaledValue = 1.0;
        };

        that.mouseUpListener = function () {
            that.model.unscaledValue = 0.0;
        };

        that.init = function () {
            var m = that.model;
            m.target = !that.options.target ? $(window) : $(that.options.target);

            m.target.mousedown(that.mouseDownListener);
            m.target.mouseup(that.mouseUpListener);

            that.onInputChanged();
        };

        that.onInputChanged = function () {
            flock.onMulAddInputChanged(that);
        };

        that.init();
        return that;
    };

    fluid.defaults("flock.ugen.mouse.click", {
        rate: "control"
    });


    flock.ugen.mediaIn = function (inputs, output, options) {
        var that = flock.ugen(inputs, output, options);

        that.gen = function (numSamps) {
            var m = that.model,
                out = that.output,
                bus = that.bus,
                val;

            for (var i = 0; i < numSamps; i++) {
                out[i] = val = bus[i];
            }

            m.unscaledValue = val;
            that.mulAdd(numSamps);
            m.value = flock.ugen.lastOutputValue(numSamps, out);
        };

        that.onInputChanged = function () {
            flock.onMulAddInputChanged(that);
        };

        that.init = function () {
            var enviro = flock.enviro.shared,
                mediaEl = $(that.options.element),
                // TODO: Direct reference to the shared environment.
                busNum = enviro.audioStrategy.nativeNodeManager.createMediaElementInput(mediaEl[0]);

            that.bus = that.options.audioSettings.buses[busNum];
            that.onInputChanged();

            // TODO: Remove this warning when Safari and Android
            // fix their MediaElementAudioSourceNode implementations.
            if (flock.platform.browser.safari) {
                flock.log.warn("MediaElementSourceNode does not work on Safari. " +
                    "For more information, see https://bugs.webkit.org/show_bug.cgi?id=84743 " +
                    "and https://bugs.webkit.org/show_bug.cgi?id=125031");
            } else if (flock.platform.isAndroid) {
                flock.log.warn("MediaElementSourceNode does not work on Android. " +
                    "For more information, see https://code.google.com/p/chromium/issues/detail?id=419446");
            }
        };

        that.init();
        return that;
    };

    fluid.defaults("flock.ugen.mediaIn", {
        rate: "audio",
        inputs: {
            mul: null,
            add: null
        },
        ugenOptions: {
            element: "audio"
        }
    });
}());
;/*!
* Flocking - Creative audio synthesis for the Web!
* http://github.com/colinbdclark/flocking
*
* Copyright 2011-2014, Colin Clark
* Dual licensed under the MIT or GPL Version 2 licenses.
*/

/*global require*/
/*jshint white: false, newcap: true, regexp: true, browser: true,
    forin: false, nomen: true, bitwise: false, maxerr: 100,
    indent: 4, plusplus: false, curly: true, eqeqeq: true,
    freeze: true, latedef: true, noarg: true, nonew: true, quotmark: double, undef: true,
    unused: true, strict: true, asi: false, boss: false, evil: false, expr: false,
    funcscope: false*/

var fluid = fluid || require("infusion"),
    flock = fluid.registerNamespace("flock");

(function () {
    "use strict";
    
    fluid.registerNamespace("flock.view");
    
    // TODO: Infusionize.
    flock.view.scope = function (canvas, model) {
        var that = {
            model: model || {
                values: []
            },
            canvas: typeof (canvas) === "string" ? document.querySelector(canvas) : canvas
        };
        
        that.refreshView = function () {
            var ctx = that.ctx,
                h = that.model.height,
                halfH = that.model.halfHeight,
                w = that.model.width,
                vals = that.model.values,
                len = vals.length,
                scaleX = that.model.scaleX * (w / len), // TODO: Doesn't support scale values < 1.0
                i,
                x,
                y;
        
            ctx.clearRect(0, 0, w, h);
            ctx.beginPath();
            for (i = 0; i < len; i++) {
                x = i * scaleX;
                y = vals[i] * that.model.scaleY * halfH + halfH;
                ctx.lineTo(x, y);
            }
            ctx.stroke();
        };
        
        that.init = function () {
            that.ctx = that.canvas.getContext("2d");
            that.ctx.fillStyle = that.model.fill || that.ctx.fillStyle;
            that.ctx.strokeStyle = that.model.strokeColor || that.ctx.strokeStyle;
            that.ctx.lineWidth = that.model.strokeWidth || that.ctx.lineWidth;
        
            that.model.min = that.model.min || -1.0;
            that.model.max = that.model.max || 1.0;
            that.model.height = that.canvas.height;
            that.model.halfHeight = that.model.height / 2;
            that.model.width = that.canvas.width;
            that.model.scaleX = that.model.scaleX || that.model.scale || 1.0;
            that.model.scaleY = that.model.scaleY || that.model.scale || 1.0;
            
            that.refreshView();
        };
        
        that.init();
        return that;
    };
    
}());
;/*
 * Flocking MIDI
 * http://github.com/colinbdclark/flocking
 *
 * Copyright 2014, Colin Clark
 * Dual licensed under the MIT and GPL Version 2 licenses.
 */

/*global require, Promise, console*/
/*jshint white: false, newcap: true, regexp: true, browser: true,
    forin: false, nomen: true, bitwise: false, maxerr: 100,
    indent: 4, plusplus: false, curly: true, eqeqeq: true,
    freeze: true, latedef: true, noarg: true, nonew: true, quotmark: double, undef: true,
    unused: true, strict: true, asi: false, boss: false, evil: false, expr: false,
    funcscope: false*/

var fluid = fluid || require("infusion"),
    flock = fluid.registerNamespace("flock");

(function () {

    "use strict";

    fluid.registerNamespace("flock.midi");

    flock.midi.requestAccess = function (sysex, onAccessGranted, onError) {
        if (!navigator.requestMIDIAccess) {
            var msg = "The Web MIDI API is not available. You may need to enable it in your browser's settings.";
            fluid.log(fluid.logLevel.WARN, msg);
            onError(msg);
            return;
        }

        var p = navigator.requestMIDIAccess({
            sysex: sysex
        });

        p.then(onAccessGranted, onError);
    };

    flock.midi.getPorts = function (access) {
        var ports = {},
            portCollector = typeof access.inputs === "function" ?
                flock.midi.collectPortsLegacy : flock.midi.collectPorts;

        portCollector("inputs", access, ports);
        portCollector("outputs", access, ports);

        return ports;
    };

    flock.midi.requestPorts = function (success, error) {
        function wrappedSuccess (access) {
            var ports = flock.midi.getPorts(access);
            success(ports);
        }

        flock.midi.requestAccess(false, wrappedSuccess, error);
    };

    flock.midi.createPortViews = function (portsArray) {
        return fluid.transform(portsArray, function (port) {
            return {
                id: port.id,
                name: port.name,
                manufacturer: port.manufacturer,
                state: port.state,
                connection: port.connection
            };
        });
    };

    flock.midi.prettyPrintPorts = function (ports) {
        return fluid.prettyPrintJSON({
            inputs: flock.midi.createPortViews(ports.inputs),
            outputs: flock.midi.createPortViews(ports.outputs)
        });
    };

    flock.midi.logPorts = function () {
        function success (ports) {
            var printed = flock.midi.prettyPrintPorts(ports);
            console.log(printed);
        }

        function error (err) {
            console.log(err);
        }

        flock.midi.requestPorts(success, error);
    };

    flock.midi.collectPorts = function (type, access, ports) {
        var portsForType = ports[type] = ports[type] || [],
            iterator = access[type].values();

        // TODO: Switch to ES6 for..of syntax when it's safe to do so
        // across all supported Flocking environments
        // (i.e. when Node.js and eventually IE support it).
        var next = iterator.next();
        while (!next.done) {
            portsForType.push(next.value);
            next = iterator.next();
        }

        return ports;
    };

    // TODO: Remove this when the new Web MIDI API makes it
    // into the Chrome release channel.
    flock.midi.collectPortsLegacy = function (type, access, ports) {
        if (access[type]) {
            ports[type] = access[type]();
        }

        return ports;
    };

    flock.midi.read = function (data) {
        var status = data[0],
            type = status >> 4,
            chan = status & 0xf,
            fn;

        switch (type) {
            case 8:
                fn = flock.midi.read.noteOff;
                break;
            case 9:
                fn = data[2] > 0 ? flock.midi.read.noteOn : flock.midi.read.noteOff;
                break;
            case 10:
                fn = flock.midi.read.polyAftertouch;
                break;
            case 11:
                fn = flock.midi.read.controlChange;
                break;
            case 12:
                fn = flock.midi.read.programChange;
                break;
            case 13:
                fn = flock.midi.read.channelAftertouch;
                break;
            case 14:
                fn = flock.midi.read.pitchbend;
                break;
            case 15:
                fn = flock.midi.read.sysex;
                break;
            default:
                throw new Error("Recieved an unrecognized MIDI message: " + data);
        }

        return fn(chan, data);
    };

    flock.midi.read.note = function (type, chan, data) {
        return {
            type: type,
            chan: chan,
            note: data[1],
            velocity: data[2]
        };
    };

    flock.midi.read.noteOn = function (chan, data) {
        return flock.midi.read.note("noteOn", chan, data);
    };

    flock.midi.read.noteOff = function (chan, data) {
        return flock.midi.read.note("noteOff", chan, data);
    };

    flock.midi.read.polyAftertouch = function (chan, data) {
        return {
            type: "aftertouch",
            chan: chan,
            note: data[1],
            pressure: data[2]
        };
    };

    flock.midi.read.controlChange = function (chan, data) {
        return {
            type: "control",
            chan: chan,
            number: data[1],
            value: data[2]
        };
    };

    flock.midi.read.programChange = function (chan, data) {
        return {
            type: "program",
            chan: chan,
            program: data[1]
        };
    };

    flock.midi.read.channelAftertouch = function (chan, data) {
        return {
            type: "aftertouch",
            chan: chan,
            pressure: data[1]
        };
    };

    flock.midi.read.pitchbend = function (chan, data) {
        return {
            type: "pitchbend",
            chan: chan,
            value: (data[1] << 7) | data[2]
        };
    };

    flock.midi.read.sysex = function (chan, data) {
        return {
            type: "system",
            chan: chan,
            data: data.subarray(1)
        };
    };


    /**
     * Represents the overall Web MIDI system,
     * including references to all the available MIDI ports
     * and the MIDIAccess object.
     */
    fluid.defaults("flock.midi.system", {
        gradeNames: ["fluid.eventedComponent", "autoInit"],

        sysex: false,

        members: {
            access: undefined,
            ports: undefined
        },

        invokers: {
            requestAccess: {
                funcName: "flock.midi.requestAccess",
                args: [
                    "{that}.options.sysex",
                    "{that}.events.onAccessGranted.fire",
                    "{that}.events.onAccessError.fire"
                ]
            },

            refreshPorts: {
                funcName: "flock.midi.system.refreshPorts",
                args: ["{that}", "{that}.access"]
            }
        },

        events: {
            onAccessGranted: null,
            onAccessError: null,
            onReady: null
        },

        listeners: {
            onCreate: {
                func: "{that}.requestAccess"
            },

            onAccessGranted: [
                {
                    funcName: "flock.midi.system.setAccess",
                    args: ["{that}", "{arguments}.0"]
                },
                {
                    func: "{that}.refreshPorts"
                },
                {
                    func: "{that}.events.onReady.fire",
                    args: "{that}.ports"
                }
            ],

            onAccessError: {
                funcName: "fluid.log",
                args: [fluid.logLevel.WARN, "MIDI Access Error: ", "{arguments}.0"]
            }
        }
    });

    flock.midi.system.setAccess = function (that, access) {
        that.access = access;
    };

    flock.midi.system.refreshPorts = function (that, access) {
        that.ports = flock.midi.getPorts(access);
    };


    /*
     * A MIDI Connection represents a connection between an arbitrary set of
     * input and output ports across one or more MIDI devices connected to the system.
     */
    // TODO: Handle port disconnection events.
    fluid.defaults("flock.midi.connection", {
        gradeNames: ["fluid.eventedComponent", "autoInit"],

        openImmediately: false,

        sysex: false,

        distributeOptions: {
            source: "{that}.options.sysex",
            target: "{that > system}.options.sysex"
        },

        // Supported PortSpec formats:
        //  - Number: the index of the input and output port to use (this is the default)
        //  - { manufacturer: "akai", name: "LPD8"}
        //  - { input: Number, output: Number}
        //  - { input: { manufacturer: "akai", name: "LPD8"}, output: {manufacturer: "korg", name: "output"}}
        ports: 0,

        invokers: {
            send: {
                func: "{that}.events.onSendMessage.fire"
            },

            open: {
                funcName: "flock.midi.connection.bind",
                args: [
                    "{system}.ports",
                    "{that}.options.ports",
                    "{that}.events.onReady.fire",
                    "{that}.events.raw.fire",
                    "{that}.events.onSendMessage"
                ]
            },

            close: {
                funcName: "flock.midi.connection.close",
                args: [
                    "{system}.ports",
                    "{that}.events.raw.fire"
                ]
            }
        },

        components: {
            system: {
                type: "flock.midi.system",
                options: {
                    events: {
                        onReady: "{connection}.events.onPortsAvailable"
                    }
                }
            }
        },

        events: {
            onPortsAvailable: null, //"{system}.events.onReady",
            onReady: null,
            onError: null,
            onSendMessage: null,

            raw: null,
            message: null,
            note: null,
            noteOn: null,
            noteOff: null,
            control: null,
            program: null,
            aftertouch: null,
            pitchbend: null
        },

        listeners: {
            onPortsAvailable: {
                funcName: "flock.midi.connection.autoOpen",
                args: [
                    "{connection}.options.openImmediately", "{connection}.open"
                ]
            },

            onError: {
                funcName: "fluid.log",
                args: [fluid.logLevel.WARN, "{arguments}.0"]
            },

            raw: {
                funcName: "flock.midi.connection.fireEvent",
                args: ["{arguments}.0", "{that}.events"]
            }
        }
    });

    flock.midi.connection.autoOpen = function (openImmediately, openFn) {
        if (openImmediately) {
            openFn();
        }
    };

    flock.midi.findPorts = function (ports, portSpecs) {
        portSpecs = fluid.makeArray(portSpecs);

        var matches = [];

        fluid.each(portSpecs, function (portSpec) {
            var portFinder = flock.midi.findPorts.portFinder(portSpec),
                matchesForSpec = portFinder(ports);

            matches = matches.concat(matchesForSpec);
        });

        return matches;
    };

    flock.midi.findPorts.portFinder = function (portSpec) {
        if (typeof portSpec === "number") {
            return flock.midi.findPorts.byIndex(portSpec);
        }

        if (typeof portSpec === "string") {
            portSpec = {
                name: portSpec
            };
        }

        if (portSpec.id) {
            return function (ports) {
                ports.find(flock.midi.findPorts.idMatcher(portSpec.id));
            };
        }

        var matcher = portSpec.manufacturer && portSpec.name ?
            flock.midi.findPorts.bothMatcher(portSpec.manufacturer, portSpec.name) :
            portSpec.manufacturer ? flock.midi.findPorts.manufacturerMatcher(portSpec.manufacturer) :
            flock.midi.findPorts.nameMatcher(portSpec.name);

        return function (ports) {
            return ports.filter(matcher);
        };
    };

    flock.midi.findPorts.byIndex = function (idx) {
        return function (ports) {
            var port = ports[idx];
            return port ? [port] : [];
        };
    };

    flock.midi.findPorts.lowerCaseContainsMatcher = function (matchSpec) {
        return function (obj) {
            var isMatch;
            for (var prop in matchSpec) {
                var objVal = obj[prop];
                var matchVal = matchSpec[prop];

                isMatch = (matchVal === "*") ? true :
                    objVal && (objVal.toLowerCase().indexOf(matchVal.toLowerCase()) > -1);

                if (!isMatch) {
                    break;
                }
            }

            return isMatch;
        };
    };

    flock.midi.findPorts.idMatcher = function (id) {
        return function (port) {
            return port.id === id;
        };
    };

    flock.midi.findPorts.bothMatcher = function (manu, name) {
        return flock.midi.findPorts.lowerCaseContainsMatcher({
            manufacturer: manu,
            name: name
        });
    };

    flock.midi.findPorts.manufacturerMatcher = function (manu) {
        return flock.midi.findPorts.lowerCaseContainsMatcher({
            manufacturer: manu
        });
    };

    flock.midi.findPorts.nameMatcher = function (name) {
        return flock.midi.findPorts.lowerCaseContainsMatcher({
            name: name
        });
    };

    flock.midi.findPorts.eachPortOfType = function (port, type, fn) {
        var ports = fluid.makeArray(port);
        fluid.each(ports, function (port) {
            if (port.type === type) {
                fn(port);
            }
        });
    };

    flock.midi.connection.openPort = function (port, openPromises) {
        // Remove this conditional when Chrome 43 has been released.
        if (port.open) {
            var p = port.open();
            openPromises.push(p);
        }

        return openPromises;
    };

    flock.midi.connection.listen = function (port, onRaw, openPromises) {
        flock.midi.findPorts.eachPortOfType(port, "input", function (port) {
            flock.midi.connection.openPort(port, openPromises);
            port.addEventListener("midimessage", onRaw, false);
        });

        return openPromises;
    };

    flock.midi.connection.stopListening = function (port, onRaw) {
        flock.midi.findPorts.eachPortOfType(port, "input", function (port) {
            port.close();
            port.removeEventListener("midimessage", onRaw, false);
        });
    };

    flock.midi.connection.bindSender = function (port, onSendMessage, openPromises) {
        var ports = fluid.makeArray(port);

        fluid.each(ports, function (port) {
            flock.midi.connection.openPort(port, openPromises);
            onSendMessage.addListener(port.send.bind(port));
        });

        return openPromises;
    };

    flock.midi.connection.fireReady = function (openPromises, onReady) {
        if (!openPromises || openPromises.length < 1) {
            return;
        }

        Promise.all(openPromises).then(onReady);
    };

    flock.midi.connection.bind = function (ports, portSpec, onReady, onRaw, onSendMessage) {
        portSpec = flock.midi.connection.expandPortSpec(portSpec);

        var input = flock.midi.findPorts(ports.inputs, portSpec.input),
            output = flock.midi.findPorts(ports.outputs, portSpec.output),
            openPromises = [];

        if (input && input.length > 0) {
            flock.midi.connection.listen(input, onRaw, openPromises);
        } else if (portSpec.input !== undefined) {
            flock.midi.connection.logNoMatchedPorts("input", portSpec);
        }

        if (output && output.length > 0) {
            flock.midi.connection.bindSender(output, onSendMessage, openPromises);
        } else if (portSpec.output !== undefined) {
            flock.midi.connection.logNoMatchedPorts("output", portSpec);
        }

        flock.midi.connection.fireReady(openPromises, onReady);
    };

    flock.midi.connection.close = function (ports, onRaw) {
        flock.midi.connection.stopListening(ports.inputs, onRaw);
        // TODO: Come up with some scheme for unbinding port senders
        // since they use Function.bind().
    };

    flock.midi.connection.logNoMatchedPorts = function (type, portSpec) {
        fluid.log(fluid.logLevel.WARN,
            "No matching " + type + " ports were found for port specification: ", portSpec[type]);
    };

    flock.midi.connection.expandPortSpec = function (portSpec) {
        if (portSpec.input !== undefined || portSpec.output !== undefined) {
            return portSpec;
        }

        var expanded = {
            input: {},
            output: {}
        };

        if (typeof portSpec === "number") {
            expanded.input = expanded.output = portSpec;
        } else {
            flock.midi.connection.expandPortSpecProperty("manufacturer", portSpec, expanded);
            flock.midi.connection.expandPortSpecProperty("name", portSpec, expanded);
        }

        return expanded;
    };

    flock.midi.connection.expandPortSpecProperty = function (propName, portSpec, expanded) {
        expanded.input[propName] = expanded.output[propName] = portSpec[propName];
        return expanded;
    };

    flock.midi.connection.fireEvent = function (midiEvent, events) {
        var model = flock.midi.read(midiEvent.data),
            eventForType = model.type ? events[model.type] : undefined;

        events.message.fire(model);

        // TODO: Remove this special-casing of noteOn/noteOff events into note events.
        if (model.type === "noteOn" || model.type === "noteOff") {
            events.note.fire(model);
        }

        if (eventForType) {
            eventForType.fire(model);
        }
    };

}());
;
    window.fluid = fluid;

    return flock;
}));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"infusion":"/Users/avojeez0/Sites/doomsynth/node_modules/flocking/node_modules/infusion/src/module/fluid.js","jquery":"/Users/avojeez0/Sites/doomsynth/node_modules/jquery/dist/jquery.js"}],"/Users/avojeez0/Sites/doomsynth/node_modules/flocking/node_modules/infusion/node_modules/resolve/index.js":[function(require,module,exports){
var core = require('./lib/core');
exports = module.exports = require('./lib/async');
exports.core = core;
exports.isCore = function (x) { return core[x] };
exports.sync = require('./lib/sync');

},{"./lib/async":"/Users/avojeez0/Sites/doomsynth/node_modules/flocking/node_modules/infusion/node_modules/resolve/lib/async.js","./lib/core":"/Users/avojeez0/Sites/doomsynth/node_modules/flocking/node_modules/infusion/node_modules/resolve/lib/core.js","./lib/sync":"/Users/avojeez0/Sites/doomsynth/node_modules/flocking/node_modules/infusion/node_modules/resolve/lib/sync.js"}],"/Users/avojeez0/Sites/doomsynth/node_modules/flocking/node_modules/infusion/node_modules/resolve/lib/async.js":[function(require,module,exports){
(function (process){
var core = require('./core');
var fs = require('fs');
var path = require('path');
var caller = require('./caller.js');
var nodeModulesPaths = require('./node-modules-paths.js');
var splitRe = process.platform === 'win32' ? /[\/\\]/ : /\//;

module.exports = function resolve (x, opts, cb) {
    if (typeof opts === 'function') {
        cb = opts;
        opts = {};
    }
    if (!opts) opts = {};
    if (typeof x !== 'string') {
        return process.nextTick(function () {
            cb(new Error('path must be a string'));
        });
    }
    
    var isFile = opts.isFile || function (file, cb) {
        fs.stat(file, function (err, stat) {
            if (err && err.code === 'ENOENT') cb(null, false)
            else if (err) cb(err)
            else cb(null, stat.isFile() || stat.isFIFO())
        });
    };
    var readFile = opts.readFile || fs.readFile;
    
    var extensions = opts.extensions || [ '.js' ];
    var y = opts.basedir || path.dirname(caller());
    
    opts.paths = opts.paths || [];
    
    if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[\\\/])/.test(x)) {
        var res = path.resolve(y, x);
        if (x === '..') res += '/';
        if (/\/$/.test(x) && res === y) {
            loadAsDirectory(res, opts.package, onfile);
        }
        else loadAsFile(res, opts.package, onfile);
    }
    else loadNodeModules(x, y, function (err, n, pkg) {
        if (err) cb(err)
        else if (n) cb(null, n, pkg)
        else if (core[x]) return cb(null, x);
        else cb(new Error("Cannot find module '" + x + "' from '" + y + "'"))
    });
    
    function onfile (err, m, pkg) {
        if (err) cb(err)
        else if (m) cb(null, m, pkg)
        else loadAsDirectory(res, function (err, d, pkg) {
            if (err) cb(err)
            else if (d) cb(null, d, pkg)
            else cb(new Error("Cannot find module '" + x + "' from '" + y + "'"))
        })
    }
    
    function loadAsFile (x, pkg, cb) {
        if (typeof pkg === 'function') {
            cb = pkg;
            pkg = undefined;
        }
        
        var exts = [''].concat(extensions);
        load(exts, x, pkg)
		
		function load (exts, x, pkg) {
            if (exts.length === 0) return cb(null, undefined, pkg);
            var file = x + exts[0];
            
            if (pkg) onpkg(null, pkg)
            else loadpkg(path.dirname(file), onpkg);
            
            function onpkg (err, pkg_, dir) {
                pkg = pkg_;
                if (err) return cb(err)
                if (dir && pkg && opts.pathFilter) {
                    var rfile = path.relative(dir, file);
                    var rel = rfile.slice(0, rfile.length - exts[0].length);
                    var r = opts.pathFilter(pkg, x, rel);
                    if (r) return load(
                        [''].concat(extensions.slice()),
                        path.resolve(dir, r),
                        pkg
                    );
                }
                isFile(file, onex);
            }
            function onex (err, ex) {
                if (err) cb(err)
                else if (!ex) load(exts.slice(1), x, pkg)
                else cb(null, file, pkg)
            }
        }
    }
    
    function loadpkg (dir, cb) {
        if (dir === '' || dir === '/') return cb(null);
        if (process.platform === 'win32' && /^\w:[\\\/]*$/.test(dir)) {
            return cb(null);
        }
        if (/[\\\/]node_modules[\\\/]*$/.test(dir)) return cb(null);
        
        var pkgfile = path.join(dir, 'package.json');
        isFile(pkgfile, function (err, ex) {
            // on err, ex is false
            if (!ex) return loadpkg(
                path.dirname(dir), cb
            );
            
            readFile(pkgfile, function (err, body) {
                if (err) cb(err);
                try { var pkg = JSON.parse(body) }
                catch (err) {}
                
                if (pkg && opts.packageFilter) {
                    pkg = opts.packageFilter(pkg, pkgfile);
                }
                cb(null, pkg, dir);
            });
        });
    }
    
    function loadAsDirectory (x, fpkg, cb) {
        if (typeof fpkg === 'function') {
            cb = fpkg;
            fpkg = opts.package;
        }
        
        var pkgfile = path.join(x, '/package.json');
        isFile(pkgfile, function (err, ex) {
            if (err) return cb(err);
            if (!ex) return loadAsFile(path.join(x, '/index'), fpkg, cb);
            
            readFile(pkgfile, function (err, body) {
                if (err) return cb(err);
                try {
                    var pkg = JSON.parse(body);
                }
                catch (err) {}
                
                if (opts.packageFilter) {
                    pkg = opts.packageFilter(pkg, pkgfile);
                }
                
                if (pkg.main) {
                    if (pkg.main === '.' || pkg.main === './'){
                        pkg.main = 'index'
                    }
                    loadAsFile(path.resolve(x, pkg.main), pkg, function (err, m, pkg) {
                        if (err) return cb(err);
                        if (m) return cb(null, m, pkg);
                        if (!pkg) return loadAsFile(path.join(x, '/index'), pkg, cb);

                        var dir = path.resolve(x, pkg.main);
                        loadAsDirectory(dir, pkg, function (err, n, pkg) {
                            if (err) return cb(err);
                            if (n) return cb(null, n, pkg);
                            loadAsFile(path.join(x, '/index'), pkg, cb);
                        });
                    });
                    return;
                }
                
                loadAsFile(path.join(x, '/index'), pkg, cb);
            });
        });
    }
    
    function loadNodeModules (x, start, cb) {
        (function process (dirs) {
            if (dirs.length === 0) return cb(null, undefined);
            var dir = dirs[0];
            
            var file = path.join(dir, '/', x);
            loadAsFile(file, undefined, onfile);
            
            function onfile (err, m, pkg) {
                if (err) return cb(err);
                if (m) return cb(null, m, pkg);
                loadAsDirectory(path.join(dir, '/', x), undefined, ondir);
            }
            
            function ondir (err, n, pkg) {
                if (err) return cb(err);
                if (n) return cb(null, n, pkg);
                process(dirs.slice(1));
            }
        })(nodeModulesPaths(start, opts));
    }
};

}).call(this,require('_process'))

},{"./caller.js":"/Users/avojeez0/Sites/doomsynth/node_modules/flocking/node_modules/infusion/node_modules/resolve/lib/caller.js","./core":"/Users/avojeez0/Sites/doomsynth/node_modules/flocking/node_modules/infusion/node_modules/resolve/lib/core.js","./node-modules-paths.js":"/Users/avojeez0/Sites/doomsynth/node_modules/flocking/node_modules/infusion/node_modules/resolve/lib/node-modules-paths.js","_process":"/Users/avojeez0/Sites/doomsynth/node_modules/browserify/node_modules/process/browser.js","fs":"/Users/avojeez0/Sites/doomsynth/node_modules/browserify/lib/_empty.js","path":"/Users/avojeez0/Sites/doomsynth/node_modules/browserify/node_modules/path-browserify/index.js"}],"/Users/avojeez0/Sites/doomsynth/node_modules/flocking/node_modules/infusion/node_modules/resolve/lib/caller.js":[function(require,module,exports){
module.exports = function () {
    // see https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi
    var origPrepareStackTrace = Error.prepareStackTrace;
    Error.prepareStackTrace = function (_, stack) { return stack };
    var stack = (new Error()).stack;
    Error.prepareStackTrace = origPrepareStackTrace;
    return stack[2].getFileName();
};

},{}],"/Users/avojeez0/Sites/doomsynth/node_modules/flocking/node_modules/infusion/node_modules/resolve/lib/core.json":[function(require,module,exports){
module.exports=[
    "assert",
    "buffer_ieee754",
    "buffer",
    "child_process",
    "cluster",
    "console",
    "constants",
    "crypto",
    "_debugger",
    "dgram",
    "dns",
    "domain",
    "events",
    "freelist",
    "fs",
    "http",
    "https",
    "_linklist",
    "module",
    "net",
    "os",
    "path",
    "punycode",
    "querystring",
    "readline",
    "repl",
    "stream",
    "string_decoder",
    "sys",
    "timers",
    "tls",
    "tty",
    "url",
    "util",
    "vm",
    "zlib"
]

},{}],"/Users/avojeez0/Sites/doomsynth/node_modules/flocking/node_modules/infusion/node_modules/resolve/lib/core.js":[function(require,module,exports){
module.exports = require('./core.json').reduce(function (acc, x) {
    acc[x] = true;
    return acc;
}, {});

},{"./core.json":"/Users/avojeez0/Sites/doomsynth/node_modules/flocking/node_modules/infusion/node_modules/resolve/lib/core.json"}],"/Users/avojeez0/Sites/doomsynth/node_modules/flocking/node_modules/infusion/node_modules/resolve/lib/node-modules-paths.js":[function(require,module,exports){
(function (process){
var path = require('path');

module.exports = function (start, opts) {
    var modules = opts.moduleDirectory
        ? [].concat(opts.moduleDirectory)
        : ['node_modules']
    ;
    var prefix = '/';
    if (/^([A-Za-z]:)/.test(start)) {
        prefix = '';
    } else if (/^\\\\/.test(start)) {
        prefix = '\\\\';
    }
    var splitRe = process.platform === 'win32' ? /[\/\\]/ : /\/+/;

    // ensure that `start` is an absolute path at this point,
    // resolving againt the process' current working directory
    start = path.resolve(start);

    var parts = start.split(splitRe);

    var dirs = [];
    for (var i = parts.length - 1; i >= 0; i--) {
        if (modules.indexOf(parts[i]) !== -1) continue;
        dirs = dirs.concat(modules.map(function(module_dir) {
            return prefix + path.join(
                path.join.apply(path, parts.slice(0, i + 1)),
                module_dir
            );
        }));
    }
    if (process.platform === 'win32'){
        dirs[dirs.length-1] = dirs[dirs.length-1].replace(":", ":\\");
    }
    return dirs.concat(opts.paths);
}

}).call(this,require('_process'))

},{"_process":"/Users/avojeez0/Sites/doomsynth/node_modules/browserify/node_modules/process/browser.js","path":"/Users/avojeez0/Sites/doomsynth/node_modules/browserify/node_modules/path-browserify/index.js"}],"/Users/avojeez0/Sites/doomsynth/node_modules/flocking/node_modules/infusion/node_modules/resolve/lib/sync.js":[function(require,module,exports){
var core = require('./core');
var fs = require('fs');
var path = require('path');
var caller = require('./caller.js');
var nodeModulesPaths = require('./node-modules-paths.js');

module.exports = function (x, opts) {
    if (!opts) opts = {};
    var isFile = opts.isFile || function (file) {
        try { var stat = fs.statSync(file) }
        catch (err) { if (err && err.code === 'ENOENT') return false }
        return stat.isFile() || stat.isFIFO();
    };
    var readFileSync = opts.readFileSync || fs.readFileSync;
    
    var extensions = opts.extensions || [ '.js' ];
    var y = opts.basedir || path.dirname(caller());

    opts.paths = opts.paths || [];

    if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[\\\/])/.test(x)) {
        var res = path.resolve(y, x);
        if (x === '..') res += '/';
        var m = loadAsFileSync(res) || loadAsDirectorySync(res);
        if (m) return m;
    } else {
        var n = loadNodeModulesSync(x, y);
        if (n) return n;
    }
    
    if (core[x]) return x;
    
    throw new Error("Cannot find module '" + x + "' from '" + y + "'");
    
    function loadAsFileSync (x) {
        if (isFile(x)) {
            return x;
        }
        
        for (var i = 0; i < extensions.length; i++) {
            var file = x + extensions[i];
            if (isFile(file)) {
                return file;
            }
        }
    }
    
    function loadAsDirectorySync (x) {
        var pkgfile = path.join(x, '/package.json');
        if (isFile(pkgfile)) {
            var body = readFileSync(pkgfile, 'utf8');
            try {
                var pkg = JSON.parse(body);
                if (opts.packageFilter) {
                    pkg = opts.packageFilter(pkg, x);
                }
                
                if (pkg.main) {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                    var n = loadAsDirectorySync(path.resolve(x, pkg.main));
                    if (n) return n;
                }
            }
            catch (err) {}
        }
        
        return loadAsFileSync(path.join( x, '/index'));
    }
    
    function loadNodeModulesSync (x, start) {
        var dirs = nodeModulesPaths(start, opts);
        for (var i = 0; i < dirs.length; i++) {
            var dir = dirs[i];
            var m = loadAsFileSync(path.join( dir, '/', x));
            if (m) return m;
            var n = loadAsDirectorySync(path.join( dir, '/', x ));
            if (n) return n;
        }
    }
};

},{"./caller.js":"/Users/avojeez0/Sites/doomsynth/node_modules/flocking/node_modules/infusion/node_modules/resolve/lib/caller.js","./core":"/Users/avojeez0/Sites/doomsynth/node_modules/flocking/node_modules/infusion/node_modules/resolve/lib/core.js","./node-modules-paths.js":"/Users/avojeez0/Sites/doomsynth/node_modules/flocking/node_modules/infusion/node_modules/resolve/lib/node-modules-paths.js","fs":"/Users/avojeez0/Sites/doomsynth/node_modules/browserify/lib/_empty.js","path":"/Users/avojeez0/Sites/doomsynth/node_modules/browserify/node_modules/path-browserify/index.js"}],"/Users/avojeez0/Sites/doomsynth/node_modules/flocking/node_modules/infusion/src/module/fluid.js":[function(require,module,exports){
(function (process,global,__dirname){
/*
Copyright 2012 OCAD University, Antranig Basman

Licensed under the Educational Community License (ECL), Version 2.0 or the New
BSD license. You may not use this file except in compliance with one these
Licenses.

You may obtain a copy of the ECL 2.0 License and BSD License at
https://github.com/fluid-project/infusion/raw/master/Infusion-LICENSE.txt
*/
/* jshint node: true */
/* global global */

(function () {
    "use strict";

    var fs = require("fs"),
        path = require("path"),
        vm = require("vm"),
        resolve = require("resolve");

    var moduleBaseDir = path.resolve(__dirname, "../..");

    /** Implementation for FLUID-5822 to avoid requirement for dedupe-infusion **/

    var upInfusion;

    try {
        var upPath = path.resolve(moduleBaseDir, "../../..");
        var upInfusionPath = resolve.sync("infusion", {
            basedir: upPath
        });
        upInfusion = require(upInfusionPath);
    } catch (e) {}

    if (upInfusion) {
        upInfusion.log("Resolved infusion from path " + __dirname + " to " + upInfusion.module.modules.infusion.baseDir);
        module.exports = upInfusion;
        return;
    } else {
        console.log("Infusion at path " + moduleBaseDir + " is at top level ");
    }

    var getBaseDir = function () {
        return __dirname;
    };

    var buildPath = function (pathSeg) {
        return path.join(getBaseDir(), pathSeg);
    };
    
    // Report of experiments performed with node.js globals done on 1/9/14 - what we might like to write at this point is 
    // fluid: {global: GLOBAL}; - this "nearly" works but unfortunately the process of transporting the "pan-global" object
    // across the sandbox initialization boundary ends up shredding it. We end up with a situation where in this file, 
    // fluid.global.fluid === fluid - but from within Fluid.js, fluid.global.fluid === undefined. node.js docs on sandboxing 
    // do report that the results can be fragile and version unstable. However, we need to continue with sandboxing because of
    // the delicate expectations, for example, on visible globals caused by QUnit's sniffing code.  
    // Experiment performed with node.js 0.8.6 on Windows. 
    // We achieve a lot of what we might want via "global.fluid = fluid" below. However, other top-level names constructed 
    // via fluid.registerNamespace will not be exported up to the pan-global. 

    var context = vm.createContext({
        console: console,
        setTimeout: setTimeout,
        clearTimeout: clearTimeout,
        setInterval: setInterval,
        clearInterval: clearInterval
    });

    context.window = context;

    /** Load a standard, non-require-aware Fluid framework file into the Fluid context, given a filename
     * relative to this directory (src/module) **/

    var loadInContext = function (path) {
        var fullpath = buildPath(path);
        var data = fs.readFileSync(fullpath);
        vm.runInContext(data, context, fullpath);
    };

    var loadIncludes = function (path) {
        var includes = require(buildPath(path));
        for (var i = 0; i < includes.length; ++i) {
            loadInContext(includes[i]);
        }
    };

    loadIncludes("includes.json");

    var fluid = context.fluid;
    // FLUID-4913: QUnit calls window.addEventListener on load. We need to add
    // it to the context it will be loaded in.
    context.addEventListener = fluid.identity;
    
    // As well as for efficiency, it's useful to customise this because an uncaught
    // exception fired from a a setTimeout handler in node.js will prevent any 
    // further from being serviced, which impedes testing these handlers
    fluid.invokeLater = function (func) {
        process.nextTick(func);
    };
    
    fluid.logObjectRenderChars = 1024;
    
    fluid.onUncaughtException = fluid.makeEventFirer({
        name: "Global uncaught exception handler"
    });
    
    // This registry of priorities will be removed once the implementation of FLUID-5506 is complete
    fluid.handlerPriorities = {
        uncaughtException: {
            log: 100, // high priority - do all logging first
            fail: "last"
        }
    };
    
    process.on("uncaughtException", function onUncaughtException (err) {
        fluid.onUncaughtException.fire(err);
    });
    
    fluid.logUncaughtException = function (err) {
        var message = "FATAL ERROR: Uncaught exception: " + err.message;
        fluid.log(fluid.logLevel.FATAL, message);
        console.log(err.stack);
    };
    
    fluid.onUncaughtException.addListener(fluid.logUncaughtException, "log", null,
        fluid.handlerPriorities.uncaughtException.log);
      
    // Convert an argument intended for console.log in the node environment to a readable form (the
    // default action of util.inspect censors at depth 1)
    fluid.renderLoggingArg = function (arg) {
        var togo = arg && fluid.isPrimitive(arg) ? arg : fluid.prettyPrintJSON(arg);
        if (typeof(togo) === "string" && togo.length > fluid.logObjectRenderChars) {
            togo = togo.substring(0, fluid.logObjectRenderChars) + " .... [output suppressed at " + fluid.logObjectRenderChars + " chars - for more output, increase fluid.logObjectRenderChars]";
        }
        return togo;
    };
    
    // Monkey-patch the built-in fluid.doLog utility to improve its behaviour within node.js - see FLUID-5475
    fluid.doLog = function (args) {
        args = fluid.transform(args, fluid.renderLoggingArg);
        console.log(args.join(""));
    };

    fluid.loadInContext = loadInContext;
    fluid.loadIncludes = loadIncludes;

    /** Load a node-aware JavaScript file using either a supplied or the native
      * Fluid require function. The module name may start with a module reference
      * of the form ${module-name} to indicate a base reference into an already
      * loaded module that was previously registered using fluid.module.register.
      * If the <code>namespace</code> argument is supplied, the module's export
      * object will be written to that path in the global Fluid namespace */

    fluid.require = function (moduleName, foreignRequire, namespace) {
        foreignRequire = foreignRequire || require;
        var resolved = fluid.module.resolvePath(moduleName);
        var module = foreignRequire(resolved);
        if (namespace) {
            fluid.setGlobalValue(namespace, module);
        }
        return module;
    };

    /** Produce a loader object exposing a "require" object which will automatically
     * prefix the supplied directory name to any requested modules before forwarding
     * the operation to fluid.require
     */

    fluid.getLoader = function (dirName, foreignRequire) {
        return {
            require: function (moduleName, namespace) {
                if (moduleName.indexOf("/") > -1) {
                    moduleName = dirName + "/" + moduleName;
                }
                return fluid.require(moduleName, foreignRequire, namespace);
            }
        };
    };

    /**
     * Set up testing environment with jqUnit and IoC Test Utils in node.
     * This function will load everything necessary for running node jqUnit.
     */
    fluid.loadTestingSupport = function () {
        fluid.loadIncludes("devIncludes.json");
    };
    
    if (global.fluid) {
        var oldPath = global.fluid.module.modules.infusion.baseDir;
        fluid.fail("Error loading infusion - infusion has already been loaded from the path \n\t" + path.resolve(oldPath) +
            "\n - please delete the duplicate copy which is found at \n\t" + path.resolve(__dirname) +
            "\n This can be done automatically by running the task \"grunt dedupe-infusion\"");
    }
    
    fluid.module.register("infusion", moduleBaseDir, require);
    
    // Export the fluid object into the pan-module node.js global object
    global.fluid = fluid;

    module.exports = fluid;

})();
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},"/node_modules/flocking/node_modules/infusion/src/module")

},{"_process":"/Users/avojeez0/Sites/doomsynth/node_modules/browserify/node_modules/process/browser.js","fs":"/Users/avojeez0/Sites/doomsynth/node_modules/browserify/lib/_empty.js","path":"/Users/avojeez0/Sites/doomsynth/node_modules/browserify/node_modules/path-browserify/index.js","resolve":"/Users/avojeez0/Sites/doomsynth/node_modules/flocking/node_modules/infusion/node_modules/resolve/index.js","vm":"/Users/avojeez0/Sites/doomsynth/node_modules/browserify/node_modules/vm-browserify/index.js"}],"/Users/avojeez0/Sites/doomsynth/node_modules/jquery/dist/jquery.js":[function(require,module,exports){
/*!
 * jQuery JavaScript Library v3.1.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2016-09-22T22:30Z
 */
( function( global, factory ) {

	"use strict";

	if ( typeof module === "object" && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var document = window.document;

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};



	function DOMEval( code, doc ) {
		doc = doc || document;

		var script = doc.createElement( "script" );

		script.text = code;
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.1.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android <=4.0 only
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = jQuery.isArray( copy ) ) ) ) {

					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray( src ) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject( src ) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isFunction: function( obj ) {
		return jQuery.type( obj ) === "function";
	},

	isArray: Array.isArray,

	isWindow: function( obj ) {
		return obj != null && obj === obj.window;
	},

	isNumeric: function( obj ) {

		// As of jQuery 3.0, isNumeric is limited to
		// strings and numbers (primitives or objects)
		// that can be coerced to finite numbers (gh-2662)
		var type = jQuery.type( obj );
		return ( type === "number" || type === "string" ) &&

			// parseFloat NaNs numeric-cast false positives ("")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			!isNaN( obj - parseFloat( obj ) );
	},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {

		/* eslint-disable no-unused-vars */
		// See https://github.com/eslint/eslint/issues/6125
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}

		// Support: Android <=2.3 only (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call( obj ) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		DOMEval( code );
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE <=9 - 11, Edge 12 - 13
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android <=4.0 only
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: Date.now,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.3
 * https://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-08-08
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	disabledAncestor = addCombinator(
		function( elem ) {
			return elem.disabled === true && ("form" in elem || "label" in elem);
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!compilerCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

				if ( nodeType !== 1 ) {
					newContext = context;
					newSelector = selector;

				// qSA looks outside Element context, which is not what we want
				// Thanks to Andrew Dupont for this workaround technique
				// Support: IE <=8
				// Exclude object elements
				} else if ( context.nodeName.toLowerCase() !== "object" ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rcssescape, fcssescape );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[i] = "#" + nid + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch ( qsaError ) {
					} finally {
						if ( nid === expando ) {
							context.removeAttribute( "id" );
						}
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement("fieldset");

	try {
		return !!fn( el );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}
		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
						disabledAncestor( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( preferredDoc !== document &&
		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( el ) {
		el.className = "i";
		return !el.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( el ) {
		el.appendChild( document.createComment("") );
		return !el.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID filter and find
	if ( support.getById ) {
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode("id");
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( (elem = elems[i++]) ) {
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( el ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll(":enabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll(":disabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( el ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		!compilerCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return (sel + "").replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( (oldCache = uniqueCache[ key ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( el ) {
	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( el ) {
	return el.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Simple selector that can be filtered directly, removing non-Elements
	if ( risSimple.test( qualifier ) ) {
		return jQuery.filter( qualifier, elements, not );
	}

	// Complex selector, compare the two sets, removing non-Elements
	qualifier = jQuery.filter( qualifier, elements );
	return jQuery.grep( elements, function( elem ) {
		return ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;
	} );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		return elem.contentDocument || jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( jQuery.isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && jQuery.isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Support: Android 4.0 only
			// Strict mode functions invoked without .call/.apply get global-object context
			resolve.call( undefined, value );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.call( undefined, value );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( jQuery.isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								jQuery.isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								jQuery.isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								jQuery.isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				jQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ jQuery.camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ jQuery.camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( jQuery.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( jQuery.camelCase );
			} else {
				key = jQuery.camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = jQuery.camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			jQuery.contains( elem.ownerDocument, elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};




function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted,
		scale = 1,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		do {

			// If previous iteration zeroed out, double until we get *something*.
			// Use string for doubling so we don't accidentally see scale as unchanged below
			scale = scale || ".5";

			// Adjust and apply
			initialInUnit = initialInUnit / scale;
			jQuery.style( elem, prop, initialInUnit + unit );

		// Update scale, tolerating zero or NaN from tween.cur()
		// Break the loop if scale is unchanged or perfect, or if we've just had enough.
		} while (
			scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
		);
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );

var rscriptType = ( /^$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE <=9 only
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE <=9 only
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && jQuery.nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, contains, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( jQuery.type( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		contains = jQuery.contains( elem.ownerDocument, elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( contains ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();
var documentElement = document.documentElement;



var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 only
// See #13393 for more info
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		// Make a writable jQuery.Event from the native event object
		var event = jQuery.event.fix( nativeEvent );

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: jQuery.isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {

			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {

			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	/* eslint-disable max-len */

	// See https://github.com/eslint/eslint/issues/3229
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

	/* eslint-enable */

	// Support: IE <=10 - 11, Edge 12 - 13
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

function manipulationTarget( elem, content ) {
	if ( jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return elem.getElementsByTagName( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );

	if ( match ) {
		elem.type = match[ 1 ];
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		isFunction = jQuery.isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( isFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( isFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl ) {
								jQuery._evalUrl( node.src );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rmargin = ( /^margin/ );

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		div.style.cssText =
			"box-sizing:border-box;" +
			"position:relative;display:block;" +
			"margin:auto;border:1px;padding:1px;" +
			"top:1%;width:50%";
		div.innerHTML = "";
		documentElement.appendChild( container );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = divStyle.marginLeft === "2px";
		boxSizingReliableVal = divStyle.width === "4px";

		// Support: Android 4.0 - 4.3 only
		// Some styles come back with percentage values, even though they shouldn't
		div.style.marginRight = "50%";
		pixelMarginRightVal = divStyle.marginRight === "4px";

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
		"padding:0;margin-top:1px;position:absolute";
	container.appendChild( div );

	jQuery.extend( support, {
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelMarginRight: function() {
			computeStyleTests();
			return pixelMarginRightVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		style = elem.style;

	computed = computed || getStyles( elem );

	// Support: IE <=9 only
	// getPropertyValue is only needed for .css('filter') (#12537)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style;

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in emptyStyle ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i,
		val = 0;

	// If we already have the right measurement, avoid augmentation
	if ( extra === ( isBorderBox ? "border" : "content" ) ) {
		i = 4;

	// Otherwise initialize for horizontal or vertical properties
	} else {
		i = name === "width" ? 1 : 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {

			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// At this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {

			// At this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// At this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var val,
		valueIsBorderBox = true,
		styles = getStyles( elem ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// Support: IE <=11 only
	// Running getBoundingClientRect on a disconnected node
	// in IE throws an error.
	if ( elem.getClientRects().length ) {
		val = elem.getBoundingClientRect()[ name ];
	}

	// Some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {

		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test( val ) ) {
			return val;
		}

		// Check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox &&
			( support.boxSizingReliable() || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// Use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		"float": "cssFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] ||
			( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			if ( type === "number" ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				style[ name ] = value;
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] ||
			( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}
		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, name, extra );
						} ) :
						getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = extra && getStyles( elem ),
				subtract = extra && augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				);

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ name ] = value;
				value = jQuery.css( elem, name );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 &&
				( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
					jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function raf() {
	if ( timerId ) {
		window.requestAnimationFrame( raf );
		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 13
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( jQuery.isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					jQuery.proxy( result.stop, result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	// Go to the end state if fx are off or if document is hidden
	if ( jQuery.fx.off || document.hidden ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	if ( timer() ) {
		jQuery.fx.start();
	} else {
		jQuery.timers.pop();
	}
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = window.requestAnimationFrame ?
			window.requestAnimationFrame( raf ) :
			window.setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	if ( window.cancelAnimationFrame ) {
		window.cancelAnimationFrame( timerId );
	} else {
		window.clearInterval( timerId );
	}

	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					jQuery.nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( typeof value === "string" && value ) {
			classes = value.match( rnothtmlwhite ) || [];

			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		if ( typeof value === "string" && value ) {
			classes = value.match( rnothtmlwhite ) || [];

			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( type === "string" ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = value.match( rnothtmlwhite ) || [];

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




support.focusin = "onfocusin" in window;


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = jQuery.now();

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = jQuery.isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( jQuery.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( jQuery.isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 13
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,
		"throws": true
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( jQuery.isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" ).prop( {
					charset: s.scriptCharset,
					src: s.url
				} ).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




/**
 * Gets a window from an element
 */
function getWindow( elem ) {
	return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
}

jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var docElem, win, rect, doc,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		rect = elem.getBoundingClientRect();

		// Make sure element is not hidden (display: none)
		if ( rect.width || rect.height ) {
			doc = elem.ownerDocument;
			win = getWindow( doc );
			docElem = doc.documentElement;

			return {
				top: rect.top + win.pageYOffset - docElem.clientTop,
				left: rect.left + win.pageXOffset - docElem.clientLeft
			};
		}

		// Return zeros for disconnected and hidden elements (gh-2310)
		return rect;
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
		// because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume getBoundingClientRect is there when computed position is fixed
			offset = elem.getBoundingClientRect();

		} else {

			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset = {
				top: parentOffset.top + jQuery.css( offsetParent[ 0 ], "borderTopWidth", true ),
				left: parentOffset.left + jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true )
			};
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	}
} );

jQuery.parseJSON = JSON.parse;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	} );
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}





return jQuery;
} );

},{}],"/Users/avojeez0/Sites/doomsynth/static/app.js":[function(require,module,exports){
var f = require('flocking/dist/flocking-no-jquery.js');
console.log(f);

},{"flocking/dist/flocking-no-jquery.js":"/Users/avojeez0/Sites/doomsynth/node_modules/flocking/dist/flocking-no-jquery.js"}]},{},["/Users/avojeez0/Sites/doomsynth/static/app.js"])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9saWIvX2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdm0tYnJvd3NlcmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy92bS1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9pbmRleG9mL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Zsb2NraW5nL2Rpc3QvZmxvY2tpbmctbm8tanF1ZXJ5LmpzIiwibm9kZV9tb2R1bGVzL2Zsb2NraW5nL25vZGVfbW9kdWxlcy9pbmZ1c2lvbi9ub2RlX21vZHVsZXMvcmVzb2x2ZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9mbG9ja2luZy9ub2RlX21vZHVsZXMvaW5mdXNpb24vbm9kZV9tb2R1bGVzL3Jlc29sdmUvbGliL2FzeW5jLmpzIiwibm9kZV9tb2R1bGVzL2Zsb2NraW5nL25vZGVfbW9kdWxlcy9pbmZ1c2lvbi9ub2RlX21vZHVsZXMvcmVzb2x2ZS9saWIvY2FsbGVyLmpzIiwibm9kZV9tb2R1bGVzL2Zsb2NraW5nL25vZGVfbW9kdWxlcy9pbmZ1c2lvbi9ub2RlX21vZHVsZXMvcmVzb2x2ZS9saWIvY29yZS5qc29uIiwibm9kZV9tb2R1bGVzL2Zsb2NraW5nL25vZGVfbW9kdWxlcy9pbmZ1c2lvbi9ub2RlX21vZHVsZXMvcmVzb2x2ZS9saWIvY29yZS5qcyIsIm5vZGVfbW9kdWxlcy9mbG9ja2luZy9ub2RlX21vZHVsZXMvaW5mdXNpb24vbm9kZV9tb2R1bGVzL3Jlc29sdmUvbGliL25vZGUtbW9kdWxlcy1wYXRocy5qcyIsIm5vZGVfbW9kdWxlcy9mbG9ja2luZy9ub2RlX21vZHVsZXMvaW5mdXNpb24vbm9kZV9tb2R1bGVzL3Jlc29sdmUvbGliL3N5bmMuanMiLCJub2RlX21vZHVsZXMvZmxvY2tpbmcvbm9kZV9tb2R1bGVzL2luZnVzaW9uL3NyYy9tb2R1bGUvZmx1aWQuanMiLCJub2RlX21vZHVsZXMvanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzIiwiL1VzZXJzL2F2b2plZXowL1NpdGVzL2Rvb21zeW50aC9zdGF0aWMvYXBwLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbmlyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzUrVEEsSUFBSSxDQUFDLEdBQUcsT0FBTyxDQUFDLHFDQUFxQyxDQUFDLENBQUM7QUFDdkQsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gcmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIGFycmF5IHdpdGggZGlyZWN0b3J5IG5hbWVzIHRoZXJlXG4vLyBtdXN0IGJlIG5vIHNsYXNoZXMsIGVtcHR5IGVsZW1lbnRzLCBvciBkZXZpY2UgbmFtZXMgKGM6XFwpIGluIHRoZSBhcnJheVxuLy8gKHNvIGFsc28gbm8gbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcyAtIGl0IGRvZXMgbm90IGRpc3Rpbmd1aXNoXG4vLyByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgcGF0aHMpXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheShwYXJ0cywgYWxsb3dBYm92ZVJvb3QpIHtcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGxhc3QgPSBwYXJ0c1tpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHBhcnRzLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG4vLyBTcGxpdCBhIGZpbGVuYW1lIGludG8gW3Jvb3QsIGRpciwgYmFzZW5hbWUsIGV4dF0sIHVuaXggdmVyc2lvblxuLy8gJ3Jvb3QnIGlzIGp1c3QgYSBzbGFzaCwgb3Igbm90aGluZy5cbnZhciBzcGxpdFBhdGhSZSA9XG4gICAgL14oXFwvP3wpKFtcXHNcXFNdKj8pKCg/OlxcLnsxLDJ9fFteXFwvXSs/fCkoXFwuW14uXFwvXSp8KSkoPzpbXFwvXSopJC87XG52YXIgc3BsaXRQYXRoID0gZnVuY3Rpb24oZmlsZW5hbWUpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aFJlLmV4ZWMoZmlsZW5hbWUpLnNsaWNlKDEpO1xufTtcblxuLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgIHZhciBwYXRoID0gKGkgPj0gMCkgPyBhcmd1bWVudHNbaV0gOiBwcm9jZXNzLmN3ZCgpO1xuXG4gICAgLy8gU2tpcCBlbXB0eSBhbmQgaW52YWxpZCBlbnRyaWVzXG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xufTtcblxuLy8gcGF0aC5ub3JtYWxpemUocGF0aClcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKSxcbiAgICAgIHRyYWlsaW5nU2xhc2ggPSBzdWJzdHIocGF0aCwgLTEpID09PSAnLyc7XG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoZmlsdGVyKHBhdGhzLCBmdW5jdGlvbihwLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLmpvaW4gbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9KS5qb2luKCcvJykpO1xufTtcblxuXG4vLyBwYXRoLnJlbGF0aXZlKGZyb20sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZWxhdGl2ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIGZyb20gPSBleHBvcnRzLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICB0byA9IGV4cG9ydHMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO1xuXG4gIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBmb3IgKDsgc3RhcnQgPCBhcnIubGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICB9XG5cbiAgdmFyIGZyb21QYXJ0cyA9IHRyaW0oZnJvbS5zcGxpdCgnLycpKTtcbiAgdmFyIHRvUGFydHMgPSB0cmltKHRvLnNwbGl0KCcvJykpO1xuXG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpO1xuICB9XG5cbiAgb3V0cHV0UGFydHMgPSBvdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtcblxuICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xufTtcblxuZXhwb3J0cy5zZXAgPSAnLyc7XG5leHBvcnRzLmRlbGltaXRlciA9ICc6JztcblxuZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgcmVzdWx0ID0gc3BsaXRQYXRoKHBhdGgpLFxuICAgICAgcm9vdCA9IHJlc3VsdFswXSxcbiAgICAgIGRpciA9IHJlc3VsdFsxXTtcblxuICBpZiAoIXJvb3QgJiYgIWRpcikge1xuICAgIC8vIE5vIGRpcm5hbWUgd2hhdHNvZXZlclxuICAgIHJldHVybiAnLic7XG4gIH1cblxuICBpZiAoZGlyKSB7XG4gICAgLy8gSXQgaGFzIGEgZGlybmFtZSwgc3RyaXAgdHJhaWxpbmcgc2xhc2hcbiAgICBkaXIgPSBkaXIuc3Vic3RyKDAsIGRpci5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIHJldHVybiByb290ICsgZGlyO1xufTtcblxuXG5leHBvcnRzLmJhc2VuYW1lID0gZnVuY3Rpb24ocGF0aCwgZXh0KSB7XG4gIHZhciBmID0gc3BsaXRQYXRoKHBhdGgpWzJdO1xuICAvLyBUT0RPOiBtYWtlIHRoaXMgY29tcGFyaXNvbiBjYXNlLWluc2Vuc2l0aXZlIG9uIHdpbmRvd3M/XG4gIGlmIChleHQgJiYgZi5zdWJzdHIoLTEgKiBleHQubGVuZ3RoKSA9PT0gZXh0KSB7XG4gICAgZiA9IGYuc3Vic3RyKDAsIGYubGVuZ3RoIC0gZXh0Lmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIGY7XG59O1xuXG5cbmV4cG9ydHMuZXh0bmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aChwYXRoKVszXTtcbn07XG5cbmZ1bmN0aW9uIGZpbHRlciAoeHMsIGYpIHtcbiAgICBpZiAoeHMuZmlsdGVyKSByZXR1cm4geHMuZmlsdGVyKGYpO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmKHhzW2ldLCBpLCB4cykpIHJlcy5wdXNoKHhzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gU3RyaW5nLnByb3RvdHlwZS5zdWJzdHIgLSBuZWdhdGl2ZSBpbmRleCBkb24ndCB3b3JrIGluIElFOFxudmFyIHN1YnN0ciA9ICdhYicuc3Vic3RyKC0xKSA9PT0gJ2InXG4gICAgPyBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7IHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pIH1cbiAgICA6IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHtcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSBzdHIubGVuZ3RoICsgc3RhcnQ7XG4gICAgICAgIHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pO1xuICAgIH1cbjtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJ2YXIgaW5kZXhPZiA9IHJlcXVpcmUoJ2luZGV4b2YnKTtcblxudmFyIE9iamVjdF9rZXlzID0gZnVuY3Rpb24gKG9iaikge1xuICAgIGlmIChPYmplY3Qua2V5cykgcmV0dXJuIE9iamVjdC5rZXlzKG9iailcbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSByZXMucHVzaChrZXkpXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufTtcblxudmFyIGZvckVhY2ggPSBmdW5jdGlvbiAoeHMsIGZuKSB7XG4gICAgaWYgKHhzLmZvckVhY2gpIHJldHVybiB4cy5mb3JFYWNoKGZuKVxuICAgIGVsc2UgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmbih4c1tpXSwgaSwgeHMpO1xuICAgIH1cbn07XG5cbnZhciBkZWZpbmVQcm9wID0gKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ18nLCB7fSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihvYmosIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBuYW1lLCB7XG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iaiwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIG9ialtuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9O1xuICAgIH1cbn0oKSk7XG5cbnZhciBnbG9iYWxzID0gWydBcnJheScsICdCb29sZWFuJywgJ0RhdGUnLCAnRXJyb3InLCAnRXZhbEVycm9yJywgJ0Z1bmN0aW9uJyxcbidJbmZpbml0eScsICdKU09OJywgJ01hdGgnLCAnTmFOJywgJ051bWJlcicsICdPYmplY3QnLCAnUmFuZ2VFcnJvcicsXG4nUmVmZXJlbmNlRXJyb3InLCAnUmVnRXhwJywgJ1N0cmluZycsICdTeW50YXhFcnJvcicsICdUeXBlRXJyb3InLCAnVVJJRXJyb3InLFxuJ2RlY29kZVVSSScsICdkZWNvZGVVUklDb21wb25lbnQnLCAnZW5jb2RlVVJJJywgJ2VuY29kZVVSSUNvbXBvbmVudCcsICdlc2NhcGUnLFxuJ2V2YWwnLCAnaXNGaW5pdGUnLCAnaXNOYU4nLCAncGFyc2VGbG9hdCcsICdwYXJzZUludCcsICd1bmRlZmluZWQnLCAndW5lc2NhcGUnXTtcblxuZnVuY3Rpb24gQ29udGV4dCgpIHt9XG5Db250ZXh0LnByb3RvdHlwZSA9IHt9O1xuXG52YXIgU2NyaXB0ID0gZXhwb3J0cy5TY3JpcHQgPSBmdW5jdGlvbiBOb2RlU2NyaXB0IChjb2RlKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNjcmlwdCkpIHJldHVybiBuZXcgU2NyaXB0KGNvZGUpO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG59O1xuXG5TY3JpcHQucHJvdG90eXBlLnJ1bkluQ29udGV4dCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgaWYgKCEoY29udGV4dCBpbnN0YW5jZW9mIENvbnRleHQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJuZWVkcyBhICdjb250ZXh0JyBhcmd1bWVudC5cIik7XG4gICAgfVxuICAgIFxuICAgIHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICBpZiAoIWlmcmFtZS5zdHlsZSkgaWZyYW1lLnN0eWxlID0ge307XG4gICAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgIFxuICAgIHZhciB3aW4gPSBpZnJhbWUuY29udGVudFdpbmRvdztcbiAgICB2YXIgd0V2YWwgPSB3aW4uZXZhbCwgd0V4ZWNTY3JpcHQgPSB3aW4uZXhlY1NjcmlwdDtcblxuICAgIGlmICghd0V2YWwgJiYgd0V4ZWNTY3JpcHQpIHtcbiAgICAgICAgLy8gd2luLmV2YWwoKSBtYWdpY2FsbHkgYXBwZWFycyB3aGVuIHRoaXMgaXMgY2FsbGVkIGluIElFOlxuICAgICAgICB3RXhlY1NjcmlwdC5jYWxsKHdpbiwgJ251bGwnKTtcbiAgICAgICAgd0V2YWwgPSB3aW4uZXZhbDtcbiAgICB9XG4gICAgXG4gICAgZm9yRWFjaChPYmplY3Rfa2V5cyhjb250ZXh0KSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB3aW5ba2V5XSA9IGNvbnRleHRba2V5XTtcbiAgICB9KTtcbiAgICBmb3JFYWNoKGdsb2JhbHMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKGNvbnRleHRba2V5XSkge1xuICAgICAgICAgICAgd2luW2tleV0gPSBjb250ZXh0W2tleV07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICB2YXIgd2luS2V5cyA9IE9iamVjdF9rZXlzKHdpbik7XG5cbiAgICB2YXIgcmVzID0gd0V2YWwuY2FsbCh3aW4sIHRoaXMuY29kZSk7XG4gICAgXG4gICAgZm9yRWFjaChPYmplY3Rfa2V5cyh3aW4pLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIC8vIEF2b2lkIGNvcHlpbmcgY2lyY3VsYXIgb2JqZWN0cyBsaWtlIGB0b3BgIGFuZCBgd2luZG93YCBieSBvbmx5XG4gICAgICAgIC8vIHVwZGF0aW5nIGV4aXN0aW5nIGNvbnRleHQgcHJvcGVydGllcyBvciBuZXcgcHJvcGVydGllcyBpbiB0aGUgYHdpbmBcbiAgICAgICAgLy8gdGhhdCB3YXMgb25seSBpbnRyb2R1Y2VkIGFmdGVyIHRoZSBldmFsLlxuICAgICAgICBpZiAoa2V5IGluIGNvbnRleHQgfHwgaW5kZXhPZih3aW5LZXlzLCBrZXkpID09PSAtMSkge1xuICAgICAgICAgICAgY29udGV4dFtrZXldID0gd2luW2tleV07XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZvckVhY2goZ2xvYmFscywgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIShrZXkgaW4gY29udGV4dCkpIHtcbiAgICAgICAgICAgIGRlZmluZVByb3AoY29udGV4dCwga2V5LCB3aW5ba2V5XSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgXG4gICAgcmV0dXJuIHJlcztcbn07XG5cblNjcmlwdC5wcm90b3R5cGUucnVuSW5UaGlzQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZXZhbCh0aGlzLmNvZGUpOyAvLyBtYXliZS4uLlxufTtcblxuU2NyaXB0LnByb3RvdHlwZS5ydW5Jbk5ld0NvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBjdHggPSBTY3JpcHQuY3JlYXRlQ29udGV4dChjb250ZXh0KTtcbiAgICB2YXIgcmVzID0gdGhpcy5ydW5JbkNvbnRleHQoY3R4KTtcblxuICAgIGZvckVhY2goT2JqZWN0X2tleXMoY3R4KSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBjb250ZXh0W2tleV0gPSBjdHhba2V5XTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXM7XG59O1xuXG5mb3JFYWNoKE9iamVjdF9rZXlzKFNjcmlwdC5wcm90b3R5cGUpLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIGV4cG9ydHNbbmFtZV0gPSBTY3JpcHRbbmFtZV0gPSBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICB2YXIgcyA9IFNjcmlwdChjb2RlKTtcbiAgICAgICAgcmV0dXJuIHNbbmFtZV0uYXBwbHkocywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICB9O1xufSk7XG5cbmV4cG9ydHMuY3JlYXRlU2NyaXB0ID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5TY3JpcHQoY29kZSk7XG59O1xuXG5leHBvcnRzLmNyZWF0ZUNvbnRleHQgPSBTY3JpcHQuY3JlYXRlQ29udGV4dCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIGNvcHkgPSBuZXcgQ29udGV4dCgpO1xuICAgIGlmKHR5cGVvZiBjb250ZXh0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3JFYWNoKE9iamVjdF9rZXlzKGNvbnRleHQpLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBjb3B5W2tleV0gPSBjb250ZXh0W2tleV07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY29weTtcbn07XG4iLCJcbnZhciBpbmRleE9mID0gW10uaW5kZXhPZjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnIsIG9iail7XG4gIGlmIChpbmRleE9mKSByZXR1cm4gYXJyLmluZGV4T2Yob2JqKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoYXJyW2ldID09PSBvYmopIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn07IiwiLyohIEZsb2NraW5nIDAuMS40IChPY3RvYmVyIDEsIDIwMTUpLCBDb3B5cmlnaHQgMjAxNSBDb2xpbiBDbGFyayB8IGZsb2NraW5nanMub3JnICovXG5cbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAvLyBXZSdyZSBpbiBhIENvbW1vbkpTLXN0eWxlIGxvYWRlci5cbiAgICAgICAgcm9vdC5mbG9jayA9IGV4cG9ydHM7ICAvLyBBbHdheXMgY3JlYXRlIHRoZSBcImZsb2NrXCIgZ2xvYmFsLlxuICAgICAgICBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoXCJqcXVlcnlcIikpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgLy8gV2UncmUgaW4gYW4gQU1ELXN0eWxlIGxvYWRlci5cbiAgICAgICAgZGVmaW5lKFtcImV4cG9ydHNcIiwgXCJqcXVlcnlcIl0sIGZ1bmN0aW9uIChleHBvcnRzLCBqUXVlcnkpIHtcbiAgICAgICAgICAgIHJvb3QuZmxvY2sgPSBleHBvcnRzOyAvLyBBbHdheXMgY3JlYXRlIHRoZSBcImZsb2NrXCIgZ2xvYmFsLlxuICAgICAgICAgICAgcmV0dXJuIChyb290LmZsb2NrLCBmYWN0b3J5KGV4cG9ydHMsIGpRdWVyeSkpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBQbGFpbiBvbGQgYnJvd3Nlci5cbiAgICAgICAgcm9vdC5mbG9jayA9IHt9O1xuICAgICAgICBmYWN0b3J5KHJvb3QuZmxvY2ssIGpRdWVyeSk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cywgalF1ZXJ5KSB7XG4gICAgLy8gVG8gaGVsbCB3aXRoIGlzb2xhdGlvbmlzbS5cbiAgICB3aW5kb3cualF1ZXJ5ID0galF1ZXJ5O1xuOy8qIVxuICogRmx1aWQgSW5mdXNpb24gdjIuMFxuICpcbiAqIEluZnVzaW9uIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBFZHVjYXRpb25hbCBDb21tdW5pdHkgTGljZW5zZSAyLjAgYW5kIG5ldyBCU0QgbGljZW5zZXM6XG4gKiBodHRwOi8vd2lraS5mbHVpZHByb2plY3Qub3JnL2Rpc3BsYXkvZmx1aWQvRmx1aWQrTGljZW5zaW5nXG4gKlxuICogRm9yIGluZm9ybWF0aW9uIG9uIGNvcHlyaWdodCwgc2VlIHRoZSBpbmRpdmlkdWFsIEluZnVzaW9uIHNvdXJjZSBjb2RlIGZpbGVzOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2ZsdWlkLXByb2plY3QvaW5mdXNpb24vXG4gKi9cbi8qXG5Db3B5cmlnaHQgMjAwNy0yMDEwIFVuaXZlcnNpdHkgb2YgQ2FtYnJpZGdlXG5Db3B5cmlnaHQgMjAwNy0yMDA5IFVuaXZlcnNpdHkgb2YgVG9yb250b1xuQ29weXJpZ2h0IDIwMDctMjAwOSBVbml2ZXJzaXR5IG9mIENhbGlmb3JuaWEsIEJlcmtlbGV5XG5Db3B5cmlnaHQgMjAxMC0yMDExIEx1Y2VuZG8gRGV2ZWxvcG1lbnQgTHRkLlxuQ29weXJpZ2h0IDIwMTAgT0NBRCBVbml2ZXJzaXR5XG5Db3B5cmlnaHQgMjAxMSBDaGFybHkgTW9sdGVyXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBFZHVjYXRpb25hbCBDb21tdW5pdHkgTGljZW5zZSAoRUNMKSwgVmVyc2lvbiAyLjAgb3IgdGhlIE5ld1xuQlNEIGxpY2Vuc2UuIFlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCBvbmUgdGhlc2VcbkxpY2Vuc2VzLlxuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIEVDTCAyLjAgTGljZW5zZSBhbmQgQlNEIExpY2Vuc2UgYXRcbmh0dHBzOi8vZ2l0aHViLmNvbS9mbHVpZC1wcm9qZWN0L2luZnVzaW9uL3Jhdy9tYXN0ZXIvSW5mdXNpb24tTElDRU5TRS50eHRcbiovXG5cbi8vIERlY2xhcmUgZGVwZW5kZW5jaWVzXG4vKiBnbG9iYWwgY29uc29sZSwgb3BlcmEsIFlBSE9PKi9cblxudmFyIGZsdWlkXzJfMCA9IGZsdWlkXzJfMCB8fCB7fTtcbnZhciBmbHVpZCA9IGZsdWlkIHx8IGZsdWlkXzJfMDtcblxuKGZ1bmN0aW9uICgkLCBmbHVpZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZmx1aWQudmVyc2lvbiA9IFwiSW5mdXNpb24gMi4wLVNOQVBTSE9UXCI7XG5cbiAgICAvLyBFeHBvcnQgdGhpcyBmb3IgdXNlIGluIGVudmlyb25tZW50cyBsaWtlIG5vZGUuanMsIHdoZXJlIGl0IGlzIHVzZWZ1bCBmb3JcbiAgICAvLyBjb25maWd1cmluZyBzdGFjayB0cmFjZSBiZWhhdmlvdXJcbiAgICBmbHVpZC5FcnJvciA9IEVycm9yO1xuXG4gICAgZmx1aWQuZW52aXJvbm1lbnQgPSB7XG4gICAgICAgIGZsdWlkOiBmbHVpZFxuICAgIH07XG5cbiAgICBmbHVpZC5nbG9iYWwgPSBmbHVpZC5nbG9iYWwgfHwgd2luZG93IHx8IHt9O1xuXG4gICAgLy8gQSBzdGFuZGFyZCB1dGlsaXR5IHRvIHNjaGVkdWxlIHRoZSBpbnZvY2F0aW9uIG9mIGEgZnVuY3Rpb24gYWZ0ZXIgdGhlIGN1cnJlbnRcbiAgICAvLyBzdGFjayByZXR1cm5zLiBPbiBicm93c2VycyB0aGlzIGRlZmF1bHRzIHRvIHNldFRpbWVvdXQoZnVuYywgMSkgYnV0IGluXG4gICAgLy8gb3RoZXIgZW52aXJvbm1lbnRzIGNhbiBiZSBjdXN0b21pc2VkIC0gZS5nLiB0byBwcm9jZXNzLm5leHRUaWNrIGluIG5vZGUuanNcbiAgICAvLyBJbiBmdXR1cmUsIHRoaXMgY291bGQgYmUgb3B0aW1pc2VkIGluIHRoZSBicm93c2VyIHRvIG5vdCBkaXNwYXRjaCBpbnRvIHRoZSBldmVudCBxdWV1ZVxuICAgIGZsdWlkLmludm9rZUxhdGVyID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuYywgMSk7XG4gICAgfTtcblxuICAgIC8vIFRoZSBmb2xsb3dpbmcgZmxhZyBkZWZlYXRzIGFsbCBsb2dnaW5nL3RyYWNpbmcgYWN0aXZpdGllcyBpbiB0aGUgbW9zdCBwZXJmb3JtYW5jZS1jcml0aWNhbCBwYXJ0cyBvZiB0aGUgZnJhbWV3b3JrLlxuICAgIC8vIFRoaXMgc2hvdWxkIHJlYWxseSBiZSBwZXJmb3JtZWQgYnkgYSBidWlsZC10aW1lIHN0ZXAgd2hpY2ggZWxpbWluYXRlcyBjYWxscyB0byBwdXNoQWN0aXZpdHkvcG9wQWN0aXZpdHkgYW5kIGZsdWlkLmxvZy5cbiAgICBmbHVpZC5kZWZlYXRMb2dnaW5nID0gdHJ1ZTtcblxuICAgIC8vIFRoaXMgZmxhZyBlbmFibGVzIHRoZSBhY2N1bXVsYXRpbmcgb2YgYWxsIFwiYWN0aXZpdHlcIiByZWNvcmRzIGdlbmVyYXRlZCBieSBwdXNoQWN0aXZpdHkgaW50byBhIHJ1bm5pbmcgdHJhY2UsIHJhdGhlclxuICAgIC8vIHRoYW4gcmVtb3ZpbmcgdGhlbSBmcm9tIHRoZSBzdGFjayByZWNvcmQgcGVybWFuZW50bHkgd2hlbiByZWNlaXZpbmcgcG9wQWN0aXZpdHkuIFRoaXMgdHJhY2Ugd2lsbCBiZSBjb25zdW1lZCBieVxuICAgIC8vIHZpc3VhbCBkZWJ1Z2dpbmcgdG9vbHMuXG4gICAgZmx1aWQuYWN0aXZpdHlUcmFjaW5nID0gZmFsc2U7XG4gICAgZmx1aWQuYWN0aXZpdHlUcmFjZSA9IFtdO1xuXG4gICAgdmFyIGFjdGl2aXR5UGFyc2VyID0gLyglXFx3KykvZztcblxuICAgIC8vIFJlbmRlcnMgYSBzaW5nbGUgYWN0aXZpdHkgZWxlbWVudCBpbiBhIGZvcm0gc3VpdGFibGUgdG8gYmUgc2VudCB0byBhIG1vZGVybiBicm93c2VyJ3MgY29uc29sZVxuICAgIC8vIHVuc3VwcG9ydGVkLCBub24tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQucmVuZGVyT25lQWN0aXZpdHkgPSBmdW5jdGlvbiAoYWN0aXZpdHksIG5vd2hpbGUpIHtcbiAgICAgICAgdmFyIHRvZ28gPSBub3doaWxlID09PSB0cnVlID8gW10gOiBbXCIgICAgd2hpbGUgXCJdO1xuICAgICAgICB2YXIgbWVzc2FnZSA9IGFjdGl2aXR5Lm1lc3NhZ2U7XG4gICAgICAgIHZhciBpbmRleCA9IGFjdGl2aXR5UGFyc2VyLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBhY3Rpdml0eVBhcnNlci5leGVjKG1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IG1hdGNoWzFdLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICB0b2dvLnB1c2gobWVzc2FnZS5zdWJzdHJpbmcoaW5kZXgsIG1hdGNoLmluZGV4KSk7XG4gICAgICAgICAgICAgICAgdG9nby5wdXNoKGFjdGl2aXR5LmFyZ3Nba2V5XSk7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBhY3Rpdml0eVBhcnNlci5sYXN0SW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZXggPCBtZXNzYWdlLmxlbmd0aCkge1xuICAgICAgICAgICAgdG9nby5wdXNoKG1lc3NhZ2Uuc3Vic3RyaW5nKGluZGV4KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvZ287XG4gICAgfTtcblxuICAgIC8vIFJlbmRlcnMgYW4gYWN0aXZpdHkgc3RhY2sgaW4gYSBmb3JtIHN1aXRhYmxlIHRvIGJlIHNlbnQgdG8gYSBtb2Rlcm4gYnJvd3NlcidzIGNvbnNvbGVcbiAgICAvLyB1bnN1cHBvcnRlZCwgbm9uLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLnJlbmRlckFjdGl2aXR5ID0gZnVuY3Rpb24gKGFjdGl2aXR5U3RhY2ssIHJlbmRlcmVyKSB7XG4gICAgICAgIHJlbmRlcmVyID0gcmVuZGVyZXIgfHwgZmx1aWQucmVuZGVyT25lQWN0aXZpdHk7XG4gICAgICAgIHJldHVybiBmbHVpZC50cmFuc2Zvcm0oYWN0aXZpdHlTdGFjaywgcmVuZGVyZXIpO1xuICAgIH07XG5cbiAgICAvLyBSZXR1cm4gYW4gYXJyYXkgb2Ygb2JqZWN0cyBkZXNjcmliaW5nIHRoZSBjdXJyZW50IGFjdGl2aXR5XG4gICAgLy8gdW5zdXBwb3J0ZWQsIG5vbi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5nZXRBY3Rpdml0eVN0YWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcm9vdCA9IGZsdWlkLmdsb2JhbFRocmVhZExvY2FsKCk7XG4gICAgICAgIGlmICghcm9vdC5hY3Rpdml0eVN0YWNrKSB7XG4gICAgICAgICAgICByb290LmFjdGl2aXR5U3RhY2sgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm9vdC5hY3Rpdml0eVN0YWNrO1xuICAgIH07XG5cbiAgICAvLyBSZXR1cm4gYW4gYXJyYXkgb2Ygb2JqZWN0cyBkZXNjcmliaW5nIHRoZSBjdXJyZW50IGFjdGl2aXR5XG4gICAgLy8gdW5zdXBwb3J0ZWQsIG5vbi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5kZXNjcmliZUFjdGl2aXR5ID0gZmx1aWQuZ2V0QWN0aXZpdHlTdGFjaztcblxuICAgIC8vIFJlbmRlcnMgZWl0aGVyIHRoZSBjdXJyZW50IGFjdGl2aXR5IG9yIHRoZSBzdXBwbGllZCBhY3Rpdml0eSB0byB0aGUgY29uc29sZVxuICAgIGZsdWlkLmxvZ0FjdGl2aXR5ID0gZnVuY3Rpb24gKGFjdGl2aXR5KSB7XG4gICAgICAgIGFjdGl2aXR5ID0gYWN0aXZpdHkgfHwgZmx1aWQuZGVzY3JpYmVBY3Rpdml0eSgpO1xuICAgICAgICB2YXIgcmVuZGVyZWQgPSBmbHVpZC5yZW5kZXJBY3Rpdml0eShhY3Rpdml0eSkucmV2ZXJzZSgpO1xuICAgICAgICBmbHVpZC5sb2coXCJDdXJyZW50IGFjdGl2aXR5OiBcIik7XG4gICAgICAgIGZsdWlkLmVhY2gocmVuZGVyZWQsIGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgICAgICBmbHVpZC5kb0xvZyhhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIEV4ZWN1dGUgdGhlIHN1cHBsaWVkIGZ1bmN0aW9uIHdpdGggdGhlIHNwZWNpZmllZCBhY3Rpdml0eSBkZXNjcmlwdGlvbiBwdXNoZWQgb250byB0aGUgc3RhY2tcbiAgICAvLyB1bnN1cHBvcnRlZCwgbm9uLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLnB1c2hBY3Rpdml0eSA9IGZ1bmN0aW9uICh0eXBlLCBtZXNzYWdlLCBhcmdzKSB7XG4gICAgICAgIHZhciByZWNvcmQgPSB7dHlwZTogdHlwZSwgbWVzc2FnZTogbWVzc2FnZSwgYXJnczogYXJncywgdGltZTogbmV3IERhdGUoKS5nZXRUaW1lKCl9O1xuICAgICAgICBpZiAoZmx1aWQuYWN0aXZpdHlUcmFjaW5nKSB7XG4gICAgICAgICAgICBmbHVpZC5hY3Rpdml0eVRyYWNlLnB1c2gocmVjb3JkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmx1aWQucGFzc0xvZ0xldmVsKGZsdWlkLmxvZ0xldmVsLlRSQUNFKSkge1xuICAgICAgICAgICAgZmx1aWQuZG9Mb2coZmx1aWQucmVuZGVyT25lQWN0aXZpdHkocmVjb3JkLCB0cnVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFjdGl2aXR5U3RhY2sgPSBmbHVpZC5nZXRBY3Rpdml0eVN0YWNrKCk7XG4gICAgICAgIGFjdGl2aXR5U3RhY2sucHVzaChyZWNvcmQpO1xuICAgIH07XG5cbiAgICAvLyBVbmRvIHRoZSBlZmZlY3Qgb2YgdGhlIG1vc3QgcmVjZW50IHB1c2hBY3Rpdml0eSwgb3IgbXVsdGlwbGUgZnJhbWVzIGlmIGFuIGFyZ3VtZW50IGlzIHN1cHBsaWVkXG4gICAgZmx1aWQucG9wQWN0aXZpdHkgPSBmdW5jdGlvbiAocG9wZnJhbWVzKSB7XG4gICAgICAgIHBvcGZyYW1lcyA9IHBvcGZyYW1lcyB8fCAxO1xuICAgICAgICBpZiAoZmx1aWQuYWN0aXZpdHlUcmFjaW5nKSB7XG4gICAgICAgICAgICBmbHVpZC5hY3Rpdml0eVRyYWNlLnB1c2goe3BvcDogcG9wZnJhbWVzfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFjdGl2aXR5U3RhY2sgPSBmbHVpZC5nZXRBY3Rpdml0eVN0YWNrKCk7XG4gICAgICAgIHZhciBwb3BwZWQgPSBhY3Rpdml0eVN0YWNrLmxlbmd0aCAtIHBvcGZyYW1lcztcbiAgICAgICAgYWN0aXZpdHlTdGFjay5sZW5ndGggPSBwb3BwZWQgPCAwID8gMCA6IHBvcHBlZDtcbiAgICB9O1xuICAgIC8vIFwidGhpcy1pc3RcIiBzdHlsZSBFcnJvciBzbyB0aGF0IHdlIGNhbiBkaXN0aW5ndWlzaCBmcmFtZXdvcmsgZXJyb3JzIHdoaWxzdCBzdGlsbCByZXRhaW5pbmcgYWNjZXNzIHRvIHBsYXRmb3JtIEVycm9yIGZlYXR1cmVzXG4gICAgLy8gdW5zdXBwb3J0ZWQsIG5vbi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5GbHVpZEVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy5zdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xuICAgIH07XG4gICAgZmx1aWQuRmx1aWRFcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcblxuICAgIC8vIFRoZSBmcmFtZXdvcmsncyBidWlsdC1pbiBcImZhaWxcIiBwb2xpY3ksIGluIGNhc2UgYSB1c2VyLWRlZmluZWQgaGFuZGxlciB3b3VsZCBsaWtlIHRvXG4gICAgLy8gZGVmZXIgdG8gaXRcbiAgICBmbHVpZC5idWlsdGluRmFpbCA9IGZ1bmN0aW9uIChzb2Z0LCBhcmdzLCBhY3Rpdml0eSkge1xuICAgICAgICBmbHVpZC5sb2cuYXBwbHkobnVsbCwgW2ZsdWlkLmxvZ0xldmVsLkZBSUwsIFwiQVNTRVJUSU9OIEZBSUxFRDogXCJdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIGZsdWlkLmxvZ0FjdGl2aXR5KGFjdGl2aXR5KTtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBhcmdzLmpvaW4oXCJcIik7XG4gICAgICAgIGlmIChzb2Z0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZmx1aWQuRmx1aWRFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2VbXCJBc3NlcnRpb24gZmFpbHVyZSAtIGNoZWNrIGNvbnNvbGUgZm9yIGRldGFpbHNcIl0oKTsgLy8gSW50ZW50aW9uYWxseSBjYXVzZSBhIGJyb3dzZXIgZXJyb3IgYnkgaW52b2tpbmcgYSBub25leGlzdGVudCBmdW5jdGlvbi5cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgc29mdEZhaWx1cmUgPSBbZmFsc2VdO1xuXG4gICAgLyoqXG4gICAgICogU2lnbmFscyBhbiBlcnJvciB0byB0aGUgZnJhbWV3b3JrLiBUaGUgZGVmYXVsdCBiZWhhdmlvdXIgaXMgdG8gbG9nIGEgc3RydWN0dXJlZCBlcnJvciBtZXNzYWdlIGFuZCB0aHJvdyBhIHZhcmlldHkgb2ZcbiAgICAgKiBleGNlcHRpb24gKGhhcmQgb3Igc29mdCkgLSBzZWUgZmx1aWQucHVzaFNvZnRGYWlsdXJlIGZvciBjb25maWd1cmF0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSB0aGUgZXJyb3IgbWVzc2FnZSB0byBsb2dcbiAgICAgKiBAcGFyYW0gLi4uIEFkZGl0aW9uYWwgYXJndW1lbnRzLCBzdWl0YWJsZSBmb3IgYmVpbmcgc2VudCB0byBuYXRpdmUgY29uc29sZS5sb2cgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBmbHVpZC5mYWlsID0gZnVuY3Rpb24gKC8qIG1lc3NhZ2UsIC4uLiAqLykge1xuICAgICAgICB2YXIgYXJncyA9IGZsdWlkLm1ha2VBcnJheShhcmd1bWVudHMpO1xuICAgICAgICB2YXIgYWN0aXZpdHkgPSBmbHVpZC5tYWtlQXJyYXkoZmx1aWQuZGVzY3JpYmVBY3Rpdml0eSgpKTsgLy8gVGFrZSBjb3B5IHNpbmNlIHdlIHdpbGwgZGVzdHJ1Y3RpdmVseSBtb2RpZnlcbiAgICAgICAgZmx1aWQucG9wQWN0aXZpdHkoYWN0aXZpdHkubGVuZ3RoKTtcbiAgICAgICAgdmFyIHRvcEZhaWx1cmUgPSBzb2Z0RmFpbHVyZVswXTtcbiAgICAgICAgaWYgKHR5cGVvZih0b3BGYWlsdXJlKSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIGZsdWlkLmJ1aWx0aW5GYWlsKHRvcEZhaWx1cmUsIGFyZ3MsIGFjdGl2aXR5KTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YodG9wRmFpbHVyZSkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdG9wRmFpbHVyZShhcmdzLCBhY3Rpdml0eSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlIHRoZSBiZWhhdmlvdXIgb2YgZmx1aWQuZmFpbCBieSBwdXNoaW5nIG9yIHBvcHBpbmcgYSBkaXNwb3NpdGlvbiByZWNvcmQgb250byBhIHN0YWNrLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbnxOdW1iZXJ8RnVuY3Rpb259IGNvbmRpdGlvblxuICAgICAmIFN1cHBseSBlaXRoZXIgYSBib29sZWFuIGZsYWcgY2hvb3NpbmcgYmV0d2VlbiBidWlsdC1pbiBmcmFtZXdvcmsgc3RyYXRlZ2llcyB0byBiZSB1c2VkIGluIGZsdWlkLmZhaWxcbiAgICAgKiAtIDxjb2RlPmZhbHNlPC9jb2RlPiwgdGhlIGRlZmF1bHQgY2F1c2VzIGEgXCJoYXJkIGZhaWx1cmVcIiBieSB1c2luZyBhIG5vbmV4aXN0ZW50IHByb3BlcnR5IG9uIGEgU3RyaW5nLCB3aGljaFxuICAgICAqIHdpbGwgaW4gYWxsIGtub3duIGVudmlyb25tZW50cyB0cmlnZ2VyIGFuIHVuaGFuZGxlYWJsZSBleGNlcHRpb24gd2hpY2ggYWlkcyBkZWJ1Z2dpbmcuIFRoZSBib29sZWFuIHZhbHVlXG4gICAgICogPGNvZGU+dHJ1ZTwvY29kZT4gZG93bmdyYWRlcyB0aGlzIGJlaGF2aW91ciB0byB0aHJvdyBhIGNvbnZlbnRpb25hbCBleGNlcHRpb24sIHdoaWNoIGlzIG1vcmUgYXBwcm9wcmlhdGUgaW5cbiAgICAgKiB0ZXN0IGNhc2VzIHdoaWNoIG5lZWQgdG8gZGVtb25zdHJhdGUgZmFpbHVyZSwgYXMgd2VsbCBhcyBpbiBzb21lIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzLlxuICAgICAqIFRoZSBhcmd1bWVudCBtYXkgYWxzbyBiZSBhIGZ1bmN0aW9uLCB3aGljaCB3aWxsIGJlIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHMsIGFyZ3MgKHRoZSBjb21wbGV0ZSBhcmd1bWVudHMgdG9cbiAgICAgKiBmbHVpZC5mYWlsKSBhbmQgYWN0aXZpdHksIGFuIGFycmF5IG9mIHN0cmluZ3MgZGVzY3JpYmluZyB0aGUgY3VycmVudCBmcmFtZXdvcmsgaW52b2NhdGlvbiBzdGF0ZS5cbiAgICAgKiBGaW5hbGx5LCB0aGUgYXJndW1lbnQgbWF5IGJlIHRoZSBudW1iZXIgPGNvZGU+LTE8L2NvZGU+IGluZGljYXRpbmcgdGhhdCB0aGUgcHJldmlvdXNseSBzdXBwbGllZCBkaXNwb3NpdGlvbiBzaG91bGRcbiAgICAgKiBiZSBwb3BwZWQgb2ZmIHRoZSBzdGFja1xuICAgICAqL1xuICAgIGZsdWlkLnB1c2hTb2Z0RmFpbHVyZSA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoY29uZGl0aW9uKSA9PT0gXCJib29sZWFuXCIgfHwgdHlwZW9mIChjb25kaXRpb24pID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHNvZnRGYWlsdXJlLnVuc2hpZnQoY29uZGl0aW9uKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb25kaXRpb24gPT09IC0xKSB7XG4gICAgICAgICAgICBzb2Z0RmFpbHVyZS5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZsdWlkLm5vdHJ5Y2F0Y2ggPSB0cnVlO1xuXG4gICAgLy8gQSB3cmFwcGVyIGZvciB0aGUgdHJ5L2NhdGNoL2ZpbmFsbHkgbGFuZ3VhZ2UgZmVhdHVyZSwgdG8gYWlkIGRlYnVnZ2luZyBvbiBlbnZpcm9ubWVudHNcbiAgICAvLyBzdWNoIGFzIElFLCB3aGVyZSBhbnkgdHJ5IHdpbGwgZGVzdHJveSBzdGFjayBpbmZvcm1hdGlvbiBmb3IgZXJyb3JzXG4gICAgLy8gVE9ETzogVGhlIG9ubHkgbm9uLWRlcHJlY2F0ZWQgY2FsbCB0byB0aGlzIGFubm95aW5nIHV0aWxpdHkgaXMgbGVmdCBpbiBEYXRhQmluZGluZy5qcyB0byBkZWFsIHdpdGhcbiAgICAvLyBjbGVhbnVwIGluIHNvdXJjZSB0cmFja2luZy4gV2Ugc2hvdWxkIHJlYWxseSByZXZpZXcgd2hldGhlciB3ZSBtZWFuIHRvIGFib2xpc2ggYWxsIGV4Y2VwdGlvbiBoYW5kbGluZ1xuICAgIC8vIGNvZGUgdGhyb3VnaG91dCB0aGUgZnJhbWV3b3JrIC0gb24gc2V2ZXJhbCBjb25zaWRlcmF0aW9ucyB0aGlzIGlzIGRlc2lyYWJsZS5cbiAgICBmbHVpZC50cnlDYXRjaCA9IGZ1bmN0aW9uICh0cnlmdW4sIGNhdGNoZnVuLCBmaW5hbGx5ZnVuKSB7XG4gICAgICAgIGZpbmFsbHlmdW4gPSBmaW5hbGx5ZnVuIHx8IGZsdWlkLmlkZW50aXR5O1xuICAgICAgICBpZiAoZmx1aWQubm90cnljYXRjaCkge1xuICAgICAgICAgICAgdmFyIHRvZ28gPSB0cnlmdW4oKTtcbiAgICAgICAgICAgIGZpbmFsbHlmdW4oKTtcbiAgICAgICAgICAgIHJldHVybiB0b2dvO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ5ZnVuKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhdGNoZnVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoZnVuKGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGZpbmFsbHlmdW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBUT0RPOiByZXNjdWVkIGZyb20ga2V0dGxlQ291Y2hEQi5qcyAtIGNsZWFuIHVwIGluIHRpbWVcbiAgICBmbHVpZC5leHBlY3QgPSBmdW5jdGlvbiAobmFtZSwgbWVtYmVycywgdGFyZ2V0KSB7XG4gICAgICAgIGZsdWlkLnRyYW5zZm9ybShmbHVpZC5tYWtlQXJyYXkobWVtYmVycyksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0W2tleV0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBmbHVpZC5mYWlsKG5hbWUgKyBcIiBtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciBcIiArIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBMb2dnaW5nXG5cbiAgICAvKiogUmV0dXJucyB3aGV0aGVyIGxvZ2dpbmcgaXMgZW5hYmxlZCAqKi9cbiAgICBmbHVpZC5pc0xvZ2dpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBsb2dMZXZlbFN0YWNrWzBdLnByaW9yaXR5ID4gZmx1aWQubG9nTGV2ZWwuSU1QT1JUQU5ULnByaW9yaXR5O1xuICAgIH07XG5cbiAgICAvKiogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzdXBwbGllZCBhcmd1bWVudCBpcyBhIHZhbGlkIGxvZ0xldmVsIG1hcmtlciAqKi9cbiAgICBmbHVpZC5pc0xvZ0xldmVsID0gZnVuY3Rpb24gKGFyZykge1xuICAgICAgICByZXR1cm4gZmx1aWQuaXNNYXJrZXIoYXJnKSAmJiBhcmcucHJpb3JpdHkgIT09IHVuZGVmaW5lZDtcbiAgICB9O1xuXG4gICAgLyoqIEFjY2VwdHMgb25lIG9mIHRoZSBtZW1iZXJzIG9mIHRoZSA8Y29kZT5mbHVpZC5sb2dMZXZlbDwvY29kZT4gc3RydWN0dXJlLiBSZXR1cm5zIDxjb2RlPnRydWU8L2NvZGU+IGlmXG4gICAgICogIGEgbWVzc2FnZSBzdXBwbGllZCBhdCB0aGF0IGxvZyBwcmlvcml0eSB3b3VsZCBiZSBhY2NlcHRlZCBhdCB0aGUgY3VycmVudCBsb2dnaW5nIGxldmVsLiBDbGllbnRzIHdob1xuICAgICAqICBpc3N1ZSBwYXJ0aWN1bGFybHkgZXhwZW5zaXZlIGxvZyBwYXlsb2FkIGFyZ3VtZW50cyBhcmUgcmVjb21tZW5kZWQgdG8gZ3VhcmQgdGhlaXIgbG9nZ2luZyBzdGF0ZW1lbnRzIHdpdGggdGhpc1xuICAgICAqICBmdW5jdGlvbiAqL1xuXG4gICAgZmx1aWQucGFzc0xvZ0xldmVsID0gZnVuY3Rpb24gKHRlc3RMb2dMZXZlbCkge1xuICAgICAgICByZXR1cm4gdGVzdExvZ0xldmVsLnByaW9yaXR5IDw9IGxvZ0xldmVsU3RhY2tbMF0ucHJpb3JpdHk7XG4gICAgfTtcblxuICAgIC8qKiBNZXRob2QgdG8gYWxsb3cgdXNlciB0byBjb250cm9sIHRoZSBsb2dnaW5nIGxldmVsLiBBY2NlcHRzIGVpdGhlciBhIGJvb2xlYW4sIGZvciB3aGljaCA8Y29kZT50cnVlPC9jb2RlPlxuICAgICAgKiByZXByZXNlbnRzIDxjb2RlPmZsdWlkLmxvZ0xldmVsLklORk88L2NvZGU+IGFuZCA8Y29kZT5mYWxzZTwvY29kZT4gcmVwcmVzZW50cyA8Y29kZT5mbHVpZC5sb2dMZXZlbC5JTVBPUlRBTlQ8L2NvZGU+ICh0aGUgZGVmYXVsdCksXG4gICAgICAqIG9yIGVsc2UgYW55IG90aGVyIG1lbWJlciBvZiB0aGUgc3RydWN0dXJlIDxjb2RlPmZsdWlkLmxvZ0xldmVsPC9jb2RlPlxuICAgICAgKiBNZXNzYWdlcyB3aG9zZSBwcmlvcml0eSBpcyBzdHJpY3RseSBsZXNzIHRoYW4gdGhlIGN1cnJlbnQgbG9nZ2luZyBsZXZlbCB3aWxsIG5vdCBiZSBzaG93biovXG4gICAgZmx1aWQuc2V0TG9nZ2luZyA9IGZ1bmN0aW9uIChlbmFibGVkKSB7XG4gICAgICAgIHZhciBsb2dMZXZlbDtcbiAgICAgICAgaWYgKHR5cGVvZiBlbmFibGVkID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgbG9nTGV2ZWwgPSBmbHVpZC5sb2dMZXZlbFtlbmFibGVkPyBcIklORk9cIiA6IFwiSU1QT1JUQU5UXCJdO1xuICAgICAgICB9IGVsc2UgaWYgKGZsdWlkLmlzTG9nTGV2ZWwoZW5hYmxlZCkpIHtcbiAgICAgICAgICAgIGxvZ0xldmVsID0gZW5hYmxlZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZsdWlkLmZhaWwoXCJVbnJlY29nbmlzZWQgZmx1aWQgbG9nZ2luZyBsZXZlbCBcIiwgZW5hYmxlZCk7XG4gICAgICAgIH1cbiAgICAgICAgbG9nTGV2ZWxTdGFjay51bnNoaWZ0KGxvZ0xldmVsKTtcbiAgICB9O1xuXG4gICAgZmx1aWQuc2V0TG9nTGV2ZWwgPSBmbHVpZC5zZXRMb2dnaW5nO1xuXG4gICAgLyoqIFVuZG8gdGhlIGVmZmVjdCBvZiB0aGUgbW9zdCByZWNlbnQgXCJzZXRMb2dnaW5nXCIsIHJldHVybmluZyB0aGUgbG9nZ2luZyBzeXN0ZW0gdG8gaXRzIHByZXZpb3VzIHN0YXRlICoqL1xuICAgIGZsdWlkLnBvcExvZ2dpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBsb2dMZXZlbFN0YWNrLmxlbmd0aCA9PT0gMT8gbG9nTGV2ZWxTdGFja1swXSA6IGxvZ0xldmVsU3RhY2suc2hpZnQoKTtcbiAgICB9O1xuXG4gICAgLyoqIEFjdHVhbGx5IGRvIHRoZSB3b3JrIG9mIGxvZ2dpbmcgPGNvZGU+YXJnczwvY29kZT4gdG8gdGhlIGVudmlyb25tZW50J3MgY29uc29sZS4gSWYgdGhlIHN0YW5kYXJkIFwiY29uc29sZVwiXG4gICAgICogc3RyZWFtIGlzIGF2YWlsYWJsZSwgdGhlIG1lc3NhZ2Ugd2lsbCBiZSBzZW50IHRoZXJlIC0gb3RoZXJ3aXNlIGVpdGhlciB0aGVcbiAgICAgKiBZQUhPTyBsb2dnZXIgb3IgdGhlIE9wZXJhIFwicG9zdEVycm9yXCIgc3RyZWFtIHdpbGwgYmUgdXNlZC4gT24gY2FwYWJsZSBlbnZpcm9ubWVudHMgKHRob3NlIG90aGVyIHRoYW5cbiAgICAgKiBJRTggb3IgSUU5KSB0aGUgZW50aXJlIGFyZ3VtZW50IHNldCB3aWxsIGJlIGRpc3BhdGNoZWQgdG8gdGhlIGxvZ2dlciAtIG90aGVyd2lzZSB0aGV5IHdpbGwgYmUgZmxhdHRlbmVkIGludG9cbiAgICAgKiBhIHN0cmluZyBmaXJzdCwgZGVzdHJveWluZyBhbnkgaW5mb3JtYXRpb24gaGVsZCBpbiBub24tcHJpbWl0aXZlIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmbHVpZC5kb0xvZyA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgIHZhciBzdHIgPSBhcmdzLmpvaW4oXCJcIik7XG4gICAgICAgIGlmICh0eXBlb2YgKGNvbnNvbGUpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBpZiAoY29uc29sZS5kZWJ1Zykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcuYXBwbHkoY29uc29sZSwgYXJncyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiAoY29uc29sZS5sb2cpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmdzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coc3RyKTsgLy8gdGhpcyBicmFuY2ggZXhlY3V0ZXMgb24gb2xkIElFLCBmdWxseSBzeW50aGV0aWMgY29uc29sZS5sb2dcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgKFlBSE9PKSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgWUFIT08ubG9nKHN0cik7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIChvcGVyYSkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIG9wZXJhLnBvc3RFcnJvcihzdHIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKiBMb2cgYSBtZXNzYWdlIHRvIGEgc3VpdGFibGUgZW52aXJvbm1lbnRhbCBjb25zb2xlLiBJZiB0aGUgZmlyc3QgYXJndW1lbnQgdG8gZmx1aWQubG9nIGlzXG4gICAgICogb25lIG9mIHRoZSBtZW1iZXJzIG9mIHRoZSA8Y29kZT5mbHVpZC5sb2dMZXZlbDwvY29kZT4gc3RydWN0dXJlLCB0aGlzIHdpbGwgYmUgdGFrZW4gYXMgdGhlIHByaW9yaXR5XG4gICAgICogb2YgdGhlIGxvZ2dlZCBtZXNzYWdlIC0gZWxzZSBpZiB3aWxsIGRlZmF1bHQgdG8gPGNvZGU+Zmx1aWQubG9nTGV2ZWwuSU5GTzwvY29kZT4uIElmIHRoZSBsb2dnZWQgbWVzc2FnZVxuICAgICAqIHByaW9yaXR5IGRvZXMgbm90IGV4Y2VlZCB0aGF0IHNldCBieSB0aGUgbW9zdCByZWNlbnQgY2FsbCB0byB0aGUgPGNvZGU+Zmx1aWQuc2V0TG9nZ2luZzwvY29kZT4gZnVuY3Rpb24sXG4gICAgICogdGhlIG1lc3NhZ2Ugd2lsbCBub3QgYXBwZWFyLlxuICAgICAqL1xuICAgIGZsdWlkLmxvZyA9IGZ1bmN0aW9uICgvKiBtZXNzYWdlIC8qLCAuLi4gKi8pIHtcbiAgICAgICAgdmFyIGRpcmVjdEFyZ3MgPSBmbHVpZC5tYWtlQXJyYXkoYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIHVzZXJMb2dMZXZlbCA9IGZsdWlkLmxvZ0xldmVsLklORk87XG4gICAgICAgIGlmIChmbHVpZC5pc0xvZ0xldmVsKGRpcmVjdEFyZ3NbMF0pKSB7XG4gICAgICAgICAgICB1c2VyTG9nTGV2ZWwgPSBkaXJlY3RBcmdzLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZsdWlkLnBhc3NMb2dMZXZlbCh1c2VyTG9nTGV2ZWwpKSB7XG4gICAgICAgICAgICB2YXIgYXJnMCA9IGZsdWlkLnJlbmRlclRpbWVzdGFtcChuZXcgRGF0ZSgpKSArIFwiOiAgXCI7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFthcmcwXS5jb25jYXQoZGlyZWN0QXJncyk7XG4gICAgICAgICAgICBmbHVpZC5kb0xvZyhhcmdzKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBGdW5jdGlvbmFsIHByb2dyYW1taW5nIHV0aWxpdGllcy5cblxuICAgIC8qKiBBIGJhc2ljIHV0aWxpdHkgdGhhdCByZXR1cm5zIGl0cyBhcmd1bWVudCB1bmNoYW5nZWQgKi9cblxuICAgIGZsdWlkLmlkZW50aXR5ID0gZnVuY3Rpb24gKGFyZykge1xuICAgICAgICByZXR1cm4gYXJnO1xuICAgIH07XG5cbiAgICAvLyBGcmFtZXdvcmsgYW5kIGluc3RhbnRpYXRpb24gZnVuY3Rpb25zLlxuXG5cbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBhcmd1bWVudCBpcyBhIHZhbHVlIG90aGVyIHRoYW4gbnVsbCBvciB1bmRlZmluZWQgKiovXG4gICAgZmx1aWQuaXNWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbDtcbiAgICB9O1xuXG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYXJndW1lbnQgaXMgYSBwcmltaXRpdmUgdHlwZSAqKi9cbiAgICBmbHVpZC5pc1ByaW1pdGl2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgdmFsdWVUeXBlID0gdHlwZW9mICh2YWx1ZSk7XG4gICAgICAgIHJldHVybiAhdmFsdWUgfHwgdmFsdWVUeXBlID09PSBcInN0cmluZ1wiIHx8IHZhbHVlVHlwZSA9PT0gXCJib29sZWFuXCIgfHwgdmFsdWVUeXBlID09PSBcIm51bWJlclwiIHx8IHZhbHVlVHlwZSA9PT0gXCJmdW5jdGlvblwiO1xuICAgIH07XG5cbiAgICAvKiogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzdXBwbGllZCBvYmplY3QgaXMgYW4gYXJyYXkuIFRoZSBzdHJhdGVneSB1c2VkIGlzIGFuIG9wdGltaXNlZFxuICAgICAqIGFwcHJvYWNoIHRha2VuIGZyb20gYW4gZWFybGllciB2ZXJzaW9uIG9mIGpRdWVyeSAtIGRldGVjdGluZyB3aGV0aGVyIHRoZSB0b1N0cmluZygpIHZlcnNpb25cbiAgICAgKiBvZiB0aGUgb2JqZWN0IGFncmVlcyB3aXRoIHRoZSB0ZXh0dWFsIGZvcm0gW29iamVjdCBBcnJheV0sIG9yIGVsc2Ugd2hldGhlciB0aGUgb2JqZWN0IGlzIGFcbiAgICAgKiBqUXVlcnkgb2JqZWN0ICh0aGUgbW9zdCBjb21tb24gc291cmNlIG9mIFwiZmFrZSBhcnJheXNcIikuXG4gICAgICovXG4gICAgZmx1aWQuaXNBcnJheWFibGUgPSBmdW5jdGlvbiAodG90ZXN0KSB7XG4gICAgICAgIHJldHVybiB0b3Rlc3QgJiYgKHRvdGVzdC5qcXVlcnkgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRvdGVzdCkgPT09IFwiW29iamVjdCBBcnJheV1cIik7XG4gICAgfTtcblxuICAgIC8qKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHN1cHBsaWVkIG9iamVjdCBpcyBhIHBsYWluIEpTT04tZm9ybWluZyBjb250YWluZXIgLSB0aGF0IGlzLCBpdCBpcyBlaXRoZXIgYSBwbGFpbiBPYmplY3RcbiAgICAgKiBvciBhIHBsYWluIEFycmF5ICovXG4gICAgZmx1aWQuaXNQbGFpbk9iamVjdCA9IGZ1bmN0aW9uICh0b3Rlc3QpIHtcbiAgICAgICAgaWYgKCF0b3Rlc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gRkxVSUQtNTE3MiAtIG9uIElFOCB0aGUgbGluZSBiZWxvdyBwcm9kdWNlcyBbb2JqZWN0IE9iamVjdF0gcmF0aGVyIHRoYW4gW29iamVjdCBOdWxsXSBvciBbb2JqZWN0IFVuZGVmaW5lZF1cbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRvdGVzdCk7XG4gICAgICAgIHJldHVybiBzdHJpbmcgPT09IFwiW29iamVjdCBBcnJheV1cIiB8fCBzdHJpbmcgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG4gICAgfTtcblxuICAgIGZsdWlkLmlzRE9NTm9kZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIC8vIFRoaXMgY291bGQgYmUgbW9yZSBzb3VuZCwgYnV0IG1lc3N5OlxuICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zODQyODYvamF2YXNjcmlwdC1pc2RvbS1ob3ctZG8teW91LWNoZWNrLWlmLWEtamF2YXNjcmlwdC1vYmplY3QtaXMtYS1kb20tb2JqZWN0XG4gICAgICAvLyBUaGUgcmVhbCBwcm9ibGVtIGlzIGJyb3dzZXJzIGxpa2UgSUU2LCA3IGFuZCA4IHdoaWNoIHN0aWxsIGRvIG5vdCBmZWF0dXJlIGEgXCJjb25zdHJ1Y3RvclwiIHByb3BlcnR5IG9uIERPTSBub2Rlc1xuICAgICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiAob2JqLm5vZGVUeXBlKSA9PT0gXCJudW1iZXJcIjtcbiAgICB9O1xuXG4gICAgZmx1aWQuaXNET01pc2ggPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBmbHVpZC5pc0RPTU5vZGUob2JqKSB8fCBvYmouanF1ZXJ5O1xuICAgIH07XG5cbiAgICBmbHVpZC5pc0NvbXBvbmVudCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgLy8gVE9ETzogaW1wcm92ZSB0aGlzIHN0cmF0ZWd5IGluIHRpbWUgLSB3ZSBtYXkgd2FudCB0byBhY3R1YWxseSB1c2UgYSBjb25zdHJ1Y3Rvci1iYXNlZCB0ZXN0IHdoZW4gd2UgY2FuIGRyb3AgSUU4XG4gICAgICAgIHJldHVybiBvYmogJiYgb2JqLnR5cGVOYW1lICYmIG9iai5pZDtcbiAgICB9O1xuXG4gICAgLyoqIFJldHVybiBhbiBlbXB0eSBjb250YWluZXIgYXMgdGhlIHNhbWUgdHlwZSBhcyB0aGUgYXJndW1lbnQgKGVpdGhlciBhblxuICAgICAqIGFycmF5IG9yIGhhc2ggKi9cbiAgICBmbHVpZC5mcmVzaENvbnRhaW5lciA9IGZ1bmN0aW9uICh0b2NvcHkpIHtcbiAgICAgICAgcmV0dXJuIGZsdWlkLmlzQXJyYXlhYmxlKHRvY29weSkgPyBbXSA6IHt9O1xuICAgIH07XG5cbiAgICAvKiogUGVyZm9ybXMgYSBkZWVwIGNvcHkgKGNsb25lKSBvZiBpdHMgYXJndW1lbnQgKiovXG5cbiAgICBmbHVpZC5jb3B5ID0gZnVuY3Rpb24gKHRvY29weSkge1xuICAgICAgICBpZiAoZmx1aWQuaXNQcmltaXRpdmUodG9jb3B5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRvY29weTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJC5leHRlbmQodHJ1ZSwgZmx1aWQuZnJlc2hDb250YWluZXIodG9jb3B5KSwgdG9jb3B5KTtcbiAgICB9O1xuXG4gICAgLyoqIENvcnJlY3RlZCB2ZXJzaW9uIG9mIGpRdWVyeSBtYWtlQXJyYXkgdGhhdCByZXR1cm5zIGFuIGVtcHR5IGFycmF5IG9uIHVuZGVmaW5lZCByYXRoZXIgdGhhbiBjcmFzaGluZy5cbiAgICAgICogV2UgZG9uJ3QgZGVhbCB3aXRoIGFzIG1hbnkgcGF0aG9sb2dpY2FsIGNhc2VzIGFzIGpRdWVyeSAqKi9cbiAgICBmbHVpZC5tYWtlQXJyYXkgPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHZhciB0b2dvID0gW107XG4gICAgICAgIGlmIChhcmcgIT09IG51bGwgJiYgYXJnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChmbHVpZC5pc1ByaW1pdGl2ZShhcmcpIHx8IHR5cGVvZihhcmcubGVuZ3RoKSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHRvZ28ucHVzaChhcmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmcubGVuZ3RoOyArKyBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvZ29baV0gPSBhcmdbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2dvO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm1JbnRlcm5hbChzb3VyY2UsIHRvZ28sIGtleSwgYXJncykge1xuICAgICAgICB2YXIgdHJhbnNpdCA9IHNvdXJjZVtrZXldO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFyZ3MubGVuZ3RoIC0gMTsgKytqKSB7XG4gICAgICAgICAgICB0cmFuc2l0ID0gYXJnc1tqICsgMV0odHJhbnNpdCwga2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0b2dvW2tleV0gPSB0cmFuc2l0O1xuICAgIH1cblxuICAgIC8qKiBSZXR1cm4gYSBsaXN0IG9yIGhhc2ggb2Ygb2JqZWN0cywgdHJhbnNmb3JtZWQgYnkgb25lIG9yIG1vcmUgZnVuY3Rpb25zLiBTaW1pbGFyIHRvXG4gICAgICogalF1ZXJ5Lm1hcCwgb25seSB3aWxsIGFjY2VwdCBhbiBhcmJpdHJhcnkgbGlzdCBvZiB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbnMgYW5kIGFsc29cbiAgICAgKiB3b3JrcyBvbiBub24tYXJyYXlzLlxuICAgICAqIEBwYXJhbSBzb3VyY2Uge0FycmF5IG9yIE9iamVjdH0gVGhlIGluaXRpYWwgY29udGFpbmVyIG9mIG9iamVjdHMgdG8gYmUgdHJhbnNmb3JtZWQuXG4gICAgICogQHBhcmFtIGZuMSwgZm4yLCBldGMuIHtGdW5jdGlvbn0gQW4gYXJiaXRyYXJ5IG51bWJlciBvZiBvcHRpb25hbCBmdXJ0aGVyIGFyZ3VtZW50cyxcbiAgICAgKiBhbGwgb2YgdHlwZSBGdW5jdGlvbiwgYWNjZXB0aW5nIHRoZSBzaWduYXR1cmUgKG9iamVjdCwgaW5kZXgpLCB3aGVyZSBvYmplY3QgaXMgdGhlXG4gICAgICogbGlzdCBtZW1iZXIgdG8gYmUgdHJhbnNmb3JtZWQsIGFuZCBpbmRleCBpcyBpdHMgbGlzdCBpbmRleC4gRWFjaCBmdW5jdGlvbiB3aWxsIGJlXG4gICAgICogYXBwbGllZCBpbiB0dXJuIHRvIGVhY2ggbGlzdCBtZW1iZXIsIHdoaWNoIHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIHJldHVybiB2YWx1ZVxuICAgICAqIGZyb20gdGhlIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm4gVGhlIGZpbmFsbHkgdHJhbnNmb3JtZWQgbGlzdCwgd2hlcmUgZWFjaCBtZW1iZXIgaGFzIGJlZW4gcmVwbGFjZWQgYnkgdGhlXG4gICAgICogb3JpZ2luYWwgbWVtYmVyIGFjdGVkIG9uIGJ5IHRoZSBmdW5jdGlvbiBvciBmdW5jdGlvbnMuXG4gICAgICovXG4gICAgZmx1aWQudHJhbnNmb3JtID0gZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICB2YXIgdG9nbyA9IGZsdWlkLmZyZXNoQ29udGFpbmVyKHNvdXJjZSk7XG4gICAgICAgIGlmIChmbHVpZC5pc0FycmF5YWJsZShzb3VyY2UpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybUludGVybmFsKHNvdXJjZSwgdG9nbywgaSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1JbnRlcm5hbChzb3VyY2UsIHRvZ28sIGtleSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9nbztcbiAgICB9O1xuXG4gICAgLyoqIEJldHRlciBqUXVlcnkuZWFjaCB3aGljaCB3b3JrcyBvbiBoYXNoZXMgYXMgd2VsbCBhcyBoYXZpbmcgdGhlIGFyZ3VtZW50c1xuICAgICAqIHRoZSByaWdodCB3YXkgcm91bmQuXG4gICAgICogQHBhcmFtIHNvdXJjZSB7QXJyYXlhYmxlIG9yIE9iamVjdH0gVGhlIGNvbnRhaW5lciB0byBiZSBpdGVyYXRlZCBvdmVyXG4gICAgICogQHBhcmFtIGZ1bmMge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uIGFjY2VwdGluZyAodmFsdWUsIGtleSkgZm9yIGVhY2ggaXRlcmF0ZWRcbiAgICAgKiBvYmplY3QuXG4gICAgICovXG4gICAgZmx1aWQuZWFjaCA9IGZ1bmN0aW9uIChzb3VyY2UsIGZ1bmMpIHtcbiAgICAgICAgaWYgKGZsdWlkLmlzQXJyYXlhYmxlKHNvdXJjZSkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgZnVuYyhzb3VyY2VbaV0sIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgICAgIGZ1bmMoc291cmNlW2tleV0sIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZmx1aWQubWFrZV9maW5kID0gZnVuY3Rpb24gKGZpbmRfaWYpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IGZpbmRfaWYgPyBmYWxzZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UsIGZ1bmMsIGRlZmZvbHQpIHtcbiAgICAgICAgICAgIHZhciBkaXNwO1xuICAgICAgICAgICAgaWYgKGZsdWlkLmlzQXJyYXlhYmxlKHNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwID0gZnVuYyhzb3VyY2VbaV0sIGkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzcCAhPT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmluZF9pZiA/IHNvdXJjZVtpXSA6IGRpc3A7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcCA9IGZ1bmMoc291cmNlW2tleV0sIGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXNwICE9PSB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaW5kX2lmID8gc291cmNlW2tleV0gOiBkaXNwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlZmZvbHQ7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8qKiBTY2FuIHRocm91Z2ggYSBsaXN0IG9yIGhhc2ggb2Ygb2JqZWN0cywgdGVybWluYXRpbmcgb24gdGhlIGZpcnN0IG1lbWJlciB3aGljaFxuICAgICAqIG1hdGNoZXMgYSBwcmVkaWNhdGUgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHNvdXJjZSB7QXJyYXlhYmxlIG9yIE9iamVjdH0gVGhlIGxpc3Qgb3IgaGFzaCBvZiBvYmplY3RzIHRvIGJlIHNlYXJjaGVkLlxuICAgICAqIEBwYXJhbSBmdW5jIHtGdW5jdGlvbn0gQSBwcmVkaWNhdGUgZnVuY3Rpb24sIGFjdGluZyBvbiBhIG1lbWJlci4gQSBwcmVkaWNhdGUgd2hpY2hcbiAgICAgKiByZXR1cm5zIGFueSB2YWx1ZSB3aGljaCBpcyBub3QgPGNvZGU+dW5kZWZpbmVkPC9jb2RlPiB3aWxsIHRlcm1pbmF0ZVxuICAgICAqIHRoZSBzZWFyY2guIFRoZSBmdW5jdGlvbiBhY2NlcHRzIChvYmplY3QsIGluZGV4KS5cbiAgICAgKiBAcGFyYW0gZGVmbHQge09iamVjdH0gQSB2YWx1ZSB0byBiZSByZXR1cm5lZCBpbiB0aGUgY2FzZSBubyBwcmVkaWNhdGUgZnVuY3Rpb24gbWF0Y2hlc1xuICAgICAqIGEgbGlzdCBtZW1iZXIuIFRoZSBkZWZhdWx0IHdpbGwgYmUgdGhlIG5hdHVyYWwgdmFsdWUgb2YgPGNvZGU+dW5kZWZpbmVkPC9jb2RlPlxuICAgICAqIEByZXR1cm4gVGhlIGZpcnN0IHJldHVybiB2YWx1ZSBmcm9tIHRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gd2hpY2ggaXMgbm90IDxjb2RlPnVuZGVmaW5lZDwvY29kZT5cbiAgICAgKi9cbiAgICBmbHVpZC5maW5kID0gZmx1aWQubWFrZV9maW5kKGZhbHNlKTtcbiAgICAvKiogVGhlIHNhbWUgc2lnbmF0dXJlIGFzIGZsdWlkLmZpbmQsIG9ubHkgdGhlIHJldHVybiB2YWx1ZSBpcyB0aGUgYWN0dWFsIGVsZW1lbnQgZm9yIHdoaWNoIHRoZVxuICAgICAqIHByZWRpY2F0ZSByZXR1cm5zIGEgdmFsdWUgZGlmZmVyZW50IGZyb20gPGNvZGU+ZmFsc2U8L2NvZGU+XG4gICAgICovXG4gICAgZmx1aWQuZmluZF9pZiA9IGZsdWlkLm1ha2VfZmluZCh0cnVlKTtcblxuICAgIC8qKiBTY2FuIHRocm91Z2ggYSBsaXN0IG9mIG9iamVjdHMsIFwiYWNjdW11bGF0aW5nXCIgYSB2YWx1ZSBvdmVyIHRoZW1cbiAgICAgKiAobWF5IGJlIGEgc3RyYWlnaHRmb3J3YXJkIFwic3VtXCIgb3Igc29tZSBvdGhlciBjaGFpbmVkIGNvbXB1dGF0aW9uKS4gXCJhY2N1bXVsYXRlXCIgaXMgdGhlIG5hbWUgZGVyaXZlZFxuICAgICAqIGZyb20gdGhlIEMrKyBTVEwsIG90aGVyIG5hbWVzIGZvciB0aGlzIGFsZ29yaXRobSBhcmUgXCJyZWR1Y2VcIiBvciBcImZvbGRcIi5cbiAgICAgKiBAcGFyYW0gbGlzdCB7QXJyYXl9IFRoZSBsaXN0IG9mIG9iamVjdHMgdG8gYmUgYWNjdW11bGF0ZWQgb3Zlci5cbiAgICAgKiBAcGFyYW0gZm4ge0Z1bmN0aW9ufSBBbiBcImFjY3VtdWxhdGlvbiBmdW5jdGlvblwiIGFjY2VwdGluZyB0aGUgc2lnbmF0dXJlIChvYmplY3QsIHRvdGFsLCBpbmRleCkgd2hlcmVcbiAgICAgKiBvYmplY3QgaXMgdGhlIGxpc3QgbWVtYmVyLCB0b3RhbCBpcyB0aGUgXCJydW5uaW5nIHRvdGFsXCIgb2JqZWN0ICh3aGljaCBpcyB0aGUgcmV0dXJuIHZhbHVlIGZyb20gdGhlIHByZXZpb3VzIGZ1bmN0aW9uKSxcbiAgICAgKiBhbmQgaW5kZXggaXMgdGhlIGluZGV4IG51bWJlci5cbiAgICAgKiBAcGFyYW0gYXJnIHtPYmplY3R9IFRoZSBpbml0aWFsIHZhbHVlIGZvciB0aGUgXCJydW5uaW5nIHRvdGFsXCIgb2JqZWN0LlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIGZpbmFsIHJ1bm5pbmcgdG90YWwgb2JqZWN0IGFzIHJldHVybmVkIGZyb20gdGhlIGZpbmFsIGludm9jYXRpb24gb2YgdGhlIGZ1bmN0aW9uIG9uIHRoZSBsYXN0IGxpc3QgbWVtYmVyLlxuICAgICAqL1xuICAgIGZsdWlkLmFjY3VtdWxhdGUgPSBmdW5jdGlvbiAobGlzdCwgZm4sIGFyZykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGFyZyA9IGZuKGxpc3RbaV0sIGFyZywgaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyZztcbiAgICB9O1xuXG4gICAgLyoqIFNjYW4gdGhyb3VnaCBhIGxpc3Qgb3IgaGFzaCBvZiBvYmplY3RzLCByZW1vdmluZyB0aG9zZSB3aGljaCBtYXRjaCBhIHByZWRpY2F0ZS4gU2ltaWxhciB0b1xuICAgICAqIGpRdWVyeS5ncmVwLCBvbmx5IGFjdHMgb24gdGhlIGxpc3QgaW4tcGxhY2UgYnkgcmVtb3ZhbCwgcmF0aGVyIHRoYW4gYnkgY3JlYXRpbmdcbiAgICAgKiBhIG5ldyBsaXN0IGJ5IGluY2x1c2lvbi5cbiAgICAgKiBAcGFyYW0gc291cmNlIHtBcnJheXxPYmplY3R9IFRoZSBsaXN0IG9yIGhhc2ggb2Ygb2JqZWN0cyB0byBiZSBzY2FubmVkIG92ZXIuXG4gICAgICogQHBhcmFtIGZuIHtGdW5jdGlvbn0gQSBwcmVkaWNhdGUgZnVuY3Rpb24gZGV0ZXJtaW5pbmcgd2hldGhlciBhbiBlbGVtZW50IHNob3VsZCBiZVxuICAgICAqIHJlbW92ZWQuIFRoaXMgYWNjZXB0cyB0aGUgc3RhbmRhcmQgc2lnbmF0dXJlIChvYmplY3QsIGluZGV4KSBhbmQgcmV0dXJucyBhIFwidHJ1dGh5XCJcbiAgICAgKiByZXN1bHQgaW4gb3JkZXIgdG8gZGV0ZXJtaW5lIHRoYXQgdGhlIHN1cHBsaWVkIG9iamVjdCBzaG91bGQgYmUgcmVtb3ZlZCBmcm9tIHRoZSBsaXN0LlxuICAgICAqIEBwYXJhbSB0YXJnZXQge0FycmF5fE9iamVjdH0gKG9wdGlvbmFsKSBBIHRhcmdldCBvYmplY3Qgb2YgdGhlIHNhbWUgdHlwZSBhcyA8Y29kZT5zb3VyY2U8L2NvZGU+LCB3aGljaCB3aWxsXG4gICAgICogcmVjZWl2ZSBhbnkgb2JqZWN0cyByZW1vdmVkIGZyb20gaXQuXG4gICAgICogQHJldHVybiA8Y29kZT50YXJnZXQ8L2NvZGU+LCBjb250YWluaW5nIHRoZSByZW1vdmVkIGVsZW1lbnRzLCBpZiBpdCB3YXMgc3VwcGxpZWQsIG9yIGVsc2UgPGNvZGU+c291cmNlPC9jb2RlPlxuICAgICAqIG1vZGlmaWVkIGJ5IHRoZSBvcGVyYXRpb24gb2YgcmVtb3ZpbmcgdGhlIG1hdGNoZWQgZWxlbWVudHMuXG4gICAgICovXG4gICAgZmx1aWQucmVtb3ZlX2lmID0gZnVuY3Rpb24gKHNvdXJjZSwgZm4sIHRhcmdldCkge1xuICAgICAgICBpZiAoZmx1aWQuaXNBcnJheWFibGUoc291cmNlKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHNvdXJjZS5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgICAgIGlmIChmbihzb3VyY2VbaV0sIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC51bnNoaWZ0KHNvdXJjZVtpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc291cmNlLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZuKHNvdXJjZVtrZXldLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0IHx8IHNvdXJjZTtcbiAgICB9O1xuXG4gICAgLyoqIEZpbGxzIGFuIGFycmF5IG9mIGdpdmVuIHNpemUgd2l0aCBjb3BpZXMgb2YgYSB2YWx1ZSBvciByZXN1bHQgb2YgYSBmdW5jdGlvbiBpbnZvY2F0aW9uXG4gICAgICogQHBhcmFtIG4ge051bWJlcn0gVGhlIHNpemUgb2YgdGhlIGFycmF5IHRvIGJlIGZpbGxlZFxuICAgICAqIEBwYXJhbSBnZW5lcmF0b3Ige09iamVjdHxGdW5jdGlvbn0gRWl0aGVyIGEgdmFsdWUgdG8gYmUgcmVwbGljYXRlZCBvciBmdW5jdGlvbiB0byBiZSBjYWxsZWRcbiAgICAgKiBAcGFyYW0gYXBwbHlGdW5jIHtCb29sZWFufSBJZiB0cnVlLCB0cmVhdCB0aGUgZ2VuZXJhdG9yIHZhbHVlIGFzIGEgZnVuY3Rpb24gdG8gYmUgaW52b2tlZCB3aXRoXG4gICAgICogYXJndW1lbnQgZXF1YWwgdG8gdGhlIGluZGV4IHBvc2l0aW9uXG4gICAgICovXG5cbiAgICBmbHVpZC5nZW5lcmF0ZSA9IGZ1bmN0aW9uIChuLCBnZW5lcmF0b3IsIGFwcGx5RnVuYykge1xuICAgICAgICB2YXIgdG9nbyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsrIGkpIHtcbiAgICAgICAgICAgIHRvZ29baV0gPSBhcHBseUZ1bmM/IGdlbmVyYXRvcihpKSA6IGdlbmVyYXRvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9nbztcbiAgICB9O1xuXG4gICAgLyoqIFJldHVybnMgYW4gYXJyYXkgb2Ygc2l6ZSBjb3VudCwgZmlsbGVkIHdpdGggaW5jcmVhc2luZyBpbnRlZ2Vycywgc3RhcnRpbmcgYXQgMCBvciBhdCB0aGUgaW5kZXggc3BlY2lmaWVkIGJ5IGZpcnN0LlxuICAgICAqIEBwYXJhbSBjb3VudCB7TnVtYmVyfSBTaXplIG9mIHRoZSBmaWxsZWQgYXJyYXkgdG8gYmUgcmV0dXJuZWRcbiAgICAgKiBAcGFyYW0gZmlyc3Qge051bWJlcn0gKG9wdGlvbmFsLCBkZWZhdWx0cyB0byAwKSBGaXJzdCBlbGVtZW50IHRvIGFwcGVhciBpbiB0aGUgYXJyYXlcbiAgICAgKi9cblxuICAgIGZsdWlkLmlvdGEgPSBmdW5jdGlvbiAoY291bnQsIGZpcnN0KSB7XG4gICAgICAgIGZpcnN0ID0gZmlyc3QgfHwgMDtcbiAgICAgICAgdmFyIHRvZ28gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICAgICAgICB0b2dvW3RvZ28ubGVuZ3RoXSA9IGZpcnN0Kys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvZ287XG4gICAgfTtcblxuICAgIC8qKiBFeHRyYWN0cyBhIHBhcnRpY3VsYXIgbWVtYmVyIGZyb20gZWFjaCB0b3AtbGV2ZWwgbWVtYmVyIG9mIGEgY29udGFpbmVyLCByZXR1cm5pbmcgYSBuZXcgY29udGFpbmVyIG9mIHRoZSBzYW1lIHR5cGVcbiAgICAgKiBAcGFyYW0gaG9sZGVyIHtBcnJheXxPYmplY3R9IFRoZSBjb250YWluZXIgdG8gYmUgZmlsdGVyZWRcbiAgICAgKiBAcGFyYW0gbmFtZSB7U3RyaW5nfEFycmF5IG9mIFN0cmluZ30gQW4gRUwgcGF0aCB0byBiZSBmZXRjaGVkIGZyb20gZWFjaCB0b3AtbGV2ZWwgbWVtYmVyXG4gICAgICovXG5cbiAgICBmbHVpZC5nZXRNZW1iZXJzID0gZnVuY3Rpb24gKGhvbGRlciwgbmFtZSkge1xuICAgICAgICByZXR1cm4gZmx1aWQudHJhbnNmb3JtKGhvbGRlciwgZnVuY3Rpb24obWVtYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmx1aWQuZ2V0KG1lbWJlciwgbmFtZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKiogQWNjZXB0cyBhbiBvYmplY3QgdG8gYmUgZmlsdGVyZWQsIGFuZCBhIGxpc3Qgb2Yga2V5cy4gRWl0aGVyIGFsbCBrZXlzIG5vdCBwcmVzZW50IGluXG4gICAgICogdGhlIGxpc3QgYXJlIHJlbW92ZWQsIG9yIG9ubHkga2V5cyBwcmVzZW50IGluIHRoZSBsaXN0IGFyZSByZXR1cm5lZC5cbiAgICAgKiBAcGFyYW0gdG9GaWx0ZXIge0FycmF5fE9iamVjdH0gVGhlIG9iamVjdCB0byBiZSBmaWx0ZXJlZCAtIHRoaXMgd2lsbCBiZSBOT1QgbW9kaWZpZWQgYnkgdGhlIG9wZXJhdGlvbiAoY3VycmVudCBpbXBsZW1lbnRhdGlvblxuICAgICAqIHBhc3NlcyB0aHJvdWdoICQuZXh0ZW5kIHNoYWxsb3cgYWxnb3JpdGhtKVxuICAgICAqIEBwYXJhbSBrZXlzIHtBcnJheSBvZiBTdHJpbmd9IFRoZSBsaXN0IG9mIGtleXMgdG8gb3BlcmF0ZSB3aXRoXG4gICAgICogQHBhcmFtIGV4Y2x1ZGUge2Jvb2xlYW59IElmIDxjb2RlPnRydWU8L2NvZGU+LCB0aGUga2V5cyBsaXN0ZWQgYXJlIHJlbW92ZWQgcmF0aGVyIHRoYW4gaW5jbHVkZWRcbiAgICAgKiBAcmV0dXJuIHRoZSBmaWx0ZXJlZCBvYmplY3QgKHRoZSBzYW1lIG9iamVjdCB0aGF0IHdhcyBzdXBwbGllZCBhcyA8Y29kZT50b0ZpbHRlcjwvY29kZT5cbiAgICAgKi9cblxuICAgIGZsdWlkLmZpbHRlcktleXMgPSBmdW5jdGlvbiAodG9GaWx0ZXIsIGtleXMsIGV4Y2x1ZGUpIHtcbiAgICAgICAgcmV0dXJuIGZsdWlkLnJlbW92ZV9pZigkLmV4dGVuZCh7fSwgdG9GaWx0ZXIpLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGV4Y2x1ZGUgXiAoJC5pbkFycmF5KGtleSwga2V5cykgPT09IC0xKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKiBBIGNvbnZlbmllbmNlIHdyYXBwZXIgZm9yIDxjb2RlPmZsdWlkLmZpbHRlcktleXM8L2NvZGU+IHdpdGggdGhlIHBhcmFtZXRlciA8Y29kZT5leGNsdWRlPC9jb2RlPiBzZXQgdG8gPGNvZGU+dHJ1ZTwvY29kZT5cbiAgICAgKiAgUmV0dXJucyB0aGUgc3VwcGxpZWQgb2JqZWN0IHdpdGggbGlzdGVkIGtleXMgcmVtb3ZlZCAqL1xuXG4gICAgZmx1aWQuY2Vuc29yS2V5cyA9IGZ1bmN0aW9uICh0b0NlbnNvciwga2V5cykge1xuICAgICAgICByZXR1cm4gZmx1aWQuZmlsdGVyS2V5cyh0b0NlbnNvciwga2V5cywgdHJ1ZSk7XG4gICAgfTtcblxuICAgIC8vIFRPRE86IFRoaXMgaXMgbm90IGFzIGNsZXZlciBhbiBpZGVhIGFzIHdlIHRoaW5rIGl0IGlzIC0gdGhpcyB0eXBpY2FsbHkgaW5uZXItbG9vcCBmdW5jdGlvbiB3aWxsIG9wdGltaXNlIGJhZGx5IGR1ZSB0byBjbG9zdXJlXG4gICAgZmx1aWQubWFrZUZsYXR0ZW4gPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHZhciB0b2dvID0gW107XG4gICAgICAgICAgICBmbHVpZC5lYWNoKG9iaiwgZnVuY3Rpb24gKC8qIHZhbHVlLCBrZXkgKi8pIHtcbiAgICAgICAgICAgICAgICB0b2dvLnB1c2goYXJndW1lbnRzW2luZGV4XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0b2dvO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvKiogUmV0dXJuIHRoZSBrZXlzIGluIHRoZSBzdXBwbGllZCBvYmplY3QgYXMgYW4gYXJyYXkgKiovXG4gICAgZmx1aWQua2V5cyA9IGZsdWlkLm1ha2VGbGF0dGVuKDEpO1xuXG4gICAgLyoqIFJldHVybiB0aGUgdmFsdWVzIGluIHRoZSBzdXBwbGllZCBvYmplY3QgYXMgYW4gYXJyYXkgKiovXG4gICAgZmx1aWQudmFsdWVzID0gZmx1aWQubWFrZUZsYXR0ZW4oMCk7XG5cbiAgICAvKipcbiAgICAgKiBTZWFyY2hlcyB0aHJvdWdoIHRoZSBzdXBwbGllZCBvYmplY3QsIGFuZCByZXR1cm5zIDxjb2RlPnRydWU8L2NvZGU+IGlmIHRoZSBzdXBwbGllZCB2YWx1ZVxuICAgICAqIGNhbiBiZSBmb3VuZFxuICAgICAqL1xuICAgIGZsdWlkLmNvbnRhaW5zID0gZnVuY3Rpb24gKG9iaiwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG9iaiA/IChmbHVpZC5pc0FycmF5YWJsZShvYmopID8gJC5pbkFycmF5KHZhbHVlLCBvYmopICE9PSAtMSA6IGZsdWlkLmZpbmQob2JqLCBmdW5jdGlvbiAodGhpc1ZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHRoaXNWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSkgOiB1bmRlZmluZWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNlYXJjaGVzIHRocm91Z2ggdGhlIHN1cHBsaWVkIG9iamVjdCBmb3IgdGhlIGZpcnN0IHZhbHVlIHdoaWNoIG1hdGNoZXMgdGhlIG9uZSBzdXBwbGllZC5cbiAgICAgKiBAcGFyYW0gb2JqIHtPYmplY3R9IHRoZSBPYmplY3QgdG8gYmUgc2VhcmNoZWQgdGhyb3VnaFxuICAgICAqIEBwYXJhbSB2YWx1ZSB7T2JqZWN0fSB0aGUgdmFsdWUgdG8gYmUgZm91bmQuIFRoaXMgd2lsbCBiZSBjb21wYXJlZCBhZ2FpbnN0IHRoZSBvYmplY3Qnc1xuICAgICAqIG1lbWJlciB1c2luZyA9PT0gZXF1YWxpdHkuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgZmlyc3Qga2V5IHdob3NlIHZhbHVlIG1hdGNoZXMgdGhlIG9uZSBzdXBwbGllZCwgb3IgPGNvZGU+bnVsbDwvY29kZT4gaWYgbm9cbiAgICAgKiBzdWNoIGtleSBpcyBmb3VuZC5cbiAgICAgKi9cbiAgICBmbHVpZC5rZXlGb3JWYWx1ZSA9IGZ1bmN0aW9uIChvYmosIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBmbHVpZC5maW5kKG9iaiwgZnVuY3Rpb24gKHRoaXNWYWx1ZSwga2V5KSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHRoaXNWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBub3cgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHJlbGVhc2Ugb2YgSW5mdXNpb24uXG4gICAgICogU2VlIGZsdWlkLmtleUZvclZhbHVlIGluc3RlYWQuXG4gICAgICovXG4gICAgZmx1aWQuZmluZEtleUluT2JqZWN0ID0gZmx1aWQua2V5Rm9yVmFsdWU7XG5cbiAgICAvKiogQ29udmVydHMgYW4gYXJyYXkgaW50byBhbiBvYmplY3Qgd2hvc2Uga2V5cyBhcmUgdGhlIGVsZW1lbnRzIG9mIHRoZSBhcnJheSwgZWFjaCB3aXRoIHRoZSB2YWx1ZSBcInRydWVcIlxuICAgICAqL1xuXG4gICAgZmx1aWQuYXJyYXlUb0hhc2ggPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgdmFyIHRvZ28gPSB7fTtcbiAgICAgICAgZmx1aWQuZWFjaChhcnJheSwgZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICB0b2dvW2VsXSA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdG9nbztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGFuIG9iamVjdCBvciBhcnJheSBvZiBpdHMgY29udGVudHMuIEZvciBvYmplY3RzLCBlYWNoIHByb3BlcnR5IGlzIGRlbGV0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gdGFyZ2V0IHRoZSB0YXJnZXQgdG8gYmUgY2xlYXJlZFxuICAgICAqL1xuICAgIGZsdWlkLmNsZWFyID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICBpZiAoZmx1aWQuaXNBcnJheWFibGUodGFyZ2V0KSkge1xuICAgICAgICAgICAgdGFyZ2V0Lmxlbmd0aCA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIHRhcmdldCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXRbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAvKipcbiAgICAqIEBwYXJhbSBib29sZWFuIGFzY2VuZGluZyA8Y29kZT50cnVlPC9jb2RlPiBpZiBhIGNvbXBhcmF0b3IgaXMgdG8gYmUgcmV0dXJuZWQgd2hpY2hcbiAgICAqIHNvcnRzIHN0cmluZ3MgaW4gZGVzY2VuZGluZyBvcmRlciBvZiBsZW5ndGhcbiAgICAqL1xuICAgIGZsdWlkLmNvbXBhcmVTdHJpbmdMZW5ndGggPSBmdW5jdGlvbiAoYXNjZW5kaW5nKSB7XG4gICAgICAgIHJldHVybiBhc2NlbmRpbmcgPyBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEubGVuZ3RoIC0gYi5sZW5ndGg7XG4gICAgICAgIH0gOiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIGZsdWlkLmxvZ0xldmVsc1NwZWMgPSB7XG4gICAgICAgIFwiRkFUQUxcIjogICAgICAwLFxuICAgICAgICBcIkZBSUxcIjogICAgICAgNSxcbiAgICAgICAgXCJXQVJOXCI6ICAgICAgMTAsXG4gICAgICAgIFwiSU1QT1JUQU5UXCI6IDEyLCAvLyBUaGUgZGVmYXVsdCBsb2dnaW5nIFwib2ZmXCIgbGV2ZWwgLSBjb3JyZXNwb25kcyB0byB0aGUgb2xkIFwiZmFsc2VcIlxuICAgICAgICBcIklORk9cIjogICAgICAxNSwgLy8gVGhlIGRlZmF1bHQgbG9nZ2luZyBcIm9uXCIgbGV2ZWwgLSBjb3JyZXNwb25kcyB0byB0aGUgb2xkIFwidHJ1ZVwiXG4gICAgICAgIFwiVFJBQ0VcIjogICAgIDIwXG4gICAgfTtcblxuICAgIC8qKiBBIHN0cnVjdHVyZSBob2xkaW5nIGFsbCBzdXBwb3J0ZWQgbG9nIGxldmVscyBhcyBzdXBwbGllZCBhcyBhIHBvc3NpYmxlIGZpcnN0IGFyZ3VtZW50IHRvIGZsdWlkLmxvZ1xuICAgICAqIE1lbWJlcnMgd2l0aCBhIGhpZ2hlciB2YWx1ZSBvZiB0aGUgXCJwcmlvcml0eVwiIGZpZWxkIHJlcHJlc2VudCBsb3dlciBwcmlvcml0eSBsb2dnaW5nIGxldmVscyAqL1xuICAgIC8vIE1vdmVkIGRvd24gaGVyZSBzaW5jZSBpdCB1c2VzIGZsdWlkLnRyYW5zZm9ybSBvbiBzdGFydHVwXG4gICAgZmx1aWQubG9nTGV2ZWwgPSBmbHVpZC50cmFuc2Zvcm0oZmx1aWQubG9nTGV2ZWxzU3BlYywgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIHt0eXBlOiBcImZsdWlkLm1hcmtlclwiLCB2YWx1ZToga2V5LCBwcmlvcml0eTogdmFsdWV9O1xuICAgIH0pO1xuICAgIHZhciBsb2dMZXZlbFN0YWNrID0gW2ZsdWlkLmxvZ0xldmVsLklNUE9SVEFOVF07IC8vIFRoZSBzdGFjayBvZiBhY3RpdmUgbG9nZ2luZyBsZXZlbHMsIHdpdGggdGhlIGN1cnJlbnQgbGV2ZWwgYXQgaW5kZXggMFxuXG4gICAgLyoqIEEgc2V0IG9mIHNwZWNpYWwgXCJtYXJrZXIgdmFsdWVzXCIgdXNlZCBpbiBzaWduYWxsaW5nIGluIGZ1bmN0aW9uIGFyZ3VtZW50cyBhbmQgcmV0dXJuIHZhbHVlcyxcbiAgICAgICogdG8gcGFydGlhbGx5IGNvbXBlbnNhdGUgZm9yIEphdmFTY3JpcHQncyBsYWNrIG9mIGRpc3Rpbmd1aXNoZWQgdHlwZXMuIFRoZXNlIHNob3VsZCBuZXZlciBhcHBlYXJcbiAgICAgICogaW4gSlNPTiBzdHJ1Y3R1cmVzIG9yIG90aGVyIGtpbmRzIG9mIHN0YXRpYyBjb25maWd1cmF0aW9uLiBBbiBBUEkgc3BlY2lmaWNhbGx5IGRvY3VtZW50cyBpZiBpdFxuICAgICAgKiBhY2NlcHRzIG9yIHJldHVybnMgYW55IG9mIHRoZXNlIHZhbHVlcywgYW5kIGlmIHNvLCB3aGF0IGl0cyBzZW1hbnRpYyBpcyAgLSBtb3N0IGFyZSBvZiBwcml2YXRlXG4gICAgICAqIHVzZSBpbnRlcm5hbCB0byB0aGUgZnJhbWV3b3JrICoqL1xuXG4gICAgLyoqIEEgc3BlY2lhbCBcIm1hcmtlciBvYmplY3RcIiByZXByZXNlbnRpbmcgdGhhdCBhIGRpc3Rpbmd1aXNoZWRcbiAgICAgKiAocHJvYmFibHkgY29udGV4dC1kZXBlbmRlbnQpIHZhbHVlIHNob3VsZCBiZSBzdWJzdGl0dXRlZC5cbiAgICAgKi9cbiAgICBmbHVpZC5WQUxVRSA9IHt0eXBlOiBcImZsdWlkLm1hcmtlclwiLCB2YWx1ZTogXCJWQUxVRVwifTtcblxuICAgIC8qKiBBIHNwZWNpYWwgXCJtYXJrZXIgb2JqZWN0XCIgcmVwcmVzZW50aW5nIHRoYXQgbm8gdmFsdWUgaXMgcHJlc2VudCAod2hlcmVcbiAgICAgKiBzaWduYWxsaW5nIHVzaW5nIHRoZSB2YWx1ZSBcInVuZGVmaW5lZFwiIGlzIG5vdCBwb3NzaWJsZSAtIGUuZy4gdGhlIHJldHVybiB2YWx1ZSBmcm9tIGEgXCJzdHJhdGVneVwiKSAqL1xuICAgIGZsdWlkLk5PX1ZBTFVFID0ge3R5cGU6IFwiZmx1aWQubWFya2VyXCIsIHZhbHVlOiBcIk5PX1ZBTFVFXCJ9O1xuXG4gICAgLyoqIEEgbWFya2VyIGluZGljYXRpbmcgdGhhdCBhIHZhbHVlIHJlcXVpcmVzIHRvIGJlIGV4cGFuZGVkIGFmdGVyIGNvbXBvbmVudCBjb25zdHJ1Y3Rpb24gYmVnaW5zICoqL1xuICAgIGZsdWlkLkVYUEFORCA9IHt0eXBlOiBcImZsdWlkLm1hcmtlclwiLCB2YWx1ZTogXCJFWFBBTkRcIn07XG4gICAgLyoqIEEgbWFya2VyIGluZGljYXRpbmcgdGhhdCBhIHZhbHVlIHJlcXVpcmVzIHRvIGJlIGV4cGFuZGVkIGltbWVkaWF0ZWx5ICoqL1xuICAgIGZsdWlkLkVYUEFORF9OT1cgPSB7dHlwZTogXCJmbHVpZC5tYXJrZXJcIiwgdmFsdWU6IFwiRVhQQU5EX05PV1wifTtcblxuICAgIC8qKiBEZXRlcm1pbmUgd2hldGhlciBhbiBvYmplY3QgaXMgYW55IG1hcmtlciwgb3IgYSBwYXJ0aWN1bGFyIG1hcmtlciAtIG9taXQgdGhlXG4gICAgICogMm5kIGFyZ3VtZW50IHRvIGRldGVjdCBhbnkgbWFya2VyXG4gICAgICovXG4gICAgZmx1aWQuaXNNYXJrZXIgPSBmdW5jdGlvbiAodG90ZXN0LCB0eXBlKSB7XG4gICAgICAgIGlmICghdG90ZXN0IHx8IHR5cGVvZiAodG90ZXN0KSAhPT0gXCJvYmplY3RcIiB8fCB0b3Rlc3QudHlwZSAhPT0gXCJmbHVpZC5tYXJrZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvdGVzdC52YWx1ZSA9PT0gdHlwZS52YWx1ZTtcbiAgICB9O1xuXG4gICAgLy8gTW9kZWwgZnVuY3Rpb25zXG4gICAgZmx1aWQubW9kZWwgPSB7fTsgLy8gY2Fubm90IGNhbGwgcmVnaXN0ZXJOYW1lc3BhY2UgeWV0IHNpbmNlIGl0IGRlcGVuZHMgb24gZmx1aWQubW9kZWxcblxuICAgIC8qKiBDb3B5IGEgc291cmNlIFwibW9kZWxcIiBvbnRvIGEgdGFyZ2V0ICoqL1xuICAgIGZsdWlkLm1vZGVsLmNvcHlNb2RlbCA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgICBmbHVpZC5jbGVhcih0YXJnZXQpO1xuICAgICAgICAkLmV4dGVuZCh0cnVlLCB0YXJnZXQsIHNvdXJjZSk7XG4gICAgfTtcblxuICAgIC8qKiBQYXJzZSBhbiBFTCBleHByZXNzaW9uIHNlcGFyYXRlZCBieSBwZXJpb2RzICguKSBpbnRvIGl0cyBjb21wb25lbnQgc2VnbWVudHMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IEVMIFRoZSBFTCBleHByZXNzaW9uIHRvIGJlIHNwbGl0XG4gICAgICogQHJldHVybiB7QXJyYXkgb2YgU3RyaW5nfSB0aGUgY29tcG9uZW50IHBhdGggZXhwcmVzc2lvbnMuXG4gICAgICogVE9ETzogVGhpcyBuZWVkcyB0byBiZSB1cGdyYWRlZCB0byBoYW5kbGUgKHRoZSBzYW1lKSBlc2NhcGluZyBydWxlcyAoYXMgUlNGKSwgc28gdGhhdFxuICAgICAqIHBhdGggc2VnbWVudHMgY29udGFpbmluZyBwZXJpb2RzIGFuZCBiYWNrc2xhc2hlcyBldGMuIGNhbiBiZSBwcm9jZXNzZWQsIGFuZCBiZSBoYXJtb25pc2VkXG4gICAgICogd2l0aCB0aGUgbW9yZSBjb21wbGV4IGltcGxlbWVudGF0aW9ucyBpbiBmbHVpZC5wYXRoVXRpbChkYXRhIGJpbmRpbmcpLlxuICAgICAqL1xuICAgIGZsdWlkLm1vZGVsLnBhcnNlRUwgPSBmdW5jdGlvbiAoRUwpIHtcbiAgICAgICAgcmV0dXJuIEVMID09PSBcIlwiID8gW10gOiBTdHJpbmcoRUwpLnNwbGl0KFwiLlwiKTtcbiAgICB9O1xuXG4gICAgLyoqIENvbXBvc2UgYW4gRUwgZXhwcmVzc2lvbiBmcm9tIHR3byBzZXBhcmF0ZSBFTCBleHByZXNzaW9ucy4gVGhlIHJldHVybmVkXG4gICAgICogZXhwcmVzc2lvbiB3aWxsIGJlIHRoZSBvbmUgdGhhdCB3aWxsIG5hdmlnYXRlIHRoZSBmaXJzdCBleHByZXNzaW9uLCBhbmQgdGhlblxuICAgICAqIHRoZSBzZWNvbmQsIGZyb20gdGhlIHZhbHVlIHJlYWNoZWQgYnkgdGhlIGZpcnN0LiBFaXRoZXIgcHJlZml4IG9yIHN1ZmZpeCBtYXkgYmVcbiAgICAgKiB0aGUgZW1wdHkgc3RyaW5nICoqL1xuXG4gICAgZmx1aWQubW9kZWwuY29tcG9zZVBhdGggPSBmdW5jdGlvbiAocHJlZml4LCBzdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIHByZWZpeCA9PT0gXCJcIiA/IHN1ZmZpeCA6IChzdWZmaXggPT09IFwiXCIgPyBwcmVmaXggOiBwcmVmaXggKyBcIi5cIiArIHN1ZmZpeCk7XG4gICAgfTtcblxuICAgIC8qKiBDb21wb3NlIGFueSBudW1iZXIgb2YgcGF0aCBzZWdtZW50cywgbm9uZSBvZiB3aGljaCBtYXkgYmUgZW1wdHkgKiovXG4gICAgZmx1aWQubW9kZWwuY29tcG9zZVNlZ21lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmx1aWQubWFrZUFycmF5KGFyZ3VtZW50cykuam9pbihcIi5cIik7XG4gICAgfTtcblxuICAgIC8qKiBIZWxwZnVsIGFsaWFzIGZvciBvbGQtc3R5bGUgQVBJICoqL1xuICAgIGZsdWlkLnBhdGggPSBmbHVpZC5tb2RlbC5jb21wb3NlU2VnbWVudHM7XG4gICAgZmx1aWQuY29tcG9zZVBhdGggPSBmbHVpZC5tb2RlbC5jb21wb3NlUGF0aDtcblxuXG4gICAgLy8gdW5zdXBwb3J0ZWQsIE5PTi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5yZXF1aXJlRGF0YUJpbmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZsdWlkLmZhaWwoXCJQbGVhc2UgaW5jbHVkZSBEYXRhQmluZGluZy5qcyBpbiBvcmRlciB0byBvcGVyYXRlIGNvbXBsZXggbW9kZWwgYWNjZXNzb3IgY29uZmlndXJhdGlvblwiKTtcbiAgICB9O1xuXG4gICAgZmx1aWQubW9kZWwuc2V0V2l0aFN0cmF0ZWd5ID0gZmx1aWQubW9kZWwuZ2V0V2l0aFN0cmF0ZWd5ID0gZmx1aWQucmVxdWlyZURhdGFCaW5kaW5nO1xuXG4gICAgLy8gdW5zdXBwb3J0ZWQsIE5PTi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5tb2RlbC5yZXNvbHZlUGF0aFNlZ21lbnQgPSBmdW5jdGlvbiAocm9vdCwgc2VnbWVudCwgY3JlYXRlLCBvcmlnRW52KSB7XG4gICAgICAgIGlmICghb3JpZ0VudiAmJiByb290LnJlc29sdmVQYXRoU2VnbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHJvb3QucmVzb2x2ZVBhdGhTZWdtZW50KHNlZ21lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjcmVhdGUgJiYgcm9vdFtzZWdtZW50XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBUaGlzIG9wdGltaXNhdGlvbiBpbiB0aGlzIGhlYXZpbHkgdXNlZCBmdW5jdGlvbiBoYXMgYSBmYWlyIGVmZmVjdFxuICAgICAgICAgICAgcmV0dXJuIHJvb3Rbc2VnbWVudF0gPSB7fTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvb3Rbc2VnbWVudF07XG4gICAgfTtcblxuICAgIC8vIHVuc3VwcG9ydGVkLCBOT04tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQubW9kZWwucGF0aFRvU2VnbWVudHMgPSBmdW5jdGlvbiAoRUwsIGNvbmZpZykge1xuICAgICAgICB2YXIgcGFyc2VyID0gY29uZmlnICYmIGNvbmZpZy5wYXJzZXIgPyBjb25maWcucGFyc2VyLnBhcnNlIDogZmx1aWQubW9kZWwucGFyc2VFTDtcbiAgICAgICAgdmFyIHNlZ3MgPSB0eXBlb2YoRUwpID09PSBcIm51bWJlclwiIHx8IHR5cGVvZihFTCkgPT09IFwic3RyaW5nXCIgPyBwYXJzZXIoRUwpIDogRUw7XG4gICAgICAgIHJldHVybiBzZWdzO1xuICAgIH07XG5cbiAgICAvLyBPdmVyYWxsIHN0cmF0ZWd5IHNrZWxldG9uIGZvciBhbGwgaW1wbGVtZW50YXRpb25zIG9mIGZsdWlkLmdldC9zZXRcbiAgICBmbHVpZC5tb2RlbC5hY2Nlc3NJbXBsID0gZnVuY3Rpb24gKHJvb3QsIEVMLCBuZXdWYWx1ZSwgY29uZmlnLCBpbml0U2VncywgcmV0dXJuU2VncywgdHJhdmVyc2VyKSB7XG4gICAgICAgIHZhciBzZWdzID0gZmx1aWQubW9kZWwucGF0aFRvU2VnbWVudHMoRUwsIGNvbmZpZyk7XG4gICAgICAgIHZhciBpbml0UG9zID0gMDtcbiAgICAgICAgaWYgKGluaXRTZWdzKSB7XG4gICAgICAgICAgICBpbml0UG9zID0gaW5pdFNlZ3MubGVuZ3RoO1xuICAgICAgICAgICAgc2VncyA9IGluaXRTZWdzLmNvbmNhdChzZWdzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdW5jZXNzID0gbmV3VmFsdWUgPT09IGZsdWlkLk5PX1ZBTFVFID8gMCA6IDE7XG4gICAgICAgIHJvb3QgPSB0cmF2ZXJzZXIocm9vdCwgc2VncywgaW5pdFBvcywgY29uZmlnLCB1bmNlc3MpO1xuICAgICAgICBpZiAobmV3VmFsdWUgPT09IGZsdWlkLk5PX1ZBTFVFIHx8IG5ld1ZhbHVlID09PSBmbHVpZC5WQUxVRSkgeyAvLyBnZXQgb3IgY3VzdG9tXG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuU2VncyA/IHtyb290OiByb290LCBzZWdzOiBzZWdzfSA6IHJvb3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIHNldFxuICAgICAgICAgICAgcm9vdFtzZWdzW3NlZ3MubGVuZ3RoIC0gMV1dID0gbmV3VmFsdWU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gdW5zdXBwb3J0ZWQsIE5PTi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5tb2RlbC5hY2Nlc3NTaW1wbGUgPSBmdW5jdGlvbiAocm9vdCwgRUwsIG5ld1ZhbHVlLCBlbnZpcm9ubWVudCwgaW5pdFNlZ3MsIHJldHVyblNlZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZsdWlkLm1vZGVsLmFjY2Vzc0ltcGwocm9vdCwgRUwsIG5ld1ZhbHVlLCBlbnZpcm9ubWVudCwgaW5pdFNlZ3MsIHJldHVyblNlZ3MsIGZsdWlkLm1vZGVsLnRyYXZlcnNlU2ltcGxlKTtcbiAgICB9O1xuXG4gICAgLy8gdW5zdXBwb3J0ZWQsIE5PTi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5tb2RlbC50cmF2ZXJzZVNpbXBsZSA9IGZ1bmN0aW9uIChyb290LCBzZWdzLCBpbml0UG9zLCBlbnZpcm9ubWVudCwgdW5jZXNzKSB7XG4gICAgICAgIHZhciBvcmlnRW52ID0gZW52aXJvbm1lbnQ7XG4gICAgICAgIHZhciBsaW1pdCA9IHNlZ3MubGVuZ3RoIC0gdW5jZXNzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbWl0OyArK2kpIHtcbiAgICAgICAgICAgIGlmICghcm9vdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNlZ21lbnQgPSBzZWdzW2ldO1xuICAgICAgICAgICAgaWYgKGVudmlyb25tZW50ICYmIGVudmlyb25tZW50W3NlZ21lbnRdKSB7XG4gICAgICAgICAgICAgICAgcm9vdCA9IGVudmlyb25tZW50W3NlZ21lbnRdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByb290ID0gZmx1aWQubW9kZWwucmVzb2x2ZVBhdGhTZWdtZW50KHJvb3QsIHNlZ21lbnQsIHVuY2VzcyA9PT0gMSwgb3JpZ0Vudik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbnZpcm9ubWVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfTtcblxuICAgIGZsdWlkLm1vZGVsLnNldFNpbXBsZSA9IGZ1bmN0aW9uIChyb290LCBFTCwgbmV3VmFsdWUsIGVudmlyb25tZW50LCBpbml0U2Vncykge1xuICAgICAgICBmbHVpZC5tb2RlbC5hY2Nlc3NTaW1wbGUocm9vdCwgRUwsIG5ld1ZhbHVlLCBlbnZpcm9ubWVudCwgaW5pdFNlZ3MsIGZhbHNlKTtcbiAgICB9O1xuXG4gICAgLyoqIE9wdGltaXNlZCB2ZXJzaW9uIG9mIGZsdWlkLmdldCBmb3IgdW5jdXN0b21pc2VkIGNvbmZpZ3VyYXRpb25zICoqL1xuXG4gICAgZmx1aWQubW9kZWwuZ2V0U2ltcGxlID0gZnVuY3Rpb24gKHJvb3QsIEVMLCBlbnZpcm9ubWVudCwgaW5pdFNlZ3MpIHtcbiAgICAgICAgaWYgKEVMID09PSBudWxsIHx8IEVMID09PSB1bmRlZmluZWQgfHwgRUwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmx1aWQubW9kZWwuYWNjZXNzU2ltcGxlKHJvb3QsIEVMLCBmbHVpZC5OT19WQUxVRSwgZW52aXJvbm1lbnQsIGluaXRTZWdzLCBmYWxzZSk7XG4gICAgfTtcblxuICAgIC8vIHVuc3VwcG9ydGVkLCBOT04tQVBJIGZ1bmN0aW9uXG4gICAgLy8gUmV0dXJucyB1bmRlZmluZWQgdG8gc2lnbmFsIGNvbXBsZXggY29uZmlndXJhdGlvbiB3aGljaCBuZWVkcyB0byBiZSBmYXJtZWQgb3V0IHRvIERhdGFCaW5kaW5nLmpzXG4gICAgLy8gYW55IG90aGVyIHJldHVybiByZXByZXNlbnRzIGFuIGVudmlyb25tZW50IHZhbHVlIEFORCBhIHNpbXBsZSBjb25maWd1cmF0aW9uIHdlIGNhbiBoYW5kbGUgaGVyZVxuICAgIGZsdWlkLmRlY29kZUFjY2Vzc29yQXJnID0gZnVuY3Rpb24gKGFyZzMpIHtcbiAgICAgICAgcmV0dXJuICghYXJnMyB8fCBhcmczID09PSBmbHVpZC5tb2RlbC5kZWZhdWx0R2V0Q29uZmlnIHx8IGFyZzMgPT09IGZsdWlkLm1vZGVsLmRlZmF1bHRTZXRDb25maWcpID9cbiAgICAgICAgICAgIG51bGwgOiAoYXJnMy50eXBlID09PSBcImVudmlyb25tZW50XCIgPyBhcmczLnZhbHVlIDogdW5kZWZpbmVkKTtcbiAgICB9O1xuXG4gICAgZmx1aWQuc2V0ID0gZnVuY3Rpb24gKHJvb3QsIEVMLCBuZXdWYWx1ZSwgY29uZmlnLCBpbml0U2Vncykge1xuICAgICAgICB2YXIgZW52ID0gZmx1aWQuZGVjb2RlQWNjZXNzb3JBcmcoY29uZmlnKTtcbiAgICAgICAgaWYgKGVudiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmbHVpZC5tb2RlbC5zZXRXaXRoU3RyYXRlZ3kocm9vdCwgRUwsIG5ld1ZhbHVlLCBjb25maWcsIGluaXRTZWdzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZsdWlkLm1vZGVsLnNldFNpbXBsZShyb290LCBFTCwgbmV3VmFsdWUsIGVudiwgaW5pdFNlZ3MpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKiBFdmFsdWF0ZXMgYW4gRUwgZXhwcmVzc2lvbiBieSBmZXRjaGluZyBhIGRvdC1zZXBhcmF0ZWQgbGlzdCBvZiBtZW1iZXJzXG4gICAgICogcmVjdXJzaXZlbHkgZnJvbSBhIHByb3ZpZGVkIHJvb3QuXG4gICAgICogQHBhcmFtIHJvb3QgVGhlIHJvb3QgZGF0YSBzdHJ1Y3R1cmUgaW4gd2hpY2ggdGhlIEVMIGV4cHJlc3Npb24gaXMgdG8gYmUgZXZhbHVhdGVkXG4gICAgICogQHBhcmFtIHtzdHJpbmcvYXJyYXl9IEVMIFRoZSBFTCBleHByZXNzaW9uIHRvIGJlIGV2YWx1YXRlZCwgb3IgYW4gYXJyYXkgb2YgcGF0aCBzZWdtZW50c1xuICAgICAqIEBwYXJhbSBjb25maWcgQW4gb3B0aW9uYWwgY29uZmlndXJhdGlvbiBvciBlbnZpcm9ubWVudCBzdHJ1Y3R1cmUgd2hpY2ggY2FuIGN1c3RvbWlzZSB0aGUgZmV0Y2ggb3BlcmF0aW9uXG4gICAgICogQHJldHVybiBUaGUgZmV0Y2hlZCBkYXRhIHZhbHVlLlxuICAgICAqL1xuXG4gICAgZmx1aWQuZ2V0ID0gZnVuY3Rpb24gKHJvb3QsIEVMLCBjb25maWcsIGluaXRTZWdzKSB7XG4gICAgICAgIHZhciBlbnYgPSBmbHVpZC5kZWNvZGVBY2Nlc3NvckFyZyhjb25maWcpO1xuICAgICAgICByZXR1cm4gZW52ID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgZmx1aWQubW9kZWwuZ2V0V2l0aFN0cmF0ZWd5KHJvb3QsIEVMLCBjb25maWcsIGluaXRTZWdzKVxuICAgICAgICAgICAgOiBmbHVpZC5tb2RlbC5hY2Nlc3NJbXBsKHJvb3QsIEVMLCBmbHVpZC5OT19WQUxVRSwgZW52LCBudWxsLCBmYWxzZSwgZmx1aWQubW9kZWwudHJhdmVyc2VTaW1wbGUpO1xuICAgIH07XG5cbiAgICAvLyBUaGlzIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgd2lsbCBiZSBtYWludGFpbmVkIGZvciBhIG51bWJlciBvZiByZWxlYXNlcywgcHJvYmFibHkgdW50aWwgRmx1aWQgMi4wXG4gICAgZmx1aWQubW9kZWwuc2V0QmVhblZhbHVlID0gZmx1aWQuc2V0O1xuICAgIGZsdWlkLm1vZGVsLmdldEJlYW5WYWx1ZSA9IGZsdWlkLmdldDtcblxuICAgIGZsdWlkLmdldEdsb2JhbFZhbHVlID0gZnVuY3Rpb24gKHBhdGgsIGVudikge1xuICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgZW52ID0gZW52IHx8IGZsdWlkLmVudmlyb25tZW50O1xuICAgICAgICAgICAgcmV0dXJuIGZsdWlkLmdldChmbHVpZC5nbG9iYWwsIHBhdGgsIHt0eXBlOiBcImVudmlyb25tZW50XCIsIHZhbHVlOiBlbnZ9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBbGxvd3MgZm9yIHRoZSBiaW5kaW5nIHRvIGEgXCJ0aGlzLWlzdFwiIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiwgXCJ0aGlzLWlzdFwiIG9iamVjdCB0byBiaW5kIHRvXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGZuTmFtZSwgdGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uIHRvIGNhbGxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJncywgYXJndW1lbnRzIHRvIGNhbGwgdGhlIGZ1bmN0aW9uIHdpdGhcbiAgICAgKi9cbiAgICBmbHVpZC5iaW5kID0gZnVuY3Rpb24gKG9iaiwgZm5OYW1lLCBhcmdzKSB7XG4gICAgICAgIHJldHVybiBvYmpbZm5OYW1lXS5hcHBseShvYmosIGZsdWlkLm1ha2VBcnJheShhcmdzKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFsbG93cyBmb3IgdGhlIGNhbGxpbmcgb2YgYSBmdW5jdGlvbiBmcm9tIGFuIEVMIGV4cHJlc3Npb24gXCJmdW5jdGlvblBhdGhcIiwgd2l0aCB0aGUgYXJndW1lbnRzIFwiYXJnc1wiLCBzY29wZWQgdG8gYW4gZnJhbWV3b3JrIHZlcnNpb24gXCJlbnZpcm9ubWVudFwiLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmdW5jdGlvblBhdGggLSBBbiBFTCBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3MgLSBBbiBhcnJheSBvZiBhcmd1bWVudHMgdG8gYmUgYXBwbGllZCB0byB0aGUgZnVuY3Rpb24sIHNwZWNpZmllZCBpbiBmdW5jdGlvblBhdGhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZW52aXJvbm1lbnQgLSAob3B0aW9uYWwpIFRoZSBvYmplY3QgdG8gc2NvcGUgdGhlIGZ1bmN0aW9uUGF0aCB0byAgKHR5cGljYWxseSB0aGUgZnJhbWV3b3JrIHJvb3QgZm9yIHZlcnNpb24gY29udHJvbClcbiAgICAgKi9cbiAgICBmbHVpZC5pbnZva2VHbG9iYWxGdW5jdGlvbiA9IGZ1bmN0aW9uIChmdW5jdGlvblBhdGgsIGFyZ3MsIGVudmlyb25tZW50KSB7XG4gICAgICAgIHZhciBmdW5jID0gZmx1aWQuZ2V0R2xvYmFsVmFsdWUoZnVuY3Rpb25QYXRoLCBlbnZpcm9ubWVudCk7XG4gICAgICAgIGlmICghZnVuYykge1xuICAgICAgICAgICAgZmx1aWQuZmFpbChcIkVycm9yIGludm9raW5nIGdsb2JhbCBmdW5jdGlvbjogXCIgKyBmdW5jdGlvblBhdGggKyBcIiBjb3VsZCBub3QgYmUgbG9jYXRlZFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZMVUlELTQ5MTU6IEZpeGVzIGFuIGlzc3VlIGZvciBJRTggYnkgZGVmYXVsdGluZyB0byBhbiBlbXB0eSBhcnJheSB3aGVuIGFyZ3MgYXJlIGZhbHNleS5cbiAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KG51bGwsIGFyZ3MgfHwgW10pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKiBSZWdpc3RlcnMgYSBuZXcgZ2xvYmFsIGZ1bmN0aW9uIGF0IGEgZ2l2ZW4gcGF0aFxuICAgICAqL1xuXG4gICAgZmx1aWQucmVnaXN0ZXJHbG9iYWxGdW5jdGlvbiA9IGZ1bmN0aW9uIChmdW5jdGlvblBhdGgsIGZ1bmMsIGVudikge1xuICAgICAgICBlbnYgPSBlbnYgfHwgZmx1aWQuZW52aXJvbm1lbnQ7XG4gICAgICAgIGZsdWlkLnNldChmbHVpZC5nbG9iYWwsIGZ1bmN0aW9uUGF0aCwgZnVuYywge3R5cGU6IFwiZW52aXJvbm1lbnRcIiwgdmFsdWU6IGVudn0pO1xuICAgIH07XG5cbiAgICBmbHVpZC5zZXRHbG9iYWxWYWx1ZSA9IGZsdWlkLnJlZ2lzdGVyR2xvYmFsRnVuY3Rpb247XG5cbiAgICAvKiogRW5zdXJlcyB0aGF0IGFuIGVudHJ5IGluIHRoZSBnbG9iYWwgbmFtZXNwYWNlIGV4aXN0cy4gSWYgaXQgZG9lcyBub3QsIGEgbmV3IGVudHJ5IGlzIGNyZWF0ZWQgYXMge30gYW5kIHJldHVybmVkLiBJZiBhbiBleGlzdGluZ1xuICAgICAqIHZhbHVlIGlzIGZvdW5kLCBpdCBpcyByZXR1cm5lZCBpbnN0ZWFkICoqL1xuICAgIGZsdWlkLnJlZ2lzdGVyTmFtZXNwYWNlID0gZnVuY3Rpb24gKG5haW1zcGFjZSwgZW52KSB7XG4gICAgICAgIGVudiA9IGVudiB8fCBmbHVpZC5lbnZpcm9ubWVudDtcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gZmx1aWQuZ2V0R2xvYmFsVmFsdWUobmFpbXNwYWNlLCBlbnYpO1xuICAgICAgICBpZiAoIWV4aXN0aW5nKSB7XG4gICAgICAgICAgICBleGlzdGluZyA9IHt9O1xuICAgICAgICAgICAgZmx1aWQuc2V0R2xvYmFsVmFsdWUobmFpbXNwYWNlLCBleGlzdGluZywgZW52KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfTtcblxuICAgIC8vIHN0dWJzIGZvciB0d28gZnVuY3Rpb25zIGluIEZsdWlkRGVidWdnaW5nLmpzXG4gICAgZmx1aWQuZHVtcEVsID0gZmx1aWQuaWRlbnRpdHk7XG4gICAgZmx1aWQucmVuZGVyVGltZXN0YW1wID0gZmx1aWQuaWRlbnRpdHk7XG5cblxuICAgIC8qKiogVGhlIE1vZGVsIEV2ZW50cyBzeXN0ZW0uICoqKi9cblxuICAgIGZsdWlkLnJlZ2lzdGVyTmFtZXNwYWNlKFwiZmx1aWQuZXZlbnRcIik7XG5cbiAgICBmbHVpZC5nZW5lcmF0ZVVuaXF1ZVByZWZpeCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxZTEyKSkudG9TdHJpbmcoMzYpICsgXCItXCI7XG4gICAgfTtcblxuICAgIHZhciBmbHVpZF9wcmVmaXggPSBmbHVpZC5nZW5lcmF0ZVVuaXF1ZVByZWZpeCgpO1xuXG4gICAgZmx1aWQuZmx1aWRJbnN0YW5jZSA9IGZsdWlkX3ByZWZpeDtcblxuICAgIHZhciBmbHVpZF9ndWlkID0gMTtcblxuICAgIC8qKiBBbGxvY2F0ZSBhbiBzdHJpbmcgdmFsdWUgdGhhdCB3aWxsIGJlIHZlcnkgbGlrZWx5IHVuaXF1ZSB3aXRoaW4gdGhpcyBGbHVpZCBzY29wZSAoZnJhbWUgb3IgcHJvY2VzcykgKiovXG5cbiAgICBmbHVpZC5hbGxvY2F0ZUd1aWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmbHVpZF9wcmVmaXggKyAoZmx1aWRfZ3VpZCsrKTtcbiAgICB9O1xuXG4gICAgZmx1aWQuZXZlbnQuaWRlbnRpZnlMaXN0ZW5lciA9IGZ1bmN0aW9uIChsaXN0ZW5lciwgc29mdCkge1xuICAgICAgICBpZiAodHlwZW9mKGxpc3RlbmVyKSAhPT0gXCJzdHJpbmdcIiAmJiAhbGlzdGVuZXIuJCRmbHVpZF9ndWlkICYmICFzb2Z0KSB7XG4gICAgICAgICAgICBsaXN0ZW5lci4kJGZsdWlkX2d1aWQgPSBmbHVpZC5hbGxvY2F0ZUd1aWQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlzdGVuZXIuJCRmbHVpZF9ndWlkO1xuICAgIH07XG5cbiAgICAvLyB1bnN1cHBvcnRlZCwgTk9OLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLmV2ZW50LmltcGVyc29uYXRlTGlzdGVuZXIgPSBmdW5jdGlvbiAob3JpZ0xpc3RlbmVyLCBuZXdMaXN0ZW5lcikge1xuICAgICAgICBmbHVpZC5ldmVudC5pZGVudGlmeUxpc3RlbmVyKG9yaWdMaXN0ZW5lcik7XG4gICAgICAgIG5ld0xpc3RlbmVyLiQkZmx1aWRfZ3VpZCA9IG9yaWdMaXN0ZW5lci4kJGZsdWlkX2d1aWQ7XG4gICAgfTtcblxuICAgIC8vIHVuc3VwcG9ydGVkLCBOT04tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQuZXZlbnQubWFwUHJpb3JpdHkgPSBmdW5jdGlvbiAocHJpb3JpdHksIGNvdW50KSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkIHJlc3BlY3QgYm90aCBwcmlvcml0eSBhbmQgY291bnQgYnkgYSBiaXQtcGFydGl0aW9uaW5nIHNjaGVtZVxuICAgICAgICByZXR1cm4gKHByaW9yaXR5ID09PSBudWxsIHx8IHByaW9yaXR5ID09PSB1bmRlZmluZWQgPyBjb3VudCA6XG4gICAgICAgICAgIChwcmlvcml0eSA9PT0gXCJsYXN0XCIgPyBOdW1iZXIuTUFYX1ZBTFVFIDpcbiAgICAgICAgICAgICAgKHByaW9yaXR5ID09PSBcImZpcnN0XCIgPyAtTnVtYmVyLk1BWF9WQUxVRSA6IC1wcmlvcml0eSkpKTtcbiAgICB9O1xuXG4gICAgLy8gdW5zdXBwb3J0ZWQsIE5PTi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5wcmlvcml0eUNvbXBhcmF0b3IgPSBmdW5jdGlvbiAocmVjQSwgcmVjQikge1xuICAgICAgICByZXR1cm4gcmVjQS5wcmlvcml0eSAtIHJlY0IucHJpb3JpdHk7XG4gICAgfTtcblxuICAgIC8vIHVuc3VwcG9ydGVkLCBOT04tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQuZXZlbnQuc29ydExpc3RlbmVycyA9IGZ1bmN0aW9uIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgdmFyIHRvZ28gPSBbXTtcbiAgICAgICAgZmx1aWQuZWFjaChsaXN0ZW5lcnMsIGZ1bmN0aW9uIChvbmVOYW1lc3BhY2UpIHtcbiAgICAgICAgICAgIHZhciBoZWFkSGFyZDsgLy8gbm90aWZ5IG9ubHkgdGhlIGZpcnN0IGxpc3RlbmVyIHdpdGggaGFyZCBuYW1lc3BhY2UgLSBvciBlbHNlIGFsbCBpZiBhbGwgYXJlIHNvZnRcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb25lTmFtZXNwYWNlLmxlbmd0aDsgKysgaSkge1xuICAgICAgICAgICAgICAgIHZhciB0aGlzTGlzdGVuZXIgPSBvbmVOYW1lc3BhY2VbaV07XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzTGlzdGVuZXIuc29mdE5hbWVzcGFjZSAmJiAhaGVhZEhhcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZEhhcmQgPSB0aGlzTGlzdGVuZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhlYWRIYXJkKSB7XG4gICAgICAgICAgICAgICAgdG9nby5wdXNoKGhlYWRIYXJkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9nbyA9IHRvZ28uY29uY2F0KG9uZU5hbWVzcGFjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdG9nby5zb3J0KGZsdWlkLnByaW9yaXR5Q29tcGFyYXRvcik7XG4gICAgfTtcblxuICAgIC8vIHVuc3VwcG9ydGVkLCBub24tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQuZXZlbnQuaW52b2tlTGlzdGVuZXIgPSBmdW5jdGlvbiAobGlzdGVuZXIsIGFyZ3MpIHtcbiAgICAgICAgaWYgKHR5cGVvZihsaXN0ZW5lcikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyID0gZmx1aWQuZXZlbnQucmVzb2x2ZUxpc3RlbmVyKHtnbG9iYWxOYW1lOiBsaXN0ZW5lcn0pOyAvLyBqdXN0IHJlc29sdmVzIGdsb2JhbHNcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlzdGVuZXIuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfTtcblxuICAgIC8vIHVuc3VwcG9ydGVkLCBOT04tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQuZXZlbnQucmVzb2x2ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIGlmIChsaXN0ZW5lci5nbG9iYWxOYW1lKSB7XG4gICAgICAgICAgICB2YXIgbGlzdGVuZXJGdW5jID0gZmx1aWQuZ2V0R2xvYmFsVmFsdWUobGlzdGVuZXIuZ2xvYmFsTmFtZSk7XG4gICAgICAgICAgICBpZiAoIWxpc3RlbmVyRnVuYykge1xuICAgICAgICAgICAgICAgIGZsdWlkLmZhaWwoXCJVbmFibGUgdG8gbG9vayB1cCBuYW1lIFwiICsgbGlzdGVuZXIuZ2xvYmFsTmFtZSArIFwiIGFzIGEgZ2xvYmFsIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyRnVuYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlzdGVuZXI7XG4gICAgfTtcblxuICAgIC8qKiBHZW5lcmF0ZSBhIG5hbWUgZm9yIGEgY29tcG9uZW50IGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMgKi9cbiAgICBmbHVpZC5uYW1lQ29tcG9uZW50ID0gZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoYXQgPyBcImNvbXBvbmVudCB3aXRoIHR5cGVuYW1lIFwiICsgdGhhdC50eXBlTmFtZSArIFwiIGFuZCBpZCBcIiArIHRoYXQuaWQgOiBcIlt1bmtub3duIGNvbXBvbmVudF1cIjtcbiAgICB9O1xuXG4gICAgZmx1aWQuZXZlbnQubmFtZUV2ZW50ID0gZnVuY3Rpb24gKHRoYXQsIGV2ZW50TmFtZSkge1xuICAgICAgICByZXR1cm4gZXZlbnROYW1lICsgXCIgb2YgXCIgKyBmbHVpZC5uYW1lQ29tcG9uZW50KHRoYXQpO1xuICAgIH07XG5cbiAgICAvKiogQ29uc3RydWN0IGFuIFwiZXZlbnQgZmlyZXJcIiBvYmplY3Qgd2hpY2ggY2FuIGJlIHVzZWQgdG8gcmVnaXN0ZXIgYW5kIGRlcmVnaXN0ZXJcbiAgICAgKiBsaXN0ZW5lcnMsIHRvIHdoaWNoIFwiZXZlbnRzXCIgY2FuIGJlIGZpcmVkLiBUaGVzZSBldmVudHMgY29uc2lzdCBvZiBhbiBhcmJpdHJhcnlcbiAgICAgKiBmdW5jdGlvbiBzaWduYXR1cmUuIEdlbmVyYWwgZG9jdW1lbnRhdGlvbiBvbiB0aGUgRmx1aWQgZXZlbnRzIHN5c3RlbSBpcyBhdFxuICAgICAqIGh0dHA6Ly93aWtpLmZsdWlkcHJvamVjdC5vcmcvZGlzcGxheS9mbHVpZC9UaGUrRmx1aWQrRXZlbnQrU3lzdGVtIC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIEEgc3RydWN0dXJlIHRvIGNvbmZpZ3VyZSB0aGlzIGV2ZW50IGZpcmVyLiBTdXBwb3J0ZWQgZmllbGRzOlxuICAgICAqICAgICB7U3RyaW5nfSBuYW1lIC0gYSBuYW1lIGZvciB0aGlzIGZpcmVyXG4gICAgICogICAgIHtCb29sZWFufSBwcmV2ZW50YWJsZSAtIElmIDxjb2RlPnRydWU8L2NvZGU+IHRoZSByZXR1cm4gdmFsdWUgb2YgZWFjaCBoYW5kbGVyIHdpbGxcbiAgICAgKiBiZSBjaGVja2VkIGZvciA8Y29kZT5mYWxzZTwvY29kZT4gaW4gd2hpY2ggY2FzZSBmdXJ0aGVyIGxpc3RlbmVycyB3aWxsIGJlIHNob3J0Y2lyY3VpdGVkLCBhbmQgdGhpc1xuICAgICAqIHdpbGwgYmUgdGhlIHJldHVybiB2YWx1ZSBvZiBmaXJlKClcbiAgICAgKi9cbiAgICBmbHVpZC5tYWtlRXZlbnRGaXJlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZSB8fCBcIjxhbm9ueW1vdXM+XCI7XG4gICAgICAgIHZhciB0aGF0O1xuICAgICAgICBmdW5jdGlvbiBmaXJlVG9MaXN0ZW5lcnMobGlzdGVuZXJzLCBhcmdzLCB3cmFwcGVyKSB7XG4gICAgICAgICAgICBpZiAoIWxpc3RlbmVycyB8fCB0aGF0LmRlc3Ryb3llZCkgeyByZXR1cm47IH1cbiAgICAgICAgICAgIGZsdWlkLmxvZyhmbHVpZC5sb2dMZXZlbC5UUkFDRSwgXCJGaXJpbmcgZXZlbnQgXCIgKyBuYW1lICsgXCIgdG8gbGlzdCBvZiBcIiArIGxpc3RlbmVycy5sZW5ndGggKyBcIiBsaXN0ZW5lcnNcIik7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBsaXNyZWMgPSBsaXN0ZW5lcnNbaV07XG4gICAgICAgICAgICAgICAgbGlzcmVjLmxpc3RlbmVyID0gZmx1aWQuZXZlbnQucmVzb2x2ZUxpc3RlbmVyKGxpc3JlYy5saXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gbGlzcmVjLmxpc3RlbmVyO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxpc3JlYy5wcmVkaWNhdGUgJiYgIWxpc3JlYy5wcmVkaWNhdGUobGlzdGVuZXIsIGFyZ3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9ICh3cmFwcGVyID8gd3JhcHBlcihsaXN0ZW5lcikgOiBsaXN0ZW5lcikuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucHJldmVudGFibGUgJiYgcmV0ID09PSBmYWxzZSB8fCB0aGF0LmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBpZGVudGlmeSA9IGZsdWlkLmV2ZW50LmlkZW50aWZ5TGlzdGVuZXI7XG5cbiAgICAgICAgdmFyIGxhenlJbml0ID0gZnVuY3Rpb24gKCkgeyAvLyBMYXp5IGluaXQgZnVuY3Rpb24gdG8gZWNvbm9taXNlIG9uIG9iamVjdCByZWZlcmVuY2VzIGZvciBldmVudHMgd2hpY2ggYXJlIG5ldmVyIGxpc3RlbmVkIHRvXG4gICAgICAgICAgICB0aGF0Lmxpc3RlbmVycyA9IHt9O1xuICAgICAgICAgICAgdGhhdC5ieUlkID0ge307XG4gICAgICAgICAgICB0aGF0LnNvcnRlZExpc3RlbmVycyA9IFtdO1xuICAgICAgICAgICAgdGhhdC5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIChsaXN0ZW5lciwgbmFtZXNwYWNlLCBwcmVkaWNhdGUsIHByaW9yaXR5LCBzb2Z0TmFtZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoYXQuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsdWlkLmZhaWwoXCJDYW5ub3QgYWRkIGxpc3RlbmVyIHRvIGRlc3Ryb3llZCBldmVudCBmaXJlciBcIiArIHRoYXQubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mKGxpc3RlbmVyKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IHtnbG9iYWxOYW1lOiBsaXN0ZW5lcn07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBpZCA9IGlkZW50aWZ5KGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2UgPSBuYW1lc3BhY2UgfHwgaWQ7XG4gICAgICAgICAgICAgICAgdmFyIHJlY29yZCA9IHtsaXN0ZW5lcjogbGlzdGVuZXIsIHByZWRpY2F0ZTogcHJlZGljYXRlLFxuICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2U6IG5hbWVzcGFjZSxcbiAgICAgICAgICAgICAgICAgICAgc29mdE5hbWVzcGFjZTogc29mdE5hbWVzcGFjZSxcbiAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHk6IGZsdWlkLmV2ZW50Lm1hcFByaW9yaXR5KHByaW9yaXR5LCB0aGF0LnNvcnRlZExpc3RlbmVycy5sZW5ndGgpfTtcbiAgICAgICAgICAgICAgICB0aGF0LmJ5SWRbaWRdID0gcmVjb3JkO1xuXG4gICAgICAgICAgICAgICAgdmFyIHRoaXNMaXN0ZW5lcnMgPSAodGhhdC5saXN0ZW5lcnNbbmFtZXNwYWNlXSA9IGZsdWlkLm1ha2VBcnJheSh0aGF0Lmxpc3RlbmVyc1tuYW1lc3BhY2VdKSk7XG4gICAgICAgICAgICAgICAgdGhpc0xpc3RlbmVyc1tzb2Z0TmFtZXNwYWNlID8gXCJwdXNoXCIgOiBcInVuc2hpZnRcIl0gKHJlY29yZCk7XG5cbiAgICAgICAgICAgICAgICB0aGF0LnNvcnRlZExpc3RlbmVycyA9IGZsdWlkLmV2ZW50LnNvcnRMaXN0ZW5lcnModGhhdC5saXN0ZW5lcnMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoYXQuYWRkTGlzdGVuZXIuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhhdCA9IHtcbiAgICAgICAgICAgIGV2ZW50SWQ6IGZsdWlkLmFsbG9jYXRlR3VpZCgpLFxuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIG93bmVySWQ6IG9wdGlvbnMub3duZXJJZCxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBcImZsdWlkLmV2ZW50LmZpcmVyXCIsXG4gICAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFkZExpc3RlbmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbGF6eUluaXQuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyOiBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoYXQubGlzdGVuZXJzKSB7IHJldHVybjsgfVxuICAgICAgICAgICAgICAgIHZhciBuYW1lc3BhY2UsIGlkLCByZWNvcmQ7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAobGlzdGVuZXIpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZSA9IGxpc3RlbmVyO1xuICAgICAgICAgICAgICAgICAgICByZWNvcmQgPSB0aGF0Lmxpc3RlbmVyc1tuYW1lc3BhY2VdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlY29yZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZihsaXN0ZW5lcikgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBpZCA9IGlkZW50aWZ5KGxpc3RlbmVyLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmx1aWQuZmFpbChcIkNhbm5vdCByZW1vdmUgdW5yZWdpc3RlcmVkIGxpc3RlbmVyIGZ1bmN0aW9uIFwiLCBsaXN0ZW5lciwgXCIgZnJvbSBldmVudCBcIiArIHRoYXQubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlYyA9IHRoYXQuYnlJZFtpZF07XG4gICAgICAgICAgICAgICAgdmFyIHNvZnROYW1lc3BhY2UgPSByZWMgJiYgcmVjLnNvZnROYW1lc3BhY2U7XG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlID0gbmFtZXNwYWNlIHx8IChyZWMgJiYgcmVjLm5hbWVzcGFjZSkgfHwgaWQ7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoYXQuYnlJZFtpZF07XG4gICAgICAgICAgICAgICAgcmVjb3JkID0gdGhhdC5saXN0ZW5lcnNbbmFtZXNwYWNlXTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlY29yZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzb2Z0TmFtZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsdWlkLnJlbW92ZV9pZihyZWNvcmQsIGZ1bmN0aW9uICh0aGlzTGlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc0xpcy5saXN0ZW5lci4kJGZsdWlkX2d1aWQgPT09IGlkO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWNvcmQuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlY29yZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoYXQubGlzdGVuZXJzW25hbWVzcGFjZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoYXQuc29ydGVkTGlzdGVuZXJzID0gZmx1aWQuZXZlbnQuc29ydExpc3RlbmVycyh0aGF0Lmxpc3RlbmVycyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gTkIgLSB0aGlzIG1ldGhvZCBleGlzdHMgb25seSB0byBzdXBwb3J0IHRoZSBvbGQgQ2hhbmdlQXBwbGllci4gSXQgd2lsbCBiZSByZW1vdmVkIGFsb25nIHdpdGggaXQuXG4gICAgICAgICAgICBmaXJlVG9MaXN0ZW5lcnM6IGZ1bmN0aW9uIChsaXN0ZW5lcnMsIGFyZ3MsIHdyYXBwZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlyZVRvTGlzdGVuZXJzKGxpc3RlbmVycywgYXJncywgd3JhcHBlcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmlyZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaXJlVG9MaXN0ZW5lcnModGhhdC5zb3J0ZWRMaXN0ZW5lcnMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgIH07XG5cbiAgICAvKiogRmlyZSB0aGUgc3BlY2lmaWVkIGV2ZW50IHdpdGggc3VwcGxpZWQgYXJndW1lbnRzLiBUaGlzIGNhbGwgaXMgYW4gb3B0aW1pc2F0aW9uIHV0aWxpdHlcbiAgICAgKiB3aGljaCBoYW5kbGVzIHRoZSBjYXNlIHdoZXJlIHRoZSBmaXJlciBoYXMgbm90IGJlZW4gaW5zdGFudGlhdGVkIChwcmVzdW1hYmx5IGFzIGEgcmVzdWx0XG4gICAgICogb2YgaGF2aW5nIG5vIGxpc3RlbmVycyByZWdpc3RlcmVkKVxuICAgICAqL1xuXG4gICAgZmx1aWQuZmlyZUV2ZW50ID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgcGF0aCwgYXJncykge1xuICAgICAgICB2YXIgZmlyZXIgPSBmbHVpZC5nZXQoY29tcG9uZW50LCBwYXRoKTtcbiAgICAgICAgaWYgKGZpcmVyKSB7XG4gICAgICAgICAgICBmaXJlci5maXJlLmFwcGx5KG51bGwsIGZsdWlkLm1ha2VBcnJheShhcmdzKSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gdW5zdXBwb3J0ZWQsIE5PTi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5ldmVudC5hZGRMaXN0ZW5lclRvRmlyZXIgPSBmdW5jdGlvbiAoZmlyZXIsIHZhbHVlLCBuYW1lc3BhY2UsIHdyYXBwZXIpIHtcbiAgICAgICAgd3JhcHBlciA9IHdyYXBwZXIgfHwgZmx1aWQuaWRlbnRpdHk7XG4gICAgICAgIGlmIChmbHVpZC5pc0FycmF5YWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBmbHVpZC5ldmVudC5hZGRMaXN0ZW5lclRvRmlyZXIoZmlyZXIsIHZhbHVlW2ldLCBuYW1lc3BhY2UsIHdyYXBwZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHdyYXBwZXIoZmlyZXIpLmFkZExpc3RlbmVyKHZhbHVlLCBuYW1lc3BhY2UpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlICYmIHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB3cmFwcGVyKGZpcmVyKS5hZGRMaXN0ZW5lcih2YWx1ZS5saXN0ZW5lciwgbmFtZXNwYWNlIHx8IHZhbHVlLm5hbWVzcGFjZSwgdmFsdWUucHJlZGljYXRlLCB2YWx1ZS5wcmlvcml0eSwgdmFsdWUuc29mdE5hbWVzcGFjZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gdW5zdXBwb3J0ZWQsIE5PTi1BUEkgZnVuY3Rpb24gLSBub24tSU9DIHBhc3N0aHJvdWdoXG4gICAgZmx1aWQuZXZlbnQucmVzb2x2ZUxpc3RlbmVyUmVjb3JkID0gZnVuY3Rpb24gKHJlY29yZHMpIHtcbiAgICAgICAgcmV0dXJuIHsgcmVjb3JkczogcmVjb3JkcyB9O1xuICAgIH07XG5cbiAgICBmbHVpZC5leHBhbmRPcHRpb25zID0gZnVuY3Rpb24gKG1hdGVyaWFsKSB7XG4gICAgICAgIGZsdWlkLmZhaWwoXCJmbHVpZC5leHBhbmRPcHRpb25zIGNvdWxkIG5vdCBiZSBsb2FkZWQgLSBwbGVhc2UgaW5jbHVkZSBGbHVpZElvQy5qcyBpbiBvcmRlciB0byBvcGVyYXRlIElvQy1kcml2ZW4gZXZlbnQgd2l0aCBkZXNjcmlwdG9yIFwiICsgbWF0ZXJpYWwpO1xuICAgIH07XG5cbiAgICAvLyB1bnN1cHBvcnRlZCwgTk9OLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLm1lcmdlTGlzdGVuZXJzID0gZnVuY3Rpb24gKHRoYXQsIGV2ZW50cywgbGlzdGVuZXJzKSB7XG4gICAgICAgIGZsdWlkLmVhY2gobGlzdGVuZXJzLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgICAgdmFyIGZpcmVyLCBuYW1lc3BhY2U7XG4gICAgICAgICAgICBpZiAoa2V5LmNoYXJBdCgwKSA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgICBmaXJlciA9IGZsdWlkLmV4cGFuZE9wdGlvbnMoa2V5LCB0aGF0KTtcbiAgICAgICAgICAgICAgICBpZiAoIWZpcmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsdWlkLmZhaWwoXCJFcnJvciBpbiBsaXN0ZW5lciByZWNvcmQ6IGtleSBcIiArIGtleSArIFwiIGNvdWxkIG5vdCBiZSBsb29rZWQgdXAgdG8gYW4gZXZlbnQgZmlyZXIgLSBkaWQgeW91IG1pc3Mgb3V0IFxcXCJldmVudHMuXFxcIiB3aGVuIHJlZmVycmluZyB0byBhbiBldmVudCBmaXJlcj9cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ZG90ID0ga2V5LmluZGV4T2YoXCIuXCIpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGtleWRvdCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZXNwYWNlID0ga2V5LnN1YnN0cmluZyhrZXlkb3QgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0ga2V5LnN1YnN0cmluZygwLCBrZXlkb3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWV2ZW50c1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsdWlkLmZhaWwoXCJMaXN0ZW5lciByZWdpc3RlcmVkIGZvciBldmVudCBcIiArIGtleSArIFwiIHdoaWNoIGlzIG5vdCBkZWZpbmVkIGZvciB0aGlzIGNvbXBvbmVudFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmlyZXIgPSBldmVudHNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZWNvcmQgPSBmbHVpZC5ldmVudC5yZXNvbHZlTGlzdGVuZXJSZWNvcmQodmFsdWUsIHRoYXQsIGtleSwgbmFtZXNwYWNlLCB0cnVlKTtcbiAgICAgICAgICAgIGZsdWlkLmV2ZW50LmFkZExpc3RlbmVyVG9GaXJlcihmaXJlciwgcmVjb3JkLnJlY29yZHMsIG5hbWVzcGFjZSwgcmVjb3JkLmFkZGVyV3JhcHBlcik7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyB1bnN1cHBvcnRlZCwgTk9OLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLmV2ZW50RnJvbVJlY29yZCA9IGZ1bmN0aW9uIChldmVudFNwZWMsIGV2ZW50S2V5LCB0aGF0KSB7XG4gICAgICAgIHZhciBpc0lvQ0V2ZW50ID0gZXZlbnRTcGVjICYmICh0eXBlb2YgKGV2ZW50U3BlYykgIT09IFwic3RyaW5nXCIgfHwgZXZlbnRTcGVjLmNoYXJBdCgwKSA9PT0gXCJ7XCIpO1xuICAgICAgICB2YXIgZXZlbnQ7XG4gICAgICAgIGlmIChpc0lvQ0V2ZW50KSB7XG4gICAgICAgICAgICBpZiAoIWZsdWlkLmV2ZW50LnJlc29sdmVFdmVudCkge1xuICAgICAgICAgICAgICAgIGZsdWlkLmZhaWwoXCJmbHVpZC5ldmVudC5yZXNvbHZlRXZlbnQgY291bGQgbm90IGJlIGxvYWRlZCAtIHBsZWFzZSBpbmNsdWRlIEZsdWlkSW9DLmpzIGluIG9yZGVyIHRvIG9wZXJhdGUgSW9DLWRyaXZlbiBldmVudCB3aXRoIGRlc2NyaXB0b3IgXCIsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50U3BlYyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV2ZW50ID0gZmx1aWQuZXZlbnQucmVzb2x2ZUV2ZW50KHRoYXQsIGV2ZW50S2V5LCBldmVudFNwZWMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXZlbnQgPSBmbHVpZC5tYWtlRXZlbnRGaXJlcih7XG4gICAgICAgICAgICAgICAgbmFtZTogZmx1aWQuZXZlbnQubmFtZUV2ZW50KHRoYXQsIGV2ZW50S2V5KSxcbiAgICAgICAgICAgICAgICBwcmV2ZW50YWJsZTogZXZlbnRTcGVjID09PSBcInByZXZlbnRhYmxlXCIsXG4gICAgICAgICAgICAgICAgb3duZXJJZDogdGhhdC5pZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH07XG5cbiAgICAvLyB1bnN1cHBvcnRlZCwgTk9OLUFQSSBmdW5jdGlvbiAtIHRoaXMgaXMgcGF0Y2hlZCBmcm9tIEZsdWlkSW9DLmpzXG4gICAgZmx1aWQuaW5zdGFudGlhdGVGaXJlcnMgPSBmdW5jdGlvbiAodGhhdCwgb3B0aW9ucykge1xuICAgICAgICBmbHVpZC5lYWNoKG9wdGlvbnMuZXZlbnRzLCBmdW5jdGlvbiAoZXZlbnRTcGVjLCBldmVudEtleSkge1xuICAgICAgICAgICAgdGhhdC5ldmVudHNbZXZlbnRLZXldID0gZmx1aWQuZXZlbnRGcm9tUmVjb3JkKGV2ZW50U3BlYywgZXZlbnRLZXksIHRoYXQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gdW5zdXBwb3J0ZWQsIE5PTi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5tZXJnZUxpc3RlbmVyUG9saWN5ID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlLCBrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoa2V5KSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZmx1aWQuZmFpbChcIkVycm9yIGluIGxpc3RlbmVycyBkZWNsYXJhdGlvbiAtIHRoZSBrZXlzIGluIHRoaXMgc3RydWN0dXJlIG11c3QgcmVzb2x2ZSB0byBldmVudCBuYW1lcyAtIGdvdCBcIiArIGtleSArIFwiIGZyb20gXCIsIHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2YuIHRyaWFnZSBpbiBtZXJnZUxpc3RlbmVyc1xuICAgICAgICB2YXIgaGFzTmFtZXNwYWNlID0ga2V5LmNoYXJBdCgwKSAhPT0gXCJ7XCIgJiYga2V5LmluZGV4T2YoXCIuXCIpICE9PSAtMTtcbiAgICAgICAgcmV0dXJuIGhhc05hbWVzcGFjZSA/IChzb3VyY2UgfHwgdGFyZ2V0KSA6IGZsdWlkLmFycmF5Q29uY2F0UG9saWN5KHRhcmdldCwgc291cmNlKTtcbiAgICB9O1xuXG4gICAgLy8gdW5zdXBwb3J0ZWQsIE5PTi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5tYWtlTWVyZ2VMaXN0ZW5lcnNQb2xpY3kgPSBmdW5jdGlvbiAobWVyZ2VyKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldCB8fCB7fTtcbiAgICAgICAgICAgIGZsdWlkLmVhY2goc291cmNlLCBmdW5jdGlvbiAobGlzdGVuZXJzLCBrZXkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IG1lcmdlcih0YXJnZXRba2V5XSwgbGlzdGVuZXJzLCBrZXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvKiogUmVtb3ZlcyBkdXBsaWNhdGVkIGFuZCBlbXB0eSBlbGVtZW50cyBmcm9tIGFuIGFscmVhZHkgc29ydGVkIGFycmF5ICoqL1xuICAgIGZsdWlkLnVuaXF1ZSA9IGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICByZXR1cm4gZmx1aWQucmVtb3ZlX2lmKGFycmF5LCBmdW5jdGlvbiAoZWxlbWVudCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuICFlbGVtZW50IHx8IGkgPiAwICYmIGVsZW1lbnQgPT09IGFycmF5W2kgLSAxXTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZsdWlkLmFycmF5Q29uY2F0UG9saWN5ID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBmbHVpZC5tYWtlQXJyYXkodGFyZ2V0KS5jb25jYXQoZmx1aWQubWFrZUFycmF5KHNvdXJjZSkpO1xuICAgIH07XG5cbiAgICAvKioqIERFRkFVTFRTIEFORCBPUFRJT05TIE1FUkdJTkcgU1lTVEVNICoqKi9cblxuICAgIC8qKiBDcmVhdGUgYSBcInR5cGUgdGFnXCIgY29tcG9uZW50IHdpdGggbm8gc3RhdGUgYnV0IHNpbXBseSBhIHR5cGUgbmFtZSBhbmQgaWQuIFRoZSBtb3N0XG4gICAgICogIG1pbmltYWwgZm9ybSBvZiBGbHVpZCBjb21wb25lbnQgKi9cblxuICAgIGZsdWlkLnR5cGVUYWcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbmFtZSA/IHtcbiAgICAgICAgICAgIHR5cGVOYW1lOiBuYW1lLFxuICAgICAgICAgICAgaWQ6IGZsdWlkLmFsbG9jYXRlR3VpZCgpXG4gICAgICAgIH0gOiBudWxsO1xuICAgIH07XG5cbiAgICAvLyBEZWZpbml0aW9ucyBmb3IgVGhyZWFkTG9jYWxzLCB0aGUgc3RhdGljIGFuZCBkeW5hbWljIGVudmlyb25tZW50IC0gbGlmdGVkIGhlcmUgZnJvbVxuICAgIC8vIEZsdWlkSW9DLmpzIHNvIHRoYXQgd2UgY2FuIGlzc3VlIGNhbGxzIHRvIGZsdWlkLmRlc2NyaWJlQWN0aXZpdHkgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlc1xuICAgIC8vIGluIHRoZSBjb3JlIGZyYW1ld29ya1xuXG4gICAgZmx1aWQuc3RhdGljRW52aXJvbm1lbnQgPSBmbHVpZC50eXBlVGFnKFwiZmx1aWQuc3RhdGljRW52aXJvbm1lbnRcIik7XG5cbiAgICAvLyB1bnN1cHBvcnRlZCwgbm9uLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLnNpbmdsZVRocmVhZExvY2FsID0gZnVuY3Rpb24gKGluaXRGdW5jKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGluaXRGdW5jKCk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkID8gdmFsdWUgOiB2YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBDdXJyZW50bHkgd2Ugb25seSBzdXBwb3J0IHNpbmdsZS10aHJlYWRlZCBlbnZpcm9ubWVudHMgLSBlbnN1cmUgdGhhdCB0aGlzIGZ1bmN0aW9uXG4gICAgLy8gaXMgbm90IHVzZWQgb24gc3RhcnR1cCBzbyBpdCBjYW4gYmUgc3VjY2Vzc2Z1bGx5IG1vbmtleS1wYXRjaGVkXG4gICAgLy8gdW5zdXBwb3J0ZWQsIG5vbi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC50aHJlYWRMb2NhbCA9IGZsdWlkLnNpbmdsZVRocmVhZExvY2FsO1xuXG4gICAgLy8gdW5zdXBwb3J0ZWQsIG5vbi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5nbG9iYWxUaHJlYWRMb2NhbCA9IGZsdWlkLnRocmVhZExvY2FsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZsdWlkLnR5cGVUYWcoXCJmbHVpZC5keW5hbWljRW52aXJvbm1lbnRcIik7XG4gICAgfSk7XG5cbiAgICB2YXIgZ3JhZGVUaWNrID0gMTsgLy8gdGljayBjb3VudGVyIGZvciBtYW5hZ2luZyBncmFkZSBjYWNoZSBpbnZhbGlkYXRpb25cbiAgICB2YXIgZ3JhZGVUaWNrU3RvcmUgPSB7fTtcblxuICAgIHZhciBkZWZhdWx0c1N0b3JlID0ge307XG5cbiAgICB2YXIgcmVzb2x2ZUdyYWRlc0ltcGwgPSBmdW5jdGlvbiAoZ3MsIGdyYWRlTmFtZXMsIGJhc2UpIHtcbiAgICAgICAgdmFyIHJhdyA9IHRydWU7XG4gICAgICAgIGlmIChiYXNlKSB7XG4gICAgICAgICAgICByYXcgPSBncmFkZU5hbWVzLmxlbmd0aCA9PT0gMTsgLy8gV2UgYXJlIGp1c3QgcmVzb2x2aW5nIGEgc2luZ2xlIGdyYWRlIGFuZCBwb3B1bGF0aW5nIHRoZSBjYWNoZVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ3JhZGVOYW1lcyA9IGZsdWlkLm1ha2VBcnJheShncmFkZU5hbWVzKTtcbiAgICAgICAgfVxuICAgICAgICBmbHVpZC5lYWNoKGdyYWRlTmFtZXMsIGZ1bmN0aW9uIChncmFkZU5hbWUpIHtcbiAgICAgICAgICAgIGlmIChncmFkZU5hbWUgJiYgIWdzLmdyYWRlSGFzaFtncmFkZU5hbWVdKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzRHluYW1pYyA9IGdyYWRlTmFtZS5jaGFyQXQoMCkgPT09IFwie1wiO1xuICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gKGlzRHluYW1pYyA/IG51bGwgOiAocmF3ID8gZmx1aWQucmF3RGVmYXVsdHMoZ3JhZGVOYW1lKSA6IGZsdWlkLmdldEdyYWRlZERlZmF1bHRzKGdyYWRlTmFtZSkpKSB8fCB7fTtcbiAgICAgICAgICAgICAgICB2YXIgdGhpc1RpY2sgPSBncmFkZVRpY2tTdG9yZVtncmFkZU5hbWVdIHx8IChncmFkZVRpY2sgLSAxKTsgLy8gYSBub25leGlzdGVudCBncmFkZSBpcyByZWNvcmRlZCBhcyBwcmV2aW91cyB0byBjdXJyZW50XG4gICAgICAgICAgICAgICAgZ3MubGFzdFRpY2sgPSBNYXRoLm1heChncy5sYXN0VGljaywgdGhpc1RpY2spO1xuICAgICAgICAgICAgICAgIGdzLmdyYWRlSGFzaFtncmFkZU5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBncy5ncmFkZUNoYWluLnB1c2goZ3JhZGVOYW1lKTtcbiAgICAgICAgICAgICAgICBncy5vcHRpb25zQ2hhaW4ucHVzaChvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB2YXIgb0dyYWRlTmFtZXMgPSBmbHVpZC5tYWtlQXJyYXkob3B0aW9ucy5ncmFkZU5hbWVzKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9HcmFkZU5hbWVzLmxlbmd0aDsgKysgaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb0dyYWRlTmFtZSA9IG9HcmFkZU5hbWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXNBdXRvID0gb0dyYWRlTmFtZSA9PT0gXCJhdXRvSW5pdFwiO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJhdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFncy5ncmFkZUhhc2hbb0dyYWRlTmFtZV0gJiYgIWlzQXV0bykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdzLmdyYWRlSGFzaFtvR3JhZGVOYW1lXSA9IHRydWU7IC8vIHRoZXNlIGhhdmUgYWxyZWFkeSBiZWVuIHJlc29sdmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3MuZ3JhZGVDaGFpbi5wdXNoKG9HcmFkZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpc0F1dG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVHcmFkZXNJbXBsKGdzLCBvR3JhZGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBncztcbiAgICB9O1xuXG4gICAgLy8gdW5zdXBwb3J0ZWQsIE5PTi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5yZXNvbHZlR3JhZGVTdHJ1Y3R1cmUgPSBmdW5jdGlvbiAoZGVmYXVsdE5hbWUsIGdyYWRlTmFtZXMpIHtcbiAgICAgICAgdmFyIGdyYWRlU3RydWN0ID0ge1xuICAgICAgICAgICAgbGFzdFRpY2s6IDAsXG4gICAgICAgICAgICBncmFkZUNoYWluOiBbXSxcbiAgICAgICAgICAgIGdyYWRlSGFzaDoge30sXG4gICAgICAgICAgICBvcHRpb25zQ2hhaW46IFtdXG4gICAgICAgIH07XG4gICAgICAgIC8vIHN0cm9uZ2VyIGdyYWRlcyBhcHBlYXIgdG8gdGhlIGxlZnQgaW4gZGVmYXVsdHMgLSBkeW5hbWljIGdyYWRlcyBhcmUgc3Ryb25nZXIgc3RpbGwgLSBGTFVJRC01MDg1XG4gICAgICAgIHJldHVybiByZXNvbHZlR3JhZGVzSW1wbChncmFkZVN0cnVjdCwgKGZsdWlkLm1ha2VBcnJheShncmFkZU5hbWVzKS5yZXZlcnNlKCkgfHwgW10pLmNvbmNhdChbZGVmYXVsdE5hbWVdKSwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIHZhciBtZXJnZWREZWZhdWx0c0NhY2hlID0ge307XG5cbiAgICAvLyB1bnN1cHBvcnRlZCwgTk9OLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLmdyYWRlTmFtZXNUb0tleSA9IGZ1bmN0aW9uIChkZWZhdWx0TmFtZSwgZ3JhZGVOYW1lcykge1xuICAgICAgICByZXR1cm4gZGVmYXVsdE5hbWUgKyBcInxcIiArIGdyYWRlTmFtZXMuam9pbihcInxcIik7XG4gICAgfTtcblxuICAgIGZsdWlkLmhhc0dyYWRlID0gZnVuY3Rpb24gKG9wdGlvbnMsIGdyYWRlTmFtZSkge1xuICAgICAgICByZXR1cm4gIW9wdGlvbnMgfHwgIW9wdGlvbnMuZ3JhZGVOYW1lcyA/IGZhbHNlIDogZmx1aWQuY29udGFpbnMob3B0aW9ucy5ncmFkZU5hbWVzLCBncmFkZU5hbWUpO1xuICAgIH07XG5cbiAgICAvLyB1bnN1cHBvcnRlZCwgTk9OLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLnJlc29sdmVHcmFkZSA9IGZ1bmN0aW9uIChkZWZhdWx0cywgZGVmYXVsdE5hbWUsIGdyYWRlTmFtZXMpIHtcbiAgICAgICAgdmFyIGdyYWRlU3RydWN0ID0gZmx1aWQucmVzb2x2ZUdyYWRlU3RydWN0dXJlKGRlZmF1bHROYW1lLCBncmFkZU5hbWVzKTtcbiAgICAgICAgdmFyIG1lcmdlQXJncyA9IGdyYWRlU3RydWN0Lm9wdGlvbnNDaGFpbi5yZXZlcnNlKCk7XG4gICAgICAgIHZhciBtZXJnZVBvbGljeSA9IHt9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lcmdlQXJncy5sZW5ndGg7ICsrIGkpIHtcbiAgICAgICAgICAgIGlmIChtZXJnZUFyZ3NbaV0gJiYgbWVyZ2VBcmdzW2ldLm1lcmdlUG9saWN5KSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VQb2xpY3kgPSAkLmV4dGVuZCh0cnVlLCBtZXJnZVBvbGljeSwgbWVyZ2VBcmdzW2ldLm1lcmdlUG9saWN5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtZXJnZUFyZ3MgPSBbbWVyZ2VQb2xpY3ksIHt9XS5jb25jYXQobWVyZ2VBcmdzKTtcbiAgICAgICAgdmFyIG1lcmdlZERlZmF1bHRzID0gZmx1aWQubWVyZ2UuYXBwbHkobnVsbCwgbWVyZ2VBcmdzKTtcbiAgICAgICAgbWVyZ2VkRGVmYXVsdHMuZ3JhZGVOYW1lcyA9IGdyYWRlU3RydWN0LmdyYWRlQ2hhaW47XG4gICAgICAgIGlmIChmbHVpZC5oYXNHcmFkZShkZWZhdWx0cywgXCJhdXRvSW5pdFwiKSkge1xuICAgICAgICAgICAgbWVyZ2VkRGVmYXVsdHMuZ3JhZGVOYW1lcy5wdXNoKFwiYXV0b0luaXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtkZWZhdWx0czogbWVyZ2VkRGVmYXVsdHMsIGxhc3RUaWNrOiBncmFkZVN0cnVjdCAmJiBncmFkZVN0cnVjdC5sYXN0VGlja307XG4gICAgfTtcblxuICAgIC8vIHVuc3VwcG9ydGVkLCBOT04tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQuZ2V0R3JhZGVkRGVmYXVsdHMgPSBmdW5jdGlvbiAoZGVmYXVsdE5hbWUsIGdyYWRlTmFtZXMpIHtcbiAgICAgICAgZ3JhZGVOYW1lcyA9IGZsdWlkLm1ha2VBcnJheShncmFkZU5hbWVzKTtcbiAgICAgICAgdmFyIGtleSA9IGZsdWlkLmdyYWRlTmFtZXNUb0tleShkZWZhdWx0TmFtZSwgZ3JhZGVOYW1lcyk7XG4gICAgICAgIHZhciBtZXJnZWREZWZhdWx0cyA9IG1lcmdlZERlZmF1bHRzQ2FjaGVba2V5XTtcbiAgICAgICAgaWYgKG1lcmdlZERlZmF1bHRzKSB7XG4gICAgICAgICAgICB2YXIgbGFzdFRpY2sgPSAwOyAvLyBjaGVjayBpZiBjYWNoZSBzaG91bGQgYmUgaW52YWxpZGF0ZWQgdGhyb3VnaCByZWFsIGxhdGVzdCB0aWNrIGJlaW5nIGxhdGVyIHRoYW4gdGhlIG9uZSBzdG9yZWRcbiAgICAgICAgICAgIHZhciBzZWFyY2hHcmFkZXMgPSBtZXJnZWREZWZhdWx0cy5kZWZhdWx0cy5ncmFkZU5hbWVzIHx8IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWFyY2hHcmFkZXMubGVuZ3RoOyArKyBpKSB7XG4gICAgICAgICAgICAgICAgbGFzdFRpY2sgPSBNYXRoLm1heChsYXN0VGljaywgZ3JhZGVUaWNrU3RvcmVbc2VhcmNoR3JhZGVzW2ldXSB8fCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXN0VGljayA+IG1lcmdlZERlZmF1bHRzLmxhc3RUaWNrKSB7XG4gICAgICAgICAgICAgICAgZmx1aWQubG9nKFwiQ2xlYXJpbmcgY2FjaGUgZm9yIGNvbXBvbmVudCBcIiArIGRlZmF1bHROYW1lICsgXCIgd2l0aCBncmFkZU5hbWVzIFwiLCBzZWFyY2hHcmFkZXMpO1xuICAgICAgICAgICAgICAgIG1lcmdlZERlZmF1bHRzID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1lcmdlZERlZmF1bHRzKSB7XG4gICAgICAgICAgICB2YXIgZGVmYXVsdHMgPSBmbHVpZC5yYXdEZWZhdWx0cyhkZWZhdWx0TmFtZSk7XG4gICAgICAgICAgICBpZiAoIWRlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWVyZ2VkRGVmYXVsdHMgPSBtZXJnZWREZWZhdWx0c0NhY2hlW2tleV0gPSBmbHVpZC5yZXNvbHZlR3JhZGUoZGVmYXVsdHMsIGRlZmF1bHROYW1lLCBncmFkZU5hbWVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVyZ2VkRGVmYXVsdHMuZGVmYXVsdHM7XG4gICAgfTtcblxuICAgIC8vIHVuc3VwcG9ydGVkLCBOT04tQVBJIGZ1bmN0aW9uXG4gICAgLy8gTW9kaWZ5IHN1cHBsaWVkIG9wdGlvbnMgcmVjb3JkIHRvIGluY2x1ZGUgXCJjb21wb25lbnRTb3VyY2VcIiBhbm5vdGF0aW9uIHJlcXVpcmVkIGJ5IEZMVUlELTUwODJcbiAgICAvLyBUT0RPOiBUaGlzIGZ1bmN0aW9uIHJlYWxseSBuZWVkcyB0byBhY3QgcmVjdXJzaXZlbHkgaW4gb3JkZXIgdG8gY2F0Y2ggbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIHN1YmNvbXBvbmVudHNcbiAgICBmbHVpZC5hbm5vdGF0ZUxpc3RlbmVycyA9IGZ1bmN0aW9uIChjb21wb25lbnROYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmxpc3RlbmVycykge1xuICAgICAgICAgICAgb3B0aW9ucy5saXN0ZW5lcnMgPSBmbHVpZC50cmFuc2Zvcm0ob3B0aW9ucy5saXN0ZW5lcnMsIGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG9nbyA9IGZsdWlkLm1ha2VBcnJheShyZWNvcmQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmbHVpZC50cmFuc2Zvcm0odG9nbywgZnVuY3Rpb24gKG9uZXJlYykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZsdWlkLmlzUHJpbWl0aXZlKG9uZXJlYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZXJlYy5jb21wb25lbnRTb3VyY2UgPSBjb21wb25lbnROYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvbmVyZWM7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyB1bnN1cHBvcnRlZCwgTk9OLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLnJhd0RlZmF1bHRzID0gZnVuY3Rpb24gKGNvbXBvbmVudE5hbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRzU3RvcmVbY29tcG9uZW50TmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmbHVpZC5wdXNoQWN0aXZpdHkoXCJyZWdpc3RlckRlZmF1bHRzXCIsIFwicmVnaXN0ZXJpbmcgZGVmYXVsdHMgZm9yIGdyYWRlICVjb21wb25lbnROYW1lIHdpdGggb3B0aW9ucyAlb3B0aW9uc1wiLFxuICAgICAgICAgICAgICAgIHtjb21wb25lbnROYW1lOiBjb21wb25lbnROYW1lLCBvcHRpb25zOiBvcHRpb25zfSk7XG4gICAgICAgICAgICB2YXIgb3B0aW9uc0NvcHkgPSBmbHVpZC5leHBhbmRDb21wYWN0ID8gZmx1aWQuZXhwYW5kQ29tcGFjdChvcHRpb25zKSA6IGZsdWlkLmNvcHkob3B0aW9ucyk7XG4gICAgICAgICAgICBmbHVpZC5hbm5vdGF0ZUxpc3RlbmVycyhjb21wb25lbnROYW1lLCBvcHRpb25zQ29weSk7XG4gICAgICAgICAgICBkZWZhdWx0c1N0b3JlW2NvbXBvbmVudE5hbWVdID0gb3B0aW9uc0NvcHk7XG4gICAgICAgICAgICBncmFkZVRpY2tTdG9yZVtjb21wb25lbnROYW1lXSA9IGdyYWRlVGljaysrO1xuICAgICAgICAgICAgZmx1aWQucG9wQWN0aXZpdHkoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyB1bnN1cHBvcnRlZCwgTk9OLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLmRvSW5kZXhEZWZhdWx0cyA9IGZ1bmN0aW9uIChkZWZhdWx0TmFtZSwgZGVmYXVsdHMsIGluZGV4LCBpbmRleFNwZWMpIHtcbiAgICAgICAgdmFyIHJlcXVpcmVkR3JhZGVzID0gZmx1aWQubWFrZUFycmF5KGluZGV4U3BlYy5ncmFkZU5hbWVzKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXF1aXJlZEdyYWRlcy5sZW5ndGg7ICsrIGkpIHtcbiAgICAgICAgICAgIGlmICghZmx1aWQuaGFzR3JhZGUoZGVmYXVsdHMsIHJlcXVpcmVkR3JhZGVzW2ldKSkgeyByZXR1cm47IH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZXhGdW5jID0gdHlwZW9mKGluZGV4U3BlYy5pbmRleEZ1bmMpID09PSBcImZ1bmN0aW9uXCIgPyBpbmRleFNwZWMuaW5kZXhGdW5jIDogZmx1aWQuZ2V0R2xvYmFsVmFsdWUoaW5kZXhTcGVjLmluZGV4RnVuYyk7XG4gICAgICAgIHZhciBrZXlzID0gaW5kZXhGdW5jKGRlZmF1bHRzKSB8fCBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBrZXlzLmxlbmd0aDsgKysgaikge1xuICAgICAgICAgICAgKGluZGV4W2tleXNbal1dID0gaW5kZXhba2V5c1tqXV0gfHwgW10pLnB1c2goZGVmYXVsdE5hbWUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKiBFdmFsdWF0ZXMgYW4gaW5kZXggc3BlY2lmaWNhdGlvbiBvdmVyIGFsbCB0aGUgZGVmYXVsdHMgcmVjb3JkcyByZWdpc3RlcmVkIGludG8gdGhlIHN5c3RlbS5cbiAgICAgKiBAcGFyYW0gaW5kZXhOYW1lIHtTdHJpbmd9IFRoZSBuYW1lIG9mIHRoaXMgaW5kZXggcmVjb3JkIChjdXJyZW50bHkgaWdub3JlZClcbiAgICAgKiBAcGFyYW0gaW5kZXhTcGVjIHtPYmplY3R9IFNwZWNpZmljYXRpb24gb2YgdGhlIGluZGV4IHRvIGJlIHBlcmZvcm1lZCAtIGZpZWxkczpcbiAgICAgKiAgICAgZ3JhZGVOYW1lczoge1N0cmluZy9BcnJheSBvZiBTdHJpbmd9IExpc3Qgb2YgZ3JhZGVzIHRoYXQgbXVzdCBiZSBtYXRjaGVkIGJ5IHRoaXMgaW5kZXhlclxuICAgICAqICAgICBpbmRleEZ1bmM6ICB7U3RyaW5nL0Z1bmN0aW9ufSBBbiBpbmRleCBmdW5jdGlvbiB3aGljaCBhY2NlcHRzIGEgZGVmYXVsdHMgcmVjb3JkIGFuZCByZXR1cm5zIGEgbGlzdCBvZiBrZXlzXG4gICAgICogQHJldHVybiBBIHN0cnVjdHVyZSBpbmRleGluZyBrZXlzIHRvIGxpc3RzIG9mIG1hdGNoZWQgZ3JhZGVuYW1lc1xuICAgICAqL1xuICAgIC8vIFRoZSBleHBlY3RhdGlvbiBpcyB0aGF0IHRoaXMgZnVuY3Rpb24gaXMgZXh0cmVtZWx5IHJhcmVseSB1c2VkIHdpdGggcmVzcGVjdCB0byByZWdpc3RyYXRpb24gb2YgZGVmYXVsdHNcbiAgICAvLyBpbiB0aGUgc3lzdGVtLCBzbyBjdXJyZW50bHkgd2UgZG8gbm90IG1ha2UgYW55IGF0dGVtcHRzIHRvIGNhY2hlIHRoZSByZXN1bHRzLiBUaGUgZmllbGQgXCJpbmRleE5hbWVcIiBpc1xuICAgIC8vIHN1cHBsaWVkIGluIGNhc2UgYSBmdXR1cmUgaW1wbGVtZW50YXRpb24gY2hvb3NlcyB0byBpbXBsZW1lbnQgY2FjaGluZ1xuICAgIGZsdWlkLmluZGV4RGVmYXVsdHMgPSBmdW5jdGlvbiAoaW5kZXhOYW1lLCBpbmRleFNwZWMpIHtcbiAgICAgICAgdmFyIGluZGV4ID0ge307XG4gICAgICAgIGZvciAodmFyIGRlZmF1bHROYW1lIGluIGRlZmF1bHRzU3RvcmUpIHtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0cyA9IGZsdWlkLmdldEdyYWRlZERlZmF1bHRzKGRlZmF1bHROYW1lKTtcbiAgICAgICAgICAgIGZsdWlkLmRvSW5kZXhEZWZhdWx0cyhkZWZhdWx0TmFtZSwgZGVmYXVsdHMsIGluZGV4LCBpbmRleFNwZWMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGFuZCBzdG9yZXMgYSBjb21wb25lbnQncyBkZWZhdWx0IHNldHRpbmdzIGNlbnRyYWxseS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29tcG9uZW50TmFtZSB0aGUgbmFtZSBvZiB0aGUgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IChvcHRpb25hbCkgYW4gY29udGFpbmVyIG9mIGtleS92YWx1ZSBwYWlycyB0byBzZXRcbiAgICAgKi9cblxuICAgIGZsdWlkLmRlZmF1bHRzID0gZnVuY3Rpb24gKGNvbXBvbmVudE5hbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZsdWlkLmdldEdyYWRlZERlZmF1bHRzKGNvbXBvbmVudE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5vcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgZmx1aWQuZmFpbChcIlByb2JhYmxlIGVycm9yIGluIG9wdGlvbnMgc3RydWN0dXJlIGZvciBcIiArIGNvbXBvbmVudE5hbWUgK1xuICAgICAgICAgICAgICAgICAgICBcIiB3aXRoIG9wdGlvbiBuYW1lZCBcXFwib3B0aW9uc1xcXCIgLSBwZXJoYXBzIHlvdSBtZWFudCB0byB3cml0ZSB0aGVzZSBvcHRpb25zIGF0IHRvcCBsZXZlbCBpbiBmbHVpZC5kZWZhdWx0cz8gLSBcIiwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbHVpZC5yYXdEZWZhdWx0cyhjb21wb25lbnROYW1lLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChmbHVpZC5oYXNHcmFkZShvcHRpb25zLCBcImF1dG9Jbml0XCIpKSB7XG4gICAgICAgICAgICAgICAgZmx1aWQubWFrZUNvbXBvbmVudChjb21wb25lbnROYW1lLCBmbHVpZC5nZXRHcmFkZWREZWZhdWx0cyhjb21wb25lbnROYW1lKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZmx1aWQubWFrZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChjb21wb25lbnROYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5ncmFkZU5hbWVzIHx8IG9wdGlvbnMuZ3JhZGVOYW1lcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGZsdWlkLmZhaWwoXCJDYW5ub3QgYXV0b0luaXQgY29tcG9uZW50IFwiICsgY29tcG9uZW50TmFtZSArIFwiIHdoaWNoIGRvZXMgbm90IGhhdmUgYW55IGdyYWRlTmFtZXMgZGVmaW5lZFwiKTtcbiAgICAgICAgfSBlbHNlIGlmICghb3B0aW9ucy5pbml0RnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBibGFua0dyYWRlcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRpb25zLmdyYWRlTmFtZXMubGVuZ3RoOyArKyBpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdyYWRlTmFtZSA9IG9wdGlvbnMuZ3JhZGVOYW1lc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdHMgPSBmbHVpZC5yYXdEZWZhdWx0cyhncmFkZU5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICghZGVmYXVsdHMgJiYgZ3JhZGVOYW1lICE9PSBcImF1dG9Jbml0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYmxhbmtHcmFkZXMucHVzaChncmFkZU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChibGFua0dyYWRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBmbHVpZC5mYWlsKFwiQ2Fubm90IGF1dG9Jbml0IGNvbXBvbmVudCBcIiArIGNvbXBvbmVudE5hbWUgKyBcIiB3aGljaCBkb2VzIG5vdCBoYXZlIGFuIGluaXRGdW5jdGlvbiBkZWZpbmVkXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmbHVpZC5mYWlsKFwiVGhlIGdyYWRlIGhpZXJhcmNoeSBvZiBjb21wb25lbnQgd2l0aCB0eXBlTmFtZSBcIiArIGNvbXBvbmVudE5hbWUgKyBcIiBpcyBpbmNvbXBsZXRlIC0gaXQgaW5oZXJpdHMgZnJvbSB0aGUgZm9sbG93aW5nIGdyYWRlKHMpOiBcIiArXG4gICAgICAgICAgICAgICAgIGJsYW5rR3JhZGVzLmpvaW4oXCIsIFwiKSArIFwiIGZvciB3aGljaCB0aGUgZ3JhZGUgZGVmaW5pdGlvbnMgYXJlIGNvcnJ1cHQgb3IgbWlzc2luZy4gUGxlYXNlIGNoZWNrIHRoZSBmaWxlcyB3aGljaCBtaWdodCBpbmNsdWRlIHRoZXNlIFwiICtcbiAgICAgICAgICAgICAgICAgXCJncmFkZXMgYW5kIGVuc3VyZSB0aGV5IGFyZSByZWFkYWJsZSBhbmQgaGF2ZSBiZWVuIGxvYWRlZCBieSB0aGlzIGluc3RhbmNlIG9mIEluZnVzaW9uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBjcmVhdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZsdWlkLmluaXRDb21wb25lbnQoY29tcG9uZW50TmFtZSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gZmx1aWQuZ2V0R2xvYmFsVmFsdWUoY29tcG9uZW50TmFtZSk7XG4gICAgICAgIGlmIChleGlzdGluZykge1xuICAgICAgICAgICAgJC5leHRlbmQoY3JlYXRvciwgZXhpc3RpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGZsdWlkLnNldEdsb2JhbFZhbHVlKGNvbXBvbmVudE5hbWUsIGNyZWF0b3IpO1xuICAgIH07XG5cbiAgICBmbHVpZC5tYWtlQ29tcG9uZW50cyA9IGZ1bmN0aW9uIChjb21wb25lbnRzKSB7XG4gICAgICAgIGZsdWlkLmVhY2goY29tcG9uZW50cywgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIGdyYWRlTmFtZXM6IGZsdWlkLm1ha2VBcnJheSh2YWx1ZSkuY29uY2F0KFtcImF1dG9Jbml0XCJdKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZsdWlkLmRlZmF1bHRzKGtleSwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBDaGVhcHNrYXRlIGltcGxlbWVudGF0aW9uIHdoaWNoIGF2b2lkcyBkZXBlbmRlbmN5IG9uIERhdGFCaW5kaW5nLmpzXG4gICAgZmx1aWQubW9kZWwubWVyZ2VNb2RlbCA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgICBpZiAoIWZsdWlkLmlzUHJpbWl0aXZlKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHZhciBjb3B5U291cmNlID0gZmx1aWQuY29weShzb3VyY2UpO1xuICAgICAgICAgICAgJC5leHRlbmQodHJ1ZSwgc291cmNlLCB0YXJnZXQpO1xuICAgICAgICAgICAgJC5leHRlbmQodHJ1ZSwgc291cmNlLCBjb3B5U291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIH07XG5cbiAgICB2YXIgZW1wdHlQb2xpY3kgPSB7fTtcbiAgICAvLyB1bnN1cHBvcnRlZCwgTk9OLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLmRlcmVmTWVyZ2VQb2xpY3kgPSBmdW5jdGlvbiAocG9saWN5KSB7XG4gICAgICAgIHJldHVybiAocG9saWN5PyBwb2xpY3lbXCIqXCJdOiBlbXB0eVBvbGljeSkgfHwgZW1wdHlQb2xpY3k7XG4gICAgfTtcblxuICAgIC8vIHVuc3VwcG9ydGVkLCBOT04tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQuY29tcGlsZU1lcmdlUG9saWN5ID0gZnVuY3Rpb24gKG1lcmdlUG9saWN5KSB7XG4gICAgICAgIHZhciBidWlsdGlucyA9IHt9LCBkZWZhdWx0VmFsdWVzID0ge307XG4gICAgICAgIHZhciB0b2dvID0ge2J1aWx0aW5zOiBidWlsdGlucywgZGVmYXVsdFZhbHVlczogZGVmYXVsdFZhbHVlc307XG5cbiAgICAgICAgaWYgKCFtZXJnZVBvbGljeSkge1xuICAgICAgICAgICAgcmV0dXJuIHRvZ287XG4gICAgICAgIH1cbiAgICAgICAgZmx1aWQuZWFjaChtZXJnZVBvbGljeSwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgIHZhciBwYXJzZWQgPSB7fSwgYnVpbHRpbiA9IHRydWU7XG4gICAgICAgICAgICBpZiAodHlwZW9mKHZhbHVlKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VkLmZ1bmMgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZih2YWx1ZSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBwYXJzZWQgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFmbHVpZC5pc0RlZmF1bHRWYWx1ZU1lcmdlUG9saWN5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhciBzcGxpdCA9IHZhbHVlLnNwbGl0KC9cXHMqLFxccyovKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwbGl0Lmxlbmd0aDsgKysgaSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWRbc3BsaXRbaV1dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRvIGdpbmdlciBzZWxmLXJlZmVyZW5jZSAtIE5CLCB0aGlzIGNhbiBvbmx5IGJlIHBhcnNlZCBieSBJb0NcbiAgICAgICAgICAgICAgICBmbHVpZC5zZXQoZGVmYXVsdFZhbHVlcywga2V5LCBcInt0aGF0fS5vcHRpb25zLlwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHRvZ28uaGFzRGVmYXVsdHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJ1aWx0aW4gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChidWlsdGluKSB7XG4gICAgICAgICAgICAgICAgZmx1aWQuc2V0KGJ1aWx0aW5zLCBmbHVpZC5jb21wb3NlUGF0aChrZXksIFwiKlwiKSwgcGFyc2VkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0b2dvO1xuICAgIH07XG5cbiAgICAvLyBUT0RPOiBkZXByZWNhdGUgdGhpcyBtZXRob2Qgb2YgZGV0ZWN0aW5nIGRlZmF1bHQgdmFsdWUgbWVyZ2UgcG9saWNpZXMgYmVmb3JlIDEuNiBpbiBmYXZvdXIgb2ZcbiAgICAvLyBleHBsaWNpdCB0eXBlZCByZWNvcmRzIGEgbGEgTW9kZWxUcmFuc2Zvcm1hdGlvbnNcbiAgICAvLyB1bnN1cHBvcnRlZCwgTk9OLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLmlzRGVmYXVsdFZhbHVlTWVyZ2VQb2xpY3kgPSBmdW5jdGlvbiAocG9saWN5KSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YocG9saWN5KSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgKHBvbGljeS5pbmRleE9mKFwiLFwiKSA9PT0gLTEgJiYgIS9yZXBsYWNlfHByZXNlcnZlfG5vbWVyZ2V8bm9leHBhbmQvLnRlc3QocG9saWN5KSk7XG4gICAgfTtcblxuICAgIC8vIHVuc3VwcG9ydGVkLCBOT04tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQubWVyZ2VPbmVJbXBsID0gZnVuY3Rpb24gKHRoaXNUYXJnZXQsIHRoaXNTb3VyY2UsIGosIHNvdXJjZXMsIG5ld1BvbGljeSwgaSwgc2Vncykge1xuICAgICAgICB2YXIgdG9nbyA9IHRoaXNUYXJnZXQ7XG5cbiAgICAgICAgdmFyIHByaW1pdGl2ZVRhcmdldCA9IGZsdWlkLmlzUHJpbWl0aXZlKHRoaXNUYXJnZXQpO1xuXG4gICAgICAgIGlmICh0aGlzU291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICghbmV3UG9saWN5LmZ1bmMgJiYgdGhpc1NvdXJjZSAhPT0gbnVsbCAmJiBmbHVpZC5pc1BsYWluT2JqZWN0KHRoaXNTb3VyY2UpICYmXG4gICAgICAgICAgICAgICAgICAgICFmbHVpZC5pc0RPTWlzaCh0aGlzU291cmNlKSAmJiB0aGlzU291cmNlICE9PSBmbHVpZC5WQUxVRSAmJlxuICAgICAgICAgICAgICAgICAgICAhbmV3UG9saWN5LnByZXNlcnZlICYmICFuZXdQb2xpY3kubm9tZXJnZSkge1xuICAgICAgICAgICAgICAgIGlmIChwcmltaXRpdmVUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9nbyA9IHRoaXNUYXJnZXQgPSBmbHVpZC5mcmVzaENvbnRhaW5lcih0aGlzU291cmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcmVjdXJzaW9uIGlzIG5vdyBleHRlcm5hbD8gV2UgY2FuJ3QgZG8gaXQgZnJvbSBoZXJlIHNpbmNlIHNvdXJjZXMgYXJlIG5vdCBhbGwga25vd25cbiAgICAgICAgICAgICAgICAvLyBvcHRpb25zLnJlY3Vyc2UodGhpc1RhcmdldCwgaSArIDEsIHNlZ3MsIHNvdXJjZXMsIG5ld1BvbGljeUhvbGRlciwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNvdXJjZXNbal0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1BvbGljeS5mdW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvZ28gPSBuZXdQb2xpY3kuZnVuYy5jYWxsKG51bGwsIHRoaXNUYXJnZXQsIHRoaXNTb3VyY2UsIHNlZ3NbaSAtIDFdLCBzZWdzLCBpKTsgLy8gTkIgLSBjaGFuZ2UgaW4gdGhpcyBtb3N0bHkgdW51c2VkIGFyZ3VtZW50XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9nbyA9IGZsdWlkLmlzVmFsdWUodGhpc1RhcmdldCkgJiYgbmV3UG9saWN5LnByZXNlcnZlID8gZmx1aWQubW9kZWwubWVyZ2VNb2RlbCh0aGlzVGFyZ2V0LCB0aGlzU291cmNlKSA6IHRoaXNTb3VyY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2dvO1xuICAgIH07XG4gICAgLy8gTkIgLSBzYW1lIHF1YWRyYXRpYyB3b3JyeSBhYm91dCB0aGVzZSBhcyBpbiBGbHVpZElvQyBpbiB0aGUgY2FzZSB0aGUgUkhTIHRydW5kbGVyIGlzIGxpdmUgLVxuICAgIC8vIHNpbmNlIGF0IGVhY2ggcmVnZW5lcmF0aW9uIHN0ZXAgZHJpdmluZyB0aGUgUkhTIHdlIGFyZSBkaXNjYXJkaW5nIHRoZSBcImN1cnNvciBhcmd1bWVudHNcIiB0aGVzZVxuICAgIC8vIHdvdWxkIGhhdmUgdG8gYmUgcmVnZW5lcmF0ZWQgYXQgZWFjaCBzdGVwIC0gYWx0aG91Z2ggaW4gcHJhY3RpY2UgdGhpcyBjYW4gb25seSBoYXBwZW4gb25jZSBmb3JcbiAgICAvLyBlYWNoIG9iamVjdCBmb3IgYWxsIHRpbWUsIHNpbmNlIGFmdGVyIGZpcnN0IHJlc29sdXRpb24gaXQgd2lsbCBiZSBjb25jcmV0ZS5cbiAgICBmdW5jdGlvbiByZWdlbmVyYXRlQ3Vyc29yIChzb3VyY2UsIHNlZ3MsIGxpbWl0LCBzb3VyY2VTdHJhdGVneSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbWl0OyArKyBpKSB7XG4gICAgICAgICAgICBzb3VyY2UgPSBzb3VyY2VTdHJhdGVneShzb3VyY2UsIHNlZ3NbaV0sIGksIGZsdWlkLm1ha2VBcnJheShzZWdzKSk7IC8vIGNvcHkgZm9yIEZMVUlELTUyNDNcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlZ2VuZXJhdGVTb3VyY2VzIChzb3VyY2VzLCBzZWdzLCBsaW1pdCwgc291cmNlU3RyYXRlZ2llcykge1xuICAgICAgICB2YXIgdG9nbyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZXMubGVuZ3RoOyArKyBpKSB7XG4gICAgICAgICAgICB2YXIgdGhpc1NvdXJjZSA9IHJlZ2VuZXJhdGVDdXJzb3Ioc291cmNlc1tpXSwgc2VncywgbGltaXQsIHNvdXJjZVN0cmF0ZWdpZXNbaV0pO1xuICAgICAgICAgICAgaWYgKHRoaXNTb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRvZ28ucHVzaCh0aGlzU291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9nbztcbiAgICB9XG5cbiAgICAvLyB1bnN1cHBvcnRlZCwgTk9OLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLmZldGNoTWVyZ2VDaGlsZHJlbiA9IGZ1bmN0aW9uICh0YXJnZXQsIGksIHNlZ3MsIHNvdXJjZXMsIG1lcmdlUG9saWN5LCBvcHRpb25zKSB7IC8qIHVudXNlZCBwYXJhbWV0ZXIgbGVmdCBmb3IgZG9jdW1lbnRhdGlvbiBwdXJwb3NlcyAqLyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgICAgdmFyIHRoaXNQb2xpY3kgPSBmbHVpZC5kZXJlZk1lcmdlUG9saWN5KG1lcmdlUG9saWN5KTtcbiAgICAgICAgZm9yICh2YXIgaiA9IHNvdXJjZXMubGVuZ3RoIC0gMTsgaiA+PSAwOyAtLSBqKSB7IC8vIHRoaXMgZGlyZWN0aW9uIG5vdyBpcnJlbGV2YW50IC0gY29udHJvbCBpcyBpbiB0aGUgc3RyYXRlZ3lcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2pdO1xuICAgICAgICAgICAgLy8gTkIgLSB0aGlzIGRldGVjdGlvbiByZWxpZXMgb24gc3RyYXRlZ3kgcmV0dXJuIGJlaW5nIGNvbXBsZXRlIG9iamVjdHMgLSB3aGljaCB0aGV5IGFyZVxuICAgICAgICAgICAgLy8gYWx0aG91Z2ggd2UgbmVlZCB0byBzZXQgdXAgdGhlIHJvb3RzIHNlcGFyYXRlbHkuIFdlIG5lZWQgdG8gU1RBUlQgdGhlIHByb2Nlc3Mgb2YgZXZhbHVhdGluZyBlYWNoXG4gICAgICAgICAgICAvLyBvYmplY3Qgcm9vdCAoc291cmNlcykgQ09NUExFVEVMWSwgYmVmb3JlIHdlIGV2ZW4gYmVnaW4hIEV2ZW4gaWYgdGhlIGVmZmVjdCBvZiB0aGlzIGlzIHRvIGNhdXNlIGFcbiAgICAgICAgICAgIC8vIGRpc3BhdGNoIGludG8gb3Vyc2VsdmVzIGFsbW9zdCBpbW1lZGlhdGVseS4gV2UgY2FuIGRvIHRoaXMgYmVjYXVzZSB3ZSBjYW4gdGFrZSBjb250cm9sIG92ZXIgb3VyXG4gICAgICAgICAgICAvLyBUQVJHRVQgb2JqZWN0cyBhbmQgY29uc3RydWN0IHRoZW0gZWFybHkuIEV2ZW4gaWYgdGhlcmUgaXMgYSBzZWxmLWRpc3BhdGNoLCBpdCB3aWxsIGJlIGZpbmUgc2luY2UgaXQgaXNcbiAgICAgICAgICAgIC8vIERJUkVDVEVEIGFuZCBzbyB3aWxsIG5vdCB0cm91YmxlIG91ciBcInNsb3dcIiBkZXRlY3Rpb24gb2YgcHJvcGVydGllcy4gQWZ0ZXIgYWxsIHNlbGYtZGlzcGF0Y2hlcyBlbmQsIGNvbnRyb2xcbiAgICAgICAgICAgIC8vIHdpbGwgVEhFTiByZXR1cm4gdG8gXCJldmFsdWF0aW9uIG9mIGFyZ3VtZW50c1wiIChleHBhbmRlciBibG9ja3MpIGFuZCBvbmx5IHRoZW4gRklOQUxMWSB0byB0aGlzIFwic2xvd1wiXG4gICAgICAgICAgICAvLyB0cmF2ZXJzYWwgb2YgY29uY3JldGUgcHJvcGVydGllcyB0byBkbyB0aGUgZmluYWwgbWVyZ2UuXG4gICAgICAgICAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHVzZSBvZiBmdW5jdGlvbiBjcmVhdGlvbiB3aXRoaW4gYSBsb29wIGlzIGFjY2VwdGFibGUgc2luY2VcbiAgICAgICAgICAgICAgICAvLyB0aGUgZnVuY3Rpb24gZG9lcyBub3QgYXR0ZW1wdCB0byBjbG9zZSBkaXJlY3RseSBvdmVyIHRoZSBsb29wIGNvdW50ZXJcbiAgICAgICAgICAgICAgICBmbHVpZC5lYWNoKHNvdXJjZSwgZnVuY3Rpb24gKG5ld1NvdXJjZSwgbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRhcmdldC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkgeyAvLyBvbmx5IHJlcXVlc3QgZWFjaCBuZXcgdGFyZ2V0IGtleSBvbmNlIC0tIGFsbCBzb3VyY2VzIHdpbGwgYmUgcXVlcmllZCBwZXIgc3RyYXRlZ3lcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZ3NbaV0gPSBuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zdHJhdGVneSh0YXJnZXQsIG5hbWUsIGkgKyAxLCBzZWdzLCBzb3VyY2VzLCBtZXJnZVBvbGljeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTsgIC8qIGZ1bmN0aW9uIGluIGxvb3AgKi8gLy9qc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgICAgICAgICAgICBpZiAodGhpc1BvbGljeS5yZXBsYWNlKSB7IC8vIHRoaXMgYnJhbmNoIHByaW1hcmlseSBkZWFscyB3aXRoIGEgcG9saWN5IG9mIHJlcGxhY2UgYXQgdGhlIHJvb3RcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfTtcblxuICAgIC8vIEEgc3BlY2lhbCBtYXJrZXIgb2JqZWN0IHdoaWNoIHdpbGwgYmUgcGxhY2VkIGF0IGEgY3VycmVudCBldmFsdWF0aW9uIHBvaW50IGluIHRoZSB0cmVlIGluIG9yZGVyXG4gICAgLy8gdG8gcHJvdGVjdCBhZ2FpbnN0IGNpcmN1bGFyIGV2YWx1YXRpb25cbiAgICBmbHVpZC5pbkV2YWx1YXRpb25NYXJrZXIgPSB7XCJfX0NVUlJFTlRMWV9JTl9FVkFMVUFUSU9OX19cIjogdHJ1ZX07XG4gICAgZmx1aWQuZGVzdHJveWVkTWFya2VyID0ge1wiX19DT01QT05FTlRfREVTVFJPWUVEX19cIjogdHJ1ZX07XG5cbiAgICAvLyBBIHBhdGggZGVwdGggYWJvdmUgd2hpY2ggdGhlIGNvcmUgXCJwcm9jZXNzIHN0cmF0ZWdpZXNcIiB3aWxsIGJhaWwgb3V0LCBhc3N1bWluZyB0aGF0IHRoZVxuICAgIC8vIHN0cnVjdHVyZSBoYXMgYmVjb21lIGNpcmN1bGFybHkgbGlua2VkLiBIZWxwZnVsIGluIGVudmlyb25tZW50cyBzdWNoIGFzIEZpcmVidWcgd2hpY2ggd2lsbFxuICAgIC8vIGtpbGwgdGhlIGJyb3dzZXIgcHJvY2VzcyBpZiB0aGV5IGhhcHBlbiB0byBiZSBvcGVuIHdoZW4gYSBzdGFjayBvdmVyZmxvdyBvY2N1cnMuIEFsc28gcHJvdmlkZXNcbiAgICAvLyBhIG1vcmUgaGVscGZ1bCBkaWFnbm9zdGljLlxuICAgIGZsdWlkLnN0cmF0ZWd5UmVjdXJzaW9uQmFpbG91dCA9IDUwO1xuXG4gICAgLy8gdW5zdXBwb3J0ZWQsIE5PTi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5tYWtlTWVyZ2VTdHJhdGVneSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBzdHJhdGVneSA9IGZ1bmN0aW9uICh0YXJnZXQsIG5hbWUsIGksIHNlZ3MsIHNvdXJjZXMsIHBvbGljeSkge1xuICAgICAgICAgICAgaWYgKGkgPiBmbHVpZC5zdHJhdGVneVJlY3Vyc2lvbkJhaWxvdXQpIHtcbiAgICAgICAgICAgICAgICBmbHVpZC5mYWlsKFwiT3ZlcmZsb3cvY2lyY3VsYXJpdHkgaW4gb3B0aW9ucyBtZXJnaW5nLCBjdXJyZW50IHBhdGggaXMgXCIsIHNlZ3MsIFwiIGF0IGRlcHRoIFwiICwgaSwgXCIgLSBwbGVhc2UgcHJvdGVjdCBjb21wb25lbnRzIGZyb20gbWVyZ2luZyB1c2luZyB0aGUgXFxcIm5vbWVyZ2VcXFwiIG1lcmdlIHBvbGljeVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmbHVpZC5pc1ByaW1pdGl2ZSh0YXJnZXQpKSB7IC8vIEZvciBcInVzZSBzdHJpY3RcIlxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7IC8vIFJldmlldyB0aGlzIGFmdGVyIEZMVUlELTQ5MjUgc2luY2UgdGhlIG9ubHkgdHJpZ2dlciBpcyBpbiBzbG93IGNvbXBvbmVudCBsb29rYWhlYWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmbHVpZC5pc1RyYWNpbmcpIHtcbiAgICAgICAgICAgICAgICBmbHVpZC50cmFjaW5nLnBhdGhDb3VudC5wdXNoKGZsdWlkLnBhdGgoc2Vncy5zbGljZSgwLCBpKSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb2xkVGFyZ2V0O1xuICAgICAgICAgICAgaWYgKHRhcmdldC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkgeyAvLyBiYWlsIG91dCBpZiBvdXIgd29yayBoYXMgYWxyZWFkeSBiZWVuIGRvbmVcbiAgICAgICAgICAgICAgICBvbGRUYXJnZXQgPSB0YXJnZXRbbmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLmV2YWx1YXRlRnVsbHkpIHsgLy8gc2VlIG5vdGVzIG9uIHRoaXMgaGFjayBpbiBcImluaXR0ZXJcIiAtIGVhcmx5IGF0dGVtcHQgdG8gZGVhbCB3aXRoIEZMVUlELTQ5MzBcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9sZFRhcmdldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHsgLy8gVGhpcyBpcyBoYXJkd2lyZWQgaGVyZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyAtIG5vIG5lZWQgdG8gcHJvdGVjdCBkZWVwZXIgc3RyYXRlZ2llc1xuICAgICAgICAgICAgICAgIHRhcmdldFtuYW1lXSA9IGZsdWlkLmluRXZhbHVhdGlvbk1hcmtlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzb3VyY2VzID09PSB1bmRlZmluZWQpIHsgLy8gcmVjb3ZlciBvdXIgc3RhdGUgaW4gY2FzZSB0aGlzIGlzIGFuIGV4dGVybmFsIGVudHJ5IHBvaW50XG4gICAgICAgICAgICAgICAgc2VncyA9IGZsdWlkLm1ha2VBcnJheShzZWdzKTsgLy8gYXZvaWQgdHJhc2hpbmcgY2FsbGVyJ3Mgc2Vnc1xuICAgICAgICAgICAgICAgIHNvdXJjZXMgPSByZWdlbmVyYXRlU291cmNlcyhvcHRpb25zLnNvdXJjZXMsIHNlZ3MsIGkgLSAxLCBvcHRpb25zLnNvdXJjZVN0cmF0ZWdpZXMpO1xuICAgICAgICAgICAgICAgIHBvbGljeSA9IHJlZ2VuZXJhdGVDdXJzb3Iob3B0aW9ucy5tZXJnZVBvbGljeSwgc2VncywgaSAtIDEsIGZsdWlkLmNvbmNyZXRlVHJ1bmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdmFyIHRoaXNQb2xpY3kgPSBmbHVpZC5kZXJlZk1lcmdlUG9saWN5KHBvbGljeSk7XG4gICAgICAgICAgICB2YXIgbmV3UG9saWN5SG9sZGVyID0gZmx1aWQuY29uY3JldGVUcnVuZGxlcihwb2xpY3ksIG5hbWUpO1xuICAgICAgICAgICAgdmFyIG5ld1BvbGljeSA9IGZsdWlkLmRlcmVmTWVyZ2VQb2xpY3kobmV3UG9saWN5SG9sZGVyKTtcblxuICAgICAgICAgICAgdmFyIHN0YXJ0LCBsaW1pdCwgbXVsO1xuICAgICAgICAgICAgaWYgKG5ld1BvbGljeS5yZXBsYWNlKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSAxIC0gc291cmNlcy5sZW5ndGg7IGxpbWl0ID0gMDsgbXVsID0gLTE7IC8qIG9uIG9uZSBsaW5lIGZvciBlYXNpZXIgdmlzdWFsIGNvbXBhcmlzb24gb2YgdGhlIHR3byBhbGdvcml0aG1zICAqLyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gMDsgbGltaXQgPSBzb3VyY2VzLmxlbmd0aCAtIDE7IG11bCA9ICsxOyAvKiBvbiBvbmUgbGluZSBmb3IgZWFzaWVyIHZpc3VhbCBjb21wYXJpc29uIG9mIHRoZSB0d28gYWxnb3JpdGhtcyAgKi8gLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbmV3U291cmNlcyA9IFtdO1xuICAgICAgICAgICAgdmFyIHRoaXNUYXJnZXQ7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSBzdGFydDsgaiA8PSBsaW1pdDsgKytqKSB7IC8vIFRPRE86IHRyeSB0byBlY29ub21pc2Ugb24gdGhpcyBhcnJheSBhbmQgb24gZ2Fwc1xuICAgICAgICAgICAgICAgIHZhciBrID0gbXVsICogajtcbiAgICAgICAgICAgICAgICB2YXIgdGhpc1NvdXJjZSA9IG9wdGlvbnMuc291cmNlU3RyYXRlZ2llc1trXShzb3VyY2VzW2tdLCBuYW1lLCBpLCBzZWdzKTsgLy8gUnVuIHRoZSBSSCBhbGdvcml0aG0gaW4gXCJkcml2aW5nXCIgbW9kZVxuICAgICAgICAgICAgICAgIGlmICh0aGlzU291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U291cmNlc1trXSA9IHRoaXNTb3VyY2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRUYXJnZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG11bCA9PT0gLTEpIHsgLy8gaWYgd2UgYXJlIGdvaW5nIGJhY2t3YXJkcywgaXQgaXMgXCJyZXBsYWNlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzVGFyZ2V0ID0gdGFyZ2V0W25hbWVdID0gdGhpc1NvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdyaXRlIHRoaXMgaW4gZWFybHksIHNpbmNlIGVhcmx5IGV4cGFuc2lvbnMgbWF5IGdlbmVyYXRlIGEgdHJ1bmsgb2JqZWN0IHdoaWNoIGlzIHdyaXR0ZW4gaW4gdG8gYnkgbGF0ZXIgb25lc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNUYXJnZXQgPSB0YXJnZXRbbmFtZV0gPSBmbHVpZC5tZXJnZU9uZUltcGwodGhpc1RhcmdldCwgdGhpc1NvdXJjZSwgaiwgbmV3U291cmNlcywgbmV3UG9saWN5LCBpLCBzZWdzLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvbGRUYXJnZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXNUYXJnZXQgPSBvbGRUYXJnZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3U291cmNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmbHVpZC5pc1ByaW1pdGl2ZSh0aGlzVGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICBmbHVpZC5mZXRjaE1lcmdlQ2hpbGRyZW4odGhpc1RhcmdldCwgaSwgc2VncywgbmV3U291cmNlcywgbmV3UG9saWN5SG9sZGVyLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2xkVGFyZ2V0ID09PSB1bmRlZmluZWQgJiYgbmV3U291cmNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGFyZ2V0W25hbWVdOyAvLyByZW1vdmUgdGhlIGV2YWx1YXRpb24gbWFya2VyIC0gbm90aGluZyB0byBldmFsdWF0ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXNUYXJnZXQ7XG4gICAgICAgIH07XG4gICAgICAgIG9wdGlvbnMuc3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgICAgICAgcmV0dXJuIHN0cmF0ZWd5O1xuICAgIH07XG5cbiAgICAvLyBBIHNpbXBsZSBzdGFuZC1pbiBmb3IgXCJmbHVpZC5nZXRcIiB3aGVyZSB0aGUgbWF0ZXJpYWwgaXMgY292ZXJlZCBieSBhIHNpbmdsZSBzdHJhdGVneVxuICAgIGZsdWlkLmRyaXZlU3RyYXRlZ3kgPSBmdW5jdGlvbiAocm9vdCwgcGF0aFNlZ3MsIHN0cmF0ZWd5KSB7XG4gICAgICAgIHBhdGhTZWdzID0gZmx1aWQubWFrZUFycmF5KHBhdGhTZWdzKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoU2Vncy5sZW5ndGg7ICsrIGkpIHtcbiAgICAgICAgICAgIGlmICghcm9vdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb290ID0gc3RyYXRlZ3kocm9vdCwgcGF0aFNlZ3NbaV0sIGkgKyAxLCBwYXRoU2Vncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfTtcblxuICAgIC8vIEEgdmVyeSBzaW1wbGUgXCJuZXcgaW5uZXIgdHJ1bmRsZXJcIiB0aGF0IGp1c3QgcGVyZm9ybXMgY29uY3JldGUgcHJvcGVydHkgYWNjZXNzXG4gICAgLy8gTm90ZSB0aGF0IGV2ZXJ5IFwic3RyYXRlZ3lcIiBpcyBhbHNvIGEgXCJ0cnVuZGxlclwiIG9mIHRoaXMgdHlwZSwgY29uc2lkZXJpbmcganVzdCB0aGUgZmlyc3QgdHdvIGFyZ3VtZW50c1xuICAgIGZsdWlkLmNvbmNyZXRlVHJ1bmRsZXIgPSBmdW5jdGlvbiAoc291cmNlLCBzZWcpIHtcbiAgICAgICAgcmV0dXJuICFzb3VyY2U/IHVuZGVmaW5lZCA6IHNvdXJjZVtzZWddO1xuICAgIH07XG5cbiAgICAvKiogTWVyZ2UgYSBjb2xsZWN0aW9uIG9mIG9wdGlvbnMgc3RydWN0dXJlcyBvbnRvIGEgdGFyZ2V0LCBmb2xsb3dpbmcgYW4gb3B0aW9uYWwgcG9saWN5LlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIG5vdyB1c2VkIG9ubHkgZm9yIHRoZSBwdXJwb3NlIG9mIG1lcmdpbmcgXCJkZWFkXCIgb3B0aW9uIGRvY3VtZW50cyBpbiBvcmRlciB0b1xuICAgICAqIGNhY2hlIGdyYWRlZCBjb21wb25lbnQgZGVmYXVsdHMuIENvbXBvbmVudCBvcHRpb24gbWVyZ2luZyBpcyBub3cgcGVyZm9ybWVkIGJ5IHRoZVxuICAgICAqIGZsdWlkLm1ha2VNZXJnZU9wdGlvbnMgcGF0aHdheSB3aGljaCBzZXRzIHVwIGEgZGVmZXJyZWQgbWVyZ2luZyBwcm9jZXNzLiBUaGlzIGZ1bmN0aW9uXG4gICAgICogd2lsbCBub3QgYmUgcmVtb3ZlZCBpbiB0aGUgRmx1aWQgMi4wIHJlbGVhc2UgYnV0IGl0IGlzIHJlY29tbWVuZGVkIHRoYXQgdXNlcnMgbm90IGNhbGwgaXRcbiAgICAgKiBkaXJlY3RseS5cbiAgICAgKiBUaGUgYmVoYXZpb3VyIG9mIHRoaXMgZnVuY3Rpb24gaXMgZXhwbGFpbmVkIG1vcmUgZnVsbHkgb25cbiAgICAgKiB0aGUgcGFnZSBodHRwOi8vd2lraS5mbHVpZHByb2plY3Qub3JnL2Rpc3BsYXkvZmx1aWQvT3B0aW9ucytNZXJnaW5nK2ZvcitGbHVpZCtDb21wb25lbnRzIC5cbiAgICAgKiBAcGFyYW0gcG9saWN5IHtPYmplY3QvU3RyaW5nfSBBIFwicG9saWN5IG9iamVjdFwiIHNwZWNpZml5aW5nIHRoZSB0eXBlIG9mIG1lcmdlIHRvIGJlIHBlcmZvcm1lZC5cbiAgICAgKiBJZiBwb2xpY3kgaXMgb2YgdHlwZSB7U3RyaW5nfSBpdCBzaG91bGQgdGFrZSBvbiB0aGUgdmFsdWUgXCJyZXBsYWNlXCIgcmVwcmVzZW50aW5nXG4gICAgICogYSBzdGF0aWMgcG9saWN5LiBJZiBpdCBpcyBhblxuICAgICAqIE9iamVjdCwgaXQgc2hvdWxkIGNvbnRhaW4gYSBtYXBwaW5nIG9mIEVMIHBhdGhzIG9udG8gdGhlc2UgU3RyaW5nIHZhbHVlcywgcmVwcmVzZW50aW5nIGFcbiAgICAgKiBmaW5lLWdyYWluZWQgcG9saWN5LiBJZiBpdCBpcyBhbiBPYmplY3QsIHRoZSB2YWx1ZXMgbWF5IGFsc28gdGhlbXNlbHZlcyBiZSBFTCBwYXRoc1xuICAgICAqIHJlcHJlc2VudGluZyB0aGF0IGEgZGVmYXVsdCB2YWx1ZSBpcyB0byBiZSB0YWtlbiBmcm9tIHRoYXQgcGF0aC5cbiAgICAgKiBAcGFyYW0gb3B0aW9uczEsIG9wdGlvbnMyLCAuLi4uIHtPYmplY3R9IGFuIGFyYml0cmFyeSBsaXN0IG9mIG9wdGlvbnMgc3RydWN0dXJlIHdoaWNoIGFyZSB0b1xuICAgICAqIGJlIG1lcmdlZCB0b2dldGhlci4gVGhlc2Ugd2lsbCBub3QgYmUgbW9kaWZpZWQuXG4gICAgICovXG5cbiAgICBmbHVpZC5tZXJnZSA9IGZ1bmN0aW9uIChwb2xpY3kgLyosIC4uLiBzb3VyY2VzICovKSB7XG4gICAgICAgIHZhciBzb3VyY2VzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgdmFyIGNvbXBpbGVkID0gZmx1aWQuY29tcGlsZU1lcmdlUG9saWN5KHBvbGljeSkuYnVpbHRpbnM7XG4gICAgICAgIHZhciBvcHRpb25zID0gZmx1aWQubWFrZU1lcmdlT3B0aW9ucyhjb21waWxlZCwgc291cmNlcywge30pO1xuICAgICAgICBvcHRpb25zLmluaXR0ZXIoKTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMudGFyZ2V0O1xuICAgIH07XG5cbiAgICAvLyB1bnN1cHBvcnRlZCwgTk9OLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLnNpbXBsZUdpbmdlckJsb2NrID0gZnVuY3Rpb24gKHNvdXJjZSwgcmVjb3JkVHlwZSkge1xuICAgICAgICB2YXIgYmxvY2sgPSB7XG4gICAgICAgICAgICB0YXJnZXQ6IHNvdXJjZSxcbiAgICAgICAgICAgIHNpbXBsZTogdHJ1ZSxcbiAgICAgICAgICAgIHN0cmF0ZWd5OiBmbHVpZC5jb25jcmV0ZVRydW5kbGVyLFxuICAgICAgICAgICAgaW5pdHRlcjogZmx1aWQuaWRlbnRpdHksXG4gICAgICAgICAgICByZWNvcmRUeXBlOiByZWNvcmRUeXBlLFxuICAgICAgICAgICAgcHJpb3JpdHk6IGZsdWlkLm1lcmdlUmVjb3JkVHlwZXNbcmVjb3JkVHlwZV1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH07XG5cbiAgICAvLyB1bnN1cHBvcnRlZCwgTk9OLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLm1ha2VNZXJnZU9wdGlvbnMgPSBmdW5jdGlvbiAocG9saWN5LCBzb3VyY2VzLCB1c2VyT3B0aW9ucykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG1lcmdlUG9saWN5OiBwb2xpY3ksXG4gICAgICAgICAgICBzb3VyY2VzOiBzb3VyY2VzXG4gICAgICAgIH07XG4gICAgICAgIG9wdGlvbnMgPSAkLmV4dGVuZChvcHRpb25zLCB1c2VyT3B0aW9ucyk7XG4gICAgICAgIG9wdGlvbnMudGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQgfHwgZmx1aWQuZnJlc2hDb250YWluZXIob3B0aW9ucy5zb3VyY2VzWzBdKTtcbiAgICAgICAgb3B0aW9ucy5zb3VyY2VTdHJhdGVnaWVzID0gb3B0aW9ucy5zb3VyY2VTdHJhdGVnaWVzIHx8IGZsdWlkLmdlbmVyYXRlKG9wdGlvbnMuc291cmNlcy5sZW5ndGgsIGZsdWlkLmNvbmNyZXRlVHJ1bmRsZXIpO1xuICAgICAgICBvcHRpb25zLmluaXR0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGhhY2sgaXMgbmVjZXNzYXJ5IHRvIGVuc3VyZSB0aGF0IHRoZSBGSU5BTCBldmFsdWF0aW9uIGRvZXNuJ3QgYmFsayB3aGVuIGRpc2NvdmVyaW5nIGEgdHJ1bmsgcGF0aCB3aGljaCB3YXMgYWxyZWFkeVxuICAgICAgICAgICAgLy8gdmlzaXRlZCBkdXJpbmcgc2VsZi1kcml2aW5nIHZpYSB0aGUgZXhwYW5kZXIuIFRoaXMgYmktbW9kYWxpdHkgaXMgc29ydCBvZiBydWJiaXNoLCBidXQgd2UgY3VycmVudGx5IGRvbid0IGhhdmUgXCJyb29tXCJcbiAgICAgICAgICAgIC8vIGluIHRoZSBzdHJhdGVneSBBUEkgdG8gZXhwcmVzcyB3aGVuIGZ1bGwgZXZhbHVhdGlvbiBpcyByZXF1aXJlZCAtIGFuZCB0aGUgXCJmbG9vZGluZyBBUElcIiBpcyBub3Qgc3RhbmRhcmRpc2VkLiBTZWUgRkxVSUQtNDkzMFxuICAgICAgICAgICAgb3B0aW9ucy5ldmFsdWF0ZUZ1bGx5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGZsdWlkLmZldGNoTWVyZ2VDaGlsZHJlbihvcHRpb25zLnRhcmdldCwgMCwgW10sIG9wdGlvbnMuc291cmNlcywgb3B0aW9ucy5tZXJnZVBvbGljeSwgb3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICAgIGZsdWlkLm1ha2VNZXJnZVN0cmF0ZWd5KG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9O1xuXG4gICAgLy8gdW5zdXBwb3J0ZWQsIE5PTi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC50cmFuc2Zvcm1PcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMsIHRyYW5zUmVjKSB7XG4gICAgICAgIGZsdWlkLmV4cGVjdChcIk9wdGlvbnMgdHJhbnNmb3JtYXRpb24gcmVjb3JkXCIsIFtcInRyYW5zZm9ybWVyXCIsIFwiY29uZmlnXCJdLCB0cmFuc1JlYyk7XG4gICAgICAgIHZhciB0cmFuc0Z1bmMgPSBmbHVpZC5nZXRHbG9iYWxWYWx1ZSh0cmFuc1JlYy50cmFuc2Zvcm1lcik7XG4gICAgICAgIHJldHVybiB0cmFuc0Z1bmMuY2FsbChudWxsLCBvcHRpb25zLCB0cmFuc1JlYy5jb25maWcpO1xuICAgIH07XG5cbiAgICAvLyB1bnN1cHBvcnRlZCwgTk9OLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLmZpbmRNZXJnZUJsb2NrcyA9IGZ1bmN0aW9uIChtZXJnZUJsb2NrcywgcmVjb3JkVHlwZSkge1xuICAgICAgICByZXR1cm4gZmx1aWQucmVtb3ZlX2lmKGZsdWlkLm1ha2VBcnJheShtZXJnZUJsb2NrcyksIGZ1bmN0aW9uIChibG9jaykgeyByZXR1cm4gYmxvY2sucmVjb3JkVHlwZSAhPT0gcmVjb3JkVHlwZTsgfSk7XG4gICAgfTtcblxuICAgIC8vIHVuc3VwcG9ydGVkLCBOT04tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQudHJhbnNmb3JtT3B0aW9uc0Jsb2NrcyA9IGZ1bmN0aW9uIChtZXJnZUJsb2NrcywgdHJhbnNmb3JtT3B0aW9ucywgcmVjb3JkVHlwZXMpIHtcbiAgICAgICAgZmx1aWQuZWFjaChyZWNvcmRUeXBlcywgZnVuY3Rpb24gKHJlY29yZFR5cGUpIHtcbiAgICAgICAgICAgIHZhciBibG9ja3MgPSBmbHVpZC5maW5kTWVyZ2VCbG9ja3MobWVyZ2VCbG9ja3MsIHJlY29yZFR5cGUpO1xuICAgICAgICAgICAgZmx1aWQuZWFjaChibG9ja3MsIGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICAgICAgICAgIGJsb2NrW2Jsb2NrLnNpbXBsZT8gXCJ0YXJnZXRcIjogXCJzb3VyY2VcIl0gPSBmbHVpZC50cmFuc2Zvcm1PcHRpb25zKGJsb2NrLnNvdXJjZSwgdHJhbnNmb3JtT3B0aW9ucyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIHVuc3VwcG9ydGVkLCBOT04tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQuZGVsaXZlck9wdGlvbnNTdHJhdGVneSA9IGZsdWlkLmlkZW50aXR5O1xuICAgIGZsdWlkLmNvbXB1dGVDb21wb25lbnRBY2Nlc3NvciA9IGZsdWlkLmlkZW50aXR5O1xuICAgIGZsdWlkLmNvbXB1dGVEeW5hbWljQ29tcG9uZW50cyA9IGZsdWlkLmlkZW50aXR5O1xuXG4gICAgLy8gVGhlIChleHRlbnNpYmxlKSB0eXBlcyBvZiBtZXJnZSByZWNvcmQgdGhlIHN5c3RlbSBzdXBwb3J0cywgd2l0aCB0aGUgd2Vha2VzdCByZWNvcmRzIGZpcnN0XG4gICAgZmx1aWQubWVyZ2VSZWNvcmRUeXBlcyA9IHtcbiAgICAgICAgZGVmYXVsdHM6ICAgICAgICAgICAgIDAsXG4gICAgICAgIGxvY2FsT3B0aW9uczogICAgICAgIDUwLCAvLyBwcm92aXNpb25hbFxuICAgICAgICBkZWZhdWx0VmFsdWVNZXJnZTogIDEwMCxcbiAgICAgICAgc3ViY29tcG9uZW50UmVjb3JkOiAyMDAsXG4gICAgICAgIGRpc3RyaWJ1dGlvbjogICAgICAgMzAwLFxuICAgICAgICAvLyByZW5kZXJlckRlY29yYXRvcjogIDQwMCwgLy8gVE9ETywgdGhlc2UgYXJlIHByb2JhYmx5IGhvbm91cmVkIGFscmVhZHkgYXMgXCJ1c2VyXCJcbiAgICAgICAgdXNlcjogICAgICAgICAgICAgICA1MDAsXG4gICAgICAgIGRlbWFuZHM6ICAgICAgICAgICAgNjAwIC8vIGFuZCBhYm92ZVxuICAgIH07XG5cbiAgICAvKiogRGVsZXRlIHRoZSB2YWx1ZSBpbiB0aGUgc3VwcGxpZWQgb2JqZWN0IGhlbGQgYXQgdGhlIHNwZWNpZmllZCBwYXRoXG4gICAgICogQHBhcmFtIHRhcmdldCB7T2JqZWN0fSBUaGUgb2JqZWN0IGhvbGRpbmcgdGhlIHZhbHVlIHRvIGJlIGRlbGV0ZWQgKHBvc3NpYmx5IGVtcHR5KVxuICAgICAqIEBwYXJhbSBwYXRoIHtTdHJpbmcvQXJyYXkgb2YgU3RyaW5nfSB0aGUgcGF0aCBvZiB0aGUgdmFsdWUgdG8gYmUgZGVsZXRlZFxuICAgICAqL1xuXG4gICAgZmx1aWQuZGVzdHJveVZhbHVlID0gZnVuY3Rpb24gKHRhcmdldCwgcGF0aCkge1xuICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICBmbHVpZC5tb2RlbC5hcHBseUNoYW5nZVJlcXVlc3QodGFyZ2V0LCB7dHlwZTogXCJERUxFVEVcIiwgcGF0aDogcGF0aH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNZXJnZXMgdGhlIGNvbXBvbmVudCdzIGRlY2xhcmVkIGRlZmF1bHRzLCBhcyBvYnRhaW5lZCBmcm9tIGZsdWlkLmRlZmF1bHRzKCksXG4gICAgICogd2l0aCB0aGUgdXNlcidzIHNwZWNpZmllZCBvdmVycmlkZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGhhdCB0aGUgaW5zdGFuY2UgdG8gYXR0YWNoIHRoZSBvcHRpb25zIHRvXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbXBvbmVudE5hbWUgdGhlIHVuaXF1ZSBcIm5hbWVcIiBvZiB0aGUgY29tcG9uZW50LCB3aGljaCB3aWxsIGJlIHVzZWRcbiAgICAgKiB0byBmZXRjaCB0aGUgZGVmYXVsdCBvcHRpb25zIGZyb20gc3RvcmUuIEJ5IHJlY29tbWVuZGF0aW9uLCB0aGlzIHNob3VsZCBiZSB0aGUgZ2xvYmFsXG4gICAgICogbmFtZSBvZiB0aGUgY29tcG9uZW50J3MgY3JlYXRvciBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdXNlck9wdGlvbnMgdGhlIHVzZXItc3BlY2lmaWVkIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhpcyBjb21wb25lbnRcbiAgICAgKi9cbiAgICAvLyB1bnN1cHBvcnRlZCwgTk9OLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLm1lcmdlQ29tcG9uZW50T3B0aW9ucyA9IGZ1bmN0aW9uICh0aGF0LCBjb21wb25lbnROYW1lLCB1c2VyT3B0aW9ucywgbG9jYWxPcHRpb25zKSB7XG4gICAgICAgIHZhciByYXdEZWZhdWx0cyA9IGZsdWlkLnJhd0RlZmF1bHRzKGNvbXBvbmVudE5hbWUpO1xuICAgICAgICB2YXIgZGVmYXVsdHMgPSBmbHVpZC5nZXRHcmFkZWREZWZhdWx0cyhjb21wb25lbnROYW1lLCByYXdEZWZhdWx0cyAmJiByYXdEZWZhdWx0cy5ncmFkZU5hbWVzID8gbnVsbCA6IGxvY2FsT3B0aW9ucy5ncmFkZU5hbWVzKTtcbiAgICAgICAgdmFyIHNoYXJlZE1lcmdlUG9saWN5ID0ge307XG5cbiAgICAgICAgdmFyIG1lcmdlQmxvY2tzID0gW107XG5cbiAgICAgICAgaWYgKGZsdWlkLmV4cGFuZENvbXBvbmVudE9wdGlvbnMpIHtcbiAgICAgICAgICAgIG1lcmdlQmxvY2tzID0gbWVyZ2VCbG9ja3MuY29uY2F0KGZsdWlkLmV4cGFuZENvbXBvbmVudE9wdGlvbnMoc2hhcmVkTWVyZ2VQb2xpY3ksIGRlZmF1bHRzLCB1c2VyT3B0aW9ucywgdGhhdCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVyZ2VCbG9ja3MgPSBtZXJnZUJsb2Nrcy5jb25jYXQoW2ZsdWlkLnNpbXBsZUdpbmdlckJsb2NrKGRlZmF1bHRzLCBcImRlZmF1bHRzXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsdWlkLnNpbXBsZUdpbmdlckJsb2NrKHVzZXJPcHRpb25zLCBcInVzZXJcIildKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3B0aW9ucyA9IHt9OyAvLyB1bHRpbWF0ZSB0YXJnZXRcbiAgICAgICAgdmFyIHNvdXJjZVN0cmF0ZWdpZXMgPSBbXSwgc291cmNlcyA9IFtdO1xuICAgICAgICB2YXIgYmFzZU1lcmdlT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHRhcmdldDogb3B0aW9ucyxcbiAgICAgICAgICAgIHNvdXJjZVN0cmF0ZWdpZXM6IHNvdXJjZVN0cmF0ZWdpZXNcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQ2FsbGVkIGJvdGggZnJvbSBoZXJlIGFuZCBmcm9tIElvQyB3aGVuZXZlciB0aGVyZSBpcyBhIGNoYW5nZSBvZiBibG9jayBjb250ZW50IG9yIGFyZ3VtZW50cyB3aGljaFxuICAgICAgICAvLyByZXF1aXJlcyB0aGVtIHRvIGJlIHJlc29ydGVkIGFuZCByZWJvdW5kXG4gICAgICAgIHZhciB1cGRhdGVCbG9ja3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBtZXJnZUJsb2Nrcy5zb3J0KGZsdWlkLnByaW9yaXR5Q29tcGFyYXRvcik7XG4gICAgICAgICAgICBzb3VyY2VTdHJhdGVnaWVzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICBzb3VyY2VzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICBmbHVpZC5lYWNoKG1lcmdlQmxvY2tzLCBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgICAgICAgICBzb3VyY2VTdHJhdGVnaWVzLnB1c2goYmxvY2suc3RyYXRlZ3kpO1xuICAgICAgICAgICAgICAgIHNvdXJjZXMucHVzaChibG9jay50YXJnZXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHVwZGF0ZUJsb2NrcygpO1xuICAgICAgICB2YXIgbWVyZ2VPcHRpb25zID0gZmx1aWQubWFrZU1lcmdlT3B0aW9ucyhzaGFyZWRNZXJnZVBvbGljeSwgc291cmNlcywgYmFzZU1lcmdlT3B0aW9ucyk7XG4gICAgICAgIG1lcmdlT3B0aW9ucy5tZXJnZUJsb2NrcyA9IG1lcmdlQmxvY2tzO1xuICAgICAgICBtZXJnZU9wdGlvbnMudXBkYXRlQmxvY2tzID0gdXBkYXRlQmxvY2tzO1xuICAgICAgICBtZXJnZU9wdGlvbnMuZGVzdHJveVZhbHVlID0gZnVuY3Rpb24gKHBhdGgpIHsgLy8gVGhpcyBtZXRob2QgaXMgYSB0ZW1wb3JhcnkgaGFjayB0byBhc3Npc3QgRkxVSUQtNTA5MVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXJnZUJsb2Nrcy5sZW5ndGg7ICsrIGkpIHtcbiAgICAgICAgICAgICAgICBmbHVpZC5kZXN0cm95VmFsdWUobWVyZ2VCbG9ja3NbaV0udGFyZ2V0LCBwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZsdWlkLmRlc3Ryb3lWYWx1ZShiYXNlTWVyZ2VPcHRpb25zLnRhcmdldCwgcGF0aCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGNvbXBpbGVkUG9saWN5O1xuICAgICAgICB2YXIgbWVyZ2VQb2xpY3k7XG4gICAgICAgIGZ1bmN0aW9uIGNvbXB1dGVNZXJnZVBvbGljeSgpIHtcbiAgICAgICAgICAgIC8vIERlY29kZSB0aGUgbm93IGF2YWlsYWJsZSBtZXJnZVBvbGljeVxuICAgICAgICAgICAgbWVyZ2VQb2xpY3kgPSBmbHVpZC5kcml2ZVN0cmF0ZWd5KG9wdGlvbnMsIFwibWVyZ2VQb2xpY3lcIiwgbWVyZ2VPcHRpb25zLnN0cmF0ZWd5KTtcbiAgICAgICAgICAgIG1lcmdlUG9saWN5ID0gJC5leHRlbmQoe30sIGZsdWlkLnJvb3RNZXJnZVBvbGljeSwgbWVyZ2VQb2xpY3kpO1xuICAgICAgICAgICAgY29tcGlsZWRQb2xpY3kgPSBmbHVpZC5jb21waWxlTWVyZ2VQb2xpY3kobWVyZ2VQb2xpY3kpO1xuICAgICAgICAgICAgLy8gVE9ETzogZXhwYW5kQ29tcG9uZW50T3B0aW9ucyBoYXMgYWxyZWFkeSBwdXQgc29tZSBidWlsdGlucyBoZXJlIC0gcGVyZm9ybWFuY2UgaW1wbGljYXRpb25zIG9mIHRoZSBub3cgaHVnZVxuICAgICAgICAgICAgLy8gZGVmYXVsdCBtZXJnZVBvbGljeSBtYXRlcmlhbCBuZWVkIHRvIGJlIGludmVzdGlnYXRlZCBhcyB3ZWxsIGFzIHRoaXMgZGVlcCBtZXJnZVxuICAgICAgICAgICAgJC5leHRlbmQodHJ1ZSwgc2hhcmVkTWVyZ2VQb2xpY3ksIGNvbXBpbGVkUG9saWN5LmJ1aWx0aW5zKTsgLy8gZW5zdXJlIGl0IGdldHMgYnJvYWRjYXN0IHRvIGFsbCBzaGFyZXJzXG4gICAgICAgIH1cbiAgICAgICAgY29tcHV0ZU1lcmdlUG9saWN5KCk7XG5cbiAgICAgICAgaWYgKGNvbXBpbGVkUG9saWN5Lmhhc0RlZmF1bHRzKSB7XG4gICAgICAgICAgICBpZiAoZmx1aWQuZ2VuZXJhdGVFeHBhbmRCbG9jaykge1xuICAgICAgICAgICAgICAgIG1lcmdlQmxvY2tzLnB1c2goZmx1aWQuZ2VuZXJhdGVFeHBhbmRCbG9jayh7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBjb21waWxlZFBvbGljeS5kZWZhdWx0VmFsdWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkVHlwZTogXCJkZWZhdWx0VmFsdWVNZXJnZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHk6IGZsdWlkLm1lcmdlUmVjb3JkVHlwZXMuZGVmYXVsdFZhbHVlTWVyZ2VcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhhdCwge30pKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVCbG9ja3MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZsdWlkLmZhaWwoXCJDYW5ub3Qgb3BlcmF0ZSBtZXJnZVBvbGljeSBcIiwgbWVyZ2VQb2xpY3ksIFwiIGZvciBjb21wb25lbnQgXCIsIHRoYXQsIFwiIHdpdGhvdXQgaW5jbHVkaW5nIEZsdWlkSW9DLmpzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoYXQub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHZhciBvcHRpb25zTmlja05hbWUgPSBmbHVpZC5kcml2ZVN0cmF0ZWd5KG9wdGlvbnMsIFwibmlja05hbWVcIiwgbWVyZ2VPcHRpb25zLnN0cmF0ZWd5KTtcbiAgICAgICAgdGhhdC5uaWNrTmFtZSA9IG9wdGlvbnNOaWNrTmFtZSB8fCBmbHVpZC5jb21wdXRlTmlja05hbWUodGhhdC50eXBlTmFtZSk7XG4gICAgICAgIGZsdWlkLmRyaXZlU3RyYXRlZ3kob3B0aW9ucywgXCJncmFkZU5hbWVzXCIsIG1lcmdlT3B0aW9ucy5zdHJhdGVneSk7XG5cbiAgICAgICAgZmx1aWQuZGVsaXZlck9wdGlvbnNTdHJhdGVneSh0aGF0LCBvcHRpb25zLCBtZXJnZU9wdGlvbnMpOyAvLyBkbyB0aGlzIGVhcmx5IHRvIGJyb2FkY2FzdCBhbmQgcmVjZWl2ZSBcImRpc3RyaWJ1dGVPcHRpb25zXCJcblxuICAgICAgICB2YXIgdHJhbnNmb3JtT3B0aW9ucyA9IGZsdWlkLmRyaXZlU3RyYXRlZ3kob3B0aW9ucywgXCJ0cmFuc2Zvcm1PcHRpb25zXCIsIG1lcmdlT3B0aW9ucy5zdHJhdGVneSk7XG4gICAgICAgIGlmICh0cmFuc2Zvcm1PcHRpb25zKSB7XG4gICAgICAgICAgICBmbHVpZC50cmFuc2Zvcm1PcHRpb25zQmxvY2tzKG1lcmdlQmxvY2tzLCB0cmFuc2Zvcm1PcHRpb25zLCBbXCJ1c2VyXCIsIFwic3ViY29tcG9uZW50UmVjb3JkXCJdKTtcbiAgICAgICAgICAgIHVwZGF0ZUJsb2NrcygpOyAvLyBiZWNhdXNlIHRoZSBwb3NzaWJseSBzaW1wbGUgYmxvY2tzIG1heSBoYXZlIGNoYW5nZWQgdGFyZ2V0XG4gICAgICAgIH1cblxuICAgICAgICBmbHVpZC5jb21wdXRlQ29tcG9uZW50QWNjZXNzb3IodGhhdCk7XG4gICAgICAgIGlmICghYmFzZU1lcmdlT3B0aW9ucy50YXJnZXQubWVyZ2VQb2xpY3kpIHtcbiAgICAgICAgICAgIGNvbXB1dGVNZXJnZVBvbGljeSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1lcmdlT3B0aW9ucztcbiAgICB9O1xuXG4gICAgLy8gVGhlIEZsdWlkIENvbXBvbmVudCBTeXN0ZW0gcHJvcGVyXG5cbiAgICAvLyBUaGUgYmFzZSBzeXN0ZW0gZ3JhZGUgZGVmaW5pdGlvbnNcblxuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmx1aWQuZnVuY3Rpb25cIiwge30pO1xuXG4gICAgLyoqIEludm9rZSBhIGdsb2JhbCBmdW5jdGlvbiBieSBuYW1lIGFuZCBuYW1lZCBhcmd1bWVudHMuIEEgY291cnRlc3kgdG8gYWxsb3cgZGVjbGFyYXRpdmVseSBlbmNvZGVkIGZ1bmN0aW9uIGNhbGxzXG4gICAgICogdG8gdXNlIG5hbWVkIGFyZ3VtZW50cyByYXRoZXIgdGhhbiBiYXJlIGFycmF5cy5cbiAgICAgKiBAcGFyYW0gbmFtZSB7U3RyaW5nfSBBIGdsb2JhbCBuYW1lIHdoaWNoIGNhbiBiZSByZXNvbHZlZCB0byBhIEZ1bmN0aW9uLiBUaGUgZGVmYXVsdHMgZm9yIHRoaXMgbmFtZSBtdXN0XG4gICAgICogcmVzb2x2ZSBvbnRvIGEgZ3JhZGUgaW5jbHVkaW5nIFwiZmx1aWQuZnVuY3Rpb25cIi4gVGhlIGRlZmF1bHRzIHJlY29yZCBzaG91bGQgYWxzbyBjb250YWluIGFuIGVudHJ5XG4gICAgICogPGNvZGU+YXJndW1lbnRNYXA8L2NvZGU+LCBhIGhhc2ggb2YgYXJndW1lbnQgbmFtZXMgb250byBpbmRleGVzLlxuICAgICAqIEBwYXJhbSBzcGVjIHtPYmplY3R9IEEgbmFtZWQgaGFzaCBob2xkaW5nIHRoZSBhcmd1bWVudCB2YWx1ZXMgdG8gYmUgc2VudCB0byB0aGUgZnVuY3Rpb24uIFRoZXNlIHdpbGwgYmUgbG9va2VkXG4gICAgICogdXAgaW4gdGhlIDxjb2RlPmFyZ3VtZW50TWFwPC9jb2RlPiBhbmQgcmVzb2x2ZWQgaW50byBhIGZsYXQgbGlzdCBvZiBhcmd1bWVudHMuXG4gICAgICogQHJldHVybiB7QW55fSBUaGUgcmV0dXJuIHZhbHVlIGZyb20gdGhlIGZ1bmN0aW9uXG4gICAgICovXG5cbiAgICBmbHVpZC5pbnZva2VHcmFkZWRGdW5jdGlvbiA9IGZ1bmN0aW9uIChuYW1lLCBzcGVjKSB7XG4gICAgICAgIHZhciBkZWZhdWx0cyA9IGZsdWlkLmRlZmF1bHRzKG5hbWUpO1xuICAgICAgICBpZiAoIWRlZmF1bHRzIHx8ICFkZWZhdWx0cy5hcmd1bWVudE1hcCB8fCAhZmx1aWQuaGFzR3JhZGUoZGVmYXVsdHMsIFwiZmx1aWQuZnVuY3Rpb25cIikpIHtcbiAgICAgICAgICAgIGZsdWlkLmZhaWwoXCJDYW5ub3QgbG9vayB1cCBuYW1lIFwiICsgbmFtZSArXG4gICAgICAgICAgICAgICAgXCIgdG8gYSBmdW5jdGlvbiB3aXRoIHJlZ2lzdGVyZWQgYXJndW1lbnRNYXAgLSBnb3QgZGVmYXVsdHMgXCIsIGRlZmF1bHRzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmbHVpZC5lYWNoKGRlZmF1bHRzLmFyZ3VtZW50TWFwLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgICAgYXJnc1t2YWx1ZV0gPSBzcGVjW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmx1aWQuaW52b2tlR2xvYmFsRnVuY3Rpb24obmFtZSwgYXJncyk7XG4gICAgfTtcblxuICAgIGZsdWlkLmxpZmVjeWNsZUZ1bmN0aW9ucyA9IHtcbiAgICAgICAgcHJlSW5pdEZ1bmN0aW9uOiB0cnVlLFxuICAgICAgICBwb3N0SW5pdEZ1bmN0aW9uOiB0cnVlLFxuICAgICAgICBmaW5hbEluaXRGdW5jdGlvbjogdHJ1ZVxuICAgIH07XG5cbiAgICBmbHVpZC5yb290TWVyZ2VQb2xpY3kgPSAkLmV4dGVuZCh7XG4gICAgICAgIGdyYWRlTmFtZXM6IGZsdWlkLmFycmF5Q29uY2F0UG9saWN5LFxuICAgICAgICBkaXN0cmlidXRlT3B0aW9uczogZmx1aWQuYXJyYXlDb25jYXRQb2xpY3ksXG4gICAgICAgIHRyYW5zZm9ybU9wdGlvbnM6IFwicmVwbGFjZVwiXG4gICAgfSwgZmx1aWQudHJhbnNmb3JtKGZsdWlkLmxpZmVjeWNsZUZ1bmN0aW9ucywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmx1aWQubWVyZ2VMaXN0ZW5lclBvbGljeTtcbiAgICB9KSk7XG5cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsdWlkLmxpdHRsZUNvbXBvbmVudFwiLCB7XG4gICAgICAgIGdyYWRlTmFtZXM6IFtcImF1dG9Jbml0XCJdLFxuICAgICAgICBpbml0RnVuY3Rpb246IFwiZmx1aWQuaW5pdExpdHRsZUNvbXBvbmVudFwiLFxuICAgICAgICBtZXJnZVBvbGljeTogZmx1aWQucm9vdE1lcmdlUG9saWN5LFxuICAgICAgICBhcmd1bWVudE1hcDoge1xuICAgICAgICAgICAgb3B0aW9uczogMFxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsdWlkLmV2ZW50ZWRDb21wb25lbnRcIiwge1xuICAgICAgICBncmFkZU5hbWVzOiBbXCJmbHVpZC5saXR0bGVDb21wb25lbnRcIiwgXCJhdXRvSW5pdFwiXSxcbiAgICAgICAgZXZlbnRzOiB7IC8vIEZpdmUgc3RhbmRhcmQgbGlmZWN5Y2xlIHBvaW50cyBjb21tb24gdG8gYWxsIGNvbXBvbmVudHNcbiAgICAgICAgICAgIG9uQ3JlYXRlOiAgICAgbnVsbCxcbiAgICAgICAgICAgIG9uQXR0YWNoOiAgICAgbnVsbCwgLy8gb25BdHRhY2gsIG9uQ2xlYXIgYXJlIG9ubHkgZmlyZWQgZm9yIElvQy1jb25maWd1cmVkIGNvbXBvbmVudHNcbiAgICAgICAgICAgIG9uQ2xlYXI6ICAgICAgbnVsbCxcbiAgICAgICAgICAgIG9uRGVzdHJveTogICAgbnVsbCxcbiAgICAgICAgICAgIGFmdGVyRGVzdHJveTogbnVsbFxuICAgICAgICB9LFxuICAgICAgICBtZXJnZVBvbGljeToge1xuICAgICAgICAgICAgbGlzdGVuZXJzOiBmbHVpZC5tYWtlTWVyZ2VMaXN0ZW5lcnNQb2xpY3koZmx1aWQubWVyZ2VMaXN0ZW5lclBvbGljeSlcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqIEEgc3BlY2lhbCBcIm1hcmtlciBvYmplY3RcIiB3aGljaCBpcyByZWNvZ25pc2VkIGFzIG9uZSBvZiB0aGUgYXJndW1lbnRzIHRvXG4gICAgICogZmx1aWQuaW5pdFN1YmNvbXBvbmVudHMuIFRoaXMgb2JqZWN0IGlzIHJlY29nbmlzZWQgYnkgcmVmZXJlbmNlIGVxdWFsaXR5IC1cbiAgICAgKiB3aGVyZSBpdCBpcyBmb3VuZCwgaXQgaXMgcmVwbGFjZWQgaW4gdGhlIGFjdHVhbCBhcmd1bWVudCBwb3NpdGlvbiBzdXBwbGllZFxuICAgICAqIHRvIHRoZSBzcGVjaWZpYyBzdWJjb21wb25lbnQgaW5zdGFuY2UsIHdpdGggdGhlIHBhcnRpY3VsYXIgb3B0aW9ucyBibG9ja1xuICAgICAqIGZvciB0aGF0IGluc3RhbmNlIGF0dGFjaGVkIHRvIHRoZSBvdmVyYWxsIFwidGhhdFwiIG9iamVjdC5cbiAgICAgKiBOT1RFOiBUaGUgdXNlIG9mIHRoaXMgbWFya2VyIGhhcyBiZWVuIGRlcHJlY2F0ZWQgYXMgb2YgdGhlIEZsdWlkIDEuNCByZWxlYXNlIGluXG4gICAgICogZmF2b3VyIG9mIHRoZSBjb250ZXh0dWFsIEVMIHBhdGggXCJ7b3B0aW9uc31cIiAtIGl0IHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZVxuICAgICAqIHJlbGVhc2Ugb2YgdGhlIGZyYW1ld29yay5cbiAgICAgKi9cbiAgICBmbHVpZC5DT01QT05FTlRfT1BUSU9OUyA9IHt0eXBlOiBcImZsdWlkLm1hcmtlclwiLCB2YWx1ZTogXCJDT01QT05FTlRfT1BUSU9OU1wifTtcblxuICAgIC8qKiBDb25zdHJ1Y3QgYSBkdW1teSBvciBcInBsYWNlaG9sZGVyXCIgc3ViY29tcG9uZW50LCB0aGF0IG9wdGlvbmFsbHkgcHJvdmlkZXMgZW1wdHlcbiAgICAgKiBpbXBsZW1lbnRhdGlvbnMgZm9yIGEgc2V0IG9mIG1ldGhvZHMuXG4gICAgICovXG4gICAgLy8gVE9ETzogdGhpcyBtZXRob2QgaXMgaW5lZmZpY2llbnQgYW5kIGluYXBwcm9wcmlhdGUsIHNob3VsZCBzaW1wbHkgZGlzY2FyZCBvcHRpb25zIGVudGlyZWx5IHBlbmRpbmcgcmV2aWV3XG4gICAgZmx1aWQuZW1wdHlTdWJjb21wb25lbnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgdGhhdCA9IGZsdWlkLnR5cGVUYWcoXCJmbHVpZC5lbXB0eVN1YmNvbXBvbmVudFwiKTtcbiAgICAgICAgdGhhdC5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdGhhdC5vcHRpb25zLmdyYWRlTmFtZXMgPSBbdGhhdC50eXBlTmFtZV07XG5cbiAgICAgICAgb3B0aW9ucyA9IGZsdWlkLm1ha2VBcnJheShvcHRpb25zKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRpb25zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB0aGF0W29wdGlvbnNbaV1dID0gZmx1aWQuaWRlbnRpdHk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfTtcblxuICAgIC8qKiBDb21wdXRlIGEgXCJuaWNrbmFtZVwiIGdpdmVuIGEgZnVsbHkgcXVhbGlmaWVkIHR5cGVuYW1lLCBieSByZXR1cm5pbmcgdGhlIGxhc3QgcGF0aFxuICAgICAqIHNlZ21lbnQuXG4gICAgICovXG5cbiAgICBmbHVpZC5jb21wdXRlTmlja05hbWUgPSBmdW5jdGlvbiAodHlwZU5hbWUpIHtcbiAgICAgICAgdmFyIHNlZ3MgPSBmbHVpZC5tb2RlbC5wYXJzZUVMKHR5cGVOYW1lKTtcbiAgICAgICAgcmV0dXJuIHNlZ3Nbc2Vncy5sZW5ndGggLSAxXTtcbiAgICB9O1xuXG4gICAgLyoqIEEgY29tYmluZWQgXCJjb21wb25lbnQgYW5kIGdyYWRlIG5hbWVcIiB3aGljaCBhbGxvd3MgdHlwZSB0YWdzIHRvIGJlIGRlY2xhcmF0aXZlbHkgY29uc3RydWN0ZWRcbiAgICAgKiBmcm9tIG9wdGlvbnMgbWF0ZXJpYWwuIEFueSBjb21wb25lbnQgZm91bmQgYmVhcmluZyB0aGlzIGdyYWRlIHdpbGwgYmUgaW5zdGFudGlhdGVkIGZpcnN0IGFtb25nc3RcbiAgICAgKiBpdHMgc2V0IG9mIHNpYmxpbmdzLCBzaW5jZSBpdCBpcyBsaWtlbHkgdG8gYmVhciBhIGNvbnRleHQtZm9ybWluZyB0eXBlIG5hbWUgKi9cblxuICAgIGZsdWlkLnR5cGVGb3VudCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciB0aGF0ID0gZmx1aWQuaW5pdExpdHRsZUNvbXBvbmVudChcImZsdWlkLnR5cGVGb3VudFwiLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGZsdWlkLnR5cGVUYWcodGhhdC5vcHRpb25zLnRhcmdldFR5cGVOYW1lKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBcImxpdHRsZSBjb21wb25lbnRcIjogYSB0aGF0LWlzdCBvYmplY3Qgd2l0aCBvcHRpb25zIG1lcmdlZCBpbnRvIGl0IGJ5IHRoZSBmcmFtZXdvcmsuXG4gICAgICogVGhpcyBtZXRob2QgaXMgYSBjb252ZW5pZW5jZSBmb3IgY3JlYXRpbmcgc21hbGwgb2JqZWN0cyB0aGF0IGhhdmUgb3B0aW9ucyBidXQgZG9uJ3QgcmVxdWlyZSBmdWxsXG4gICAgICogVmlldy1saWtlIGZlYXR1cmVzIHN1Y2ggYXMgdGhlIERPTSBCaW5kZXIgb3IgZXZlbnRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbmFtZSB0aGUgbmFtZSBvZiB0aGUgbGl0dGxlIGNvbXBvbmVudCB0byBjcmVhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB1c2VyLXN1cHBsaWVkIG9wdGlvbnMgdG8gbWVyZ2Ugd2l0aCB0aGUgZGVmYXVsdHNcbiAgICAgKi9cbiAgICAvLyBOT1RFOiB0aGUgM3JkIGFyZ3VtZW50IGxvY2FsT3B0aW9ucyBpcyBOT1QgdG8gYmUgYWR2ZXJ0aXNlZCBhcyBwYXJ0IG9mIHRoZSBzdGFibGUgQVBJLCBpdCBpcyBwcmVzZW50XG4gICAgLy8ganVzdCB0byBhbGxvdyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdoaWxzdCBncmFkZSBzcGVjaWZpY2F0aW9ucyBhcmUgbm90IG1hbmRhdG9yeSAtIHNpbWlsYXJseSBmb3IgNHRoIGFyZyBcInJlY2VpdmVyXCJcbiAgICBmbHVpZC5pbml0TGl0dGxlQ29tcG9uZW50ID0gZnVuY3Rpb24gKG5hbWUsIHVzZXJPcHRpb25zLCBsb2NhbE9wdGlvbnMsIHJlY2VpdmVyKSB7XG4gICAgICAgIHZhciB0aGF0ID0gZmx1aWQudHlwZVRhZyhuYW1lKTtcbiAgICAgICAgbG9jYWxPcHRpb25zID0gbG9jYWxPcHRpb25zIHx8IHtncmFkZU5hbWVzOiBcImZsdWlkLmxpdHRsZUNvbXBvbmVudFwifTtcblxuICAgICAgICB0aGF0LmRlc3Ryb3kgPSBmbHVpZC5tYWtlUm9vdERlc3Ryb3kodGhhdCk7IC8vIG92ZXJ3cml0dGVuIGJ5IEZsdWlkSW9DIGZvciBjb25zdHJ1Y3RlZCBzdWJjb21wb25lbnRzXG4gICAgICAgIHZhciBtZXJnZU9wdGlvbnMgPSBmbHVpZC5tZXJnZUNvbXBvbmVudE9wdGlvbnModGhhdCwgbmFtZSwgdXNlck9wdGlvbnMsIGxvY2FsT3B0aW9ucyk7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhhdC5vcHRpb25zO1xuICAgICAgICB2YXIgZXZlbnRlZCA9IGZsdWlkLmhhc0dyYWRlKG9wdGlvbnMsIFwiZmx1aWQuZXZlbnRlZENvbXBvbmVudFwiKTtcbiAgICAgICAgaWYgKGV2ZW50ZWQpIHtcbiAgICAgICAgICAgIHRoYXQuZXZlbnRzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVsaXZlciB0byBhIG5vbi1Jb0Mgc2lkZSBlYXJseSByZWNlaXZlciBvZiB0aGUgY29tcG9uZW50IChjdXJyZW50bHkgb25seSBpbml0VmlldylcbiAgICAgICAgKHJlY2VpdmVyIHx8IGZsdWlkLmlkZW50aXR5KSh0aGF0LCBvcHRpb25zLCBtZXJnZU9wdGlvbnMuc3RyYXRlZ3kpO1xuICAgICAgICBmbHVpZC5jb21wdXRlRHluYW1pY0NvbXBvbmVudHModGhhdCwgbWVyZ2VPcHRpb25zKTtcblxuICAgICAgICAvLyBUT0RPOiAqKioqVEhJUyoqKiogaXMgdGhlIHBvaW50IHdlIG11c3QgZGVsaXZlciBhbmQgc3VzcGVuZCEhIENvbnN0cnVjdCB0aGUgXCJjb21wb25lbnQgc2tlbGV0b25cIiBmaXJzdCwgYW5kIHRoZW4gY29udGludWVcbiAgICAgICAgLy8gZm9yIGFzIGxvbmcgYXMgd2UgY2FuIGNvbnRpbnVlIHRvIGZpbmQgY29tcG9uZW50cy5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXJnZU9wdGlvbnMubWVyZ2VCbG9ja3MubGVuZ3RoOyArKyBpKSB7XG4gICAgICAgICAgICBtZXJnZU9wdGlvbnMubWVyZ2VCbG9ja3NbaV0uaW5pdHRlcigpO1xuICAgICAgICB9XG4gICAgICAgIG1lcmdlT3B0aW9ucy5pbml0dGVyKCk7XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLm1lcmdlUG9saWN5O1xuXG4gICAgICAgIGZsdWlkLmluaXRMaWZlY3ljbGVGdW5jdGlvbnModGhhdCk7XG4gICAgICAgIGZsdWlkLmZpcmVFdmVudChvcHRpb25zLCBcInByZUluaXRGdW5jdGlvblwiLCB0aGF0KTtcblxuICAgICAgICBpZiAoZXZlbnRlZCkge1xuICAgICAgICAgICAgZmx1aWQuaW5zdGFudGlhdGVGaXJlcnModGhhdCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBmbHVpZC5tZXJnZUxpc3RlbmVycyh0aGF0LCB0aGF0LmV2ZW50cywgb3B0aW9ucy5saXN0ZW5lcnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZmx1aWQuaGFzR3JhZGUob3B0aW9ucywgXCJhdXRvSW5pdFwiKSkge1xuICAgICAgICAgICAgZmx1aWQuY2xlYXJMaWZlY3ljbGVGdW5jdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfTtcblxuICAgIC8vIHVuc3VwcG9ydGVkLCBOT04tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQudXBkYXRlV2l0aERlZmF1bHRMaWZlY3ljbGUgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgdHlwZU5hbWUpIHtcbiAgICAgICAgdmFyIGZ1bmNOYW1lID0gdHlwZU5hbWUgKyBcIi5cIiArIGtleS5zdWJzdHJpbmcoMCwga2V5Lmxlbmd0aCAtIFwiZnVuY3Rpb25cIi5sZW5ndGgpO1xuICAgICAgICB2YXIgZnVuY1ZhbCA9IGZsdWlkLmdldEdsb2JhbFZhbHVlKGZ1bmNOYW1lKTtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnVuY1ZhbCkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdmFsdWUgPSBmbHVpZC5tYWtlQXJyYXkodmFsdWUpO1xuICAgICAgICAgICAgdmFyIGV4aXN0aW5nID0gZmx1aWQuZmluZCh2YWx1ZSwgZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gZWwubGlzdGVuZXIgfHwgZWw7XG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyID09PSBmdW5jVmFsIHx8IGxpc3RlbmVyID09PSBmdW5jTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghZXhpc3RpbmcpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZS5wdXNoKGZ1bmNWYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuXG4gICAgLy8gdW5zdXBwb3J0ZWQsIE5PTi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5pbml0TGlmZWN5Y2xlRnVuY3Rpb25zID0gZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgICAgdmFyIGdyYWRlTmFtZXMgPSB0aGF0Lm9wdGlvbnMuZ3JhZGVOYW1lcyB8fCBbXTtcbiAgICAgICAgZmx1aWQuZWFjaChmbHVpZC5saWZlY3ljbGVGdW5jdGlvbnMsIGZ1bmN0aW9uIChmdW5jLCBrZXkpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoYXQub3B0aW9uc1trZXldO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGdyYWRlTmFtZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLSBpKSB7IC8vIG1vc3Qgc3BlY2lmaWMgZ3JhZGVzIGFyZSBhdCBmcm9udFxuICAgICAgICAgICAgICAgIGlmIChncmFkZU5hbWVzW2ldICE9PSBcImF1dG9Jbml0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBmbHVpZC51cGRhdGVXaXRoRGVmYXVsdExpZmVjeWNsZShrZXksIHZhbHVlLCBncmFkZU5hbWVzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGF0Lm9wdGlvbnNba2V5XSA9IGZsdWlkLm1ha2VFdmVudEZpcmVyKHtuYW1lOiBrZXksIG93bmVySWQ6IHRoYXQuaWR9KTtcbiAgICAgICAgICAgICAgICBmbHVpZC5ldmVudC5hZGRMaXN0ZW5lclRvRmlyZXIodGhhdC5vcHRpb25zW2tleV0sIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIHVuc3VwcG9ydGVkLCBOT04tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQuY2xlYXJMaWZlY3ljbGVGdW5jdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBmbHVpZC5lYWNoKGZsdWlkLmxpZmVjeWNsZUZ1bmN0aW9ucywgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgICBkZWxldGUgb3B0aW9ucy5pbml0RnVuY3Rpb247XG4gICAgfTtcblxuICAgIGZsdWlkLmRpYWdub3NlRmFpbGVkVmlldyA9IGZsdWlkLmlkZW50aXR5O1xuXG4gICAgLy8gdW5zdXBwb3J0ZWQsIE5PTi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5tYWtlUm9vdERlc3Ryb3kgPSBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZmx1aWQuZmlyZUV2ZW50KHRoYXQsIFwiZXZlbnRzLm9uQ2xlYXJcIiwgW3RoYXQsIFwiXCIsIG51bGxdKTtcbiAgICAgICAgICAgIGZsdWlkLmRvRGVzdHJveSh0aGF0KTtcbiAgICAgICAgICAgIGZsdWlkLmZpcmVFdmVudCh0aGF0LCBcImV2ZW50cy5hZnRlckRlc3Ryb3lcIiwgW3RoYXQsIFwiXCIsIG51bGxdKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqIFJldHVybnMgPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhlIHN1cHBsaWVkIHJlZmVyZW5jZSBob2xkcyBhIGNvbXBvbmVudCB3aGljaCBoYXMgYmVlbiBkZXN0cm95ZWQgKiovXG5cbiAgICBmbHVpZC5pc0Rlc3Ryb3llZCA9IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICAgIHJldHVybiB0aGF0LmRlc3Ryb3kgPT09IGZsdWlkLmRlc3Ryb3llZE1hcmtlcjtcbiAgICB9O1xuXG4gICAgLy8gdW5zdXBwb3J0ZWQsIE5PTi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5kb0Rlc3Ryb3kgPSBmdW5jdGlvbiAodGhhdCwgbmFtZSwgcGFyZW50KSB7XG4gICAgICAgIGZsdWlkLmZpcmVFdmVudCh0aGF0LCBcImV2ZW50cy5vbkRlc3Ryb3lcIiwgW3RoYXQsIG5hbWUgfHwgXCJcIiwgcGFyZW50XSk7XG4gICAgICAgIHRoYXQuZGVzdHJveSA9IGZsdWlkLmRlc3Ryb3llZE1hcmtlcjtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoYXQuZXZlbnRzKSB7XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSBcImFmdGVyRGVzdHJveVwiICYmIHR5cGVvZih0aGF0LmV2ZW50c1trZXldLmRlc3Ryb3kpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB0aGF0LmV2ZW50c1trZXldLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhhdC5hcHBsaWVyKSB7IC8vIFRPRE86IEJyZWFrIHRoaXMgb3V0IGludG8gdGhlIGdyYWRlJ3MgZGVzdHJveWVyXG4gICAgICAgICAgICB0aGF0LmFwcGxpZXIuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZsdWlkLnJlc29sdmVSZXR1cm5lZFBhdGggPSBmbHVpZC5pZGVudGl0eTtcblxuICAgIC8vIHVuc3VwcG9ydGVkLCBOT04tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQuaW5pdENvbXBvbmVudCA9IGZ1bmN0aW9uIChjb21wb25lbnROYW1lLCBpbml0QXJncykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGZsdWlkLmRlZmF1bHRzKGNvbXBvbmVudE5hbWUpO1xuICAgICAgICBpZiAoIW9wdGlvbnMuZ3JhZGVOYW1lcykge1xuICAgICAgICAgICAgZmx1aWQuZmFpbChcIkNhbm5vdCBpbml0aWFsaXNlIGNvbXBvbmVudCBcIiArIGNvbXBvbmVudE5hbWUgKyBcIiB3aGljaCBoYXMgbm8gZ3JhZGVOYW1lIHJlZ2lzdGVyZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFyZ3MgPSBbY29tcG9uZW50TmFtZV0uY29uY2F0KGZsdWlkLm1ha2VBcnJheShpbml0QXJncykpOyAvLyBUT0RPOiBzdXBwb3J0IGRpZmZlcmVudCBpbml0RnVuY3Rpb24gdmFyaWFudHNcbiAgICAgICAgdmFyIHRoYXQ7XG4gICAgICAgIGZsdWlkLnB1c2hBY3Rpdml0eShcImluaXRDb21wb25lbnRcIiwgXCJjb25zdHJ1Y3RpbmcgY29tcG9uZW50IG9mIHR5cGUgJWNvbXBvbmVudE5hbWUgd2l0aCBhcmd1bWVudHMgJWluaXRBcmdzXCIsXG4gICAgICAgICAgICB7Y29tcG9uZW50TmFtZTogY29tcG9uZW50TmFtZSwgaW5pdEFyZ3M6IGluaXRBcmdzfSk7XG4gICAgICAgIHRoYXQgPSBmbHVpZC5pbnZva2VHbG9iYWxGdW5jdGlvbihvcHRpb25zLmluaXRGdW5jdGlvbiwgYXJncyk7XG4gICAgICAgIGZsdWlkLmRpYWdub3NlRmFpbGVkVmlldyhjb21wb25lbnROYW1lLCB0aGF0LCBvcHRpb25zLCBhcmdzKTtcbiAgICAgICAgZmx1aWQuZmlyZUV2ZW50KHRoYXQub3B0aW9ucywgXCJwb3N0SW5pdEZ1bmN0aW9uXCIsIHRoYXQpO1xuICAgICAgICBpZiAoZmx1aWQuaW5pdERlcGVuZGVudHMpIHtcbiAgICAgICAgICAgIGZsdWlkLmluaXREZXBlbmRlbnRzKHRoYXQpO1xuICAgICAgICB9XG4gICAgICAgIGZsdWlkLmZpcmVFdmVudCh0aGF0Lm9wdGlvbnMsIFwiZmluYWxJbml0RnVuY3Rpb25cIiwgdGhhdCk7XG4gICAgICAgIGZsdWlkLmNsZWFyTGlmZWN5Y2xlRnVuY3Rpb25zKHRoYXQub3B0aW9ucyk7XG4gICAgICAgIGZsdWlkLmZpcmVFdmVudCh0aGF0LCBcImV2ZW50cy5vbkNyZWF0ZVwiLCB0aGF0KTtcbiAgICAgICAgZmx1aWQucG9wQWN0aXZpdHkoKTtcbiAgICAgICAgcmV0dXJuIGZsdWlkLnJlc29sdmVSZXR1cm5lZFBhdGgodGhhdC5vcHRpb25zLnJldHVybmVkUGF0aCwgdGhhdCkgPyBmbHVpZC5nZXQodGhhdCwgdGhhdC5vcHRpb25zLnJldHVybmVkUGF0aCkgOiB0aGF0O1xuICAgIH07XG5cbiAgICAvLyB1bnN1cHBvcnRlZCwgTk9OLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLmluaXRTdWJjb21wb25lbnRJbXBsID0gZnVuY3Rpb24gKHRoYXQsIGVudHJ5LCBhcmdzKSB7XG4gICAgICAgIHZhciB0b2dvO1xuICAgICAgICBpZiAodHlwZW9mIChlbnRyeSkgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdmFyIGVudHJ5VHlwZSA9IHR5cGVvZiAoZW50cnkpID09PSBcInN0cmluZ1wiID8gZW50cnkgOiBlbnRyeS50eXBlO1xuICAgICAgICAgICAgdG9nbyA9IGVudHJ5VHlwZSA9PT0gXCJmbHVpZC5lbXB0eVN1YmNvbXBvbmVudFwiID9cbiAgICAgICAgICAgICAgICBmbHVpZC5lbXB0eVN1YmNvbXBvbmVudChlbnRyeS5vcHRpb25zKSA6XG4gICAgICAgICAgICAgICAgZmx1aWQuaW52b2tlR2xvYmFsRnVuY3Rpb24oZW50cnlUeXBlLCBhcmdzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRvZ28gPSBlbnRyeS5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9nbztcbiAgICB9O1xuXG4gICAgLyoqIEluaXRpYWxpc2UgYWxsIHRoZSBcInN1YmNvbXBvbmVudHNcIiB3aGljaCBhcmUgY29uZmlndXJlZCB0byBiZSBhdHRhY2hlZCB0b1xuICAgICAqIHRoZSBzdXBwbGllZCB0b3AtbGV2ZWwgY29tcG9uZW50LCB3aGljaCBzaGFyZSBhIHBhcnRpY3VsYXIgXCJjbGFzcyBuYW1lXCIuIFRoaXMgbWV0aG9kXG4gICAgICogb2YgaW5zdGFudGlhdGluZyBjb21wb25lbnRzIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBmYXZvdXIgb2YgdGhlIGF1dG9tYXRlZFxuICAgICAqIElvQyBzeXN0ZW0gaW4gdGhlIEZsdWlkIDIuMCByZWxlYXNlLlxuICAgICAqIEBwYXJhbSB7Q29tcG9uZW50fSB0aGF0IFRoZSB0b3AtbGV2ZWwgY29tcG9uZW50IGZvciB3aGljaCBzdWItY29tcG9uZW50cyBhcmVcbiAgICAgKiB0byBiZSBpbnN0YW50aWF0ZWQuIEl0IGNvbnRhaW5zIHNwZWNpZmljYXRpb25zIGZvciB0aGVzZSBzdWJjb21wb25lbnRzIGluIGl0c1xuICAgICAqIDxjb2RlPm9wdGlvbnM8L2NvZGU+IHN0cnVjdHVyZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NOYW1lIFRoZSBcImNsYXNzIG5hbWVcIiBvciBcImNhdGVnb3J5XCIgZm9yIHRoZSBzdWJjb21wb25lbnRzIHRvXG4gICAgICogYmUgaW5zdGFudGlhdGVkLiBBIGNsYXNzIG5hbWUgc3BlY2lmaWVzIGFuIG92ZXJhbGwgXCJmdW5jdGlvblwiIGZvciBhIGNsYXNzIG9mXG4gICAgICogc3ViY29tcG9uZW50cyBhbmQgcmVwcmVzZW50cyBhIGNhdGVnb3J5IHdoaWNoIGFjY2VwdCB0aGUgc2FtZSBzaWduYXR1cmUgb2ZcbiAgICAgKiBpbnN0YW50aWF0aW9uIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5IG9mIE9iamVjdH0gYXJncyBUaGUgaW5zdGFudGlhdGlvbiBhcmd1bWVudHMgdG8gYmUgcGFzc2VkIHRvIGVhY2hcbiAgICAgKiBjb25zdHJ1Y3RlZCBzdWJjb21wb25lbnQuIFRoZXNlIHdpbGwgdHlwaWNhbGx5IGJlIG1lbWJlcnMgZGVyaXZlZCBmcm9tIHRoZVxuICAgICAqIHRvcC1sZXZlbCA8Y29kZT50aGF0PC9jb2RlPiBvciBwZXJoYXBzIGdsb2JhbGx5IGRpc2NvdmVyZWQgZnJvbSBlbHNld2hlcmUuIE9uZVxuICAgICAqIG9mIHRoZXNlIGFyZ3VtZW50cyBtYXkgYmUgPGNvZGU+Zmx1aWQuQ09NUE9ORU5UX09QVElPTlM8L2NvZGU+IGluIHdoaWNoIGNhc2UgdGhpc1xuICAgICAqIHBsYWNlaG9sZGVyIGFyZ3VtZW50IHdpbGwgYmUgcmVwbGFjZWQgYnkgaW5zdGFuY2Utc3BlY2lmaWMgb3B0aW9ucyBjb25maWd1cmVkXG4gICAgICogaW50byB0aGUgbWVtYmVyIG9mIHRoZSB0b3AtbGV2ZWwgPGNvZGU+b3B0aW9uczwvY29kZT4gc3RydWN0dXJlIG5hbWVkIGZvciB0aGVcbiAgICAgKiA8Y29kZT5jbGFzc05hbWU8L2NvZGU+XG4gICAgICogQHJldHVybiB7QXJyYXkgb2YgT2JqZWN0fSBUaGUgaW5zdGFudGlhdGVkIHN1YmNvbXBvbmVudHMsIG9uZSBmb3IgZWFjaCBtZW1iZXJcbiAgICAgKiBvZiA8Y29kZT50aGF0Lm9wdGlvbnNbY2xhc3NOYW1lXTwvY29kZT4uXG4gICAgICovXG5cbiAgICBmbHVpZC5pbml0U3ViY29tcG9uZW50cyA9IGZ1bmN0aW9uICh0aGF0LCBjbGFzc05hbWUsIGFyZ3MpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhhdC5vcHRpb25zW2NsYXNzTmFtZV07XG4gICAgICAgIGlmICghZW50cnkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW50cmllcyA9IGZsdWlkLm1ha2VBcnJheShlbnRyeSk7XG4gICAgICAgIHZhciBvcHRpbmRleCA9IC0xO1xuICAgICAgICB2YXIgdG9nbyA9IFtdO1xuICAgICAgICBhcmdzID0gZmx1aWQubWFrZUFycmF5KGFyZ3MpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChhcmdzW2ldID09PSBmbHVpZC5DT01QT05FTlRfT1BUSU9OUykge1xuICAgICAgICAgICAgICAgIG9wdGluZGV4ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgZW50cnkgPSBlbnRyaWVzW2ldO1xuICAgICAgICAgICAgaWYgKG9wdGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGFyZ3Nbb3B0aW5kZXhdID0gZW50cnkub3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvZ29baV0gPSBmbHVpZC5pbml0U3ViY29tcG9uZW50SW1wbCh0aGF0LCBlbnRyeSwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvZ287XG4gICAgfTtcblxuICAgIGZsdWlkLmluaXRTdWJjb21wb25lbnQgPSBmdW5jdGlvbiAodGhhdCwgY2xhc3NOYW1lLCBhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbHVpZC5pbml0U3ViY29tcG9uZW50cyh0aGF0LCBjbGFzc05hbWUsIGFyZ3MpWzBdO1xuICAgIH07XG5cbiAgICAvLyAqKioqKioqIFNFTEVDVE9SIEVOR0lORSAqKioqKioqKipcblxuICAgIC8vIHNlbGVjdG9yIHJlZ2V4cHMgY29waWVkIGZyb20galF1ZXJ5IC0gcmVjZW50IHZlcnNpb25zIGNvcnJlY3QgdGhlIHJhbmdlIHRvIHN0YXJ0IEMwXG4gICAgLy8gVGhlIGluaXRpYWwgcG9ydGlvbiBvZiB0aGUgbWFpbiBjaGFyYWN0ZXIgc2VsZWN0b3IgXCJqdXN0IGFkZCB3YXRlclwiIHRvIGFkZCBvbiBleHRyYVxuICAgIC8vIGFjY2VwdGVkIGNoYXJhY3RlcnMsIGFzIHdlbGwgYXMgdGhlIFwiXFxcXFxcXFwuXCIgLT4gXCJcXC5cIiBwb3J0aW9uIG5lY2Vzc2FyeSBmb3IgbWF0Y2hpbmdcbiAgICAvLyBwZXJpb2QgY2hhcmFjdGVycyBlc2NhcGVkIGluIHNlbGVjdG9yc1xuICAgIHZhciBjaGFyU3RhcnQgPSBcIig/OltcXFxcd1xcXFx1MDBjMC1cXFxcdUZGRkYqXy1cIjtcblxuICAgIGZsdWlkLnNpbXBsZUNTU01hdGNoZXIgPSB7XG4gICAgICAgIHJlZ2V4cDogbmV3IFJlZ0V4cChcIihbIy5dPykoXCIgKyBjaGFyU3RhcnQgKyBcIl18XFxcXFxcXFwuKSspXCIsIFwiZ1wiKSxcbiAgICAgICAgY2hhclRvVGFnOiB7XG4gICAgICAgICAgICBcIlwiOiBcInRhZ1wiLFxuICAgICAgICAgICAgXCIjXCI6IFwiaWRcIixcbiAgICAgICAgICAgIFwiLlwiOiBcImNsYXp6XCJcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmbHVpZC5Jb0NTU01hdGNoZXIgPSB7XG4gICAgICAgIHJlZ2V4cDogbmV3IFJlZ0V4cChcIihbJiNdPykoXCIgKyBjaGFyU3RhcnQgKyBcIl18XFxcXC4pKylcIiwgXCJnXCIpLFxuICAgICAgICBjaGFyVG9UYWc6IHtcbiAgICAgICAgICAgIFwiXCI6IFwiY29udGV4dFwiLFxuICAgICAgICAgICAgXCImXCI6IFwiY29udGV4dFwiLFxuICAgICAgICAgICAgXCIjXCI6IFwiaWRcIlxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBjaGlsZFNlZyA9IG5ldyBSZWdFeHAoXCJcXFxccyooPik/XFxcXHMqXCIsIFwiZ1wiKTtcbi8vICAgIHZhciB3aGl0ZVNwYWNlID0gbmV3IFJlZ0V4cChcIl5cXFxcdyokXCIpO1xuXG4gICAgLy8gUGFyc2VzIGEgc2VsZWN0b3IgZXhwcmVzc2lvbiBpbnRvIGEgZGF0YSBzdHJ1Y3R1cmUgaG9sZGluZyBhIGxpc3Qgb2YgcHJlZGljYXRlc1xuICAgIC8vIDJuZCBhcmd1bWVudCBpcyBhIFwic3RyYXRlZ3lcIiBzdHJ1Y3R1cmUsIGUuZy4gIGZsdWlkLnNpbXBsZUNTU01hdGNoZXIgb3IgZmx1aWQuSW9DU1NNYXRjaGVyXG4gICAgLy8gdW5zdXBwb3J0ZWQsIG5vbi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5wYXJzZVNlbGVjdG9yID0gZnVuY3Rpb24gKHNlbHN0cmluZywgc3RyYXRlZ3kpIHtcbiAgICAgICAgdmFyIHRvZ28gPSBbXTtcbiAgICAgICAgc2Vsc3RyaW5nID0gJC50cmltKHNlbHN0cmluZyk7XG4gICAgICAgIC8vd3MtKHNzKilbd3MvPl1cbiAgICAgICAgdmFyIHJlZ2V4cCA9IHN0cmF0ZWd5LnJlZ2V4cDtcbiAgICAgICAgcmVnZXhwLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHZhciBsYXN0SW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgdmFyIGF0Tm9kZSA9IFtdOyAvLyBhIGxpc3Qgb2YgcHJlZGljYXRlcyBhdCBhIHBhcnRpY3VsYXIgbm9kZVxuICAgICAgICAgICAgdmFyIGZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlZ01hdGNoID0gcmVnZXhwLmV4ZWMoc2Vsc3RyaW5nKTtcbiAgICAgICAgICAgICAgICBpZiAoIXNlZ01hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VnTWF0Y2guaW5kZXggIT09IGxhc3RJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsdWlkLmZhaWwoXCJFcnJvciBpbiBzZWxlY3RvciBzdHJpbmcgLSBjYW5ub3QgbWF0Y2ggY2hpbGQgc2VsZWN0b3IgZXhwcmVzc2lvbiBzdGFydGluZyBhdCBcIiArIHNlbHN0cmluZy5zdWJzdHJpbmcobGFzdEluZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdGhpc05vZGUgPSB7fTtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IHNlZ01hdGNoWzJdO1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRUYWcgPSBzdHJhdGVneS5jaGFyVG9UYWdbc2VnTWF0Y2hbMV1dO1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRUYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc05vZGVbdGFyZ2V0VGFnXSA9IHRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF0Tm9kZVthdE5vZGUubGVuZ3RoXSA9IHRoaXNOb2RlO1xuICAgICAgICAgICAgICAgIGxhc3RJbmRleCA9IHJlZ2V4cC5sYXN0SW5kZXg7XG4gICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkU2VnLmxhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgICAgIHZhciBmdWxsQXROb2RlID0ge3ByZWRMaXN0OiBhdE5vZGV9O1xuICAgICAgICAgICAgdmFyIGNoaWxkTWF0Y2ggPSBjaGlsZFNlZy5leGVjKHNlbHN0cmluZyk7XG4gICAgICAgICAgICBpZiAoIWNoaWxkTWF0Y2ggfHwgY2hpbGRNYXRjaC5pbmRleCAhPT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgZmx1aWQuZmFpbChcIkVycm9yIGluIHNlbGVjdG9yIHN0cmluZyAtIGNhbiBub3QgbWF0Y2ggY2hpbGQgc2VsZWN0b3IgZXhwcmVzc2lvbiBhdCBcIiArIHNlbHN0cmluZy5zdWJzdHJpbmcobGFzdEluZGV4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hpbGRNYXRjaFsxXSA9PT0gXCI+XCIpIHtcbiAgICAgICAgICAgICAgICBmdWxsQXROb2RlLmNoaWxkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvZ29bdG9nby5sZW5ndGhdID0gZnVsbEF0Tm9kZTtcbiAgICAgICAgICAgIC8vID49IHRlc3QgaGVyZSB0byBjb21wZW5zYXRlIGZvciBJRSBidWcgaHR0cDovL2Jsb2cuc3RldmVubGV2aXRoYW4uY29tL2FyY2hpdmVzL2V4ZWMtYnVnc1xuICAgICAgICAgICAgaWYgKGNoaWxkU2VnLmxhc3RJbmRleCA+PSBzZWxzdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0SW5kZXggPSBjaGlsZFNlZy5sYXN0SW5kZXg7XG4gICAgICAgICAgICByZWdleHAubGFzdEluZGV4ID0gY2hpbGRTZWcubGFzdEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2dvO1xuICAgIH07XG5cbiAgICAvLyBNZXNzYWdlIHJlc29sdXRpb24gYW5kIHRlbXBsYXRpbmdcblxuICAgLyoqXG4gICAgKiBDb252ZXJ0cyBhIHN0cmluZyB0byBhIHJlZ2V4cCB3aXRoIHRoZSBzcGVjaWZpZWQgZmxhZ3MgZ2l2ZW4gaW4gcGFyYW1ldGVyc1xuICAgICogQHBhcmFtIHtTdHJpbmd9IGEgc3RyaW5nIHRoYXQgaGFzIHRvIGJlIHR1cm5lZCBpbnRvIGEgcmVndWxhciBleHByZXNzaW9uXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gdGhlIGZsYWdzIHRvIHByb3ZpZGUgdG8gdGhlIHJlZyBleHBcbiAgICAqL1xuICAgIGZsdWlkLnN0cmluZ1RvUmVnRXhwID0gZnVuY3Rpb24gKHN0ciwgZmxhZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoc3RyLnJlcGxhY2UoL1tcXC1cXFtcXF17fSgpKis/LixcXFxcXFxeJHwjXFxzXS9nLCBcIlxcXFwkJlwiKSwgZmxhZ3MpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTaW1wbGUgc3RyaW5nIHRlbXBsYXRlIHN5c3RlbS5cbiAgICAgKiBUYWtlcyBhIHRlbXBsYXRlIHN0cmluZyBjb250YWluaW5nIHRva2VucyBpbiB0aGUgZm9ybSBvZiBcIiV2YWx1ZVwiLlxuICAgICAqIFJldHVybnMgYSBuZXcgc3RyaW5nIHdpdGggdGhlIHRva2VucyByZXBsYWNlZCBieSB0aGUgc3BlY2lmaWVkIHZhbHVlcy5cbiAgICAgKiBLZXlzIGFuZCB2YWx1ZXMgY2FuIGJlIG9mIGFueSBkYXRhIHR5cGUgdGhhdCBjYW4gYmUgY29lcmNlZCBpbnRvIGEgc3RyaW5nLiBBcnJheXMgd2lsbCB3b3JrIGhlcmUgYXMgd2VsbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgICB0ZW1wbGF0ZSAgICBhIHN0cmluZyAoY2FuIGJlIEhUTUwpIHRoYXQgY29udGFpbnMgdG9rZW5zIGVtYmVkZGVkIGludG8gaXRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gICAgdmFsdWVzICAgICAgYSBjb2xsZWN0aW9uIG9mIHRva2VuIGtleXMgYW5kIHZhbHVlc1xuICAgICAqL1xuICAgIGZsdWlkLnN0cmluZ1RlbXBsYXRlID0gZnVuY3Rpb24gKHRlbXBsYXRlLCB2YWx1ZXMpIHtcbiAgICAgICAgdmFyIGtleXMgPSBmbHVpZC5rZXlzKHZhbHVlcyk7XG4gICAgICAgIGtleXMgPSBrZXlzLnNvcnQoZmx1aWQuY29tcGFyZVN0cmluZ0xlbmd0aCgpKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIHZhciByZSA9IGZsdWlkLnN0cmluZ1RvUmVnRXhwKFwiJVwiICsga2V5LCBcImdcIik7XG4gICAgICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLnJlcGxhY2UocmUsIHZhbHVlc1trZXldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVtcGxhdGU7XG4gICAgfTtcblxuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmx1aWQubWVzc2FnZVJlc29sdmVyXCIsIHtcbiAgICAgICAgZ3JhZGVOYW1lczogW1wiZmx1aWQubGl0dGxlQ29tcG9uZW50XCIsIFwiYXV0b0luaXRcIl0sXG4gICAgICAgIG1lcmdlUG9saWN5OiB7XG4gICAgICAgICAgICBtZXNzYWdlQmFzZTogXCJub21lcmdlXCIsXG4gICAgICAgICAgICBwYXJlbnRzOiBcIm5vbWVyZ2VcIlxuICAgICAgICB9LFxuICAgICAgICByZXNvbHZlRnVuYzogZmx1aWQuc3RyaW5nVGVtcGxhdGUsXG4gICAgICAgIHBhcnNlRnVuYzogZmx1aWQuaWRlbnRpdHksXG4gICAgICAgIG1lc3NhZ2VCYXNlOiB7fSxcbiAgICAgICAgcGFyZW50czogW11cbiAgICB9KTtcblxuICAgIGZsdWlkLm1lc3NhZ2VSZXNvbHZlci5wcmVJbml0ID0gZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgICAgdGhhdC5tZXNzYWdlQmFzZSA9IHRoYXQub3B0aW9ucy5wYXJzZUZ1bmModGhhdC5vcHRpb25zLm1lc3NhZ2VCYXNlKTtcblxuICAgICAgICB0aGF0Lmxvb2t1cCA9IGZ1bmN0aW9uIChtZXNzYWdlY29kZXMpIHtcbiAgICAgICAgICAgIHZhciByZXNvbHZlZCA9IGZsdWlkLm1lc3NhZ2VSZXNvbHZlci5yZXNvbHZlT25lKHRoYXQubWVzc2FnZUJhc2UsIG1lc3NhZ2Vjb2Rlcyk7XG4gICAgICAgICAgICBpZiAocmVzb2x2ZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbHVpZC5maW5kKHRoYXQub3B0aW9ucy5wYXJlbnRzLCBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnQgPyBwYXJlbnQubG9va3VwKG1lc3NhZ2Vjb2RlcykgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7dGVtcGxhdGU6IHJlc29sdmVkLCByZXNvbHZlRnVuYzogdGhhdC5vcHRpb25zLnJlc29sdmVGdW5jfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhhdC5yZXNvbHZlID0gZnVuY3Rpb24gKG1lc3NhZ2Vjb2RlcywgYXJncykge1xuICAgICAgICAgICAgaWYgKCFtZXNzYWdlY29kZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJbTm8gbWVzc2FnZWNvZGVzIHByb3ZpZGVkXVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWVzc2FnZWNvZGVzID0gZmx1aWQubWFrZUFycmF5KG1lc3NhZ2Vjb2Rlcyk7XG4gICAgICAgICAgICB2YXIgbG9va2VkID0gdGhhdC5sb29rdXAobWVzc2FnZWNvZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBsb29rZWQgPyBsb29rZWQucmVzb2x2ZUZ1bmMobG9va2VkLnRlbXBsYXRlLCBhcmdzKSA6XG4gICAgICAgICAgICAgICAgXCJbTWVzc2FnZSBzdHJpbmcgZm9yIGtleSBcIiArIG1lc3NhZ2Vjb2Rlc1swXSArIFwiIG5vdCBmb3VuZF1cIjtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gdW5zdXBwb3J0ZWQsIE5PTi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5tZXNzYWdlUmVzb2x2ZXIucmVzb2x2ZU9uZSA9IGZ1bmN0aW9uIChtZXNzYWdlQmFzZSwgbWVzc2FnZWNvZGVzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZWNvZGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgY29kZSA9IG1lc3NhZ2Vjb2Rlc1tpXTtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbWVzc2FnZUJhc2VbY29kZV07XG4gICAgICAgICAgICBpZiAobWVzc2FnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqIENvbnZlcnRzIGEgZGF0YSBzdHJ1Y3R1cmUgY29uc2lzdGluZyBvZiBhIG1hcHBpbmcgb2Yga2V5cyB0byBtZXNzYWdlIHN0cmluZ3MsXG4gICAgICogaW50byBhIFwibWVzc2FnZUxvY2F0b3JcIiBmdW5jdGlvbiB3aGljaCBtYXBzIGFuIGFycmF5IG9mIG1lc3NhZ2UgY29kZXMsIHRvIGJlXG4gICAgICogdHJpZWQgaW4gc2VxdWVuY2UgdW50aWwgYSBrZXkgaXMgZm91bmQsIGFuZCBhbiBhcnJheSBvZiBzdWJzdGl0dXRpb24gYXJndW1lbnRzLFxuICAgICAqIGludG8gYSBzdWJzdGl0dXRlZCBtZXNzYWdlIHN0cmluZy5cbiAgICAgKi9cbiAgICBmbHVpZC5tZXNzYWdlTG9jYXRvciA9IGZ1bmN0aW9uIChtZXNzYWdlQmFzZSwgcmVzb2x2ZUZ1bmMpIHtcbiAgICAgICAgdmFyIHJlc29sdmVyID0gZmx1aWQubWVzc2FnZVJlc29sdmVyKHttZXNzYWdlQmFzZTogbWVzc2FnZUJhc2UsIHJlc29sdmVGdW5jOiByZXNvbHZlRnVuY30pO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1lc3NhZ2Vjb2RlcywgYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVyLnJlc29sdmUobWVzc2FnZWNvZGVzLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG59KShqUXVlcnksIGZsdWlkXzJfMCk7XG47LypcbkNvcHlyaWdodCAyMDA3LTIwMTAgVW5pdmVyc2l0eSBvZiBDYW1icmlkZ2VcbkNvcHlyaWdodCAyMDA3LTIwMDkgVW5pdmVyc2l0eSBvZiBUb3JvbnRvXG5Db3B5cmlnaHQgMjAxMC0yMDExIEx1Y2VuZG8gRGV2ZWxvcG1lbnQgTHRkLlxuQ29weXJpZ2h0IDIwMTAgT0NBRCBVbml2ZXJzaXR5XG5Db3B5cmlnaHQgMjAwNS0yMDEzIGpRdWVyeSBGb3VuZGF0aW9uLCBJbmMuIGFuZCBvdGhlciBjb250cmlidXRvcnNcblxuTGljZW5zZWQgdW5kZXIgdGhlIEVkdWNhdGlvbmFsIENvbW11bml0eSBMaWNlbnNlIChFQ0wpLCBWZXJzaW9uIDIuMCBvciB0aGUgTmV3XG5CU0QgbGljZW5zZS4gWW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIG9uZSB0aGVzZVxuTGljZW5zZXMuXG5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgRUNMIDIuMCBMaWNlbnNlIGFuZCBCU0QgTGljZW5zZSBhdFxuaHR0cHM6Ly9naXRodWIuY29tL2ZsdWlkLXByb2plY3QvaW5mdXNpb24vcmF3L21hc3Rlci9JbmZ1c2lvbi1MSUNFTlNFLnR4dFxuKi9cblxuLyoqIFRoaXMgZmlsZSBjb250YWlucyBmdW5jdGlvbnMgd2hpY2ggZGVwZW5kIG9uIHRoZSBwcmVzZW5jZSBvZiBhIERPTSBkb2N1bWVudFxuICogYnV0IHdoaWNoIGRvIG5vdCBkZXBlbmQgb24gdGhlIGNvbnRlbnRzIG9mIEZsdWlkLmpzICoqL1xuXG52YXIgZmx1aWRfMl8wID0gZmx1aWRfMl8wIHx8IHt9O1xuXG4oZnVuY3Rpb24gKCQsIGZsdWlkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLyBwb2x5ZmlsbCBmb3IgJC5icm93c2VyIHdoaWNoIHdhcyByZW1vdmVkIGluIGpRdWVyeSAxLjkgYW5kIGxhdGVyXG4gICAgLy8gVGFrZW4gZnJvbSBqcXVlcnktbWlncmF0ZS0xLjIuMS5qcyxcbiAgICAvLyBqUXVlcnkgTWlncmF0ZSAtIHYxLjIuMSAtIDIwMTMtMDUtMDhcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS1taWdyYXRlXG4gICAgLy8gQ29weXJpZ2h0IDIwMDUsIDIwMTMgalF1ZXJ5IEZvdW5kYXRpb24sIEluYy4gYW5kIG90aGVyIGNvbnRyaWJ1dG9yczsgTGljZW5zZWQgTUlUXG5cbiAgICBmbHVpZC51YU1hdGNoID0gZnVuY3Rpb24gKHVhKSB7XG4gICAgICAgIHVhID0gdWEudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICB2YXIgbWF0Y2ggPSAvKGNocm9tZSlbIFxcL10oW1xcdy5dKykvLmV4ZWMoIHVhICkgfHxcbiAgICAgICAgICAgIC8od2Via2l0KVsgXFwvXShbXFx3Ll0rKS8uZXhlYyggdWEgKSB8fFxuICAgICAgICAgICAgLyhvcGVyYSkoPzouKnZlcnNpb258KVsgXFwvXShbXFx3Ll0rKS8uZXhlYyggdWEgKSB8fFxuICAgICAgICAgICAgLyhtc2llKSAoW1xcdy5dKykvLmV4ZWMoIHVhICkgfHxcbiAgICAgICAgdWEuaW5kZXhPZihcImNvbXBhdGlibGVcIikgPCAwICYmIC8obW96aWxsYSkoPzouKj8gcnY6KFtcXHcuXSspfCkvLmV4ZWMoIHVhICkgfHwgW107XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJyb3dzZXI6IG1hdGNoWyAxIF0gfHwgXCJcIixcbiAgICAgICAgICAgIHZlcnNpb246IG1hdGNoWyAyIF0gfHwgXCIwXCJcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIG1hdGNoZWQsIGJyb3dzZXI7XG5cbiAgICAvLyBEb24ndCBjbG9iYmVyIGFueSBleGlzdGluZyBqUXVlcnkuYnJvd3NlciBpbiBjYXNlIGl0J3MgZGlmZmVyZW50XG4gICAgaWYgKCEkLmJyb3dzZXIpIHtcbiAgICAgICAgaWYgKCEhbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvVHJpZGVudFxcLzdcXC4vKSkge1xuICAgICAgICAgICAgYnJvd3NlciA9IHsgLy8gRnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE4Njg0MDk5L2pxdWVyeS1mYWlsLXRvLWRldGVjdC1pZS0xMVxuICAgICAgICAgICAgICAgIG1zaWU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogMTFcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXRjaGVkID0gZmx1aWQudWFNYXRjaChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICAgICAgICAgIGJyb3dzZXIgPSB7fTtcblxuICAgICAgICAgICAgaWYgKG1hdGNoZWQuYnJvd3Nlcikge1xuICAgICAgICAgICAgICAgIGJyb3dzZXJbbWF0Y2hlZC5icm93c2VyXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJvd3Nlci52ZXJzaW9uID0gbWF0Y2hlZC52ZXJzaW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hyb21lIGlzIFdlYmtpdCwgYnV0IFdlYmtpdCBpcyBhbHNvIFNhZmFyaS5cbiAgICAgICAgICAgIGlmIChicm93c2VyLmNocm9tZSkge1xuICAgICAgICAgICAgICAgIGJyb3dzZXIud2Via2l0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYnJvd3Nlci53ZWJraXQpIHtcbiAgICAgICAgICAgICAgICBicm93c2VyLnNhZmFyaSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgJC5icm93c2VyID0gYnJvd3NlcjtcbiAgICB9XG5cbiAgICAvLyBQcml2YXRlIGNvbnN0YW50cy5cbiAgICB2YXIgTkFNRVNQQUNFX0tFWSA9IFwiZmx1aWQtc2NvcGVkLWRhdGFcIjtcblxuICAgIC8qKlxuICAgICAqIEdldHMgc3RvcmVkIHN0YXRlIGZyb20gdGhlIGpRdWVyeSBpbnN0YW5jZSdzIGRhdGEgbWFwLlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgdW5zdXBwb3J0ZWQ6IEl0IGlzIG5vdCByZWFsbHkgaW50ZW5kZWQgZm9yIHVzZSBieSBpbXBsZW1lbnRvcnMuXG4gICAgICovXG4gICAgZmx1aWQuZ2V0U2NvcGVkRGF0YSA9IGZ1bmN0aW9uKHRhcmdldCwga2V5KSB7XG4gICAgICAgIHZhciBkYXRhID0gJCh0YXJnZXQpLmRhdGEoTkFNRVNQQUNFX0tFWSk7XG4gICAgICAgIHJldHVybiBkYXRhID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTdG9yZXMgc3RhdGUgaW4gdGhlIGpRdWVyeSBpbnN0YW5jZSdzIGRhdGEgbWFwLiBVbmxpa2UgalF1ZXJ5J3MgdmVyc2lvbixcbiAgICAgKiBhY2NlcHRzIG11bHRpcGxlLWVsZW1lbnQgalF1ZXJpZXMuXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyB1bnN1cHBvcnRlZDogSXQgaXMgbm90IHJlYWxseSBpbnRlbmRlZCBmb3IgdXNlIGJ5IGltcGxlbWVudG9ycy5cbiAgICAgKi9cbiAgICBmbHVpZC5zZXRTY29wZWREYXRhID0gZnVuY3Rpb24odGFyZ2V0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgICQodGFyZ2V0KS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSAkLmRhdGEodGhpcywgTkFNRVNQQUNFX0tFWSkgfHwge307XG4gICAgICAgICAgICBkYXRhW2tleV0gPSB2YWx1ZTtcblxuICAgICAgICAgICAgJC5kYXRhKHRoaXMsIE5BTUVTUEFDRV9LRVksIGRhdGEpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqIEdsb2JhbCBmb2N1cyBtYW5hZ2VyIC0gbWFrZXMgdXNlIG9mIFwiZm9jdXNpblwiIGV2ZW50IHN1cHBvcnRlZCBpbiBqcXVlcnkgMS40LjIgb3IgbGF0ZXIuXG4gICAgICovXG5cbiAgICB2YXIgbGFzdEZvY3VzZWRFbGVtZW50ID0gbnVsbDtcblxuICAgICQoZG9jdW1lbnQpLmJpbmQoXCJmb2N1c2luXCIsIGZ1bmN0aW9uIChldmVudCl7XG4gICAgICAgIGxhc3RGb2N1c2VkRWxlbWVudCA9IGV2ZW50LnRhcmdldDtcbiAgICB9KTtcblxuICAgIGZsdWlkLmdldExhc3RGb2N1c2VkRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGxhc3RGb2N1c2VkRWxlbWVudDtcbiAgICB9O1xuXG5cbiAgICB2YXIgRU5BQkxFTUVOVF9LRVkgPSBcImVuYWJsZW1lbnRcIjtcblxuICAgIC8qKiBRdWVyaWVzIG9yIHNldHMgdGhlIGVuYWJsZWQgc3RhdHVzIG9mIGEgY29udHJvbC4gQW4gYWN0aXZhdGFibGUgbm9kZVxuICAgICAqIG1heSBiZSBcImRpc2FibGVkXCIgaW4gd2hpY2ggY2FzZSBpdHMga2V5Ym9hcmQgYmluZGluZ3Mgd2lsbCBiZSBpbm9wZXJhYmxlXG4gICAgICogKGJ1dCBzdGlsbCBzdG9yZWQpIHVudGlsIGl0IGlzIHJlZW5hYmxlZCBhZ2Fpbi5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHVuc3VwcG9ydGVkOiBJdCBpcyBub3QgcmVhbGx5IGludGVuZGVkIGZvciB1c2UgYnkgaW1wbGVtZW50b3JzLlxuICAgICAqL1xuXG4gICAgZmx1aWQuZW5hYmxlZCA9IGZ1bmN0aW9uKHRhcmdldCwgc3RhdGUpIHtcbiAgICAgICAgdGFyZ2V0ID0gJCh0YXJnZXQpO1xuICAgICAgICBpZiAoc3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZsdWlkLmdldFNjb3BlZERhdGEodGFyZ2V0LCBFTkFCTEVNRU5UX0tFWSkgIT09IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgJChcIipcIiwgdGFyZ2V0KS5hZGQodGFyZ2V0KS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChmbHVpZC5nZXRTY29wZWREYXRhKHRoaXMsIEVOQUJMRU1FTlRfS0VZKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsdWlkLnNldFNjb3BlZERhdGEodGhpcywgRU5BQkxFTUVOVF9LRVksIHN0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoL3NlbGVjdHx0ZXh0YXJlYXxpbnB1dC9pLnRlc3QodGhpcy5ub2RlTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5wcm9wKFwiZGlzYWJsZWRcIiwgIXN0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZsdWlkLnNldFNjb3BlZERhdGEodGFyZ2V0LCBFTkFCTEVNRU5UX0tFWSwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZsdWlkLmluaXRFbmFibGVtZW50ID0gZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgIGZsdWlkLnNldFNjb3BlZERhdGEodGFyZ2V0LCBFTkFCTEVNRU5UX0tFWSwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIC8vIFRoaXMgdXRpbGl0eSBpcyByZXF1aXJlZCB0aHJvdWdoIHRoZSB1c2Ugb2YgbmV3ZXIgdmVyc2lvbnMgb2YgalF1ZXJ5IHdoaWNoIHdpbGwgb2JzY3VyZSB0aGUgb3JpZ2luYWxcbiAgICAvLyBldmVudCByZXNwb25zaWJsZSBmb3IgaW50ZXJhY3Rpb24gd2l0aCBhIHRhcmdldC4gVGhpcyBpcyBjdXJyZW50bHkgdXNlIGluIFRvb2x0aXAuanMgYW5kIEZsdWlkVmlldy5qc1xuICAgIC8vIFwiZGVhZCBtYW4ncyBibHVyXCIgYnV0IHdvdWxkIGJlIG9mIGdlbmVyYWwgdXRpbGl0eVxuXG4gICAgZmx1aWQucmVzb2x2ZUV2ZW50VGFyZ2V0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHdoaWxlIChldmVudC5vcmlnaW5hbEV2ZW50ICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnQudGFyZ2V0KSB7XG4gICAgICAgICAgICBldmVudCA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50LnRhcmdldDtcbiAgICB9O1xuXG4gICAgLy8gVGhlc2UgZnVuY3Rpb24gKGZsdWlkLmZvY3VzKCkgYW5kIGZsdWlkLmJsdXIoKSkgc2VydmUgc2V2ZXJhbCBmdW5jdGlvbnMuIFRoZXkgc2hvdWxkIGJlIHVzZWQgYnlcbiAgICAvLyBhbGwgaW1wbGVtZW50YXRpb24gYm90aCBpbiB0ZXN0IGNhc2VzIGFuZCBjb21wb25lbnQgaW1wbGVtZW50YXRpb24gd2hpY2ggcmVxdWlyZSB0byB0cmlnZ2VyIGEgZm9jdXNcbiAgICAvLyBldmVudC4gRmlyc3RseSwgdGhleSByZXN0b3JlIHRoZSBvbGQgYmVoYXZpb3VyIGluIGpRdWVyeSB2ZXJzaW9ucyBwcmlvciB0byAxLjEwIGluIHdoaWNoIGEgZm9jdXNcbiAgICAvLyB0cmlnZ2VyIHN5bmNocm9ub3VzbHkgcmVsYXlzIHRvIGEgZm9jdXMgaGFuZGxlci4gSW4gbmV3ZXIgalF1ZXJpZXMgdGhpcyBkZWZlcnMgdG8gdGhlIHJlYWwgYnJvd3NlclxuICAgIC8vIHJlbGF5IHdpdGggbnVtZXJvdXMgcGxhdGZvcm0gYW5kIHRpbWluZy1kZXBlbmRlbnQgZWZmZWN0cy5cbiAgICAvLyBTZWNvbmRseSwgdGhleSBhcmUgbmVjZXNzYXJ5IHNpbmNlIHNpbXVsYXRpb24gb2YgZm9jdXMgZXZlbnRzIGJ5IGpRdWVyeSB1bmRlciBJRVxuICAgIC8vIGlzIG5vdCBzdWZmaWNpZW50bHkgZ29vZCB0byBpbnRlcmNlcHQgdGhlIFwiZm9jdXNpblwiIGJpbmRpbmcuIEFueSBjb2RlIHdoaWNoIHRyaWdnZXJzXG4gICAgLy8gZm9jdXMgb3IgYmx1ciBzeW50aGV0aWNhbGx5IHRocm91Z2hvdXQgdGhlIGZyYW1ld29yayBhbmQgY2xpZW50IGNvZGUgbXVzdCB1c2UgdGhpcyBmdW5jdGlvbixcbiAgICAvLyBlc3BlY2lhbGx5IGlmIGNvcnJlY3QgY3Jvc3MtcGxhdGZvcm0gaW50ZXJhY3Rpb24gaXMgcmVxdWlyZWQgd2l0aCB0aGUgXCJkZWFkTWFuc0JsdXJcIiBmdW5jdGlvbi5cblxuICAgIGZ1bmN0aW9uIGFwcGx5T3Aobm9kZSwgZnVuYykge1xuICAgICAgICBub2RlID0gJChub2RlKTtcbiAgICAgICAgbm9kZS50cmlnZ2VyKFwiZmx1aWQtXCIrZnVuYyk7XG4gICAgICAgIG5vZGUudHJpZ2dlckhhbmRsZXIoZnVuYyk7XG4gICAgICAgIG5vZGVbZnVuY10oKTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgJC5lYWNoKFtcImZvY3VzXCIsIFwiYmx1clwiXSwgZnVuY3Rpb24oaSwgbmFtZSkge1xuICAgICAgICBmbHVpZFtuYW1lXSA9IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBhcHBseU9wKGVsZW0sIG5hbWUpO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG59KShqUXVlcnksIGZsdWlkXzJfMCk7XG47LypcbkNvcHlyaWdodCAyMDA4LTIwMTAgVW5pdmVyc2l0eSBvZiBDYW1icmlkZ2VcbkNvcHlyaWdodCAyMDA4LTIwMDkgVW5pdmVyc2l0eSBvZiBUb3JvbnRvXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBFZHVjYXRpb25hbCBDb21tdW5pdHkgTGljZW5zZSAoRUNMKSwgVmVyc2lvbiAyLjAgb3IgdGhlIE5ld1xuQlNEIGxpY2Vuc2UuIFlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCBvbmUgdGhlc2VcbkxpY2Vuc2VzLlxuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIEVDTCAyLjAgTGljZW5zZSBhbmQgQlNEIExpY2Vuc2UgYXRcbmh0dHBzOi8vZ2l0aHViLmNvbS9mbHVpZC1wcm9qZWN0L2luZnVzaW9uL3Jhdy9tYXN0ZXIvSW5mdXNpb24tTElDRU5TRS50eHRcbiovXG5cbnZhciBmbHVpZF8yXzAgPSBmbHVpZF8yXzAgfHwge307XG5cbihmdW5jdGlvbiAoJCwgZmx1aWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGZsdWlkLmRvbSA9IGZsdWlkLmRvbSB8fCB7fTtcblxuICAgIC8vIE5vZGUgd2Fsa2VyIGZ1bmN0aW9uIGZvciBpdGVyYXRlRG9tLlxuICAgIHZhciBnZXROZXh0Tm9kZSA9IGZ1bmN0aW9uIChpdGVyYXRvcikge1xuICAgICAgICBpZiAoaXRlcmF0b3Iubm9kZS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICBpdGVyYXRvci5ub2RlID0gaXRlcmF0b3Iubm9kZS5maXJzdENoaWxkO1xuICAgICAgICAgICAgaXRlcmF0b3IuZGVwdGggKz0gMTtcbiAgICAgICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaXRlcmF0b3Iubm9kZSkge1xuICAgICAgICAgICAgaWYgKGl0ZXJhdG9yLm5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5ub2RlID0gaXRlcmF0b3Iubm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVyYXRvci5ub2RlID0gaXRlcmF0b3Iubm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgaXRlcmF0b3IuZGVwdGggLT0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFdhbGtzIHRoZSBET00sIGFwcGx5aW5nIHRoZSBzcGVjaWZpZWQgYWNjZXB0b3IgZnVuY3Rpb24gdG8gZWFjaCBlbGVtZW50LlxuICAgICAqIFRoZXJlIGlzIGEgc3BlY2lhbCBjYXNlIGZvciB0aGUgYWNjZXB0b3IsIGFsbG93aW5nIGZvciBxdWljayBkZWxldGlvbiBvZiBlbGVtZW50cyBhbmQgdGhlaXIgY2hpbGRyZW4uXG4gICAgICogUmV0dXJuIFwiZGVsZXRlXCIgZnJvbSB5b3VyIGFjY2VwdG9yIGZ1bmN0aW9uIGlmIHlvdSB3YW50IHRvIGRlbGV0ZSB0aGUgZWxlbWVudCBpbiBxdWVzdGlvbi5cbiAgICAgKiBSZXR1cm4gXCJzdG9wXCIgdG8gdGVybWluYXRlIGl0ZXJhdGlvbi5cblxuICAgICAqIEltcGxlbWVudGF0aW9uIG5vdGUgLSB0aGlzIHV0aWxpdHkgZXhpc3RzIG1haW5seSBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4gSXQgd2FzIGxhc3QgdGVzdGVkXG4gICAgICogY2FyZWZ1bGx5IHNvbWUgdGltZSBhZ28gKGFyb3VuZCBqUXVlcnkgMS4yKSBidXQgYXQgdGhhdCB0aW1lIHdhcyBhcm91bmQgMy00eCBmYXN0ZXIgYXQgcmF3IERPTVxuICAgICAqIGZpbHRyYXRpb24gdGFza3MgdGhhbiB0aGUgalF1ZXJ5IGVxdWl2YWxlbnRzLCB3aGljaCB3YXMgYW4gaW1wb3J0YW50IHNvdXJjZSBvZiBwZXJmb3JtYW5jZSBsb3NzIGluIHRoZVxuICAgICAqIFJlb3JkZXJlciBjb21wb25lbnQuIEdlbmVyYWwgY2xpZW50cyBvZiB0aGUgZnJhbWV3b3JrIHNob3VsZCB1c2UgdGhpcyBtZXRob2Qgd2l0aCBjYXV0aW9uIGlmIGF0IGFsbCwgYW5kXG4gICAgICogdGhlIHBlcmZvcm1hbmNlIGlzc3VlcyBzaG91bGQgYmUgcmVhc3Nlc3NlZCB3aGVuIHdlIGhhdmUgdGltZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSB0aGUgbm9kZSB0byBzdGFydCB3YWxraW5nIGZyb21cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhY2NlcHRvciB0aGUgZnVuY3Rpb24gdG8gaW52b2tlIHdpdGggZWFjaCBET00gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxsbm9kZXMgVXNlIDxjb2RlPnRydWU8L2NvZGU+IHRvIGNhbGwgYWNjZXB0b3Igb24gYWxsIG5vZGVzLFxuICAgICAqIHJhdGhlciB0aGFuIGp1c3QgZWxlbWVudCBub2RlcyAodHlwZSAxKVxuICAgICAqL1xuICAgIGZsdWlkLmRvbS5pdGVyYXRlRG9tID0gZnVuY3Rpb24gKG5vZGUsIGFjY2VwdG9yLCBhbGxOb2Rlcykge1xuICAgICAgICB2YXIgY3VycmVudE5vZGUgPSB7bm9kZTogbm9kZSwgZGVwdGg6IDB9O1xuICAgICAgICB2YXIgcHJldk5vZGUgPSBub2RlO1xuICAgICAgICB2YXIgY29uZGl0aW9uO1xuICAgICAgICB3aGlsZSAoY3VycmVudE5vZGUubm9kZSAhPT0gbnVsbCAmJiBjdXJyZW50Tm9kZS5kZXB0aCA+PSAwICYmIGN1cnJlbnROb2RlLmRlcHRoIDwgZmx1aWQuZG9tLml0ZXJhdGVEb20uRE9NX0JBSUxfREVQVEgpIHtcbiAgICAgICAgICAgIGNvbmRpdGlvbiA9IG51bGw7XG4gICAgICAgICAgICBpZiAoY3VycmVudE5vZGUubm9kZS5ub2RlVHlwZSA9PT0gMSB8fCBhbGxOb2Rlcykge1xuICAgICAgICAgICAgICAgIGNvbmRpdGlvbiA9IGFjY2VwdG9yKGN1cnJlbnROb2RlLm5vZGUsIGN1cnJlbnROb2RlLmRlcHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25kaXRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoY29uZGl0aW9uID09PSBcImRlbGV0ZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLm5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjdXJyZW50Tm9kZS5ub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUubm9kZSA9IHByZXZOb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb25kaXRpb24gPT09IFwic3RvcFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50Tm9kZS5ub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZOb2RlID0gY3VycmVudE5vZGUubm9kZTtcbiAgICAgICAgICAgIGN1cnJlbnROb2RlID0gZ2V0TmV4dE5vZGUoY3VycmVudE5vZGUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFdvcmsgYXJvdW5kIElFIGNpcmN1bGFyIERPTSBpc3N1ZS4gVGhpcyBpcyB0aGUgZGVmYXVsdCBtYXggRE9NIGRlcHRoIG9uIElFLlxuICAgIC8vIGh0dHA6Ly9tc2RuMi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM3NjEzOTIoVlMuODUpLmFzcHhcbiAgICBmbHVpZC5kb20uaXRlcmF0ZURvbS5ET01fQkFJTF9ERVBUSCA9IDI1NjtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgc3BlY2lmaWVkIGNvbnRhaW5lciBpcyBhY3R1YWxseSB0aGUgcGFyZW50IG9mIGNvbnRhaW5lZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gY29udGFpbmVyIHRoZSBwb3RlbnRpYWwgcGFyZW50XG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBjb250YWluZWUgdGhlIGNoaWxkIGluIHF1ZXN0aW9uXG4gICAgICovXG4gICAgZmx1aWQuZG9tLmlzQ29udGFpbmVyID0gZnVuY3Rpb24gKGNvbnRhaW5lciwgY29udGFpbmVlKSB7XG4gICAgICAgIGZvciAoOyBjb250YWluZWU7IGNvbnRhaW5lZSA9IGNvbnRhaW5lZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBpZiAoY29udGFpbmVyID09PSBjb250YWluZWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKiBSZXR1cm4gdGhlIGVsZW1lbnQgdGV4dCBmcm9tIHRoZSBzdXBwbGllZCBET00gbm9kZSBhcyBhIHNpbmdsZSBTdHJpbmcuXG4gICAgICogSW1wbGVtZW50YXRpb24gbm90ZSAtIHRoaXMgaXMgYSBzcGVjaWFsLXB1cnBvc2UgdXRpbGl0eSB1c2VkIGluIHRoZSBmcmFtZXdvcmsgaW4ganVzdCBvbmVcbiAgICAgKiBwb3NpdGlvbiBpbiB0aGUgUmVvcmRlcmVyLiBJdCBvbmx5IHBlcmZvcm1zIGEgXCJzaGFsbG93XCIgdHJhdmVyc2FsIG9mIHRoZSB0ZXh0IGFuZCB3YXMgaW50ZW5kZWRcbiAgICAgKiBhcyBhIHF1aWNrIGFuZCBkaXJ0eSBtZWFucyBvZiBleHRyYWN0aW5nIGVsZW1lbnQgbGFiZWxzIHdoZXJlIHRoZSB1c2VyIGhhZCBub3QgZXhwbGljaXRseSBwcm92aWRlZCBvbmUuXG4gICAgICogSXQgc2hvdWxkIG5vdCBiZSB1c2VkIGJ5IGdlbmVyYWwgdXNlcnMgb2YgdGhlIGZyYW1ld29yayBhbmQgaXRzIHByZXNlbmNlIGhlcmUgbmVlZHMgdG8gYmVcbiAgICAgKiByZWFzc2Vzc2VkLlxuICAgICAqL1xuICAgIGZsdWlkLmRvbS5nZXRFbGVtZW50VGV4dCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHZhciBub2RlcyA9IGVsZW1lbnQuY2hpbGROb2RlcztcbiAgICAgICAgdmFyIHRleHQgPSBcIlwiO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gMykge1xuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0ICsgY2hpbGQubm9kZVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH07XG5cbn0pKGpRdWVyeSwgZmx1aWRfMl8wKTtcbjsvKlxuQ29weXJpZ2h0IDIwMDctMjAxMCBVbml2ZXJzaXR5IG9mIENhbWJyaWRnZVxuQ29weXJpZ2h0IDIwMDctMjAwOSBVbml2ZXJzaXR5IG9mIFRvcm9udG9cbkNvcHlyaWdodCAyMDA3LTIwMDkgVW5pdmVyc2l0eSBvZiBDYWxpZm9ybmlhLCBCZXJrZWxleVxuQ29weXJpZ2h0IDIwMTAgT0NBRCBVbml2ZXJzaXR5XG5Db3B5cmlnaHQgMjAxMC0yMDExIEx1Y2VuZG8gRGV2ZWxvcG1lbnQgTHRkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgRWR1Y2F0aW9uYWwgQ29tbXVuaXR5IExpY2Vuc2UgKEVDTCksIFZlcnNpb24gMi4wIG9yIHRoZSBOZXdcbkJTRCBsaWNlbnNlLiBZb3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggb25lIHRoZXNlXG5MaWNlbnNlcy5cblxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBFQ0wgMi4wIExpY2Vuc2UgYW5kIEJTRCBMaWNlbnNlIGF0XG5odHRwczovL2dpdGh1Yi5jb20vZmx1aWQtcHJvamVjdC9pbmZ1c2lvbi9yYXcvbWFzdGVyL0luZnVzaW9uLUxJQ0VOU0UudHh0XG4qL1xuXG52YXIgZmx1aWRfMl8wID0gZmx1aWRfMl8wIHx8IHt9O1xudmFyIGZsdWlkID0gZmx1aWQgfHwgZmx1aWRfMl8wO1xuXG4oZnVuY3Rpb24gKCQsIGZsdWlkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvKiogUmVuZGVyIGEgdGltZXN0YW1wIGZyb20gYSBEYXRlIG9iamVjdCBpbnRvIGEgaGVscGZ1bCBmaXhlZCBmb3JtYXQgZm9yIGRlYnVnIGxvZ3MgdG8gbWlsbGlzZWNvbmQgYWNjdXJhY3lcbiAgICAgKiBAcGFyYW0gZGF0ZSB7RGF0ZX0gVGhlIGRhdGUgdG8gYmUgcmVuZGVyZWRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IEEgc3RyaW5nIGZvcm1hdCBjb25zaXN0aW5nIG9mIGhvdXJzOm1pbnV0ZXM6c2Vjb25kcy5taWxsaXMgZm9yIHRoZSBkYXRlc3RhbXAgcGFkZGVkIHRvIGZpeGVkIHdpdGggXG4gICAgICovXG5cbiAgICBmbHVpZC5yZW5kZXJUaW1lc3RhbXAgPSBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICB2YXIgemVyb3BhZCA9IGZ1bmN0aW9uIChudW0sIHdpZHRoKSB7XG4gICAgICAgICAgICBpZiAoIXdpZHRoKSB7IHdpZHRoID0gMjsgfVxuICAgICAgICAgICAgdmFyIG51bXN0ciA9IChudW0gPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBudW0udG9TdHJpbmcoKSk7XG4gICAgICAgICAgICByZXR1cm4gXCIwMDAwMFwiLnN1YnN0cmluZyg1IC0gd2lkdGggKyBudW1zdHIubGVuZ3RoKSArIG51bXN0cjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHplcm9wYWQoZGF0ZS5nZXRIb3VycygpKSArIFwiOlwiICsgemVyb3BhZChkYXRlLmdldE1pbnV0ZXMoKSkgKyBcIjpcIiArIHplcm9wYWQoZGF0ZS5nZXRTZWNvbmRzKCkpICsgXCIuXCIgKyB6ZXJvcGFkKGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCksIDMpO1xuICAgIH07XG5cbiAgICBmbHVpZC5pc1RyYWNpbmcgPSBmYWxzZTtcblxuICAgIGZsdWlkLnJlZ2lzdGVyTmFtZXNwYWNlKFwiZmx1aWQudHJhY2luZ1wiKTtcblxuICAgIGZsdWlkLnRyYWNpbmcucGF0aENvdW50ID0gW107XG5cbiAgICBmbHVpZC50cmFjaW5nLnN1bW1hcmlzZVBhdGhDb3VudCA9IGZ1bmN0aW9uIChwYXRoQ291bnQpIHtcbiAgICAgICAgcGF0aENvdW50ID0gcGF0aENvdW50IHx8IGZsdWlkLnRyYWNpbmcucGF0aENvdW50O1xuICAgICAgICB2YXIgdG9nbyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhDb3VudC5sZW5ndGg7ICsrIGkpIHtcbiAgICAgICAgICAgIHZhciBwYXRoID0gcGF0aENvdW50W2ldO1xuICAgICAgICAgICAgaWYgKCF0b2dvW3BhdGhdKSB7XG4gICAgICAgICAgICAgICAgdG9nb1twYXRoXSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICArK3RvZ29bcGF0aF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRvUmVhbGx5R28gPSBbXTtcbiAgICAgICAgZmx1aWQuZWFjaCh0b2dvLCBmdW5jdGlvbiAoZWwsIHBhdGgpIHtcbiAgICAgICAgICAgIHRvUmVhbGx5R28ucHVzaCh7cGF0aDogcGF0aCwgY291bnQ6IGVsfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0b1JlYWxseUdvLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtyZXR1cm4gYi5jb3VudCAtIGEuY291bnQ7fSk7XG4gICAgICAgIHJldHVybiB0b1JlYWxseUdvO1xuICAgIH07XG5cbiAgICBmbHVpZC50cmFjaW5nLmNvbmRlbnNlUGF0aENvdW50ID0gZnVuY3Rpb24gKHByZWZpeGVzLCBwYXRoQ291bnQpIHtcbiAgICAgICAgcHJlZml4ZXMgPSBmbHVpZC5tYWtlQXJyYXkocHJlZml4ZXMpO1xuICAgICAgICB2YXIgcHJlZml4Q291bnQgPSB7fTtcbiAgICAgICAgZmx1aWQuZWFjaChwcmVmaXhlcywgZnVuY3Rpb24ocHJlZml4KSB7XG4gICAgICAgICAgICBwcmVmaXhDb3VudFtwcmVmaXhdID0gMDtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB0b2dvID0gW107XG4gICAgICAgIGZsdWlkLmVhY2gocGF0aENvdW50LCBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHZhciBwYXRoID0gZWwucGF0aDtcbiAgICAgICAgICAgIGlmICghZmx1aWQuZmluZChwcmVmaXhlcywgZnVuY3Rpb24ocHJlZml4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhdGguaW5kZXhPZihwcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWZpeENvdW50W3ByZWZpeF0gKz0gZWwuY291bnQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgdG9nby5wdXNoKGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGZsdWlkLmVhY2gocHJlZml4Q291bnQsIGZ1bmN0aW9uKGNvdW50LCBwYXRoKSB7XG4gICAgICAgICAgICB0b2dvLnVuc2hpZnQoe3BhdGg6IHBhdGgsIGNvdW50OiBjb3VudH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRvZ287XG4gICAgfTtcblxuICAgIC8vIEV4Y2VwdGlvbiBzdHJpcHBpbmcgY29kZSB0YWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9lbXdlbmRlbGluL2phdmFzY3JpcHQtc3RhY2t0cmFjZS9ibG9iL21hc3Rlci9zdGFja3RyYWNlLmpzXG4gICAgLy8gQlNEIGxpY2VuY2UsIHNlZSBoZWFkZXJcblxuICAgIGZsdWlkLmRldGVjdFN0YWNrU3R5bGUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgc3R5bGUgPSBcIm90aGVyXCI7XG4gICAgICAgIHZhciBzdGFja1N0eWxlID0ge1xuICAgICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgIH07XG4gICAgICAgIGlmIChlW1wiYXJndW1lbnRzXCJdKSB7XG4gICAgICAgICAgICBzdHlsZSA9IFwiY2hyb21lXCI7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cub3BlcmEgJiYgZS5zdGFja3RyYWNlKSB7XG4gICAgICAgICAgICBzdHlsZSA9IFwib3BlcmExMFwiO1xuICAgICAgICB9IGVsc2UgaWYgKGUuc3RhY2spIHtcbiAgICAgICAgICAgIHN0eWxlID0gXCJmaXJlZm94XCI7XG4gICAgICAgICAgICAvLyBEZXRlY3QgRmlyZUZveCA0LXN0eWxlIHN0YWNrcyB3aGljaCBhcmUgMSBsZXZlbCBsZXNzIGRlZXBcbiAgICAgICAgICAgIHN0YWNrU3R5bGUub2Zmc2V0ID0gZS5zdGFjay5pbmRleE9mKFwiVHJhY2UgZXhjZXB0aW9uXCIpID09PSAtMT8gMSA6IDA7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cub3BlcmEgJiYgIShcInN0YWNrdHJhY2VcIiBpbiBlKSkgeyAvL09wZXJhIDktXG4gICAgICAgICAgICBzdHlsZSA9IFwib3BlcmFcIjtcbiAgICAgICAgfVxuICAgICAgICBzdGFja1N0eWxlLnN0eWxlID0gc3R5bGU7XG4gICAgICAgIHJldHVybiBzdGFja1N0eWxlO1xuICAgIH07XG5cbiAgICBmbHVpZC5vYnRhaW5FeGNlcHRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmFjZSBleGNlcHRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBzdGFja1N0eWxlID0gZmx1aWQuZGV0ZWN0U3RhY2tTdHlsZShmbHVpZC5vYnRhaW5FeGNlcHRpb24oKSk7XG5cbiAgICBmbHVpZC5yZWdpc3Rlck5hbWVzcGFjZShcImZsdWlkLmV4Y2VwdGlvbkRlY29kZXJzXCIpO1xuXG4gICAgZmx1aWQuZGVjb2RlU3RhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChzdGFja1N0eWxlLnN0eWxlICE9PSBcImZpcmVmb3hcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGUgPSBmbHVpZC5vYnRhaW5FeGNlcHRpb24oKTtcbiAgICAgICAgcmV0dXJuIGZsdWlkLmV4Y2VwdGlvbkRlY29kZXJzW3N0YWNrU3R5bGUuc3R5bGVdKGUpO1xuICAgIH07XG5cbiAgICBmbHVpZC5leGNlcHRpb25EZWNvZGVycy5maXJlZm94ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGxpbmVzID0gZS5zdGFjay5yZXBsYWNlKC8oPzpcXG5AOjApP1xccyskL20sIFwiXCIpLnJlcGxhY2UoL15cXCgvZ20sIFwie2Fub255bW91c30oXCIpLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICByZXR1cm4gZmx1aWQudHJhbnNmb3JtKGxpbmVzLCBmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAgICAgdmFyIGF0aW5kID0gbGluZS5pbmRleE9mKFwiQFwiKTtcbiAgICAgICAgICAgIHJldHVybiBhdGluZCA9PT0gLTE/IFtsaW5lXSA6IFtsaW5lLnN1YnN0cmluZyhhdGluZCArIDEpLCBsaW5lLnN1YnN0cmluZygwLCBhdGluZCldO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gTWFpbiBlbnRyeSBwb2ludCBmb3IgY2FsbGVycy4gXG4gICAgLy8gVE9ETzogVGhpcyBpbmZyYXN0cnVjdHVyZSBpcyBzZXZlcmFsIHllYXJzIG9sZCBhbmQgcHJvYmFibHkgc3RpbGwgb25seSB3b3JrcyBvbiBGaXJlZm94IGlmIHRoZXJlXG4gICAgZmx1aWQuZ2V0Q2FsbGVySW5mbyA9IGZ1bmN0aW9uIChhdERlcHRoKSB7XG4gICAgICAgIGF0RGVwdGggPSAoYXREZXB0aCB8fCAzKSAtIHN0YWNrU3R5bGUub2Zmc2V0O1xuICAgICAgICB2YXIgc3RhY2sgPSBmbHVpZC5kZWNvZGVTdGFjaygpO1xuICAgICAgICByZXR1cm4gc3RhY2s/IHN0YWNrW2F0RGVwdGhdWzBdIDogbnVsbDtcbiAgICB9O1xuXG4gICAgLyoqIEdlbmVyYXRlcyBhIHN0cmluZyBmb3IgcGFkZGluZyBwdXJwb3NlcyBieSByZXBsaWNhdGluZyBhIGNoYXJhY3RlciBhIGdpdmVuIG51bWJlciBvZiB0aW1lc1xuICAgICAqIEBwYXJhbSBjIHtDaGFyYWN0ZXJ9IEEgY2hhcmFjdGVyIHRvIGJlIHVzZWQgZm9yIHBhZGRpbmdcbiAgICAgKiBAcGFyYW0gY291bnQge0ludGVnZXJ9IFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IHRoZSBjaGFyYWN0ZXJcbiAgICAgKiBAcmV0dXJuIEEgc3RyaW5nIG9mIGxlbmd0aCA8Y29kZT5jb3VudDwvY29kZT4gY29uc2lzdGluZyBvZiByZXBldGl0aW9ucyBvZiB0aGUgc3VwcGxpZWQgY2hhcmFjdGVyXG4gICAgICovXG4gICAgLy8gVU5PUFRJTUlTRUQgXG4gICAgZmx1aWQuZ2VuZXJhdGVQYWRkaW5nID0gZnVuY3Rpb24gKGMsIGNvdW50KSB7XG4gICAgICAgIHZhciB0b2dvID0gXCJcIjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgKysgaSkge1xuICAgICAgICAgICAgdG9nbyArPSBjO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2dvO1xuICAgIH07XG4gICAgIFxuICAgIC8vIE1hcmtlciBzbyB0aGF0IHdlIGNhbiByZW5kZXIgYSBjdXN0b20gc3RyaW5nIGZvciBwcm9wZXJ0aWVzIHdoaWNoIGFyZSBub3QgZGlyZWN0IGFuZCBjb25jcmV0ZVxuICAgIGZsdWlkLlNZTlRIRVRJQ19QUk9QRVJUWSA9IHt9O1xuXG4gICAgLy8gdXRpbGl0eSB0byBhdm9pZCB0cmlnZ2VyaW5nIGN1c3RvbSBnZXR0ZXIgY29kZSB3aGljaCBjb3VsZCB0aHJvdyBhbiBleGNlcHRpb24gLSBlLmcuIGV4cHJlc3MgMy54J3MgcmVxdWVzdCBvYmplY3QgXG4gICAgZmx1aWQuZ2V0U2FmZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iaiwga2V5KSB7XG4gICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7IC8vIHN1cHBvcnRlZCBvbiBhbGwgb2Ygb3VyIGVudmlyb25tZW50cyAtIGlzIGJyb2tlbiBvbiBJRThcbiAgICAgICAgcmV0dXJuIGRlc2MgJiYgIWRlc2MuZ2V0ID8gb2JqW2tleV0gOiBmbHVpZC5TWU5USEVUSUNfUFJPUEVSVFk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHByaW50SW1wbCAob2JqLCBzbWFsbCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgYmlnID0gc21hbGwgKyBvcHRpb25zLmluZGVudENoYXJzLCB0b2dvLCBpc0Z1bmN0aW9uID0gdHlwZW9mKG9iaikgPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdG9nbyA9IFwibnVsbFwiO1xuICAgICAgICB9IGVsc2UgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0b2dvID0gXCJ1bmRlZmluZWRcIjsgLy8gTkIgLSBvYmplY3QgaW52YWxpZCBmb3IgSlNPTiBpbnRlcmNoYW5nZVxuICAgICAgICB9IGVsc2UgaWYgKG9iaiA9PT0gZmx1aWQuU1lOVEhFVElDX1BST1BFUlRZKSB7XG4gICAgICAgICAgICB0b2dvID0gXCJbU3ludGhldGljIHByb3BlcnR5XVwiO1xuICAgICAgICB9IGVsc2UgaWYgKGZsdWlkLmlzUHJpbWl0aXZlKG9iaikgJiYgIWlzRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHRvZ28gPSBKU09OLnN0cmluZ2lmeShvYmopO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCQuaW5BcnJheShvYmosIG9wdGlvbnMuc3RhY2spICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIihDSVJDVUxBUilcIjsgLy8gTkIgLSBvYmplY3QgaW52YWxpZCBmb3IgSlNPTiBpbnRlcmNoYW5nZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0aW9ucy5zdGFjay5wdXNoKG9iaik7XG4gICAgICAgICAgICB2YXIgaiA9IFtdO1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBpZiAoZmx1aWQuaXNBcnJheWFibGUob2JqKSkge1xuICAgICAgICAgICAgICAgIGlmIChvYmoubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvZ28gPSBcIltdXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG9iai5sZW5ndGg7ICsrIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpbaV0gPSBwcmludEltcGwob2JqW2ldLCBiaWcsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRvZ28gPSBcIltcXG5cIiArIGJpZyArIGouam9pbihcIixcXG5cIiArIGJpZykgKyBcIlxcblwiICsgc21hbGwgKyBcIl1cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICB0b2dvID0gXCJ7XCIgKyAoaXNGdW5jdGlvbiA/IFwiIEZ1bmN0aW9uXCIgOiBcIlwiKSArIFwiXFxuXCI7IC8vIE5CIC0gRnVuY3Rpb24gb2JqZWN0IGludmFsaWQgZm9yIEpTT04gaW50ZXJjaGFuZ2VcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGZsdWlkLmdldFNhZmVQcm9wZXJ0eShvYmosIGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGpbaSsrXSA9IEpTT04uc3RyaW5naWZ5KGtleSkgKyBcIjogXCIgKyBwcmludEltcGwodmFsdWUsIGJpZywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRvZ28gKz0gYmlnICsgai5qb2luKFwiLFxcblwiICsgYmlnKSArIFwiXFxuXCIgKyBzbWFsbCArIFwifVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0aW9ucy5zdGFjay5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9nbztcbiAgICB9XG5cbiAgICAvKiogUmVuZGVyIGEgY29tcGxleCBKU09OIG9iamVjdCBpbnRvIGEgbmljZWx5IGluZGVudGVkIGZvcm1hdCBzdWl0YWJsZSBmb3IgaHVtYW4gcmVhZGFiaWxpdHkuXG4gICAgICogQHBhcmFtIG9iaiB7T2JqZWN0fSBUaGUgb2JqZWN0IHRvIGJlIHJlbmRlcmVkXG4gICAgICogQHBhcmFtIG9wdGlvbnMge09iamVjdH0gQW4gb3B0aW9ucyBzdHJ1Y3R1cmUgZ292ZXJuaW5nIHRoZSByZW5kZXJpbmcgcHJvY2Vzcy4gVGhlIG9ubHkgb3B0aW9uIHdoaWNoXG4gICAgICogaXMgY3VycmVudGx5IHN1cHBvcnRlZCBpcyA8Y29kZT5pbmRlbnQ8L2NvZGU+IGhvbGRpbmcgdGhlIG51bWJlciBvZiBzcGFjZSBjaGFyYWN0ZXJzIHRvIGJlIHVzZWQgdG9cbiAgICAgKiBpbmRlbnQgZWFjaCBsZXZlbCBvZiBjb250YWlubWVudC5cbiAgICAgKi9cbiAgICBmbHVpZC5wcmV0dHlQcmludEpTT04gPSBmdW5jdGlvbiAob2JqLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSAkLmV4dGVuZCh7aW5kZW50OiA0LCBzdGFjazogW119LCBvcHRpb25zKTtcbiAgICAgICAgb3B0aW9ucy5pbmRlbnRDaGFycyA9IGZsdWlkLmdlbmVyYXRlUGFkZGluZyhcIiBcIiwgb3B0aW9ucy5pbmRlbnQpO1xuICAgICAgICByZXR1cm4gcHJpbnRJbXBsKG9iaiwgXCJcIiwgb3B0aW9ucyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIER1bXBzIGEgRE9NIGVsZW1lbnQgaW50byBhIHJlYWRpbHkgcmVjb2duaXNhYmxlIGZvcm0gZm9yIGRlYnVnZ2luZyAtIHByb2R1Y2VzIGFcbiAgICAgKiBcInNlbWktc2VsZWN0b3JcIiBzdW1tYXJpc2luZyBpdHMgdGFnIG5hbWUsIGNsYXNzIGFuZCBpZCwgd2hpY2hldmVyIGFyZSBzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2pRdWVyeWFibGV9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gYmUgZHVtcGVkXG4gICAgICogQHJldHVybiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGVsZW1lbnQuXG4gICAgICovXG4gICAgZmx1aWQuZHVtcEVsID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHRvZ287XG5cbiAgICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW1lbnQubm9kZVR5cGUgPT09IDMgfHwgZWxlbWVudC5ub2RlVHlwZSA9PT0gOCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiW2RhdGE6IFwiICsgZWxlbWVudC5kYXRhICsgXCJdXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW1lbnQubm9kZVR5cGUgPT09IDkpIHtcbiAgICAgICAgICAgIHJldHVybiBcIltkb2N1bWVudDogbG9jYXRpb24gXCIgKyBlbGVtZW50LmxvY2F0aW9uICsgXCJdXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFlbGVtZW50Lm5vZGVUeXBlICYmIGZsdWlkLmlzQXJyYXlhYmxlKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICB0b2dvID0gXCJbXCI7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnQubGVuZ3RoOyArKyBpKSB7XG4gICAgICAgICAgICAgICAgdG9nbyArPSBmbHVpZC5kdW1wRWwoZWxlbWVudFtpXSk7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCBlbGVtZW50Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9nbyArPSBcIiwgXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRvZ28gKyBcIl1cIjtcbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50ID0gJChlbGVtZW50KTtcbiAgICAgICAgdG9nbyA9IGVsZW1lbnQuZ2V0KDApLnRhZ05hbWU7XG4gICAgICAgIGlmIChlbGVtZW50LmlkKSB7XG4gICAgICAgICAgICB0b2dvICs9IFwiI1wiICsgZWxlbWVudC5pZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxlbWVudC5hdHRyKFwiY2xhc3NcIikpIHtcbiAgICAgICAgICAgIHRvZ28gKz0gXCIuXCIgKyBlbGVtZW50LmF0dHIoXCJjbGFzc1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9nbztcbiAgICB9O1xuXG59KShqUXVlcnksIGZsdWlkXzJfMCk7XG47LypcbkNvcHlyaWdodCAyMDExLTIwMTMgT0NBRCBVbml2ZXJzaXR5XG5Db3B5cmlnaHQgMjAxMC0yMDExIEx1Y2VuZG8gRGV2ZWxvcG1lbnQgTHRkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgRWR1Y2F0aW9uYWwgQ29tbXVuaXR5IExpY2Vuc2UgKEVDTCksIFZlcnNpb24gMi4wIG9yIHRoZSBOZXdcbkJTRCBsaWNlbnNlLiBZb3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggb25lIHRoZXNlXG5MaWNlbnNlcy5cblxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBFQ0wgMi4wIExpY2Vuc2UgYW5kIEJTRCBMaWNlbnNlIGF0XG5odHRwczovL2dpdGh1Yi5jb20vZmx1aWQtcHJvamVjdC9pbmZ1c2lvbi9yYXcvbWFzdGVyL0luZnVzaW9uLUxJQ0VOU0UudHh0XG4qL1xuXG52YXIgZmx1aWRfMl8wID0gZmx1aWRfMl8wIHx8IHt9O1xuXG4oZnVuY3Rpb24gKCQsIGZsdWlkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvKiogVGhlIEZsdWlkIFwiSW9DIFN5c3RlbSBwcm9wZXJcIiAtIHJlc29sdXRpb24gb2YgcmVmZXJlbmNlcyBhbmRcbiAgICAgKiBjb21wbGV0ZWx5IGF1dG9tYXRlZCBpbnN0YW50aWF0aW9uIG9mIGRlY2xhcmF0aXZlbHkgZGVmaW5lZFxuICAgICAqIGNvbXBvbmVudCB0cmVlcyAqL1xuXG4gICAgLy8gdW5zdXBwb3J0ZWQsIG5vbi1BUEkgZnVuY3Rpb25cbiAgICAvLyBDdXJyZW50bHkgc3RpbGwgdXNlcyBtYW51YWwgdHJhdmVyc2FsIC0gb25jZSB3ZSBiYW4gbWFudWFsbHkgaW5zdGFudGlhdGVkIGNvbXBvbmVudHMsXG4gICAgLy8gaXQgd2lsbCB1c2UgdGhlIGluc3RhbnRpYXRvcidzIHJlY29yZHMgaW5zdGVhZC5cbiAgICBmbHVpZC52aXNpdENvbXBvbmVudENoaWxkcmVuID0gZnVuY3Rpb24gKHRoYXQsIHZpc2l0b3IsIG9wdGlvbnMsIHBhdGgsIGkpIHtcbiAgICAgICAgdmFyIGluc3RhbnRpYXRvciA9IGZsdWlkLmdldEluc3RhbnRpYXRvcih0aGF0KTtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGF0KSB7XG4gICAgICAgICAgICB2YXIgbmV3UGF0aCA9IGluc3RhbnRpYXRvci5jb21wb3NlUGF0aChwYXRoLCBuYW1lKTtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSB0aGF0W25hbWVdO1xuICAgICAgICAgICAgLy8gVGhpcyBlbnRpcmUgYWxnb3JpdGhtIGlzIHByaW1pdGl2ZSBhbmQgZXhwZW5zaXZlIGFuZCB3aWxsIGJlIHJlbW92ZWQgb25jZSB3ZSBjYW4gYWJvbGlzaCBtYW51YWwgaW5pdCBjb21wb25lbnRzXG4gICAgICAgICAgICBpZiAoIWZsdWlkLmlzQ29tcG9uZW50KGNvbXBvbmVudCkgfHwgKG9wdGlvbnMudmlzaXRlZCAmJiBvcHRpb25zLnZpc2l0ZWRbY29tcG9uZW50LmlkXSkpIHtjb250aW51ZTsgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMudmlzaXRlZCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudmlzaXRlZFtjb21wb25lbnQuaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2aXNpdG9yKGNvbXBvbmVudCwgbmFtZSwgbmV3UGF0aCwgcGF0aCwgaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5mbGF0KSB7XG4gICAgICAgICAgICAgICAgZmx1aWQudmlzaXRDb21wb25lbnRDaGlsZHJlbihjb21wb25lbnQsIHZpc2l0b3IsIG9wdGlvbnMsIG5ld1BhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIHVuc3VwcG9ydGVkLCBub24tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQuZ2V0TWVtYmVyTmFtZXMgPSBmdW5jdGlvbiAoaW5zdGFudGlhdG9yLCB0aGF0U3RhY2spIHtcbiAgICAgICAgdmFyIHBhdGggPSBpbnN0YW50aWF0b3IuaWRUb1BhdGgodGhhdFN0YWNrW3RoYXRTdGFjay5sZW5ndGggLSAxXS5pZCk7XG4gICAgICAgIHZhciBzZWdzID0gZmx1aWQubW9kZWwucGFyc2VFTChwYXRoKTtcbiAgICAgICAgc2Vncy51bnNoaWZ0LmFwcGx5KHNlZ3MsIGZsdWlkLmdlbmVyYXRlKHRoYXRTdGFjay5sZW5ndGggLSBzZWdzLmxlbmd0aCwgXCJcIikpO1xuICAgICAgICByZXR1cm4gc2VncztcbiAgICB9O1xuXG4gICAgLy8gdGhhdFN0YWNrIGNvbnRhaW5zIGFuIGluY3JlYXNpbmcgbGlzdCBvZiBNT1JFIFNQRUNJRklDIHRoYXRzLlxuICAgIC8vIHRoaXMgdmlzaXRzIGFsbCBjb21wb25lbnRzIHN0YXJ0aW5nIGZyb20gdGhlIGN1cnJlbnQgbG9jYXRpb24gKGVuZCBvZiBzdGFjaylcbiAgICAvLyBpbiB2aXNpYmlsaXR5IG9yZGVyIHVwIHRoZSB0cmVlLlxuICAgIHZhciB2aXNpdENvbXBvbmVudHMgPSBmdW5jdGlvbiAoaW5zdGFudGlhdG9yLCB0aGF0U3RhY2ssIHZpc2l0b3IsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge1xuICAgICAgICAgICAgdmlzaXRlZDoge30sXG4gICAgICAgICAgICBmbGF0OiB0cnVlLFxuICAgICAgICAgICAgaW5zdGFudGlhdG9yOiBpbnN0YW50aWF0b3JcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG1lbWJlck5hbWVzID0gZmx1aWQuZ2V0TWVtYmVyTmFtZXMoaW5zdGFudGlhdG9yLCB0aGF0U3RhY2spO1xuICAgICAgICBmb3IgKHZhciBpID0gdGhhdFN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoYXRTdGFja1tpXSwgcGF0aDtcbiAgICAgICAgICAgIGlmICh0aGF0LnR5cGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy52aXNpdGVkW3RoYXQuaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwYXRoID0gaW5zdGFudGlhdG9yLmlkVG9QYXRoW3RoYXQuaWRdO1xuICAgICAgICAgICAgICAgIGlmICh2aXNpdG9yKHRoYXQsIG1lbWJlck5hbWVzW2ldLCBwYXRoLCBwYXRoLCBpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZsdWlkLnZpc2l0Q29tcG9uZW50Q2hpbGRyZW4odGhhdCwgdmlzaXRvciwgb3B0aW9ucywgcGF0aCwgaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZmx1aWQubW91bnRTdHJhdGVneSA9IGZ1bmN0aW9uIChwcmVmaXgsIHJvb3QsIHRvTW91bnQpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IHByZWZpeC5sZW5ndGg7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBuYW1lLCBpLCBzZWdzKSB7XG4gICAgICAgICAgICBpZiAoaSA8PSBwcmVmaXgubGVuZ3RoKSB7IC8vIEF2b2lkIE9PQiB0byBub3QgdHJpZ2dlciBkZW9wdGltaXNhdGlvbiFcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHByZWZpeC5sZW5ndGg7ICsrIGopIHtcbiAgICAgICAgICAgICAgICBpZiAoc2Vnc1tqXSAhPT0gcHJlZml4W2pdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG9Nb3VudCh0YXJnZXQsIG5hbWUsIGkgLSBwcmVmaXgubGVuZ3RoLCBzZWdzLnNsaWNlKG9mZnNldCkpO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvLyB1bnN1cHBvcnRlZCwgTk9OLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLmludm9rZXJGcm9tUmVjb3JkID0gZnVuY3Rpb24gKGludm9rZXJlYywgbmFtZSwgdGhhdCkge1xuICAgICAgICBmbHVpZC5wdXNoQWN0aXZpdHkoXCJtYWtlSW52b2tlclwiLCBcImJlZ2lubmluZyBpbnN0YW50aWF0aW9uIG9mIGludm9rZXIgd2l0aCBuYW1lICVuYW1lIGFuZCByZWNvcmQgJXJlY29yZCBhcyBjaGlsZCBvZiAldGhhdFwiLFxuICAgICAgICAgICAge25hbWU6IG5hbWUsIHJlY29yZDogaW52b2tlcmVjLCB0aGF0OiB0aGF0fSk7XG4gICAgICAgIHZhciBpbnZva2VyID0gZmx1aWQubWFrZUludm9rZXIodGhhdCwgaW52b2tlcmVjLCBuYW1lKTtcbiAgICAgICAgZmx1aWQucG9wQWN0aXZpdHkoKTtcbiAgICAgICAgcmV0dXJuIGludm9rZXI7XG4gICAgfTtcblxuICAgIC8vIHVuc3VwcG9ydGVkLCBOT04tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQubWVtYmVyRnJvbVJlY29yZCA9IGZ1bmN0aW9uIChtZW1iZXJyZWMsIG5hbWUsIHRoYXQpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gZmx1aWQuZXhwYW5kT3B0aW9ucyhtZW1iZXJyZWMsIHRoYXQsIG51bGwsIG51bGwsIHtmcmVlUm9vdDogdHJ1ZX0pO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcblxuICAgIC8vIHVuc3VwcG9ydGVkLCBOT04tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQucmVjb3JkU3RyYXRlZ3kgPSBmdW5jdGlvbiAodGhhdCwgb3B0aW9ucywgb3B0aW9uc1N0cmF0ZWd5LCByZWNvcmRQYXRoLCByZWNvcmRNYWtlciwgcHJlZml4KSB7XG4gICAgICAgIHByZWZpeCA9IHByZWZpeCB8fCBbXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0cmF0ZWd5OiBmdW5jdGlvbiAodGFyZ2V0LCBuYW1lLCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVjb3JkID0gZmx1aWQuZHJpdmVTdHJhdGVneShvcHRpb25zLCBbcmVjb3JkUGF0aCwgbmFtZV0sIG9wdGlvbnNTdHJhdGVneSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlY29yZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmx1aWQuc2V0KHRhcmdldCwgW25hbWVdLCBmbHVpZC5pbkV2YWx1YXRpb25NYXJrZXIpO1xuICAgICAgICAgICAgICAgIHZhciBtZW1iZXIgPSByZWNvcmRNYWtlcihyZWNvcmQsIG5hbWUsIHRoYXQpO1xuICAgICAgICAgICAgICAgIGZsdWlkLnNldCh0YXJnZXQsIFtuYW1lXSwgbWVtYmVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVtYmVyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGluaXR0ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVjb3JkcyA9IGZsdWlkLmRyaXZlU3RyYXRlZ3kob3B0aW9ucywgcmVjb3JkUGF0aCwgb3B0aW9uc1N0cmF0ZWd5KSB8fCB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIHJlY29yZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZmx1aWQuZ2V0Rm9yQ29tcG9uZW50KHRoYXQsIHByZWZpeC5jb25jYXQoW25hbWVdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBwYXRjaCBGbHVpZC5qcyB2ZXJzaW9uIGZvciB0aW1pbmdcbiAgICAvLyB1bnN1cHBvcnRlZCwgTk9OLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLmluc3RhbnRpYXRlRmlyZXJzID0gZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgICAgdmFyIHNoYWRvdyA9IGZsdWlkLnNoYWRvd0ZvckNvbXBvbmVudCh0aGF0KTtcbiAgICAgICAgdmFyIGluaXR0ZXIgPSBmbHVpZC5nZXQoc2hhZG93LCBbXCJldmVudFN0cmF0ZWd5QmxvY2tcIiwgXCJpbml0dGVyXCJdKSB8fCBmbHVpZC5pZGVudGl0eTtcbiAgICAgICAgaW5pdHRlcigpO1xuICAgIH07XG5cbiAgICAvLyB1bnN1cHBvcnRlZCwgTk9OLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLm1ha2VEaXN0cmlidXRpb25SZWNvcmQgPSBmdW5jdGlvbiAoY29udGV4dFRoYXQsIHNvdXJjZVJlY29yZCwgc291cmNlUGF0aCwgdGFyZ2V0U2VncywgZXhjbHVzaW9ucywgb2Zmc2V0LCBzb3VyY2VUeXBlKSB7XG4gICAgICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICAgICAgICBzb3VyY2VUeXBlID0gc291cmNlVHlwZSB8fCBcImRpc3RyaWJ1dGlvblwiO1xuXG4gICAgICAgIHZhciBzb3VyY2UgPSBmbHVpZC5jb3B5KGZsdWlkLmdldChzb3VyY2VSZWNvcmQsIHNvdXJjZVBhdGgpKTtcbiAgICAgICAgZmx1aWQuZWFjaChleGNsdXNpb25zLCBmdW5jdGlvbiAoZXhjbHVzaW9uKSB7XG4gICAgICAgICAgICBmbHVpZC5tb2RlbC5hcHBseUNoYW5nZVJlcXVlc3Qoc291cmNlLCB7cGF0aDogZXhjbHVzaW9uLCB0eXBlOiBcIkRFTEVURVwifSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB7b3B0aW9uczoge319O1xuICAgICAgICB2YXIgcHJpbWl0aXZlU291cmNlID0gZmx1aWQuaXNQcmltaXRpdmUoc291cmNlKTtcbiAgICAgICAgZmx1aWQubW9kZWwuYXBwbHlDaGFuZ2VSZXF1ZXN0KHJlY29yZCwge3BhdGg6IHRhcmdldFNlZ3MsIHR5cGU6IHByaW1pdGl2ZVNvdXJjZT8gXCJBRERcIjogXCJNRVJHRVwiLCB2YWx1ZTogc291cmNlfSk7XG4gICAgICAgIHJldHVybiAkLmV4dGVuZChyZWNvcmQsIHtjb250ZXh0VGhhdDogY29udGV4dFRoYXQsIHJlY29yZFR5cGU6IHNvdXJjZVR5cGUsIHByaW9yaXR5OiBmbHVpZC5tZXJnZVJlY29yZFR5cGVzLmRpc3RyaWJ1dGlvbiArIG9mZnNldH0pO1xuICAgIH07XG5cbiAgICAvLyB1bnN1cHBvcnRlZCwgTk9OLUFQSSBmdW5jdGlvblxuICAgIC8vIFBhcnQgb2YgdGhlIGVhcmx5IFwiZGlzdHJpYnV0ZU9wdGlvbnNcIiB3b3JrZmxvdy4gR2l2ZW4gdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBibG9ja3MgdG8gYmUgZGlzdHJpYnV0ZWQsIGFzc2VtYmxlcyBcImNhbm5lZFwiIHJlY29yZHNcbiAgICAvLyBzdWl0YWJsZSB0byBiZSBlaXRoZXIgcmVnaXN0ZXJlZCBpbnRvIHRoZSBzaGFkb3cgcmVjb3JkIGZvciBsYXRlciBvciBkaXJlY3RseSBwdXNoZWQgdG8gYW4gZXhpc3RpbmcgY29tcG9uZW50LCBhcyB3ZWxsIGFzIGhvbm91cmluZ1xuICAgIC8vIGFueSBcInJlbW92ZVNvdXJjZVwiIGFubm90YXRpb25zIGJ5IHJlbW92aW5nIHRoZXNlIG9wdGlvbnMgZnJvbSB0aGUgc291cmNlIGJsb2NrLlxuICAgIGZsdWlkLmZpbHRlckJsb2NrcyA9IGZ1bmN0aW9uIChjb250ZXh0VGhhdCwgc291cmNlQmxvY2tzLCBzb3VyY2VQYXRoLCB0YXJnZXRTZWdzLCBleGNsdXNpb25zLCByZW1vdmVTb3VyY2UpIHtcbiAgICAgICAgdmFyIHRvZ28gPSBbXSwgb2Zmc2V0ID0gMDtcbiAgICAgICAgZmx1aWQuZWFjaChzb3VyY2VCbG9ja3MsIGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGZsdWlkLmdldChibG9jay5zb3VyY2UsIHNvdXJjZVBhdGgpO1xuICAgICAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHRvZ28ucHVzaChmbHVpZC5tYWtlRGlzdHJpYnV0aW9uUmVjb3JkKGNvbnRleHRUaGF0LCBibG9jay5zb3VyY2UsIHNvdXJjZVBhdGgsIHRhcmdldFNlZ3MsIGV4Y2x1c2lvbnMsIG9mZnNldCsrLCBibG9jay5yZWNvcmRUeXBlKSk7XG4gICAgICAgICAgICAgICAgdmFyIHJlc2N1ZWQgPSAkLmV4dGVuZCh7fSwgc291cmNlKTtcbiAgICAgICAgICAgICAgICBpZiAocmVtb3ZlU291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsdWlkLm1vZGVsLmFwcGx5Q2hhbmdlUmVxdWVzdChibG9jay5zb3VyY2UsIHtwYXRoOiBzb3VyY2VQYXRoLCB0eXBlOiBcIkRFTEVURVwifSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZsdWlkLmVhY2goZXhjbHVzaW9ucywgZnVuY3Rpb24gKGV4Y2x1c2lvbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZyA9IGZsdWlkLmdldChyZXNjdWVkLCBleGNsdXNpb24pO1xuICAgICAgICAgICAgICAgICAgICBmbHVpZC5zZXQoYmxvY2suc291cmNlLCBzb3VyY2VQYXRoLmNvbmNhdChleGNsdXNpb24pLCBvcmlnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0b2dvO1xuICAgIH07XG5cbiAgICAvLyB1bnN1cHBvcnRlZCwgTk9OLUFQSSBmdW5jdGlvblxuICAgIC8vIFRPRE86IFRoaXMgaW1wbGVtZW50YXRpb24gaXMgb2J2aW91c2x5IHBvb3IgYW5kIGhhcyBudW1lcm91cyBmbGF3c1xuICAgIGZsdWlkLm1hdGNoSW9DU2VsZWN0b3IgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHRoYXRTdGFjaywgY29udGV4dEhhc2hlcywgbWVtYmVyTmFtZXMsIGkpIHtcbiAgICAgICAgdmFyIHRoYXRwb3MgPSB0aGF0U3RhY2subGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIHNlbHBvcyA9IHNlbGVjdG9yLmxlbmd0aCAtIDE7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICB2YXIgbXVzdE1hdGNoSGVyZSA9IHRoYXRwb3MgPT09IHRoYXRTdGFjay5sZW5ndGggLSAxIHx8IHNlbGVjdG9yW3NlbHBvc10uY2hpbGQ7XG5cbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhhdFN0YWNrW3RoYXRwb3NdO1xuICAgICAgICAgICAgdmFyIHNlbGVsID0gc2VsZWN0b3Jbc2VscG9zXTtcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlbGVsLnByZWRMaXN0Lmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByZWQgPSBzZWxlbC5wcmVkTGlzdFtqXTtcbiAgICAgICAgICAgICAgICBpZiAocHJlZC5jb250ZXh0ICYmICEoY29udGV4dEhhc2hlc1t0aGF0cG9zXVtwcmVkLmNvbnRleHRdIHx8IG1lbWJlck5hbWVzW3RoYXRwb3NdID09PSBwcmVkLmNvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJlZC5pZCAmJiB0aGF0LmlkICE9PSBwcmVkLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxwb3MgPT09IDAgJiYgdGhhdHBvcyA+IGkgJiYgbXVzdE1hdGNoSGVyZSkge1xuICAgICAgICAgICAgICAgIG1hdGNoID0gZmFsc2U7IC8vIGNoaWxkIHNlbGVjdG9yIG11c3QgZXhoYXVzdCBzdGFjayBjb21wbGV0ZWx5IC0gRkxVSUQtNTAyOVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbHBvcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLS10aGF0cG9zO1xuICAgICAgICAgICAgICAgIC0tc2VscG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG11c3RNYXRjaEhlcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLS10aGF0cG9zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGF0cG9zIDwgaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBVc2UgdGhpcyBwZWN1bGlhciBzaWduYXR1cmUgc2luY2UgdGhlIGFjdHVhbCBjb21wb25lbnQgYW5kIHNoYWRvdyBpdHNlbGYgbWF5IG5vdCBleGlzdCB5ZXQuIFBlcmhhcHMgY2xlYW4gdXAgd2l0aCBGTFVJRC00OTI1XG4gICAgZmx1aWQubm90ZUNvbGxlY3RlZERpc3RyaWJ1dGlvbiA9IGZ1bmN0aW9uIChwYXJlbnRTaGFkb3csIG1lbWJlck5hbWUsIGRpc3RyaWJ1dGlvbikge1xuICAgICAgICBmbHVpZC5tb2RlbC5zZXRTaW1wbGUocGFyZW50U2hhZG93LCBbXCJjb2xsZWN0ZWREaXN0cmlidXRpb25zXCIsIG1lbWJlck5hbWUsIGRpc3RyaWJ1dGlvbi5pZF0sIHRydWUpO1xuICAgIH07XG5cbiAgICBmbHVpZC5pc0NvbGxlY3RlZERpc3RyaWJ1dGlvbiA9IGZ1bmN0aW9uIChwYXJlbnRTaGFkb3csIG1lbWJlck5hbWUsIGRpc3RyaWJ1dGlvbikge1xuICAgICAgICByZXR1cm4gZmx1aWQubW9kZWwuZ2V0U2ltcGxlKHBhcmVudFNoYWRvdywgW1wiY29sbGVjdGVkRGlzdHJpYnV0aW9uc1wiLCBtZW1iZXJOYW1lLCBkaXN0cmlidXRpb24uaWRdKTtcbiAgICB9O1xuXG4gICAgZmx1aWQuY2xlYXJDb2xsZWN0ZWREaXN0cmlidXRpb25zID0gZnVuY3Rpb24gKHBhcmVudFNoYWRvdywgbWVtYmVyTmFtZSkge1xuICAgICAgICBmbHVpZC5tb2RlbC5hcHBseUNoYW5nZVJlcXVlc3QocGFyZW50U2hhZG93LCB7cGF0aDogW1wiY29sbGVjdGVkRGlzdHJpYnV0aW9uc1wiLCBtZW1iZXJOYW1lXSwgdHlwZTogXCJERUxFVEVcIn0pO1xuICAgIH07XG5cbiAgICAvLyB1bnN1cHBvcnRlZCwgTk9OLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLmNvbGxlY3REaXN0cmlidXRpb25zID0gZnVuY3Rpb24gKGRpc3RyaWJ1dGVkQmxvY2tzLCBwYXJlbnRTaGFkb3csIGRpc3RyaWJ1dGlvbiwgdGhhdFN0YWNrLCBjb250ZXh0SGFzaGVzLCBtZW1iZXJOYW1lcywgaSkge1xuICAgICAgICB2YXIgbGFzdE1lbWJlciA9IG1lbWJlck5hbWVzW21lbWJlck5hbWVzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoIWZsdWlkLmlzQ29sbGVjdGVkRGlzdHJpYnV0aW9uKHBhcmVudFNoYWRvdywgbGFzdE1lbWJlciwgZGlzdHJpYnV0aW9uKSAmJlxuICAgICAgICAgICAgICAgIGZsdWlkLm1hdGNoSW9DU2VsZWN0b3IoZGlzdHJpYnV0aW9uLnNlbGVjdG9yLCB0aGF0U3RhY2ssIGNvbnRleHRIYXNoZXMsIG1lbWJlck5hbWVzLCBpKSkge1xuICAgICAgICAgICAgZGlzdHJpYnV0ZWRCbG9ja3MucHVzaC5hcHBseShkaXN0cmlidXRlZEJsb2NrcywgZGlzdHJpYnV0aW9uLmJsb2Nrcyk7XG4gICAgICAgICAgICBmbHVpZC5ub3RlQ29sbGVjdGVkRGlzdHJpYnV0aW9uKHBhcmVudFNoYWRvdywgbGFzdE1lbWJlciwgZGlzdHJpYnV0aW9uKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBTbGlnaHRseSBzaWxseSBmdW5jdGlvbiB0byBjbGVhbiB1cCB0aGUgXCJhcHBsaWVkRGlzdHJpYnV0aW9uc1wiIHJlY29yZHMuIEluIGdlbmVyYWwgd2UgbmVlZCB0byBiZSBtdWNoIG1vcmUgYWdncmVzc2l2ZSBib3RoXG4gICAgLy8gYWJvdXQgY2xlYXJpbmcgaW5zdGFudGlhdGlvbiBnYXJiYWdlIChlLmcuIG9uQ3JlYXRlIGFuZCBtb3N0IG9mIHRoZSBzaGFkb3cpXG4gICAgLy8gYXMgd2VsbCBhcyBjYWNoaW5nIGZyZXF1ZW50bHktdXNlZCByZWNvcmRzIHN1Y2ggYXMgdGhlIFwidGhhdFN0YWNrXCIgd2hpY2hcbiAgICAvLyB3b3VsZCBtZWFuIHRoaXMgZnVuY3Rpb24gY291bGQgYmUgd3JpdHRlbiBpbiBhIHNlbnNpYmxlIHdheVxuICAgIGZsdWlkLnJlZ2lzdGVyQ29sbGVjdGVkQ2xlYXJlciA9IGZ1bmN0aW9uIChzaGFkb3csIHBhcmVudFNoYWRvdywgbWVtYmVyTmFtZSkge1xuICAgICAgICBpZiAoIXNoYWRvdy5jb2xsZWN0ZWRDbGVhcmVyICYmIHBhcmVudFNoYWRvdykge1xuICAgICAgICAgICAgc2hhZG93LmNvbGxlY3RlZENsZWFyZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZmx1aWQuY2xlYXJDb2xsZWN0ZWREaXN0cmlidXRpb25zKHBhcmVudFNoYWRvdywgbWVtYmVyTmFtZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIHVuc3VwcG9ydGVkLCBOT04tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQucmVjZWl2ZURpc3RyaWJ1dGlvbnMgPSBmdW5jdGlvbiAocGFyZW50VGhhdCwgZ3JhZGVOYW1lcywgbWVtYmVyTmFtZSwgdGhhdCkge1xuICAgICAgICB2YXIgaW5zdGFudGlhdG9yID0gZmx1aWQuZ2V0SW5zdGFudGlhdG9yKHBhcmVudFRoYXQgfHwgdGhhdCk7XG4gICAgICAgIHZhciB0aGF0U3RhY2sgPSBpbnN0YW50aWF0b3IuZ2V0VGhhdFN0YWNrKHBhcmVudFRoYXQgfHwgdGhhdCk7IC8vIG1vc3Qgc3BlY2lmaWMgaXMgYXQgZW5kXG4gICAgICAgIHZhciBtZW1iZXJOYW1lcyA9IGZsdWlkLmdldE1lbWJlck5hbWVzKGluc3RhbnRpYXRvciwgdGhhdFN0YWNrKTtcbiAgICAgICAgdmFyIGRpc3RyaWJ1dGVkQmxvY2tzID0gW107XG4gICAgICAgIHZhciBzaGFkb3dzID0gZmx1aWQudHJhbnNmb3JtKHRoYXRTdGFjaywgZnVuY3Rpb24gKHRoaXNUaGF0KSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFudGlhdG9yLmlkVG9TaGFkb3dbdGhpc1RoYXQuaWRdO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHBhcmVudFNoYWRvdyA9IHNoYWRvd3Nbc2hhZG93cy5sZW5ndGggLSAocGFyZW50VGhhdCA/IDEgOiAyKV07XG4gICAgICAgIHZhciBjb250ZXh0SGFzaGVzID0gZmx1aWQuZ2V0TWVtYmVycyhzaGFkb3dzLCBcImNvbnRleHRIYXNoXCIpO1xuICAgICAgICBpZiAocGFyZW50VGhhdCkgeyAvLyBpZiBjYWxsZWQgYmVmb3JlIGNvbnN0cnVjdGlvbiBvZiBjb21wb25lbnQgZnJvbSBlbWJvZHlEZW1hbmRzIC0gTkIgdGhpcyBwYXRoIHdpbGwgYmUgYWJvbGlzaGVkL2FtYWxnYW1hdGVkXG4gICAgICAgICAgICBtZW1iZXJOYW1lcy5wdXNoKG1lbWJlck5hbWUpO1xuICAgICAgICAgICAgY29udGV4dEhhc2hlcy5wdXNoKGZsdWlkLmdyYWRlTmFtZXNUb0hhc2goZ3JhZGVOYW1lcykpO1xuICAgICAgICAgICAgdGhhdFN0YWNrLnB1c2godGhhdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmbHVpZC5yZWdpc3RlckNvbGxlY3RlZENsZWFyZXIoc2hhZG93c1tzaGFkb3dzLmxlbmd0aCAtIDFdLCBwYXJlbnRTaGFkb3csIG1lbWJlck5hbWVzW21lbWJlck5hbWVzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIHVzZSBvZiBmdW5jdGlvbiBjcmVhdGlvbiB3aXRoaW4gYSBsb29wIGlzIGFjY2VwdGFibGUgc2luY2VcbiAgICAgICAgLy8gdGhlIGZ1bmN0aW9uIGRvZXMgbm90IGF0dGVtcHQgdG8gY2xvc2UgZGlyZWN0bHkgb3ZlciB0aGUgbG9vcCBjb3VudGVyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhhdFN0YWNrLmxlbmd0aCAtIDE7ICsrIGkpIHtcbiAgICAgICAgICAgIGZsdWlkLmVhY2goc2hhZG93c1tpXS5kaXN0cmlidXRpb25zLCBmdW5jdGlvbiAoZGlzdHJpYnV0aW9uKSB7XG4gICAgICAgICAgICAgICAgZmx1aWQuY29sbGVjdERpc3RyaWJ1dGlvbnMoZGlzdHJpYnV0ZWRCbG9ja3MsIHBhcmVudFNoYWRvdywgZGlzdHJpYnV0aW9uLCB0aGF0U3RhY2ssIGNvbnRleHRIYXNoZXMsIG1lbWJlck5hbWVzLCBpKTtcbiAgICAgICAgICAgIH0pOyAgLyogZnVuY3Rpb24gaW4gbG9vcCAqLyAvKiBqc2hpbnQgaWdub3JlOmxpbmUgKi9cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlzdHJpYnV0ZWRCbG9ja3M7XG4gICAgfTtcblxuICAgIC8vIHVuc3VwcG9ydGVkLCBOT04tQVBJIGZ1bmN0aW9uXG4gICAgLy8gY29udmVydCBcInByZUJsb2Nrc1wiIGFzIHByb2R1Y2VkIGZyb20gZmx1aWQuZmlsdGVyQmxvY2tzIGludG8gXCJyZWFsIGJsb2Nrc1wiIHN1aXRhYmxlIHRvIGJlIHVzZWQgYnkgdGhlIGV4cGFuc2lvbiBtYWNoaW5lcnkuXG4gICAgZmx1aWQuYXBwbHlEaXN0cmlidXRpb25zID0gZnVuY3Rpb24gKHRoYXQsIHByZUJsb2NrcywgdGFyZ2V0U2hhZG93KSB7XG4gICAgICAgIHZhciBkaXN0cmlidXRlZEJsb2NrcyA9IGZsdWlkLnRyYW5zZm9ybShwcmVCbG9ja3MsIGZ1bmN0aW9uIChwcmVCbG9jaykge1xuICAgICAgICAgICAgcmV0dXJuIGZsdWlkLmdlbmVyYXRlRXhwYW5kQmxvY2socHJlQmxvY2ssIHRoYXQsIHRhcmdldFNoYWRvdy5tZXJnZVBvbGljeSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbWVyZ2VPcHRpb25zID0gdGFyZ2V0U2hhZG93Lm1lcmdlT3B0aW9ucztcbiAgICAgICAgbWVyZ2VPcHRpb25zLm1lcmdlQmxvY2tzLnB1c2guYXBwbHkobWVyZ2VPcHRpb25zLm1lcmdlQmxvY2tzLCBkaXN0cmlidXRlZEJsb2Nrcyk7XG4gICAgICAgIG1lcmdlT3B0aW9ucy51cGRhdGVCbG9ja3MoKTtcbiAgICAgICAgcmV0dXJuIGRpc3RyaWJ1dGVkQmxvY2tzO1xuICAgIH07XG5cbiAgICAvLyB1bnN1cHBvcnRlZCwgTk9OLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLnBhcnNlRXhwZWN0ZWRPcHRpb25zUGF0aCA9IGZ1bmN0aW9uIChwYXRoLCByb2xlKSB7XG4gICAgICAgIHZhciBzZWdzID0gZmx1aWQubW9kZWwucGFyc2VFTChwYXRoKTtcbiAgICAgICAgaWYgKHNlZ3MubGVuZ3RoID4gMSAmJiBzZWdzWzBdICE9PSBcIm9wdGlvbnNcIikge1xuICAgICAgICAgICAgZmx1aWQuZmFpbChcIkVycm9yIGluIG9wdGlvbnMgZGlzdHJpYnV0aW9uIHBhdGggXCIsIHBhdGgsIFwiIC0gb25seSBcIiArIHJvbGUgKyBcIiBwYXRocyBiZWdpbm5pbmcgd2l0aCBcXFwib3B0aW9uc1xcXCIgYXJlIHN1cHBvcnRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2Vncy5zbGljZSgxKTtcbiAgICB9O1xuXG4gICAgLy8gdW5zdXBwb3J0ZWQsIE5PTi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5pc0lvQ1NTU2VsZWN0b3IgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5pbmRleE9mKFwiIFwiKSAhPT0gLTE7IC8vIHNpbXBsZS1taW5kZWQgY2hlY2sgZm9yIGFuIElvQ1NTIHJlZmVyZW5jZVxuICAgIH07XG5cbiAgICAvLyB1bnN1cHBvcnRlZCwgTk9OLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLnB1c2hEaXN0cmlidXRpb25zID0gZnVuY3Rpb24gKHRhcmdldEhlYWQsIHNlbGVjdG9yLCBibG9ja3MpIHtcbiAgICAgICAgdmFyIHRhcmdldFNoYWRvdyA9IGZsdWlkLnNoYWRvd0ZvckNvbXBvbmVudCh0YXJnZXRIZWFkKTtcbiAgICAgICAgdmFyIGlkID0gZmx1aWQuYWxsb2NhdGVHdWlkKCk7XG4gICAgICAgIHZhciBkaXN0cmlidXRpb25zID0gKHRhcmdldFNoYWRvdy5kaXN0cmlidXRpb25zID0gdGFyZ2V0U2hhZG93LmRpc3RyaWJ1dGlvbnMgfHwgW10pO1xuICAgICAgICBkaXN0cmlidXRpb25zLnB1c2goe1xuICAgICAgICAgICAgaWQ6IGlkLCAvLyBUaGlzIGlkIGlzIHVzZWQgaW4gY2xlYXJEaXN0cmlidXRpb25zIC0gd2hpY2ggaXRzZWxmIGN1cnJlbnRseSBvbmx5IHNlZW1zIHRvIGFwcGVhciBpbiBJb0NUZXN0VXRpbHNcbiAgICAgICAgICAgIHNlbGVjdG9yOiBzZWxlY3RvcixcbiAgICAgICAgICAgIGJsb2NrczogYmxvY2tzXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfTtcblxuICAgIC8vIHVuc3VwcG9ydGVkLCBOT04tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQuY2xlYXJEaXN0cmlidXRpb25zID0gZnVuY3Rpb24gKHRhcmdldEhlYWQsIGlkKSB7XG4gICAgICAgIHZhciB0YXJnZXRTaGFkb3cgPSBmbHVpZC5zaGFkb3dGb3JDb21wb25lbnQodGFyZ2V0SGVhZCk7XG4gICAgICAgIGZsdWlkLnJlbW92ZV9pZih0YXJnZXRTaGFkb3cuZGlzdHJpYnV0aW9ucywgZnVuY3Rpb24gKGRpc3RyaWJ1dGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGRpc3RyaWJ1dGlvbi5pZCA9PT0gaWQ7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyB1bnN1cHBvcnRlZCwgTk9OLUFQSSBmdW5jdGlvblxuICAgIC8vIE1vZGlmaWVzIGEgcGFyc2VkIHNlbGVjdG9yIHRvIGV4dHJhIGl0cyBoZWFkIGNvbnRleHQgd2hpY2ggd2lsbCBiZSBtYXRjaGVkIHVwd2FyZHNcbiAgICBmbHVpZC5leHRyYWN0U2VsZWN0b3JIZWFkID0gZnVuY3Rpb24gKHBhcnNlZFNlbGVjdG9yKSB7XG4gICAgICAgIHZhciBwcmVkTGlzdCA9IHBhcnNlZFNlbGVjdG9yWzBdLnByZWRMaXN0O1xuICAgICAgICB2YXIgY29udGV4dCA9IHByZWRMaXN0WzBdLmNvbnRleHQ7XG4gICAgICAgIHByZWRMaXN0Lmxlbmd0aCA9IDA7XG4gICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH07XG5cbiAgICBmbHVpZC51bmRpc3RyaWJ1dGFibGVPcHRpb25zID0gW1wiZ3JhZGVOYW1lc1wiLCBcImRpc3RyaWJ1dGVPcHRpb25zXCIsIFwicmV0dXJuZWRQYXRoXCIsIFwiYXJndW1lbnRNYXBcIiwgXCJpbml0RnVuY3Rpb25cIiwgXCJtZXJnZVBvbGljeVwiLCBcInByb2dyZXNzaXZlQ2hlY2tlck9wdGlvbnNcIl07IC8vIGF1dG9tYXRpY2FsbHkgYWRkZWQgdG8gXCJleGNsdXNpb25zXCIgb2YgZXZlcnkgZGlzdHJpYnV0aW9uXG5cbiAgICAvLyB1bnN1cHBvcnRlZCwgTk9OLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLmRpc3RyaWJ1dGVPcHRpb25zID0gZnVuY3Rpb24gKHRoYXQsIG9wdGlvbnNTdHJhdGVneSkge1xuICAgICAgICB2YXIgcmVjb3JkcyA9IGZsdWlkLm1ha2VBcnJheShmbHVpZC5kcml2ZVN0cmF0ZWd5KHRoYXQub3B0aW9ucywgXCJkaXN0cmlidXRlT3B0aW9uc1wiLCBvcHRpb25zU3RyYXRlZ3kpKTtcbiAgICAgICAgZmx1aWQuZWFjaChyZWNvcmRzLCBmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0UmVmID0gZmx1aWQucGFyc2VDb250ZXh0UmVmZXJlbmNlKHJlY29yZC50YXJnZXQpO1xuICAgICAgICAgICAgdmFyIHRhcmdldENvbXAsIHNlbGVjdG9yO1xuICAgICAgICAgICAgaWYgKGZsdWlkLmlzSW9DU1NTZWxlY3Rvcih0YXJnZXRSZWYuY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RvciA9IGZsdWlkLnBhcnNlU2VsZWN0b3IodGFyZ2V0UmVmLmNvbnRleHQsIGZsdWlkLklvQ1NTTWF0Y2hlcik7XG4gICAgICAgICAgICAgICAgdmFyIGhlYWRDb250ZXh0ID0gZmx1aWQuZXh0cmFjdFNlbGVjdG9ySGVhZChzZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgaWYgKGhlYWRDb250ZXh0ICE9PSBcInRoYXRcIikge1xuICAgICAgICAgICAgICAgICAgICBmbHVpZC5mYWlsKFwiRG93bndhcmRzIG9wdGlvbnMgZGlzdHJpYnV0aW9uIG5vdCBzdXBwb3J0ZWQgZnJvbSBjb21wb25lbnQgb3RoZXIgdGhhbiBcXFwidGhhdFxcXCJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhcmdldENvbXAgPSB0aGF0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Q29tcCA9IGZsdWlkLnJlc29sdmVDb250ZXh0KHRhcmdldFJlZi5jb250ZXh0LCB0aGF0KTtcbiAgICAgICAgICAgICAgICBpZiAoIXRhcmdldENvbXApIHtcbiAgICAgICAgICAgICAgICAgICAgZmx1aWQuZmFpbChcIkVycm9yIGluIG9wdGlvbnMgZGlzdHJpYnV0aW9uIHJlY29yZCBcIiwgcmVjb3JkLCBcIiAtIGNvdWxkIG5vdCByZXNvbHZlIGNvbnRleHQgc2VsZWN0b3Ige1wiK3RhcmdldFJlZi5jb250ZXh0K1wifSB0byBhIHJvb3QgY29tcG9uZW50XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0YXJnZXRTZWdzID0gZmx1aWQubW9kZWwucGFyc2VFTCh0YXJnZXRSZWYucGF0aCk7XG4gICAgICAgICAgICB2YXIgcHJlQmxvY2tzO1xuICAgICAgICAgICAgaWYgKHJlY29yZC5yZWNvcmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHByZUJsb2NrcyA9IFsoZmx1aWQubWFrZURpc3RyaWJ1dGlvblJlY29yZCh0aGF0LCByZWNvcmQucmVjb3JkLCBbXSwgdGFyZ2V0U2VncywgW10sIDApKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgdGhhdFNoYWRvdyA9IGZsdWlkLnNoYWRvd0ZvckNvbXBvbmVudCh0aGF0KTtcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gZmx1aWQucGFyc2VDb250ZXh0UmVmZXJlbmNlKHJlY29yZC5zb3VyY2UgfHwgXCJ7dGhhdH0ub3B0aW9uc1wiKTsgLy8gVE9ETzogVGhpcyBpcyBwcm9iYWJseSBub3QgYSBzZW5zaWJsZSBkZWZhdWx0XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jb250ZXh0ICE9PSBcInRoYXRcIikge1xuICAgICAgICAgICAgICAgICAgICBmbHVpZC5mYWlsKFwiRXJyb3IgaW4gb3B0aW9ucyBkaXN0cmlidXRpb24gcmVjb3JkIFwiLCByZWNvcmQsIFwiIG9ubHkgYSBjb250ZXh0IG9mIHt0aGF0fSBpcyBzdXBwb3J0ZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzb3VyY2VQYXRoID0gZmx1aWQucGFyc2VFeHBlY3RlZE9wdGlvbnNQYXRoKHNvdXJjZS5wYXRoLCBcInNvdXJjZVwiKTtcbiAgICAgICAgICAgICAgICB2YXIgZnVsbEV4Y2x1c2lvbnMgPSBmbHVpZC5tYWtlQXJyYXkocmVjb3JkLmV4Y2x1c2lvbnMpLmNvbmNhdChzb3VyY2VQYXRoLmxlbmd0aCA9PT0gMCA/IGZsdWlkLnVuZGlzdHJpYnV0YWJsZU9wdGlvbnMgOiBbXSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZXhjbHVzaW9ucyA9IGZsdWlkLnRyYW5zZm9ybShmdWxsRXhjbHVzaW9ucywgZnVuY3Rpb24gKGV4Y2x1c2lvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmx1aWQubW9kZWwucGFyc2VFTChleGNsdXNpb24pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcHJlQmxvY2tzID0gZmx1aWQuZmlsdGVyQmxvY2tzKHRoYXQsIHRoYXRTaGFkb3cubWVyZ2VPcHRpb25zLm1lcmdlQmxvY2tzLCBzb3VyY2VQYXRoLCB0YXJnZXRTZWdzLCBleGNsdXNpb25zLCByZWNvcmQucmVtb3ZlU291cmNlKTtcbiAgICAgICAgICAgICAgICB0aGF0U2hhZG93Lm1lcmdlT3B0aW9ucy51cGRhdGVCbG9ja3MoKTsgLy8gcGVyaGFwcyB1bm5lY2Vzc2FyeVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVE9ETzogaW5saW5lIG1hdGVyaWFsIGhhcyB0byBiZSBleHBhbmRlZCBpbiBpdHMgb3JpZ2luYWwgY29udGV4dCFcblxuICAgICAgICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgZmx1aWQucHVzaERpc3RyaWJ1dGlvbnModGFyZ2V0Q29tcCwgc2VsZWN0b3IsIHByZUJsb2Nrcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHsgLy8gVGhlIGNvbXBvbmVudCBleGlzdHMgbm93LCB3ZSBtdXN0IHJlYmFsYW5jZSBpdFxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRTaGFkb3cgPSBmbHVpZC5zaGFkb3dGb3JDb21wb25lbnQodGFyZ2V0Q29tcCk7XG4gICAgICAgICAgICAgICAgZmx1aWQuYXBwbHlEaXN0cmlidXRpb25zKHRoYXQsIHByZUJsb2NrcywgdGFyZ2V0U2hhZG93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIHVuc3VwcG9ydGVkLCBOT04tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQuZ3JhZGVOYW1lc1RvSGFzaCA9IGZ1bmN0aW9uIChncmFkZU5hbWVzKSB7XG4gICAgICAgIHZhciBjb250ZXh0SGFzaCA9IHt9O1xuICAgICAgICBmbHVpZC5lYWNoKGdyYWRlTmFtZXMsIGZ1bmN0aW9uIChncmFkZU5hbWUpIHtcbiAgICAgICAgICAgIGNvbnRleHRIYXNoW2dyYWRlTmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgY29udGV4dEhhc2hbZmx1aWQuY29tcHV0ZU5pY2tOYW1lKGdyYWRlTmFtZSldID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb250ZXh0SGFzaDtcbiAgICB9O1xuXG4gICAgLy8gdW5zdXBwb3J0ZWQsIE5PTi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5jYWNoZVNoYWRvd0dyYWRlcyA9IGZ1bmN0aW9uICh0aGF0LCBzaGFkb3cpIHtcbiAgICAgICAgdmFyIGNvbnRleHRIYXNoID0gZmx1aWQuZ3JhZGVOYW1lc1RvSGFzaCh0aGF0Lm9wdGlvbnMuZ3JhZGVOYW1lcyk7XG4gICAgICAgIGNvbnRleHRIYXNoW3RoYXQubmlja05hbWVdID0gdHJ1ZTtcbiAgICAgICAgc2hhZG93LmNvbnRleHRIYXNoID0gY29udGV4dEhhc2g7XG4gICAgfTtcblxuICAgIC8vIEZpcnN0IHNlcXVlbmNlIHBvaW50IHdoZXJlIHRoZSBtZXJnZU9wdGlvbnMgc3RyYXRlZ3kgaXMgZGVsaXZlcmVkIGZyb20gRmx1aWQuanMgLSBoZXJlIHdlIHRha2UgY2FyZVxuICAgIC8vIG9mIGJvdGggcmVjZWl2aW5nIGFuZCB0cmFuc21pdHRpbmcgb3B0aW9ucyBkaXN0cmlidXRpb25zXG4gICAgLy8gdW5zdXBwb3J0ZWQsIE5PTi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5kZWxpdmVyT3B0aW9uc1N0cmF0ZWd5ID0gZnVuY3Rpb24gKHRoYXQsIHRhcmdldCwgbWVyZ2VPcHRpb25zKSB7XG4gICAgICAgIHZhciBzaGFkb3cgPSBmbHVpZC5zaGFkb3dGb3JDb21wb25lbnQodGhhdCwgc2hhZG93KTtcbiAgICAgICAgZmx1aWQuY2FjaGVTaGFkb3dHcmFkZXModGhhdCwgc2hhZG93KTtcbiAgICAgICAgc2hhZG93Lm1lcmdlT3B0aW9ucyA9IG1lcmdlT3B0aW9ucztcbiAgICB9O1xuXG4gICAgLy8gdW5zdXBwb3J0ZWQsIE5PTi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5yZXNvbHZlUmV0dXJuZWRQYXRoID0gZnVuY3Rpb24gKHJldHVybmVkUGF0aCwgdGhhdCkge1xuICAgICAgICB2YXIgc2hhZG93ID0gZmx1aWQuc2hhZG93Rm9yQ29tcG9uZW50KHRoYXQpO1xuICAgICAgICAvLyBUaGlzIHByZXZlbnRzIGNvcnJ1cHRpb24gb2YgaW5zdGFudGlhdG9yIHJlY29yZHMgYnkgZGVmZWF0aW5nIGVmZmVjdCBvZiBcInJldHVybmVkUGF0aFwiIGZvciBub24tcm9vdHNcbiAgICAgICAgcmV0dXJuIHNoYWRvdyAmJiBzaGFkb3cucGF0aCAhPT0gXCJcIiA/IG51bGwgOiByZXR1cm5lZFBhdGg7XG4gICAgfTtcblxuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmx1aWQuZ3JhZGVMaW5rYWdlUmVjb3JkXCIsIHtcbiAgICAgICAgZ3JhZGVOYW1lczogW1wiZmx1aWQubGl0dGxlQ29tcG9uZW50XCJdXG4gICAgfSk7XG5cbiAgICAvKiogQSBcInRhZyBjb21wb25lbnRcIiB0byBvcHQgaW4gdG8gdGhlIGdyYWRlIGxpbmthZ2Ugc3lzdGVtIChGTFVJRC01MjEyKSB3aGljaCBpcyBjdXJyZW50bHkgdmVyeSBleHBlbnNpdmUgLVxuICAgICAgKiB0aGlzIHdpbGwgYmVjb21lIHRoZSBkZWZhdWx0IG9uY2Ugd2UgaGF2ZSBhIGJldHRlciBpbXBsZW1lbnRhdGlvbiBhbmQgaGF2ZSBzdGFiaWxpc2VkIHJlcXVpcmVtZW50c1xuICAgICAgKi9cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsdWlkLmFwcGx5R3JhZGVMaW5rYWdlXCIsIHsgfSk7XG5cbiAgICBmbHVpZC5ncmFkZUxpbmthZ2VJbmRleGVyID0gZnVuY3Rpb24gKGRlZmF1bHRzKSB7XG4gICAgICAgIGlmIChkZWZhdWx0cy5jb250ZXh0R3JhZGVzICYmIGRlZmF1bHRzLnJlc3VsdEdyYWRlcykge1xuICAgICAgICAgICAgcmV0dXJuIFtcIipcIl07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZmx1aWQuZ2V0TGlua2VkR3JhZGVzID0gZnVuY3Rpb24gKGdyYWRlTmFtZXMpIHtcbiAgICAgICAgdmFyIHRvZ28gPSBbXTtcbiAgICAgICAgdmFyIGdyYWRlTGlua2FnZXMgPSBmbHVpZC5pbmRleERlZmF1bHRzKFwiZ3JhZGVMaW5rYWdlc1wiLCB7XG4gICAgICAgICAgICBncmFkZU5hbWVzOiBcImZsdWlkLmdyYWRlTGlua2FnZVJlY29yZFwiLFxuICAgICAgICAgICAgaW5kZXhGdW5jOiBmbHVpZC5ncmFkZUxpbmthZ2VJbmRleGVyXG4gICAgICAgIH0pO1xuICAgICAgICBmbHVpZC5lYWNoKGdyYWRlTGlua2FnZXNbXCIqXCJdLCBmdW5jdGlvbiAoZGVmYXVsdHNOYW1lKSB7XG4gICAgICAgICAgICB2YXIgZGVmYXVsdHMgPSBmbHVpZC5kZWZhdWx0cyhkZWZhdWx0c05hbWUpO1xuICAgICAgICAgICAgdmFyIGV4Y2x1ZGUgPSBmbHVpZC5maW5kKGZsdWlkLm1ha2VBcnJheShkZWZhdWx0cy5jb250ZXh0R3JhZGVzKSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZ3JhZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmbHVpZC5jb250YWlucyhncmFkZU5hbWVzLCBncmFkZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICghZXhjbHVkZSkge1xuICAgICAgICAgICAgICAgIHRvZ28ucHVzaC5hcHBseSh0b2dvLCBmbHVpZC5tYWtlQXJyYXkoZGVmYXVsdHMucmVzdWx0R3JhZGVzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdG9nbztcbiAgICB9O1xuXG4gICAgZmx1aWQuZXhwYW5kRHluYW1pY0dyYWRlcyA9IGZ1bmN0aW9uICh0aGF0LCBzaGFkb3csIGdyYWRlTmFtZXMsIGR5bmFtaWNHcmFkZXMpIHtcbiAgICAgICAgdmFyIHJlc29sdmVkID0gW107XG4gICAgICAgIGZsdWlkLmVhY2goZHluYW1pY0dyYWRlcywgZnVuY3Rpb24gKGR5bmFtaWNHcmFkZSkge1xuICAgICAgICAgICAgdmFyIGV4cGFuZGVkID0gZmx1aWQuZXhwYW5kT3B0aW9ucyhkeW5hbWljR3JhZGUsIHRoYXQpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZihleHBhbmRlZCkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGV4cGFuZGVkID0gZXhwYW5kZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHBhbmRlZCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVkID0gcmVzb2x2ZWQuY29uY2F0KGV4cGFuZGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBhbGxHcmFkZXMgPSBmbHVpZC5tYWtlQXJyYXkoZ3JhZGVOYW1lcykuY29uY2F0KHJlc29sdmVkKTtcbiAgICAgICAgaWYgKGZsdWlkLmNvbnRhaW5zKGFsbEdyYWRlcywgXCJmbHVpZC5hcHBseUdyYWRlTGlua2FnZVwiKSkge1xuICAgICAgICAgICAgdmFyIGxpbmtlZEdyYWRlcyA9IGZsdWlkLmdldExpbmtlZEdyYWRlcyhhbGxHcmFkZXMpO1xuICAgICAgICAgICAgZmx1aWQucmVtb3ZlX2lmKGxpbmtlZEdyYWRlcywgZnVuY3Rpb24gKGdyYWRlTmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbHVpZC5jb250YWlucyhhbGxHcmFkZXMsIGdyYWRlTmFtZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlc29sdmVkID0gcmVzb2x2ZWQuY29uY2F0KGxpbmtlZEdyYWRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRpc3RyaWJ1dGVkQmxvY2tzID0gZmx1aWQucmVjZWl2ZURpc3RyaWJ1dGlvbnMobnVsbCwgbnVsbCwgbnVsbCwgdGhhdCk7XG4gICAgICAgIGlmIChkaXN0cmlidXRlZEJsb2Nrcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgcmVhZHlCbG9ja3MgPSBmbHVpZC5hcHBseURpc3RyaWJ1dGlvbnModGhhdCwgZGlzdHJpYnV0ZWRCbG9ja3MsIHNoYWRvdyk7XG4gICAgICAgICAgICAvLyByZWx5IG9uIHRoZSBmYWN0IHRoYXQgXCJkaXJ0eSB0cmlja3MgYXJlIG5vdCBwZXJtaXR0ZWRcIiB3cnQuIHJlc29sdmluZyBncmFkZU5hbWVzIC0gZWFjaCBlbGVtZW50IG11c3QgYmUgYSBsaXRlcmFsIGVudHJ5IG9yIGFycmF5XG4gICAgICAgICAgICAvLyBob2xkaW5nIHByaW1pdGl2ZSBvciBFTCB2YWx1ZXMgLSBvdGhlcndpc2Ugd2Ugd291bGQgaGF2ZSB0byBnbyBhbGwgcm91bmQgdGhlIGhvdXNlcyBhbmQgcmVlbnRlciB0aGUgdG9wIG9mIGZsdWlkLmNvbXB1dGVEeW5hbWljR3JhZGVzXG4gICAgICAgICAgICB2YXIgZ3JhZGVOYW1lc0xpc3QgPSBmbHVpZC50cmFuc2Zvcm0oZmx1aWQuZ2V0TWVtYmVycyhyZWFkeUJsb2NrcywgW1wic291cmNlXCIsIFwiZ3JhZGVOYW1lc1wiXSksIGZsdWlkLm1ha2VBcnJheSk7XG4gICAgICAgICAgICByZXNvbHZlZCA9IHJlc29sdmVkLmNvbmNhdC5hcHBseShyZXNvbHZlZCwgZ3JhZGVOYW1lc0xpc3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHZlZDtcbiAgICB9O1xuXG4gICAgLy8gRGlzY292ZXIgZnVydGhlciBncmFkZXMgdGhhdCBhcmUgZW50YWlsZWQgYnkgdGhlIGdpdmVuIGJhc2UgdHlwZU5hbWUgYW5kIHRoZSBjdXJyZW50IHRvdGFsIFwiZHluYW1pYyBncmFkZXMgbGlzdFwiIGhlbGQgaW4gdGhlIGFyZ3VtZW50IFwicmVzb2x2ZWRcIi5cbiAgICAvLyBUaGVzZSBhcmUgbG9va2VkIHVwIGNvbmpvaW50bHkgaW4gdGhlIGdyYWRlIHJlZ2lzdHJ5LCBhbmQgdGhlbiBhbnkgZnVydGhlciBpKSBkeW5hbWljIGdyYWRlcyByZWZlcmVuY2VzIHt9IGlpKSBncmFkZSBsaW5rYWdlIHJlY29yZHNcbiAgICAvLyBhcmUgZXhwYW5kZWQgYW5kIGFkZGVkIGludG8gdGhlIGxpc3QgYW5kIGNvbmNhdGVuYXRlZCBpbnRvIFwicmVzb2x2ZWRcIi4gQWRkaXRpb25hbCBncmFkZXMgZGlzY292ZXJlZCBkdXJpbmcgdGhpcyBmdW5jdGlvbiBhcmUgcmV0dXJuZWQgYXNcbiAgICAvLyBcImZ1cnRoZXJSZXNvbHZlZFwiLlxuICAgIGZsdWlkLmNvbGxlY3REeW5hbWljR3JhZGVzID0gZnVuY3Rpb24gKHRoYXQsIHNoYWRvdywgZGVmYXVsdHNCbG9jaywgZ3JhZGVOYW1lcywgZHluYW1pY0dyYWRlcywgcmVzb2x2ZWQpIHtcbiAgICAgICAgdmFyIG5ld0RlZmF1bHRzID0gZmx1aWQuY29weShmbHVpZC5nZXRHcmFkZWREZWZhdWx0cyh0aGF0LnR5cGVOYW1lLCByZXNvbHZlZCkpO1xuICAgICAgICBncmFkZU5hbWVzLmxlbmd0aCA9IDA7IC8vIGFjcXVpcmUgZGVyaXZhdGl2ZXMgb2YgZHluYW1pYyBncmFkZXMgKEZMVUlELTUwNTQpXG4gICAgICAgIGdyYWRlTmFtZXMucHVzaC5hcHBseShncmFkZU5hbWVzLCBuZXdEZWZhdWx0cy5ncmFkZU5hbWVzKTtcblxuICAgICAgICBmbHVpZC5jYWNoZVNoYWRvd0dyYWRlcyh0aGF0LCBzaGFkb3cpO1xuICAgICAgICAvLyBUaGlzIGNoZWFwIHN0cmF0ZWd5IHBhdGNoZXMgRkxVSUQtNTA5MSBmb3Igbm93IC0gc29tZSBtb3JlIHNvcGhpc3RpY2F0ZWQgYWN0aXZpdHkgd2lsbCB0YWtlIHBsYWNlXG4gICAgICAgIC8vIGF0IHRoaXMgc2l0ZSB3aGVuIHdlIGhhdmUgYSBmdWxsIGZpeCBmb3IgRkxVSUQtNTAyOFxuICAgICAgICBzaGFkb3cubWVyZ2VPcHRpb25zLmRlc3Ryb3lWYWx1ZShcIm1lcmdlUG9saWN5XCIpO1xuICAgICAgICBzaGFkb3cubWVyZ2VPcHRpb25zLmRlc3Ryb3lWYWx1ZShcImNvbXBvbmVudHNcIik7XG4gICAgICAgIHNoYWRvdy5tZXJnZU9wdGlvbnMuZGVzdHJveVZhbHVlKFwiaW52b2tlcnNcIik7XG5cbiAgICAgICAgZGVmYXVsdHNCbG9jay5zb3VyY2UgPSBuZXdEZWZhdWx0cztcbiAgICAgICAgc2hhZG93Lm1lcmdlT3B0aW9ucy51cGRhdGVCbG9ja3MoKTtcblxuICAgICAgICB2YXIgZnVydGhlclJlc29sdmVkID0gZmx1aWQucmVtb3ZlX2lmKGdyYWRlTmFtZXMsIGZ1bmN0aW9uIChncmFkZU5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBncmFkZU5hbWUuY2hhckF0KDApID09PSBcIntcIiAmJiAhZmx1aWQuY29udGFpbnMoZHluYW1pY0dyYWRlcywgZ3JhZGVOYW1lKTtcbiAgICAgICAgfSwgW10pO1xuICAgICAgICBkeW5hbWljR3JhZGVzLnB1c2guYXBwbHkoZHluYW1pY0dyYWRlcywgZnVydGhlclJlc29sdmVkKTtcbiAgICAgICAgZnVydGhlclJlc29sdmVkID0gZmx1aWQuZXhwYW5kRHluYW1pY0dyYWRlcyh0aGF0LCBzaGFkb3csIGdyYWRlTmFtZXMsIGZ1cnRoZXJSZXNvbHZlZCk7XG5cbiAgICAgICAgcmVzb2x2ZWQucHVzaC5hcHBseShyZXNvbHZlZCwgZnVydGhlclJlc29sdmVkKTtcblxuICAgICAgICByZXR1cm4gZnVydGhlclJlc29sdmVkO1xuICAgIH07XG5cbiAgICAvLyB1bnN1cHBvcnRlZCwgTk9OLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLmNvbXB1dGVEeW5hbWljR3JhZGVzID0gZnVuY3Rpb24gKHRoYXQsIHNoYWRvdywgc3RyYXRlZ3kpIHtcbiAgICAgICAgZGVsZXRlIHRoYXQub3B0aW9ucy5ncmFkZU5hbWVzOyAvLyBSZWNvbXB1dGUgZ3JhZGVOYW1lcyBmb3IgRkxVSUQtNTAxMiBhbmQgb3RoZXJzXG5cbiAgICAgICAgdmFyIGdyYWRlTmFtZXMgPSBmbHVpZC5kcml2ZVN0cmF0ZWd5KHRoYXQub3B0aW9ucywgXCJncmFkZU5hbWVzXCIsIHN0cmF0ZWd5KTtcbiAgICAgICAgLy8gVE9ETzogSW4gY29tcGxleCBkaXN0cmlidXRpb24gY2FzZXMsIGEgY29tcG9uZW50IG1pZ2h0IGVuZCB1cCB3aXRoIG11bHRpcGxlIGRlZmF1bHQgYmxvY2tzXG4gICAgICAgIHZhciBkZWZhdWx0c0Jsb2NrID0gZmx1aWQuZmluZE1lcmdlQmxvY2tzKHNoYWRvdy5tZXJnZU9wdGlvbnMubWVyZ2VCbG9ja3MsIFwiZGVmYXVsdHNcIilbMF07XG4gICAgICAgIHZhciBkeW5hbWljR3JhZGVzID0gZmx1aWQucmVtb3ZlX2lmKGdyYWRlTmFtZXMsIGZ1bmN0aW9uIChncmFkZU5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBncmFkZU5hbWUuY2hhckF0KDApID09PSBcIntcIiB8fCAhZmx1aWQuaGFzR3JhZGUoZGVmYXVsdHNCbG9jay50YXJnZXQsIGdyYWRlTmFtZSk7XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgdmFyIHJlc29sdmVkID0gZmx1aWQuZXhwYW5kRHluYW1pY0dyYWRlcyh0aGF0LCBzaGFkb3csIGdyYWRlTmFtZXMsIGR5bmFtaWNHcmFkZXMpO1xuICAgICAgICBpZiAocmVzb2x2ZWQubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB2YXIgZnVydGhlclJlc29sdmVkO1xuICAgICAgICAgICAgZG8geyAvLyByZXBlYXRlZGx5IGNvbGxlY3QgZHluYW1pYyBncmFkZXMgd2hpbHN0IHRoZXkgYXJyaXZlIChGTFVJRC01MTU1KVxuICAgICAgICAgICAgICAgIGZ1cnRoZXJSZXNvbHZlZCA9IGZsdWlkLmNvbGxlY3REeW5hbWljR3JhZGVzKHRoYXQsIHNoYWRvdywgZGVmYXVsdHNCbG9jaywgZ3JhZGVOYW1lcywgZHluYW1pY0dyYWRlcywgcmVzb2x2ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGZ1cnRoZXJSZXNvbHZlZC5sZW5ndGggIT09IDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaGFkb3cuY29sbGVjdGVkQ2xlYXJlcikge1xuICAgICAgICAgICAgc2hhZG93LmNvbGxlY3RlZENsZWFyZXIoKTtcbiAgICAgICAgICAgIGRlbGV0ZSBzaGFkb3cuY29sbGVjdGVkQ2xlYXJlcjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmbHVpZC5jb21wdXRlRHluYW1pY0NvbXBvbmVudEtleSA9IGZ1bmN0aW9uIChyZWNvcmRLZXksIHNvdXJjZUtleSkge1xuICAgICAgICByZXR1cm4gcmVjb3JkS2V5ICsgKHNvdXJjZUtleSA9PT0gMCA/IFwiXCIgOiBcIi1cIiArIHNvdXJjZUtleSk7IC8vIFRPRE86IGNvbmZpZ3VyYWJsZSBuYW1lIHN0cmF0ZWdpZXNcbiAgICB9O1xuXG4gICAgLy8gdW5zdXBwb3J0ZWQsIE5PTi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5yZWdpc3RlckR5bmFtaWNSZWNvcmQgPSBmdW5jdGlvbiAodGhhdCwgcmVjb3JkS2V5LCBzb3VyY2VLZXksIHJlY29yZCwgdG9DZW5zb3IpIHtcbiAgICAgICAgdmFyIGtleSA9IGZsdWlkLmNvbXB1dGVEeW5hbWljQ29tcG9uZW50S2V5KHJlY29yZEtleSwgc291cmNlS2V5KTtcbiAgICAgICAgdmFyIGNSZWNvcmQgPSBmbHVpZC5jb3B5KHJlY29yZCk7XG4gICAgICAgIGRlbGV0ZSBjUmVjb3JkW3RvQ2Vuc29yXTtcbiAgICAgICAgZmx1aWQuc2V0KHRoYXQub3B0aW9ucywgW1wiY29tcG9uZW50c1wiLCBrZXldLCBjUmVjb3JkKTtcbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICB9O1xuXG4gICAgLy8gdW5zdXBwb3J0ZWQsIE5PTi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5jb21wdXRlRHluYW1pY0NvbXBvbmVudHMgPSBmdW5jdGlvbiAodGhhdCwgbWVyZ2VPcHRpb25zKSB7XG4gICAgICAgIHZhciBzaGFkb3cgPSBmbHVpZC5zaGFkb3dGb3JDb21wb25lbnQodGhhdCk7XG4gICAgICAgIHZhciBsb2NhbFN1YiA9IHNoYWRvdy5zdWJjb21wb25lbnRMb2NhbCA9IHt9O1xuICAgICAgICB2YXIgcmVjb3JkcyA9IGZsdWlkLmRyaXZlU3RyYXRlZ3kodGhhdC5vcHRpb25zLCBcImR5bmFtaWNDb21wb25lbnRzXCIsIG1lcmdlT3B0aW9ucy5zdHJhdGVneSk7XG4gICAgICAgIGZsdWlkLmVhY2gocmVjb3JkcywgZnVuY3Rpb24gKHJlY29yZCwgcmVjb3JkS2V5KSB7XG4gICAgICAgICAgICBpZiAoIXJlY29yZC5zb3VyY2VzICYmICFyZWNvcmQuY3JlYXRlT25FdmVudCkge1xuICAgICAgICAgICAgICAgIGZsdWlkLmZhaWwoXCJDYW5ub3QgcHJvY2VzcyBkeW5hbWljQ29tcG9uZW50cyByZWNvcmQgXCIsIHJlY29yZCwgXCIgd2l0aG91dCBhIFxcXCJzb3VyY2VzXFxcIiBvciBcXFwiY3JlYXRlT25FdmVudFxcXCIgZW50cnlcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVjb3JkLnNvdXJjZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlcyA9IGZsdWlkLmV4cGFuZE9wdGlvbnMocmVjb3JkLnNvdXJjZXMsIHRoYXQpO1xuICAgICAgICAgICAgICAgIGZsdWlkLmVhY2goc291cmNlcywgZnVuY3Rpb24gKHNvdXJjZSwgc291cmNlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBmbHVpZC5yZWdpc3RlckR5bmFtaWNSZWNvcmQodGhhdCwgcmVjb3JkS2V5LCBzb3VyY2VLZXksIHJlY29yZCwgXCJzb3VyY2VzXCIpO1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFN1YltrZXldID0ge1wic291cmNlXCI6IHNvdXJjZSwgXCJzb3VyY2VQYXRoXCI6IHNvdXJjZUtleX07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZWNvcmQuY3JlYXRlT25FdmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBldmVudCA9IGZsdWlkLmV2ZW50LmV4cGFuZE9uZUV2ZW50KHRoYXQsIHJlY29yZC5jcmVhdGVPbkV2ZW50KTtcbiAgICAgICAgICAgICAgICBmbHVpZC5zZXQoc2hhZG93LCBbXCJkeW5hbWljQ29tcG9uZW50Q291bnRcIiwgcmVjb3JkS2V5XSwgMCk7XG4gICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gZmx1aWQucmVnaXN0ZXJEeW5hbWljUmVjb3JkKHRoYXQsIHJlY29yZEtleSwgc2hhZG93LmR5bmFtaWNDb21wb25lbnRDb3VudFtyZWNvcmRLZXldKyssIHJlY29yZCwgXCJjcmVhdGVPbkV2ZW50XCIpO1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFN1YltrZXldID0ge1wiYXJndW1lbnRzXCI6IGZsdWlkLm1ha2VBcnJheShhcmd1bWVudHMpfTtcbiAgICAgICAgICAgICAgICAgICAgZmx1aWQuaW5pdERlcGVuZGVudCh0aGF0LCBrZXkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZXZlbnQuYWRkTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIGZsdWlkLnJlY29yZExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgc2hhZG93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIFNlY29uZCBzZXF1ZW5jZSBwb2ludCBmb3IgbWVyZ2VPcHRpb25zIGZyb20gRmx1aWQuanMgLSBoZXJlIHdlIGNvbnN0cnVjdCBhbGwgZnVydGhlclxuICAgIC8vIHN0cmF0ZWdpZXMgcmVxdWlyZWQgb24gdGhlIElvQyBzaWRlIGFuZCBtb3VudCB0aGVtIGludG8gdGhlIHNoYWRvdydzIGdldENvbmZpZyBmb3IgdW5pdmVyc2FsIHVzZVxuICAgIC8vIHVuc3VwcG9ydGVkLCBOT04tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQuY29tcHV0ZUNvbXBvbmVudEFjY2Vzc29yID0gZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgICAgdmFyIHNoYWRvdyA9IGZsdWlkLnNoYWRvd0ZvckNvbXBvbmVudCh0aGF0KTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGF0Lm9wdGlvbnM7XG4gICAgICAgIHZhciBzdHJhdGVneSA9IHNoYWRvdy5tZXJnZU9wdGlvbnMuc3RyYXRlZ3k7XG4gICAgICAgIHZhciBvcHRpb25zU3RyYXRlZ3kgPSBmbHVpZC5tb3VudFN0cmF0ZWd5KFtcIm9wdGlvbnNcIl0sIG9wdGlvbnMsIHN0cmF0ZWd5KTtcbiAgICAgICAgc2hhZG93Lmludm9rZXJTdHJhdGVneSA9IGZsdWlkLnJlY29yZFN0cmF0ZWd5KHRoYXQsIG9wdGlvbnMsIHN0cmF0ZWd5LCBcImludm9rZXJzXCIsIGZsdWlkLmludm9rZXJGcm9tUmVjb3JkKTtcbiAgICAgICAgc2hhZG93LmV2ZW50U3RyYXRlZ3lCbG9jayA9IGZsdWlkLnJlY29yZFN0cmF0ZWd5KHRoYXQsIG9wdGlvbnMsIHN0cmF0ZWd5LCBcImV2ZW50c1wiLCBmbHVpZC5ldmVudEZyb21SZWNvcmQsIFtcImV2ZW50c1wiXSk7XG4gICAgICAgIHZhciBldmVudFN0cmF0ZWd5ID0gZmx1aWQubW91bnRTdHJhdGVneShbXCJldmVudHNcIl0sIHRoYXQsIHNoYWRvdy5ldmVudFN0cmF0ZWd5QmxvY2suc3RyYXRlZ3ksIFtcImV2ZW50c1wiXSk7XG4gICAgICAgIHNoYWRvdy5tZW1iZXJTdHJhdGVneSA9IGZsdWlkLnJlY29yZFN0cmF0ZWd5KHRoYXQsIG9wdGlvbnMsIHN0cmF0ZWd5LCBcIm1lbWJlcnNcIiwgZmx1aWQubWVtYmVyRnJvbVJlY29yZCk7XG4gICAgICAgIC8vIE5CIC0gZ2luZ2VyIHN0cmF0ZWd5IGhhbmRsZXMgY29uY3JldGUsIHJhdGlvbmFsaXNlXG4gICAgICAgIHNoYWRvdy5nZXRDb25maWcgPSB7c3RyYXRlZ2llczogW2ZsdWlkLm1vZGVsLmZ1bmNSZXNvbHZlclN0cmF0ZWd5LCBmbHVpZC5tYWtlR2luZ2VyU3RyYXRlZ3kodGhhdCksXG4gICAgICAgICAgICBvcHRpb25zU3RyYXRlZ3ksIHNoYWRvdy5pbnZva2VyU3RyYXRlZ3kuc3RyYXRlZ3ksIHNoYWRvdy5tZW1iZXJTdHJhdGVneS5zdHJhdGVneSwgZXZlbnRTdHJhdGVneV19O1xuXG4gICAgICAgIGZsdWlkLmNvbXB1dGVEeW5hbWljR3JhZGVzKHRoYXQsIHNoYWRvdywgc3RyYXRlZ3ksIHNoYWRvdy5tZXJnZU9wdGlvbnMubWVyZ2VCbG9ja3MpO1xuICAgICAgICBmbHVpZC5kaXN0cmlidXRlT3B0aW9ucyh0aGF0LCBzdHJhdGVneSk7XG5cbiAgICAgICAgcmV0dXJuIHNoYWRvdy5nZXRDb25maWc7XG4gICAgfTtcblxuICAgIGZsdWlkLnNoYWRvd0ZvckNvbXBvbmVudCA9IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgdmFyIGluc3RhbnRpYXRvciA9IGZsdWlkLmdldEluc3RhbnRpYXRvcihjb21wb25lbnQpO1xuICAgICAgICByZXR1cm4gaW5zdGFudGlhdG9yICYmIGNvbXBvbmVudCA/IGluc3RhbnRpYXRvci5pZFRvU2hhZG93W2NvbXBvbmVudC5pZF0gOiBudWxsO1xuICAgIH07XG5cbiAgICBmbHVpZC5nZXRGb3JDb21wb25lbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50LCBwYXRoKSB7XG4gICAgICAgIHZhciBzaGFkb3cgPSBmbHVpZC5zaGFkb3dGb3JDb21wb25lbnQoY29tcG9uZW50KTtcbiAgICAgICAgdmFyIGdldENvbmZpZyA9IHNoYWRvdyA/IHNoYWRvdy5nZXRDb25maWcgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBmbHVpZC5nZXQoY29tcG9uZW50LCBwYXRoLCBnZXRDb25maWcpO1xuICAgIH07XG5cbiAgICAvLyBBbiBFTCBzZWdtZW50IHJlc29sdmVyIHN0cmF0ZWd5IHRoYXQgd2lsbCBhdHRlbXB0IHRvIHRyaWdnZXIgY3JlYXRpb24gb2ZcbiAgICAvLyBjb21wb25lbnRzIHRoYXQgaXQgZGlzY292ZXJzIGFsb25nIHRoZSBFTCBwYXRoLCBpZiB0aGV5IGhhdmUgYmVlbiBkZWZpbmVkIGJ1dCBub3QgeWV0XG4gICAgLy8gY29uc3RydWN0ZWQuXG4gICAgLy8gdW5zdXBwb3J0ZWQsIE5PTi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5tYWtlR2luZ2VyU3RyYXRlZ3kgPSBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgICB2YXIgaW5zdGFudGlhdG9yID0gZmx1aWQuZ2V0SW5zdGFudGlhdG9yKHRoYXQpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNvbXBvbmVudCwgdGhpc1NlZywgaW5kZXgsIHNlZ3MpIHtcbiAgICAgICAgICAgIHZhciBhdHZhbCA9IGNvbXBvbmVudFt0aGlzU2VnXTtcbiAgICAgICAgICAgIGlmIChhdHZhbCA9PT0gZmx1aWQuaW5FdmFsdWF0aW9uTWFya2VyICYmIGluZGV4ID09PSBzZWdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZsdWlkLmZhaWwoXCJFcnJvciBpbiBjb21wb25lbnQgY29uZmlndXJhdGlvbiAtIGEgY2lyY3VsYXIgcmVmZXJlbmNlIHdhcyBmb3VuZCBkdXJpbmcgZXZhbHVhdGlvbiBvZiBwYXRoIHNlZ21lbnQgXFxcIlwiICsgdGhpc1NlZyArXG4gICAgICAgICAgICAgICAgICAgIFwiXFxcIjogZm9yIG1vcmUgZGV0YWlscywgc2VlIHRoZSBhY3Rpdml0eSByZWNvcmRzIGZvbGxvd2luZyB0aGlzIG1lc3NhZ2UgaW4gdGhlIGNvbnNvbGUsIG9yIGlzc3VlIGZsdWlkLnNldExvZ2dpbmcoZmx1aWQubG9nTGV2ZWwuVFJBQ0UpIHdoZW4gcnVubmluZyB5b3VyIGFwcGxpY2F0aW9uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluZGV4ID4gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhdHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhdHZhbCA9PT0gdW5kZWZpbmVkICYmIGNvbXBvbmVudC5oYXNPd25Qcm9wZXJ0eSh0aGlzU2VnKSkgeyAvLyBhdm9pZCByZWNvbXB1dGluZyBwcm9wZXJ0aWVzIHRoYXQgaGF2ZSBiZWVuIGV4cGxpY2l0bHkgZXZhbHVhdGVkIHRvIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIHJldHVybiBmbHVpZC5OT19WQUxVRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhdHZhbCA9PT0gdW5kZWZpbmVkKSB7IC8vIHBpY2sgdXAgY29tcG9uZW50cyBpbiBpbnN0YW50aWF0aW9uIGhlcmUgLSB3ZSBjYW4gY3V0IHRoaXMgYnJhbmNoIGJ5IGF0dGFjaGluZyBlYXJseVxuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRQYXRoID0gaW5zdGFudGlhdG9yLmlkVG9TaGFkb3dbY29tcG9uZW50LmlkXS5wYXRoO1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZFBhdGggPSBmbHVpZC5jb21wb3NlUGF0aChwYXJlbnRQYXRoLCB0aGlzU2VnKTtcbiAgICAgICAgICAgICAgICBhdHZhbCA9IGluc3RhbnRpYXRvci5wYXRoVG9Db21wb25lbnRbY2hpbGRQYXRoXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhdHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogVGhpcyBjaGVjayBpcyB2ZXJ5IGV4cGVuc2l2ZSAtIG9uY2UgZ2luZ2VybmVzcyBpcyBzdGFibGUsIHdlIG91Z2h0IHRvIGJlIGFibGUgdG9cbiAgICAgICAgICAgICAgICAvLyBlYWdlcmx5IGNvbXB1dGUgYW5kIGNhY2hlIHRoZSB2YWx1ZSBvZiBvcHRpb25zLmNvbXBvbmVudHMgLSBjaGVjayBpcyBhbHNvIGluY29ycmVjdCBhbmQgd2lsbCBtaXNzIGluamVjdGlvbnNcbiAgICAgICAgICAgICAgICB2YXIgc3ViUmVjb3JkID0gZmx1aWQuZ2V0Rm9yQ29tcG9uZW50KGNvbXBvbmVudCwgW1wib3B0aW9uc1wiLCBcImNvbXBvbmVudHNcIiwgdGhpc1NlZ10pO1xuICAgICAgICAgICAgICAgIGlmIChzdWJSZWNvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1YlJlY29yZC5jcmVhdGVPbkV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbHVpZC5mYWlsKFwiRXJyb3IgcmVzb2x2aW5nIHBhdGggc2VnbWVudCBcXFwiXCIgKyB0aGlzU2VnICsgXCJcXFwiIG9mIHBhdGggXCIgKyBzZWdzLmpvaW4oXCIuXCIpICsgXCIgc2luY2UgY29tcG9uZW50IHdpdGggcmVjb3JkIFwiLCBzdWJSZWNvcmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgaGFzIGFubm90YXRpb24gXFxcImNyZWF0ZU9uRXZlbnRcXFwiIC0gdGhpcyB2ZXJ5IGxpa2VseSByZXByZXNlbnRzIGFuIGltcGxlbWVudGF0aW9uIGVycm9yLiBFaXRoZXIgYWx0ZXIgdGhlIHJlZmVyZW5jZSBzbyBpdCBkb2VzIG5vdCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgbWF0Y2ggdGhpcyBjb21wb25lbnQsIG9yIGFsdGVyIHlvdXIgd29ya2Zsb3cgdG8gZW5zdXJlIHRoYXQgdGhlIGNvbXBvbmVudCBpcyBpbnN0YW50aWF0ZWQgYnkgdGhlIHRpbWUgdGhpcyByZWZlcmVuY2UgcmVzb2x2ZXNcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmx1aWQuaW5pdERlcGVuZGVudChjb21wb25lbnQsIHRoaXNTZWcpO1xuICAgICAgICAgICAgICAgICAgICBhdHZhbCA9IGNvbXBvbmVudFt0aGlzU2VnXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXR2YWw7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIGZsdWlkLmZpbHRlckJ1aWx0aW5HcmFkZXMgPSBmdW5jdGlvbiAoZ3JhZGVOYW1lcykge1xuICAgICAgICByZXR1cm4gZmx1aWQucmVtb3ZlX2lmKGZsdWlkLm1ha2VBcnJheShncmFkZU5hbWVzKSwgZnVuY3Rpb24gKGdyYWRlTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuICgvXihhdXRvSW5pdHxmbHVpZC5saXR0bGVDb21wb25lbnR8Zmx1aWQubW9kZWxDb21wb25lbnR8Zmx1aWQuZXZlbnRlZENvbXBvbmVudHxmbHVpZC52aWV3Q29tcG9uZW50fGZsdWlkLnR5cGVGb3VudCkkLykudGVzdChncmFkZU5hbWUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZmx1aWQuZHVtcEdyYWRlTmFtZXMgPSBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgICByZXR1cm4gdGhhdC5vcHRpb25zICYmIHRoYXQub3B0aW9ucy5ncmFkZU5hbWVzID9cbiAgICAgICAgICAgIFwiIGdyYWRlTmFtZXM6IFwiICsgSlNPTi5zdHJpbmdpZnkoZmx1aWQuZmlsdGVyQnVpbHRpbkdyYWRlcyh0aGF0Lm9wdGlvbnMuZ3JhZGVOYW1lcykpIDogXCJcIjtcbiAgICB9O1xuXG4gICAgLy8gdW5zdXBwb3J0ZWQsIG5vbi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5kdW1wVGhhdCA9IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICAgIHJldHVybiBcInsgdHlwZU5hbWU6IFxcXCJcIiArIHRoYXQudHlwZU5hbWUgKyBcIlxcXCJcIiArIGZsdWlkLmR1bXBHcmFkZU5hbWVzKHRoYXQpICsgXCIgaWQ6IFwiICsgdGhhdC5pZCArIFwifVwiO1xuICAgIH07XG5cbiAgICAvLyB1bnN1cHBvcnRlZCwgbm9uLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLmR1bXBUaGF0U3RhY2sgPSBmdW5jdGlvbiAodGhhdFN0YWNrLCBpbnN0YW50aWF0b3IpIHtcbiAgICAgICAgdmFyIHRvZ28gPSBmbHVpZC50cmFuc2Zvcm0odGhhdFN0YWNrLCBmdW5jdGlvbih0aGF0KSB7XG4gICAgICAgICAgICB2YXIgcGF0aCA9IGluc3RhbnRpYXRvci5pZFRvUGF0aCh0aGF0LmlkKTtcbiAgICAgICAgICAgIHJldHVybiBmbHVpZC5kdW1wVGhhdCh0aGF0KSArIChwYXRoPyAoXCIgLSBwYXRoOiBcIiArIHBhdGgpIDogXCJcIik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdG9nby5qb2luKFwiXFxuXCIpO1xuICAgIH07XG5cbiAgICAvLyB1bnN1cHBvcnRlZCwgTk9OLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLnJlc29sdmVDb250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQsIHRoYXQpIHtcbiAgICAgICAgdmFyIGluc3RhbnRpYXRvciA9IGZsdWlkLmdldEluc3RhbnRpYXRvcih0aGF0KTtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IFwiaW5zdGFudGlhdG9yXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW50aWF0b3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29udGV4dCA9PT0gXCJ0aGF0XCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGF0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBmb3VuZENvbXBvbmVudDtcbiAgICAgICAgdmFyIHRoYXRTdGFjayA9IGluc3RhbnRpYXRvci5nZXRGdWxsU3RhY2sodGhhdCk7XG4gICAgICAgIHZpc2l0Q29tcG9uZW50cyhpbnN0YW50aWF0b3IsIHRoYXRTdGFjaywgZnVuY3Rpb24gKGNvbXBvbmVudCwgbmFtZSkge1xuICAgICAgICAgICAgdmFyIHNoYWRvdyA9IGZsdWlkLnNoYWRvd0ZvckNvbXBvbmVudChjb21wb25lbnQpO1xuICAgICAgICAgICAgLy8gVE9ETzogU29tZSBjb21wb25lbnRzLCBlLmcuIHRoZSBzdGF0aWMgZW52aXJvbm1lbnQgYW5kIHR5cGVUYWdzIGRvIG5vdCBoYXZlIGEgc2hhZG93LCB3aGljaCBzbG93cyB1cyBkb3duIGhlcmVcbiAgICAgICAgICAgIGlmIChjb250ZXh0ID09PSBuYW1lIHx8IHNoYWRvdyAmJiBzaGFkb3cuY29udGV4dEhhc2ggJiYgc2hhZG93LmNvbnRleHRIYXNoW2NvbnRleHRdIHx8IGNvbnRleHQgPT09IGNvbXBvbmVudC50eXBlTmFtZSB8fCBjb250ZXh0ID09PSBjb21wb25lbnQubmlja05hbWUpIHtcbiAgICAgICAgICAgICAgICBmb3VuZENvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gWU9VUiBWSVNJVCBJUyBBVCBBTiBFTkQhIVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZsdWlkLmdldEZvckNvbXBvbmVudChjb21wb25lbnQsIFtcIm9wdGlvbnNcIiwgXCJjb21wb25lbnRzXCIsIGNvbnRleHQsIFwidHlwZVwiXSkgJiYgIWNvbXBvbmVudFtjb250ZXh0XSkge1xuICAvLyBUaGlzIGlzIGFuIGV4cGVuc2l2ZSBndWVzcyBzaW5jZSB3ZSBtYWtlIGl0IGZvciBldmVyeSBjb21wb25lbnQgdXAgdGhlIHN0YWNrIC0gbXVzdCBhcHBseSB0aGUgV0FWRSBPRiBFWFBMT1NJT05TIChGTFVJRC00OTI1KSB0byBkaXNjb3ZlciBhbGwgY29tcG9uZW50cyBmaXJzdFxuICAvLyBUaGlzIGxpbmUgYXR0ZW1wdHMgYSBob3BlZnVsIGNvbnN0cnVjdGlvbiBvZiBjb21wb25lbnRzIHRoYXQgY291bGQgYmUgZ3Vlc3NlZCBieSBuaWNrbmFtZSB0aHJvdWdoIGZpbmRpbmcgdGhlbSB1bmNvbnN0cnVjdGVkXG4gIC8vIGluIG9wdGlvbnMuIEluIHRoZSBuZWFyIGZ1dHVyZSB3ZSBzaG91bGQgZWFnZXJseSBCRUdJTiB0aGUgcHJvY2VzcyBvZiBjb25zdHJ1Y3RpbmcgY29tcG9uZW50cywgZGlzY292ZXJpbmcgdGhlaXJcbiAgLy8gdHlwZXMgYW5kIHRoZW4gYXR0YWNoaW5nIHRoZW0gdG8gdGhlIHRyZWUgVkVSWSBFQVJMWSBzbyB0aGF0IHdlIGdldCBjb25zaXN0ZW50IHJlc3VsdHMgZnJvbSBkaWZmZXJlbnQgc3RyYXRlZ2llcy5cbiAgICAgICAgICAgICAgICBmb3VuZENvbXBvbmVudCA9IGZsdWlkLmdldEZvckNvbXBvbmVudChjb21wb25lbnQsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZvdW5kQ29tcG9uZW50O1xuICAgIH07XG5cbiAgICB2YXIgbG9jYWxSZWNvcmRFeHBlY3RlZCA9IC9eKGFyZ3VtZW50c3xvcHRpb25zfGNvbnRhaW5lcnxzb3VyY2V8c291cmNlUGF0aHxjaGFuZ2UpJC87XG5cbiAgICAvLyB1bnN1cHBvcnRlZCwgTk9OLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLm1ha2VTdGFja0ZldGNoZXIgPSBmdW5jdGlvbiAocGFyZW50VGhhdCwgbG9jYWxSZWNvcmQpIHtcbiAgICAgICAgdmFyIGZldGNoZXIgPSBmdW5jdGlvbiAocGFyc2VkKSB7XG4gICAgICAgICAgICBpZiAocGFyZW50VGhhdCAmJiBwYXJlbnRUaGF0LmRlc3Ryb3kgPT09IGZsdWlkLmRlc3Ryb3llZE1hcmtlcikge1xuICAgICAgICAgICAgICAgIGZsdWlkLmZhaWwoXCJDYW5ub3QgcmVzb2x2ZSByZWZlcmVuY2UgXCIgKyBmbHVpZC5yZW5kZXJDb250ZXh0UmVmZXJlbmNlKHBhcnNlZCkgKyBcIiBmcm9tIGNvbXBvbmVudCBcIiArIGZsdWlkLmR1bXBUaGF0KHBhcmVudFRoYXQpICsgXCIgd2hpY2ggaGFzIGJlZW4gZGVzdHJveWVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBwYXJzZWQuY29udGV4dDtcbiAgICAgICAgICAgIGlmIChsb2NhbFJlY29yZCAmJiBsb2NhbFJlY29yZEV4cGVjdGVkLnRlc3QoY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmV0Y2hlZCA9IGZsdWlkLmdldChsb2NhbFJlY29yZFtjb250ZXh0XSwgcGFyc2VkLnBhdGgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0ID09PSBcImFyZ3VtZW50c1wiIHx8IGNvbnRleHQgPT09IFwic291cmNlXCIgfHwgY29udGV4dCA9PT0gXCJzb3VyY2VQYXRoXCIgfHwgY29udGV4dCA9PT0gXCJjaGFuZ2VcIiA/IGZldGNoZWQgOiB7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtlcjogY29udGV4dCA9PT0gXCJvcHRpb25zXCIgPyBmbHVpZC5FWFBBTkQgOiBmbHVpZC5FWFBBTkRfTk9XLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZmV0Y2hlZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZm91bmRDb21wb25lbnQgPSBmbHVpZC5yZXNvbHZlQ29udGV4dChjb250ZXh0LCBwYXJlbnRUaGF0KTtcbiAgICAgICAgICAgIGlmICghZm91bmRDb21wb25lbnQgJiYgcGFyc2VkLnBhdGggIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVmID0gZmx1aWQucmVuZGVyQ29udGV4dFJlZmVyZW5jZShwYXJzZWQpO1xuICAgICAgICAgICAgICAgIGZsdWlkLmZhaWwoXCJGYWlsZWQgdG8gcmVzb2x2ZSByZWZlcmVuY2UgXCIgKyByZWYgKyBcIiAtIGNvdWxkIG5vdCBtYXRjaCBjb250ZXh0IHdpdGggbmFtZSBcIiArXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQgKyBcIiBmcm9tIGNvbXBvbmVudCBcIiArIGZsdWlkLmR1bXBUaGF0KHBhcmVudFRoYXQpLCBwYXJlbnRUaGF0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmbHVpZC5nZXRGb3JDb21wb25lbnQoZm91bmRDb21wb25lbnQsIHBhcnNlZC5wYXRoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZldGNoZXI7XG4gICAgfTtcblxuICAgIC8vIHVuc3VwcG9ydGVkLCBOT04tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQubWFrZVN0YWNrUmVzb2x2ZXJPcHRpb25zID0gZnVuY3Rpb24gKHBhcmVudFRoYXQsIGxvY2FsUmVjb3JkKSB7XG4gICAgICAgIHJldHVybiAkLmV4dGVuZChmbHVpZC5jb3B5KGZsdWlkLnJhd0RlZmF1bHRzKFwiZmx1aWQubWFrZUV4cGFuZE9wdGlvbnNcIikpLCB7XG4gICAgICAgICAgICBmZXRjaGVyOiBmbHVpZC5tYWtlU3RhY2tGZXRjaGVyKHBhcmVudFRoYXQsIGxvY2FsUmVjb3JkKSxcbiAgICAgICAgICAgIGNvbnRleHRUaGF0OiBwYXJlbnRUaGF0XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyB1bnN1cHBvcnRlZCwgbm9uLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLmNsZWFyTGlzdGVuZXJzID0gZnVuY3Rpb24gKHNoYWRvdykge1xuICAgICAgICAvLyBUT0RPOiBidWcgaGVyZSAtIFwiYWZ0ZXJEZXN0cm95XCIgbGlzdGVuZXJzIHdpbGwgYmUgdW5yZWdpc3RlcmVkIGFscmVhZHkgdW5sZXNzIHRoZXkgY29tZSBmcm9tIHRoaXMgY29tcG9uZW50XG4gICAgICAgIGZsdWlkLmVhY2goc2hhZG93Lmxpc3RlbmVycywgZnVuY3Rpb24gKHJlYykge1xuICAgICAgICAgICAgcmVjLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHJlYy5saXN0ZW5lcik7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWxldGUgc2hhZG93Lmxpc3RlbmVycztcbiAgICB9O1xuXG4gICAgLy8gdW5zdXBwb3J0ZWQsIG5vbi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5yZWNvcmRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCwgbGlzdGVuZXIsIHNoYWRvdykge1xuICAgICAgICBpZiAoZXZlbnQub3duZXJJZCAhPT0gc2hhZG93LnRoYXQuaWQpIHsgLy8gZG9uJ3QgYm90aGVyIHJlY29yZGluZyBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmcm9tIHRoaXMgY29tcG9uZW50IGl0c2VsZlxuICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IHNoYWRvdy5saXN0ZW5lcnM7XG4gICAgICAgICAgICBpZiAoIWxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVycyA9IHNoYWRvdy5saXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpc3RlbmVycy5wdXNoKHtldmVudDogZXZlbnQsIGxpc3RlbmVyOiBsaXN0ZW5lcn0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBpZFRvSW5zdGFudGlhdG9yID0ge307XG5cbiAgICAvLyB1bnN1cHBvcnRlZCwgbm9uLUFQSSBmdW5jdGlvbiAtIGhvd2V2ZXIsIHRoaXMgc3RydWN0dXJlIGlzIG9mIGNvbnNpZGVyYWJsZSBpbnRlcmVzdCB0byB0aG9zZSBkZWJ1Z2dpbmdcbiAgICAvLyBpbnRvIElvQyBpc3N1ZXMuIFRoZSBzdHJ1Y3R1cmVzIGlkVG9TaGFkb3cgYW5kIHBhdGhUb0NvbXBvbmVudCBjb250YWluIGEgY29tcGxldGUgbWFwIG9mIHRoZSBjb21wb25lbnQgdHJlZVxuICAgIC8vIGZvcm1pbmcgdGhlIHN1cnJvdW5kaW5nIHNjb3BlXG4gICAgZmx1aWQuaW5zdGFudGlhdG9yID0gZnVuY3Rpb24gKGZyZWVJbnN0YW50aWF0b3IpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB7XG4gICAgICAgICAgICBpZDogZmx1aWQuYWxsb2NhdGVHdWlkKCksXG4gICAgICAgICAgICBmcmVlOiBmcmVlSW5zdGFudGlhdG9yLFxuICAgICAgICAgICAgbmlja05hbWU6IFwiaW5zdGFudGlhdG9yXCIsXG4gICAgICAgICAgICBwYXRoVG9Db21wb25lbnQ6IHt9LFxuICAgICAgICAgICAgaWRUb1NoYWRvdzoge30sXG4gICAgICAgICAgICBtb2RlbFRyYW5zYWN0aW9uczoge2luaXQ6IHt9fSwgLy8gYSBtYXAgb2YgdHJhbnNhY3Rpb24gaWQgdG8gbWFwIG9mIGNvbXBvbmVudCBpZCB0byByZWNvcmRzIG9mIGNvbXBvbmVudHMgZW5saXN0ZWQgaW4gYSBjdXJyZW50IG1vZGVsIGluaXRpYWxpc2F0aW9uIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICBjb21wb3NlUGF0aDogZmx1aWQuY29tcG9zZVBhdGggLy8gRm9yIHNwZWVkLCB3ZSBkZWNsYXJlIHRoYXQgbm8gY29tcG9uZW50J3MgbmFtZSBtYXkgY29udGFpbiBhIHBlcmlvZFxuICAgICAgICB9O1xuICAgICAgICAvLyBXZSBmcmVxdWVudGx5IGdldCByZXF1ZXN0cyBmb3IgY29tcG9uZW50cyBub3QgaW4gdGhpcyBpbnN0YW50aWF0b3IgLSBlLmcuIGZyb20gdGhlIGR5bmFtaWNFbnZpcm9ubWVudCBvciBtYW51YWxseSBjcmVhdGVkIG9uZXNcbiAgICAgICAgdGhhdC5pZFRvUGF0aCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgdmFyIHNoYWRvdyA9IHRoYXQuaWRUb1NoYWRvd1tpZF07XG4gICAgICAgICAgICByZXR1cm4gc2hhZG93ID8gc2hhZG93LnBhdGggOiBcIlwiO1xuICAgICAgICB9O1xuICAgICAgICB0aGF0LmdldFRoYXRTdGFjayA9IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgIHZhciBzaGFkb3cgPSB0aGF0LmlkVG9TaGFkb3dbY29tcG9uZW50LmlkXTtcbiAgICAgICAgICAgIGlmIChzaGFkb3cpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGF0aCA9IHNoYWRvdy5wYXRoO1xuICAgICAgICAgICAgICAgIHZhciBwYXJzZWQgPSBmbHVpZC5tb2RlbC5wYXJzZUVMKHBhdGgpO1xuICAgICAgICAgICAgICAgIHZhciB0b2dvID0gZmx1aWQudHJhbnNmb3JtKHBhcnNlZCwgZnVuY3Rpb24gKHZhbHVlLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRQYXRoID0gZmx1aWQubW9kZWwuY29tcG9zZVNlZ21lbnRzLmFwcGx5KG51bGwsIHBhcnNlZC5zbGljZSgwLCBpICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC5wYXRoVG9Db21wb25lbnRbcGFyZW50UGF0aF07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIHJvb3QgPSB0aGF0LnBhdGhUb0NvbXBvbmVudFtcIlwiXTtcbiAgICAgICAgICAgICAgICBpZiAocm9vdCkge1xuICAgICAgICAgICAgICAgICAgICB0b2dvLnVuc2hpZnQocm9vdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0b2dvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7IHJldHVybiBbY29tcG9uZW50XTt9XG4gICAgICAgIH07XG4gICAgICAgIHRoYXQuZ2V0RW52aXJvbm1lbnRhbFN0YWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRvZ28gPSBbZmx1aWQuc3RhdGljRW52aXJvbm1lbnRdO1xuICAgICAgICAgICAgaWYgKCFmcmVlSW5zdGFudGlhdG9yKSB7XG4gICAgICAgICAgICAgICAgdG9nby5wdXNoKGZsdWlkLmdsb2JhbFRocmVhZExvY2FsKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRvZ287XG4gICAgICAgIH07XG4gICAgICAgIHRoYXQuZ2V0RnVsbFN0YWNrID0gZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgdmFyIHRoYXRTdGFjayA9IGNvbXBvbmVudD8gdGhhdC5nZXRUaGF0U3RhY2soY29tcG9uZW50KSA6IFtdO1xuICAgICAgICAgICAgcmV0dXJuIHRoYXQuZ2V0RW52aXJvbm1lbnRhbFN0YWNrKCkuY29uY2F0KHRoYXRTdGFjayk7XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIHJlY29yZENvbXBvbmVudChjb21wb25lbnQsIHBhdGgsIGNyZWF0ZWQpIHtcbiAgICAgICAgICAgIGlmIChjcmVhdGVkKSB7XG4gICAgICAgICAgICAgICAgaWRUb0luc3RhbnRpYXRvcltjb21wb25lbnQuaWRdID0gdGhhdDtcbiAgICAgICAgICAgICAgICB2YXIgc2hhZG93ID0gdGhhdC5pZFRvU2hhZG93W2NvbXBvbmVudC5pZF0gPSB7fTtcbiAgICAgICAgICAgICAgICBzaGFkb3cudGhhdCA9IGNvbXBvbmVudDtcbiAgICAgICAgICAgICAgICBzaGFkb3cucGF0aCA9IHBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhhdC5wYXRoVG9Db21wb25lbnRbcGF0aF0pIHtcbiAgICAgICAgICAgICAgICBmbHVpZC5mYWlsKFwiRXJyb3IgZHVyaW5nIGluc3RhbnRpYXRpb24gLSBwYXRoIFwiICsgcGF0aCArIFwiIHdoaWNoIGhhcyBqdXN0IGNyZWF0ZWQgY29tcG9uZW50IFwiICsgZmx1aWQuZHVtcFRoYXQoY29tcG9uZW50KSArXG4gICAgICAgICAgICAgICAgICAgIFwiIGhhcyBhbHJlYWR5IGJlZW4gdXNlZCBmb3IgY29tcG9uZW50IFwiICsgZmx1aWQuZHVtcFRoYXQodGhhdC5wYXRoVG9Db21wb25lbnRbcGF0aF0pICsgXCIgLSB0aGlzIGlzIGEgY2lyY3VsYXIgaW5zdGFudGlhdGlvbiBvciBvdGhlciBvdmVyc2lnaHQuXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIiBQbGVhc2UgY2xlYXIgdGhlIGNvbXBvbmVudCB1c2luZyBpbnN0YW50aWF0b3IuY2xlYXJDb21wb25lbnQoKSBiZWZvcmUgcmV1c2luZyB0aGUgcGF0aC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGF0LnBhdGhUb0NvbXBvbmVudFtwYXRoXSA9IGNvbXBvbmVudDtcbiAgICAgICAgfVxuICAgICAgICB0aGF0LnJlY29yZFJvb3QgPSBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50ICYmIGNvbXBvbmVudC5pZCAmJiAhdGhhdC5wYXRoVG9Db21wb25lbnRbXCJcIl0pIHtcbiAgICAgICAgICAgICAgICByZWNvcmRDb21wb25lbnQoY29tcG9uZW50LCBcIlwiLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhhdC5yZWNvcmRLbm93bkNvbXBvbmVudCA9IGZ1bmN0aW9uIChwYXJlbnQsIGNvbXBvbmVudCwgbmFtZSwgY3JlYXRlZCkge1xuICAgICAgICAgICAgdmFyIHBhcmVudFBhdGggPSB0aGF0LmlkVG9TaGFkb3dbcGFyZW50LmlkXS5wYXRoO1xuICAgICAgICAgICAgdmFyIHBhdGggPSB0aGF0LmNvbXBvc2VQYXRoKHBhcmVudFBhdGgsIG5hbWUpO1xuICAgICAgICAgICAgcmVjb3JkQ29tcG9uZW50KGNvbXBvbmVudCwgcGF0aCwgY3JlYXRlZCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoYXQuY2xlYXJDb21wb25lbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50LCBuYW1lLCBjaGlsZCwgb3B0aW9ucywgbm9Nb2RUcmVlLCBwYXRoKSB7XG4gICAgICAgICAgICB2YXIgcmVjb3JkID0gdGhhdC5pZFRvU2hhZG93W2NvbXBvbmVudC5pZF0ucGF0aDtcbiAgICAgICAgICAgIC8vIHVzZSBmbGF0IHJlY3Vyc2lvbiBzaW5jZSB3ZSB3YW50IHRvIHVzZSBvdXIgb3duIHJlY3Vyc2lvbiByYXRoZXIgdGhhbiByZWx5IG9uIFwidmlzaXRlZFwiIHJlY29yZHNcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHtmbGF0OiB0cnVlLCBpbnN0YW50aWF0b3I6IHRoYXR9O1xuICAgICAgICAgICAgY2hpbGQgPSBjaGlsZCB8fCBjb21wb25lbnRbbmFtZV07XG4gICAgICAgICAgICBwYXRoID0gcGF0aCB8fCByZWNvcmQ7XG4gICAgICAgICAgICBpZiAocGF0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZmx1aWQuZmFpbChcIkNhbm5vdCBjbGVhciBjb21wb25lbnQgXCIgKyBuYW1lICsgXCIgZnJvbSBjb21wb25lbnQgXCIsIGNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICAgICAgXCIgd2hpY2ggd2FzIG5vdCBjcmVhdGVkIGJ5IHRoaXMgaW5zdGFudGlhdG9yXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmx1aWQuZmlyZUV2ZW50KGNoaWxkLCBcImV2ZW50cy5vbkNsZWFyXCIsIFtjaGlsZCwgbmFtZSwgY29tcG9uZW50XSk7XG5cbiAgICAgICAgICAgIHZhciBjaGlsZFBhdGggPSB0aGF0LmNvbXBvc2VQYXRoKHBhdGgsIG5hbWUpO1xuICAgICAgICAgICAgdmFyIGNoaWxkUmVjb3JkID0gdGhhdC5pZFRvU2hhZG93W2NoaWxkLmlkXTtcblxuICAgICAgICAgICAgLy8gb25seSByZWN1cnNlIG9uIGNvbXBvbmVudHMgd2hpY2ggd2VyZSBjcmVhdGVkIGluIHBsYWNlIC0gaWYgdGhlIGlkIHJlY29yZCBkaXNhZ3JlZXMgd2l0aCB0aGVcbiAgICAgICAgICAgIC8vIHJlY3Vyc2UgcGF0aCwgaXQgbXVzdCBoYXZlIGJlZW4gaW5qZWN0ZWRcbiAgICAgICAgICAgIGlmIChjaGlsZFJlY29yZCAmJiBjaGlsZFJlY29yZC5wYXRoID09PSBjaGlsZFBhdGgpIHtcbiAgICAgICAgICAgICAgICBmbHVpZC5kb0Rlc3Ryb3koY2hpbGQsIG5hbWUsIGNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogVGhlcmUgbmVlZHMgdG8gYmUgYSBjYWxsIHRvIGZsdWlkLmNsZWFyRGlzdHJpYnV0aW9ucyBoZXJlXG4gICAgICAgICAgICAgICAgZmx1aWQuY2xlYXJMaXN0ZW5lcnMoY2hpbGRSZWNvcmQpO1xuICAgICAgICAgICAgICAgIGZsdWlkLnZpc2l0Q29tcG9uZW50Q2hpbGRyZW4oY2hpbGQsIGZ1bmN0aW9uKGdjaGlsZCwgZ2NoaWxkbmFtZSwgbmV3UGF0aCwgcGFyZW50UGF0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGF0LmNsZWFyQ29tcG9uZW50KGNoaWxkLCBnY2hpbGRuYW1lLCBudWxsLCBvcHRpb25zLCB0cnVlLCBwYXJlbnRQYXRoKTtcbiAgICAgICAgICAgICAgICB9LCBvcHRpb25zLCBjaGlsZFBhdGgpO1xuICAgICAgICAgICAgICAgIGZsdWlkLmZpcmVFdmVudChjaGlsZCwgXCJldmVudHMuYWZ0ZXJEZXN0cm95XCIsIFtjaGlsZCwgbmFtZSwgY29tcG9uZW50XSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoYXQuaWRUb1NoYWRvd1tjaGlsZC5pZF07XG4gICAgICAgICAgICAgICAgZGVsZXRlIGlkVG9JbnN0YW50aWF0b3JbY2hpbGQuaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIHRoYXQucGF0aFRvQ29tcG9uZW50W2NoaWxkUGF0aF07IC8vIHRoZXJlIG1heSBiZSBubyBlbnRyeSAtIGlmIGNyZWF0ZWQgaW5mb3JtYWxseVxuICAgICAgICAgICAgaWYgKCFub01vZFRyZWUpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgY29tcG9uZW50W25hbWVdOyAvLyB0aGVyZSBtYXkgYmUgbm8gZW50cnkgLSBpZiBjcmVhdGlvbiBpcyBub3QgY29uY2x1ZGVkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgIH07XG5cbiAgICAvLyBBbiBpbnN0YW50aWF0b3IgdG8gYmUgdXNlZCBpbiB0aGUgXCJmcmVlIGVudmlyb25tZW50XCIsIHVuYXR0YWNoZWQgdG8gYW55IGNvbXBvbmVudCB0cmVlXG4gICAgZmx1aWQuZnJlZUluc3RhbnRpYXRvciA9IGZsdWlkLmluc3RhbnRpYXRvcih0cnVlKTtcblxuICAgIC8vIExvb2sgdXAgdGhlIGdsb2JhbGx5IHJlZ2lzdGVyZWQgaW5zdGFudGlhdG9yIGZvciBhIHBhcnRpY3VsYXIgY29tcG9uZW50XG4gICAgZmx1aWQuZ2V0SW5zdGFudGlhdG9yID0gZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICByZXR1cm4gY29tcG9uZW50ICYmIGlkVG9JbnN0YW50aWF0b3JbY29tcG9uZW50LmlkXSB8fCBmbHVpZC5mcmVlSW5zdGFudGlhdG9yO1xuICAgIH07XG5cbiAgICAvKiogRXhwYW5kIGEgc2V0IG9mIGNvbXBvbmVudCBvcHRpb25zIGVpdGhlciBpbW1lZGlhdGVseSwgb3Igd2l0aCBkZWZlcnJlZCBlZmZlY3QuXG4gICAgICogIFRoZSBjdXJyZW50IHBvbGljeSBpcyB0byBleHBhbmQgaW1tZWRpYXRlbHkgZnVuY3Rpb24gYXJndW1lbnRzIHdpdGhpbiBmbHVpZC5lbWJvZHlEZW1hbmRzIHdoaWNoIGFyZSBub3QgdGhlIG1haW4gb3B0aW9ucyBvZiBhXG4gICAgICogIGNvbXBvbmVudC4gVGhlIGNvbXBvbmVudCdzIG93biBvcHRpb25zIHRha2UgPGNvZGU+e2RlZmVyOiB0cnVlfTwvY29kZT4gYXMgcGFydCBvZlxuICAgICAqICA8Y29kZT5vdXRlckV4cGFuZE9wdGlvbnM8L2NvZGU+IHdoaWNoIHByb2R1Y2VzIGFuIFwiZXhwYW5kT3B0aW9uc1wiIHN0cnVjdHVyZSBob2xkaW5nIHRoZSBcInN0cmF0ZWd5XCIgYW5kIFwiaW5pdHRlclwiIHBhdHRlcm5cbiAgICAgKiAgY29tbW9uIHRvIGdpbmdlciBwYXJ0aWNpcGFudHMuXG4gICAgICogIFByb2JhYmx5IG5vdCB0byBiZSBhZHZlcnRpc2VkIGFzIHBhcnQgb2YgYSBwdWJsaWMgQVBJLCBidXQgaXMgY29uc2lkZXJhYmx5IG1vcmUgc3RhYmxlIHRoYW4gbW9zdCBvZiB0aGUgcmVzdFxuICAgICAqICBvZiB0aGUgSW9DIEFQSSBzdHJ1Y3R1cmUgZXNwZWNpYWxseSB3aXRoIHJlc3BlY3QgdG8gdGhlIGZpcnN0IGFyZ3VtZW50cy5cbiAgICAgKi9cblxuICAgIGZsdWlkLmV4cGFuZE9wdGlvbnMgPSBmdW5jdGlvbiAoYXJncywgdGhhdCwgbWVyZ2VQb2xpY3ksIGxvY2FsUmVjb3JkLCBvdXRlckV4cGFuZE9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFhcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJncztcbiAgICAgICAgfVxuICAgICAgICBmbHVpZC5wdXNoQWN0aXZpdHkoXCJleHBhbmRPcHRpb25zXCIsIFwiZXhwYW5kaW5nIG9wdGlvbnMgJWFyZ3MgZm9yIGNvbXBvbmVudCAldGhhdCBcIiwge3RoYXQ6IHRoYXQsIGFyZ3M6IGFyZ3N9KTtcbiAgICAgICAgdmFyIGV4cGFuZE9wdGlvbnMgPSBmbHVpZC5tYWtlU3RhY2tSZXNvbHZlck9wdGlvbnModGhhdCwgbG9jYWxSZWNvcmQpO1xuICAgICAgICBleHBhbmRPcHRpb25zLm1lcmdlUG9saWN5ID0gbWVyZ2VQb2xpY3k7XG4gICAgICAgIGV4cGFuZE9wdGlvbnMuZnJlZVJvb3QgPSBvdXRlckV4cGFuZE9wdGlvbnMgJiYgb3V0ZXJFeHBhbmRPcHRpb25zLmZyZWVSb290O1xuICAgICAgICB2YXIgZXhwYW5kZWQgPSBvdXRlckV4cGFuZE9wdGlvbnMgJiYgb3V0ZXJFeHBhbmRPcHRpb25zLmRlZmVyID9cbiAgICAgICAgICAgIGZsdWlkLm1ha2VFeHBhbmRPcHRpb25zKGFyZ3MsIGV4cGFuZE9wdGlvbnMpIDogZmx1aWQuZXhwYW5kKGFyZ3MsIGV4cGFuZE9wdGlvbnMpO1xuICAgICAgICBmbHVpZC5wb3BBY3Rpdml0eSgpO1xuICAgICAgICByZXR1cm4gZXhwYW5kZWQ7XG4gICAgfTtcblxuICAgIC8vIHVuc3VwcG9ydGVkLCBub24tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQubG9jYWxSZWNvcmRFeHBlY3RlZCA9IFtcInR5cGVcIiwgXCJvcHRpb25zXCIsIFwiYXJnc1wiLCBcIm1lcmdlT3B0aW9uc1wiLCBcImNyZWF0ZU9uRXZlbnRcIiwgXCJwcmlvcml0eVwiLCBcInJlY29yZFR5cGVcIl07IC8vIGxhc3QgZWxlbWVudCB1bmF2b2lkYWJseSBwb2xsdXRpbmdcbiAgICAvLyB1bnN1cHBvcnRlZCwgbm9uLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLmNoZWNrQ29tcG9uZW50UmVjb3JkID0gZnVuY3Rpb24gKGRlZmF1bHRzLCBsb2NhbFJlY29yZCkge1xuICAgICAgICB2YXIgZXhwZWN0ZWQgPSBmbHVpZC5hcnJheVRvSGFzaChmbHVpZC5sb2NhbFJlY29yZEV4cGVjdGVkKTtcbiAgICAgICAgZmx1aWQuZWFjaChkZWZhdWx0cyAmJiBkZWZhdWx0cy5hcmd1bWVudE1hcCwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgICAgZXhwZWN0ZWRba2V5XSA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICBmbHVpZC5lYWNoKGxvY2FsUmVjb3JkLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgICAgaWYgKCFleHBlY3RlZFtrZXldKSB7XG4gICAgICAgICAgICAgICAgZmx1aWQuZmFpbChcIlByb2JhYmxlIGVycm9yIGluIHN1YmNvbXBvbmVudCByZWNvcmQgLSBrZXkgXFxcIlwiICsga2V5ICtcbiAgICAgICAgICAgICAgICAgICAgXCJcXFwiIGZvdW5kLCB3aGVyZSB0aGUgb25seSBsZWdhbCBvcHRpb25zIGFyZSBcIiArXG4gICAgICAgICAgICAgICAgICAgIGZsdWlkLmtleXMoZXhwZWN0ZWQpLmpvaW4oXCIsIFwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyB1bnN1cHBvcnRlZCwgbm9uLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLnB1c2hEZW1hbmRzID0gZnVuY3Rpb24gKGxpc3QsIGRlbWFuZHMpIHtcbiAgICAgICAgZGVtYW5kcyA9IGZsdWlkLm1ha2VBcnJheShkZW1hbmRzKTtcbiAgICAgICAgdmFyIHRoaXNwID0gZmx1aWQubWVyZ2VSZWNvcmRUeXBlcy5kZW1hbmRzO1xuICAgICAgICBmdW5jdGlvbiBwdXNoKHJlYykge1xuICAgICAgICAgICAgcmVjLnJlY29yZFR5cGUgPSBcImRlbWFuZHNcIjtcbiAgICAgICAgICAgIHJlYy5wcmlvcml0eSA9IHRoaXNwKys7XG4gICAgICAgICAgICBsaXN0LnB1c2gocmVjKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBidWlsZEFuZFB1c2gocmVjKSB7XG4gICAgICAgICAgICBwdXNoKHtvcHRpb25zOiByZWN9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBc3N1bWUgdGhlc2UgYXJlIHNvcnRlZCBhdCBzb3VyY2UgYnkgaW50ZXJzZWN0IGNvdW50IChjYW4ndCBwcmUtbWVyZ2UgaWYgd2Ugd2FudCBcIm1lcmdlT3B0aW9uc1wiKVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlbWFuZHMubGVuZ3RoOyArKyBpKSB7XG4gICAgICAgICAgICB2YXIgdGhpc2QgPSBkZW1hbmRzW2ldO1xuICAgICAgICAgICAgaWYgKHRoaXNkLm9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBwdXNoKHRoaXNkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXNkLm1lcmdlT3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHZhciBtZXJnZU9wdGlvbnMgPSBmbHVpZC5tYWtlQXJyYXkodGhpc2QubWVyZ2VPcHRpb25zKTtcbiAgICAgICAgICAgICAgICBmbHVpZC5lYWNoKG1lcmdlT3B0aW9ucywgYnVpbGRBbmRQdXNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZsdWlkLmZhaWwoXCJVbmludGVycHJldGFibGUgZGVtYW5kcyByZWNvcmQgd2l0aG91dCBvcHRpb25zIG9yIG1lcmdlT3B0aW9ucyBcIiwgdGhpc2QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIHVuc3VwcG9ydGVkLCBub24tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQubWVyZ2VSZWNvcmRzVG9MaXN0ID0gZnVuY3Rpb24gKG1lcmdlUmVjb3Jkcykge1xuICAgICAgICB2YXIgbGlzdCA9IFtdO1xuICAgICAgICBmbHVpZC5lYWNoKG1lcmdlUmVjb3JkcywgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgIHZhbHVlLnJlY29yZFR5cGUgPSBrZXk7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcImRpc3RyaWJ1dGlvbnNcIikge1xuICAgICAgICAgICAgICAgIGxpc3QucHVzaC5hcHBseShsaXN0LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09IFwiZGVtYW5kc1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF2YWx1ZS5vcHRpb25zKSB7IHJldHVybjsgfVxuICAgICAgICAgICAgICAgIHZhbHVlLnByaW9yaXR5ID0gZmx1aWQubWVyZ2VSZWNvcmRUeXBlc1trZXldO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5wcmlvcml0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsdWlkLmZhaWwoXCJNZXJnZSByZWNvcmQgd2l0aCB1bnJlY29nbmlzZWQgdHlwZSBcIiArIGtleSArIFwiOiBcIiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaXN0LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZmx1aWQucHVzaERlbWFuZHMobGlzdCwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfTtcblxuICAgIC8vIFRPRE86IG92ZXJhbGwgZWZmaWNpZW5jeSBjb3VsZCBodWdlIGJlIGltcHJvdmVkIGJ5IHJlc29ydGluZyB0byB0aGUgaGF0ZWQgUFJPVE9UWVBBTElTTSBhcyBhbiBvcHRpbWlzYXRpb25cbiAgICAvLyBmb3IgdGhpcyBtZXJnZVBvbGljeSB3aGljaCBvY2N1cnMgaW4gZXZlcnkgY29tcG9uZW50LiBBbHRob3VnaCBpdCBpcyBhIGRlZXAgc3RydWN0dXJlLCB0aGUgcm9vdCBrZXlzIGFyZSBhbGwgd2UgbmVlZFxuICAgIHZhciBhZGRQb2xpY3lCdWlsdGlucyA9IGZ1bmN0aW9uIChwb2xpY3kpIHtcbiAgICAgICAgZmx1aWQuZWFjaChbXCJncmFkZU5hbWVzXCIsIFwibWVyZ2VQb2xpY3lcIiwgXCJhcmd1bWVudE1hcFwiLCBcImNvbXBvbmVudHNcIiwgXCJkeW5hbWljQ29tcG9uZW50c1wiLCBcIm1lbWJlcnNcIiwgXCJpbnZva2Vyc1wiLCBcImV2ZW50c1wiLCBcImxpc3RlbmVyc1wiLCBcIm1vZGVsTGlzdGVuZXJzXCIsIFwiZGlzdHJpYnV0ZU9wdGlvbnNcIiwgXCJ0cmFuc2Zvcm1PcHRpb25zXCJdLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBmbHVpZC5zZXQocG9saWN5LCBba2V5LCBcIipcIiwgXCJub2V4cGFuZFwiXSwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcG9saWN5O1xuICAgIH07XG5cbiAgICAvLyB1bnN1cHBvcnRlZCwgTk9OLUFQSSBmdW5jdGlvbiAtIHVzZWQgZnJvbSBGbHVpZC5qc1xuICAgIGZsdWlkLmdlbmVyYXRlRXhwYW5kQmxvY2sgPSBmdW5jdGlvbiAocmVjb3JkLCB0aGF0LCBtZXJnZVBvbGljeSwgbG9jYWxSZWNvcmQpIHtcbiAgICAgICAgdmFyIGV4cGFuZGVkID0gZmx1aWQuZXhwYW5kT3B0aW9ucyhyZWNvcmQub3B0aW9ucywgcmVjb3JkLmNvbnRleHRUaGF0IHx8IHRoYXQsIG1lcmdlUG9saWN5LCBsb2NhbFJlY29yZCwge2RlZmVyOiB0cnVlfSk7XG4gICAgICAgIGV4cGFuZGVkLnByaW9yaXR5ID0gcmVjb3JkLnByaW9yaXR5O1xuICAgICAgICBleHBhbmRlZC5yZWNvcmRUeXBlID0gcmVjb3JkLnJlY29yZFR5cGU7XG4gICAgICAgIHJldHVybiBleHBhbmRlZDtcbiAgICB9O1xuXG4gICAgdmFyIGV4cGFuZENvbXBvbmVudE9wdGlvbnNJbXBsID0gZnVuY3Rpb24gKG1lcmdlUG9saWN5LCBkZWZhdWx0cywgdXNlck9wdGlvbnMsIHRoYXQpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRDb3B5ID0gZmx1aWQuY29weShkZWZhdWx0cyk7XG4gICAgICAgIGFkZFBvbGljeUJ1aWx0aW5zKG1lcmdlUG9saWN5KTtcbiAgICAgICAgdmFyIHNoYWRvdyA9IGZsdWlkLnNoYWRvd0ZvckNvbXBvbmVudCh0aGF0KTtcbiAgICAgICAgc2hhZG93Lm1lcmdlUG9saWN5ID0gbWVyZ2VQb2xpY3k7XG4gICAgICAgIHZhciBtZXJnZVJlY29yZHMgPSB7XG4gICAgICAgICAgICBkZWZhdWx0czoge29wdGlvbnM6IGRlZmF1bHRDb3B5fVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh1c2VyT3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKHVzZXJPcHRpb25zLm1hcmtlciA9PT0gZmx1aWQuRVhQQU5EKSB7XG4gICAgICAgICAgICAgICAgJC5leHRlbmQobWVyZ2VSZWNvcmRzLCB1c2VyT3B0aW9ucy5tZXJnZVJlY29yZHMpO1xuICAgICAgICAgICAgICAgIC8vIERvIHRoaXMgaGVyZSBmb3IgZ3JhZGVsZXNzIGNvbXBvbmVudHMgdGhhdCB3ZXJlIGNvcnJlY3RlZCBieSBcImxvY2FsT3B0aW9uc1wiXG4gICAgICAgICAgICAgICAgaWYgKG1lcmdlUmVjb3Jkcy5zdWJjb21wb25lbnRSZWNvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmx1aWQuY2hlY2tDb21wb25lbnRSZWNvcmQoZGVmYXVsdHMsIG1lcmdlUmVjb3Jkcy5zdWJjb21wb25lbnRSZWNvcmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lcmdlUmVjb3Jkcy51c2VyID0ge29wdGlvbnM6IGZsdWlkLmV4cGFuZENvbXBhY3QodXNlck9wdGlvbnMsIHRydWUpfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgZXhwYW5kTGlzdCA9IGZsdWlkLm1lcmdlUmVjb3Jkc1RvTGlzdChtZXJnZVJlY29yZHMpO1xuXG4gICAgICAgIHZhciB0b2dvID0gZmx1aWQudHJhbnNmb3JtKGV4cGFuZExpc3QsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZsdWlkLmdlbmVyYXRlRXhwYW5kQmxvY2sodmFsdWUsIHRoYXQsIG1lcmdlUG9saWN5LCB1c2VyT3B0aW9ucyAmJiB1c2VyT3B0aW9ucy5sb2NhbFJlY29yZCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdG9nbztcbiAgICB9O1xuXG4gICAgLy8gdW5zdXBwb3J0ZWQsIG5vbi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5tYWtlSW9DUm9vdERlc3Ryb3kgPSBmdW5jdGlvbiAoaW5zdGFudGlhdG9yLCB0aGF0KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpbnN0YW50aWF0b3IuY2xlYXJDb21wb25lbnQodGhhdCwgXCJcIiwgdGhhdCwgbnVsbCwgdHJ1ZSk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBcbiAgICAvLyBOT04tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQuZmFicmljYXRlRGVzdHJveU1ldGhvZCA9IGZ1bmN0aW9uICh0aGF0LCBuYW1lLCBpbnN0YW50aWF0b3IsIGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpbnN0YW50aWF0b3IuY2xlYXJDb21wb25lbnQodGhhdCwgbmFtZSwgY2hpbGQpO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvLyB1bnN1cHBvcnRlZCwgbm9uLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLmV4cGFuZENvbXBvbmVudE9wdGlvbnMgPSBmdW5jdGlvbiAobWVyZ2VQb2xpY3ksIGRlZmF1bHRzLCB1c2VyT3B0aW9ucywgdGhhdCkge1xuICAgICAgICB2YXIgaW5zdGFudGlhdG9yID0gdXNlck9wdGlvbnMgJiYgdXNlck9wdGlvbnMubWFya2VyID09PSBmbHVpZC5FWFBBTkQgJiYgdXNlck9wdGlvbnMubWVtYmVyTmFtZSAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgIHVzZXJPcHRpb25zLmluc3RhbnRpYXRvciA6IG51bGw7XG4gICAgICAgIHZhciBmcmVzaDtcbiAgICAgICAgaWYgKCFpbnN0YW50aWF0b3IpIHtcbiAgICAgICAgICAgIGluc3RhbnRpYXRvciA9IGZsdWlkLmluc3RhbnRpYXRvcigpO1xuICAgICAgICAgICAgZnJlc2ggPSB0cnVlO1xuICAgICAgICAgICAgZmx1aWQubG9nKFwiQ3JlYXRlZCBuZXcgaW5zdGFudGlhdG9yIHdpdGggaWQgXCIgKyBpbnN0YW50aWF0b3IuaWQgKyBcIiBpbiBvcmRlciB0byBvcGVyYXRlIG9uIGNvbXBvbmVudCBcIiArICh0aGF0PyB0aGF0LnR5cGVOYW1lIDogXCJbbm9uZV1cIikpO1xuICAgICAgICAgICAgdGhhdC5kZXN0cm95ID0gZmx1aWQubWFrZUlvQ1Jvb3REZXN0cm95KGluc3RhbnRpYXRvciwgdGhhdCk7XG4gICAgICAgIH1cbiAgICAgICAgZmx1aWQucHVzaEFjdGl2aXR5KFwiZXhwYW5kQ29tcG9uZW50T3B0aW9uc1wiLCBcImV4cGFuZGluZyBjb21wb25lbnQgb3B0aW9ucyAlb3B0aW9ucyB3aXRoIHJlY29yZCAlcmVjb3JkIGZvciBjb21wb25lbnQgJXRoYXRcIixcbiAgICAgICAgICAgIHtvcHRpb25zOiB1c2VyT3B0aW9ucyAmJiB1c2VyT3B0aW9ucy5tZXJnZVJlY29yZHMsIHJlY29yZDogdXNlck9wdGlvbnMsIHRoYXQ6IHRoYXR9KTtcbiAgICAgICAgaWYgKGZyZXNoKSB7XG4gICAgICAgICAgICBpbnN0YW50aWF0b3IucmVjb3JkUm9vdCh0aGF0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGluc3RhbnRpYXRvci5yZWNvcmRLbm93bkNvbXBvbmVudCh1c2VyT3B0aW9ucy5wYXJlbnRUaGF0LCB0aGF0LCB1c2VyT3B0aW9ucy5tZW1iZXJOYW1lLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdG9nbyA9IGV4cGFuZENvbXBvbmVudE9wdGlvbnNJbXBsKG1lcmdlUG9saWN5LCBkZWZhdWx0cywgdXNlck9wdGlvbnMsIHRoYXQpO1xuICAgICAgICBmbHVpZC5wb3BBY3Rpdml0eSgpO1xuICAgICAgICByZXR1cm4gdG9nbztcbiAgICB9O1xuXG4gICAgLy8gdW5zdXBwb3J0ZWQsIG5vbi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5hcmdNYXBUb0RlbWFuZHMgPSBmdW5jdGlvbiAoYXJnTWFwKSB7XG4gICAgICAgIHZhciB0b2dvID0gW107XG4gICAgICAgIGZsdWlkLmVhY2goYXJnTWFwLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgICAgdG9nb1t2YWx1ZV0gPSBcIntcIiArIGtleSArIFwifVwiO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRvZ287XG4gICAgfTtcblxuICAgIC8vIHVuc3VwcG9ydGVkLCBub24tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQubWFrZVBhc3NBcmdzU3BlYyA9IGZ1bmN0aW9uIChpbml0QXJncykge1xuICAgICAgICByZXR1cm4gZmx1aWQudHJhbnNmb3JtKGluaXRBcmdzLCBmdW5jdGlvbihhcmcsIGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gXCJ7YXJndW1lbnRzfS5cIiArIGluZGV4O1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gdW5zdXBwb3J0ZWQsIE5PTi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5wdXNoRGVtYW5kU3BlYyA9IGZ1bmN0aW9uIChyZWNvcmQsIG9wdGlvbnMsIG1lcmdlT3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zICE9PSBcIntvcHRpb25zfVwiKSB7XG4gICAgICAgICAgICByZWNvcmQucHVzaCh7b3B0aW9uczogb3B0aW9uc30pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXJnZU9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJlY29yZC5wdXNoKHttZXJnZU9wdGlvbnM6IG1lcmdlT3B0aW9uc30pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKiBHaXZlbiBhIGNvbmNyZXRlIGFyZ3VtZW50IGxpc3QgYW5kL29yIG9wdGlvbnMsIGRldGVybWluZSB0aGUgZmluYWwgY29uY3JldGVcbiAgICAgKiBcImludm9jYXRpb24gc3BlY2lmaWNhdGlvblwiIHdoaWNoIGlzIGNvZGVkIGJ5IHRoZSBzdXBwbGllZCBkZW1hbmRzcGVjIGluIHRoZVxuICAgICAqIGVudmlyb25tZW50IFwidGhhdFN0YWNrXCIgLSB0aGUgcmV0dXJuIGlzIGEgcGFja2FnZSBvZiBjb25jcmV0ZSBnbG9iYWwgZnVuY3Rpb24gbmFtZVxuICAgICAqIGFuZCBhcmd1bWVudCBsaXN0IHdoaWNoIGlzIHN1aXRhYmxlIHRvIGJlIGV4ZWN1dGVkIGRpcmVjdGx5IGJ5IGZsdWlkLmludm9rZUdsb2JhbEZ1bmN0aW9uLlxuICAgICAqL1xuICAgIC8vIHVuc3VwcG9ydGVkLCBub24tQVBJIGZ1bmN0aW9uXG4gICAgLy8gb3B0aW9ucyBpcyBqdXN0IGEgZGlzcG9zaXRpb24gcmVjb3JkIGNvbnRhaW5pbmcgbWVtYmVyTmFtZSwgY29tcG9uZW50UmVjb3JkICsgcGFzc0FyZ3NcbiAgICAvLyB2YXJpb3VzIGJ1aWx0LWluIGVmZmVjdHMgb2YgdGhpcyBtZXRob2RcbiAgICAvLyBpKSBub3RlIHRoYXQgaXQgbWFrZXMgbm8gZWZmb3J0IHRvIGFjdHVhbGx5IHByb3BhZ2F0ZSBkaXJlY3RcbiAgICAvLyBvcHRpb25zIGZyb20gXCJpbml0QXJnc1wiLCBhc3N1bWluZyB0aGF0IHRoZXkgd2lsbCBiZSBzZWVuIGFnYWluIGluIGV4cGFuZENvbXBvbmVudE9wdGlvbnNcbiAgICBmbHVpZC5lbWJvZHlEZW1hbmRzID0gZnVuY3Rpb24gKHBhcmVudFRoYXQsIGRlbWFuZHNwZWMsIGluaXRBcmdzLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIGlmIChkZW1hbmRzcGVjLm1lcmdlT3B0aW9ucyAmJiBkZW1hbmRzcGVjLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIGZsdWlkLmZhaWwoXCJkZW1hbmRzcGVjIFwiLCBkZW1hbmRzcGVjLFxuICAgICAgICAgICAgICAgICAgICBcIiBpcyBpbnZhbGlkIC0gY2Fubm90IHNwZWNpZnkgbGl0ZXJhbCBvcHRpb25zIHRvZ2V0aGVyIHdpdGggbWVyZ2VPcHRpb25zXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZW1hbmRzcGVjLnRyYW5zZm9ybU9wdGlvbnMpIHsgLy8gU3VwcG9ydCBmb3IgXCJ0cmFuc2Zvcm1PcHRpb25zXCIgYXQgdG9wIGxldmVsIGluIGEgZGVtYW5kcyByZWNvcmRcbiAgICAgICAgICAgIGRlbWFuZHNwZWMub3B0aW9ucyA9ICQuZXh0ZW5kKHRydWUsIHt9LCBkZW1hbmRzcGVjLm9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1PcHRpb25zOiBkZW1hbmRzcGVjLnRyYW5zZm9ybU9wdGlvbnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkZW1hbmRzID0gZmx1aWQubWFrZUFycmF5KGRlbWFuZHNwZWMuYXJncyk7XG5cbiAgICAgICAgdmFyIHVwRGVmYXVsdHMgPSBmbHVpZC5kZWZhdWx0cyhkZW1hbmRzcGVjLmZ1bmNOYW1lKTtcblxuICAgICAgICB2YXIgZmFrZVRoYXQgPSB7fTsgLy8gZmFrZSBcInRoYXRcIiBmb3IgcmVjZWl2ZURpc3RyaWJ1dGlvbnMgc2luY2Ugd2UgdHJ5IHRvIG1hdGNoIHNlbGVjdG9ycyBiZWZvcmUgY3JlYXRpb24gZm9yIEZMVUlELTUwMTNcbiAgICAgICAgdmFyIGRpc3RyaWJ1dGlvbnMgPSB1cERlZmF1bHRzICYmIHBhcmVudFRoYXQgPyBmbHVpZC5yZWNlaXZlRGlzdHJpYnV0aW9ucyhwYXJlbnRUaGF0LCB1cERlZmF1bHRzLmdyYWRlTmFtZXMsIG9wdGlvbnMubWVtYmVyTmFtZSwgZmFrZVRoYXQpIDogW107XG5cbiAgICAgICAgdmFyIGFyZ01hcCA9IHVwRGVmYXVsdHM/IHVwRGVmYXVsdHMuYXJndW1lbnRNYXAgOiBudWxsO1xuICAgICAgICB2YXIgaW5mZXJNYXAgPSBmYWxzZTtcbiAgICAgICAgaWYgKHVwRGVmYXVsdHMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucGFzc0FyZ3MgPSBmYWxzZTsgLy8gRG9uJ3QgYXR0ZW1wdCB0byBjb25zdHJ1Y3QgYSBjb21wb25lbnQgdXNpbmcgXCJwYXNzQXJnc1wiIHNwZWNcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFyZ01hcCAmJiAodXBEZWZhdWx0cyB8fCAob3B0aW9ucyAmJiBvcHRpb25zLmNvbXBvbmVudFJlY29yZCkpKSB7XG4gICAgICAgICAgICBpbmZlck1hcCA9IHRydWU7XG4gICAgICAgICAgICAvLyBpbmZlciB0aGF0IGl0IG11c3QgYmUgYSBsaXR0bGUgY29tcG9uZW50IGlmIHdlIGhhdmUgYW55IHJlYXNvbiB0byBiZWxpZXZlIGl0IGlzIGEgY29tcG9uZW50XG4gICAgICAgICAgICBpZiAoZGVtYW5kcy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgYXJnTWFwID0gZmx1aWQucmF3RGVmYXVsdHMoXCJmbHVpZC5saXR0bGVDb21wb25lbnRcIikuYXJndW1lbnRNYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucG9zID0gJC5pbkFycmF5KFwie29wdGlvbnN9XCIsIGRlbWFuZHMpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25wb3MgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnBvcyA9IGRlbWFuZHMubGVuZ3RoIC0gMTsgLy8gd2lsZCBndWVzcyBpbiB0aGUgb2xkIHN0eWxlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFyZ01hcCA9IHtvcHRpb25zOiBvcHRpb25wb3N9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBpZiAoZGVtYW5kcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmIChhcmdNYXApIHtcbiAgICAgICAgICAgICAgICBkZW1hbmRzID0gZmx1aWQuYXJnTWFwVG9EZW1hbmRzKGFyZ01hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLnBhc3NBcmdzKSB7XG4gICAgICAgICAgICAgICAgZGVtYW5kcyA9IGZsdWlkLm1ha2VQYXNzQXJnc1NwZWMoaW5pdEFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBzaGFkb3cgPSBmbHVpZC5zaGFkb3dGb3JDb21wb25lbnQocGFyZW50VGhhdCk7XG4gICAgICAgIHZhciBsb2NhbER5bmFtaWMgPSBzaGFkb3cgJiYgb3B0aW9ucy5tZW1iZXJOYW1lID8gc2hhZG93LnN1YmNvbXBvbmVudExvY2FsW29wdGlvbnMubWVtYmVyTmFtZV0gOiBudWxsO1xuXG4gICAgICAgIC8vIGNvbmZ1c2lvbiByZW1haW5zIHdpdGggXCJsb2NhbFJlY29yZFwiIC0gaXQgaXMgYSByYW5kb20gbWlzaG1hc2ggb2YgdXNlciBhcmd1bWVudHMgYW5kIHRoZSBjb21wb25lbnQgcmVjb3JkXG4gICAgICAgIC8vIHRoaXMgc2hvdWxkIGl0c2VsZiBiZSBhYnNvcmJlZCBpbnRvIFwibWVyZ2VSZWNvcmRzXCIgYW5kIGxldCBzdGFja0ZldGNoZXIgc29ydCBpdCBvdXRcbiAgICAgICAgdmFyIGxvY2FsUmVjb3JkID0gJC5leHRlbmQoe1wiYXJndW1lbnRzXCI6IGluaXRBcmdzfSwgZmx1aWQuY2Vuc29yS2V5cyhvcHRpb25zLmNvbXBvbmVudFJlY29yZCwgW1widHlwZVwiXSksIGxvY2FsRHluYW1pYyk7XG5cbiAgICAgICAgZmx1aWQuZWFjaChhcmdNYXAsIGZ1bmN0aW9uIChpbmRleCwgbmFtZSkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBpbmNvcnJlY3QgYW55d2F5ISBXaGF0IGlmIHRoZSBzdXBwbGllZCBhcmd1bWVudHMgd2VyZSBub3QgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlIHRhcmdldCBhcmdtYXAsXG4gICAgICAgICAgICAvLyB3aGljaCB3YXMgb2J0YWluZWQgZnJvbSB0aGUgdGFyZ2V0IGRlZmF1bHRzXG4gICAgICAgICAgICBpZiAoaW5pdEFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGxvY2FsUmVjb3JkW25hbWVdID0gbG9jYWxSZWNvcmRbXCJhcmd1bWVudHNcIl1baW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlbWFuZHNwZWNbbmFtZV0gIT09IHVuZGVmaW5lZCAmJiBsb2NhbFJlY29yZFtuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxSZWNvcmRbbmFtZV0gPSBkZW1hbmRzcGVjW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5hbWUgIT09IFwib3B0aW9uc1wiKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXN0cmlidXRpb25zLmxlbmd0aDsgKysgaSkgeyAvLyBBcHBseSBub24tb3B0aW9ucyBtYXRlcmlhbCBmcm9tIGRpc3RyaWJ1dGlvbnMgKEZMVUlELTUwMTMpXG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXN0cmlidXRpb25zW2ldW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsUmVjb3JkW25hbWVdID0gZGlzdHJpYnV0aW9uc1tpXVtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGlzdHJpYnV0aW9ucy5sZW5ndGg7ICsrIGkpIHtcbiAgICAgICAgICAgIGlmIChkaXN0cmlidXRpb25zW2ldLnR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGRlbWFuZHNwZWMuZnVuY05hbWUgPSBkaXN0cmlidXRpb25zW2ldLnR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWVyZ2VSZWNvcmRzID0ge2Rpc3RyaWJ1dGlvbnM6IGRpc3RyaWJ1dGlvbnN9O1xuXG4gICAgICAgIGlmIChvcHRpb25zLmNvbXBvbmVudFJlY29yZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBEZWxpYmVyYXRlbHkgcHV0IHRvbyBtYW55IHRoaW5ncyBoZXJlIHNvIHRoZXkgY2FuIGJlIGNoZWNrZWQgaW4gZXhwYW5kQ29tcG9uZW50T3B0aW9ucyAoRkxVSUQtNDI4NSlcbiAgICAgICAgICAgIG1lcmdlUmVjb3Jkcy5zdWJjb21wb25lbnRSZWNvcmQgPSAkLmV4dGVuZCh7fSwgb3B0aW9ucy5jb21wb25lbnRSZWNvcmQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBleHBhbmRPcHRpb25zID0gZmx1aWQubWFrZVN0YWNrUmVzb2x2ZXJPcHRpb25zKHBhcmVudFRoYXQsIGxvY2FsUmVjb3JkKTtcbiAgICAgICAgdmFyIHB1c2hCYWNrU3BlYyA9IGZ1bmN0aW9uIChiYWNrU3BlYykge1xuICAgICAgICAgICAgZmx1aWQucHVzaERlbWFuZFNwZWMobWVyZ2VSZWNvcmRzLmRlbWFuZHMsIGJhY2tTcGVjLm9wdGlvbnMsIGJhY2tTcGVjLm1lcmdlT3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGlmIChkZW1hbmRzKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGVtYW5kcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBhcmcgPSBkZW1hbmRzW2ldO1xuICAgICAgICAgICAgICAgIC8vIFdlYWsgZGV0ZWN0aW9uIHNpbmNlIHdlIGNhbm5vdCBndWFyYW50ZWUgdGhpcyBtYXRlcmlhbCBoYXMgbm90IGJlZW4gY29waWVkXG4gICAgICAgICAgICAgICAgaWYgKGZsdWlkLmlzTWFya2VyKGFyZykgJiYgYXJnLnZhbHVlID09PSBmbHVpZC5DT01QT05FTlRfT1BUSU9OUy52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBhcmcgPSBcIntvcHRpb25zfVwiO1xuICAgICAgICAgICAgICAgICAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBmb3Igbm9uLXVzZXJzIG9mIEdSQURFUyAtIGxhc3QtZGl0Y2ggY2hhbmNlIHRvIGNvcnJlY3QgdGhlIGluZmVyZW5jZVxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5mZXJNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ01hcCA9IHtvcHRpb25zOiBpfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mKGFyZykgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZy5jaGFyQXQoMCkgPT09IFwiQFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJncG9zID0gYXJnLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IFwie2FyZ3VtZW50c30uXCIgKyBhcmdwb3M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVtYW5kc1tpXSA9IGFyZztcbiAgICAgICAgICAgICAgICBpZiAoIWFyZ01hcCB8fCBhcmdNYXAub3B0aW9ucyAhPT0gaSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBleHBhbmQgaW1tZWRpYXRlbHkgaWYgdGhlcmUgY2FuIGJlIG5vIG9wdGlvbnMgb3IgdGhpcyBpcyBub3QgdGhlIG9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tpXSA9IGZsdWlkLmV4cGFuZChhcmcsIGV4cGFuZE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHsgLy8gSXQgaXMgdGhlIGNvbXBvbmVudCBvcHRpb25zXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnBhc3NBcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbHVpZC5mYWlsKFwiRXJyb3IgaW52b2tpbmcgZnVuY3Rpb24gXCIgKyBkZW1hbmRzcGVjLmZ1bmNOYW1lICsgXCI6IGZvdW5kIGNvbXBvbmVudCBjcmVhdG9yIHJhdGhlciB0aGFuIGZyZWUgZnVuY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZihhcmcpID09PSBcIm9iamVjdFwiICYmICFhcmcudGFyZ2V0VHlwZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZy50YXJnZXRUeXBlTmFtZSA9IGRlbWFuZHNwZWMuZnVuY05hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VSZWNvcmRzLmRlbWFuZHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZmx1aWQuZWFjaCgoZGVtYW5kc3BlYy5iYWNrU3BlY3MpLnJldmVyc2UoKSwgcHVzaEJhY2tTcGVjKTtcbiAgICAgICAgICAgICAgICAgICAgZmx1aWQucHVzaERlbWFuZFNwZWMobWVyZ2VSZWNvcmRzLmRlbWFuZHMsIGRlbWFuZHNwZWMub3B0aW9ucyB8fCBhcmcsIGRlbWFuZHNwZWMubWVyZ2VPcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluaXRBcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlUmVjb3Jkcy51c2VyID0ge29wdGlvbnM6IGxvY2FsUmVjb3JkLm9wdGlvbnN9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbaV0gPSB7bWFya2VyOiBmbHVpZC5FWFBBTkQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxSZWNvcmQ6IGxvY2FsRHluYW1pYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXJnZVJlY29yZHM6IG1lcmdlUmVjb3JkcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW50aWF0b3I6IGZsdWlkLmdldEluc3RhbnRpYXRvcihwYXJlbnRUaGF0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRUaGF0OiBwYXJlbnRUaGF0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lbWJlck5hbWU6IG9wdGlvbnMubWVtYmVyTmFtZX07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhcmdzW2ldICYmIGZsdWlkLmlzTWFya2VyKGFyZ3NbaV0ubWFya2VyLCBmbHVpZC5FWFBBTkRfTk9XKSkge1xuICAgICAgICAgICAgICAgICAgICBhcmdzW2ldID0gZmx1aWQuZXhwYW5kKGFyZ3NbaV0udmFsdWUsIGV4cGFuZE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFyZ3MgPSBpbml0QXJncz8gaW5pdEFyZ3MgOiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0b2dvID0ge1xuICAgICAgICAgICAgYXJnczogYXJncyxcbiAgICAgICAgICAgIHByZUV4cGFuZDogZGVtYW5kcyxcbiAgICAgICAgICAgIGZ1bmNOYW1lOiBkZW1hbmRzcGVjLmZ1bmNOYW1lXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0b2dvO1xuICAgIH07XG5cbiAgICAvKiogSW5zdGFudGlhdGUgdGhlIHN1YmNvbXBvbmVudCB3aXRoIHRoZSBzdXBwbGllZCBuYW1lIG9mIHRoZSBzdXBwbGllZCB0b3AtbGV2ZWwgY29tcG9uZW50LiBBbHRob3VnaCB0aGlzIG1ldGhvZFxuICAgICAqIGlzIHB1Ymxpc2hlZCBhcyBwYXJ0IG9mIHRoZSBGbHVpZCBBUEksIGl0IHNob3VsZCBub3QgYmUgY2FsbGVkIGJ5IGdlbmVyYWwgdXNlcnMgYW5kIG1heSBub3QgcmVtYWluIHN0YWJsZS4gSXQgaXNcbiAgICAgKiBjdXJyZW50bHkgdGhlIG9ubHkgbWVjaGFuaXNtIHByb3ZpZGVkIGZvciBpbnN0YW50aWF0aW5nIGNvbXBvbmVudHMgd2hvc2UgZGVmaW5pdGlvbnMgYXJlIGR5bmFtaWMsIGFuZCB3aWxsIGJlXG4gICAgICogcmVwbGFjZWQgaW4gdGltZSBieSBkZWRpY2F0ZWQgZGVjbGFyYXRpdmUgZnJhbWV3b3JrIGRlc2NyaWJlZCBieSBGTFVJRC01MDIyLlxuICAgICAqIEBwYXJhbSB0aGF0IHtDb21wb25lbnR9IHRoZSBwYXJlbnQgY29tcG9uZW50IGZvciB3aGljaCB0aGUgc3ViY29tcG9uZW50IGlzIHRvIGJlIGluc3RhbnRpYXRlZFxuICAgICAqIEBwYXJhbSBuYW1lIHtTdHJpbmd9IHRoZSBuYW1lIG9mIHRoZSBjb21wb25lbnQgLSB0aGUgaW5kZXggb2YgdGhlIG9wdGlvbnMgYmxvY2sgd2hpY2ggY29uZmlndXJlcyBpdCBhcyBwYXJ0IG9mIHRoZVxuICAgICAqIDxjb2RlPmNvbXBvbmVudHM8L2NvZGU+IHNlY3Rpb24gb2YgaXRzIHBhcmVudCdzIG9wdGlvbnNcbiAgICAgKi9cbiAgICAgLy8gTkIgXCJkaXJlY3RBcmdzXCIgaXMgbm93IGRpc3VzZWQgYnkgdGhlIGZyYW1ld29ya1xuXG4gICAgZmx1aWQuaW5pdERlcGVuZGVudCA9IGZ1bmN0aW9uICh0aGF0LCBuYW1lLCBkaXJlY3RBcmdzKSB7XG4gICAgICAgIGlmICh0aGF0W25hbWVdKSB7IHJldHVybjsgfSAvLyBUT0RPOiBtb3ZlIHRoaXMgaW50byBzdHJhdGVneVxuICAgICAgICBkaXJlY3RBcmdzID0gZGlyZWN0QXJncyB8fCBbXTtcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoYXQub3B0aW9ucy5jb21wb25lbnRzW25hbWVdO1xuICAgICAgICBmbHVpZC5wdXNoQWN0aXZpdHkoXCJpbml0RGVwZW5kZW50XCIsIFwiaW5zdGFudGlhdGluZyBkZXBlbmRlbnQgY29tcG9uZW50IHdpdGggbmFtZSBcXFwiJW5hbWVcXFwiIHdpdGggcmVjb3JkICVyZWNvcmQgYXMgY2hpbGQgb2YgJXBhcmVudFwiLFxuICAgICAgICAgICAge25hbWU6IG5hbWUsIHJlY29yZDogY29tcG9uZW50LCBwYXJlbnQ6IHRoYXR9KTtcbiAgICAgICAgdmFyIGluc3RhbmNlO1xuICAgICAgICB2YXIgaW5zdGFudGlhdG9yID0gaWRUb0luc3RhbnRpYXRvclt0aGF0LmlkXTtcblxuICAgICAgICBpZiAodHlwZW9mKGNvbXBvbmVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGluc3RhbmNlID0gZmx1aWQuZXhwYW5kT3B0aW9ucyhjb21wb25lbnQsIHRoYXQpO1xuICAgICAgICAgICAgaW5zdGFudGlhdG9yLnJlY29yZEtub3duQ29tcG9uZW50KHRoYXQsIGluc3RhbmNlLCBuYW1lLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29tcG9uZW50LnR5cGUpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gZmx1aWQuZXhwYW5kT3B0aW9ucyhjb21wb25lbnQudHlwZSwgdGhhdCk7XG4gICAgICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgICAgICBmbHVpZC5mYWlsKFwiRXJyb3IgaW4gc3ViY29tcG9uZW50IHJlY29yZDogXCIsIGNvbXBvbmVudC50eXBlLCBcIiBjb3VsZCBub3QgYmUgcmVzb2x2ZWQgdG8gYSB0eXBlIGZvciBjb21wb25lbnQgXCIsIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIFwiIG9mIHBhcmVudCBcIiwgdGhhdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaW52b2tlU3BlYyA9IGZsdWlkLnJlc29sdmVEZW1hbmRzKHRoYXQsIFt0eXBlLCBuYW1lXSwgZGlyZWN0QXJncyxcbiAgICAgICAgICAgICAgICB7Y29tcG9uZW50UmVjb3JkOiBjb21wb25lbnQsIG1lbWJlck5hbWU6IG5hbWV9KTtcbiAgICAgICAgICAgIGluc3RhbmNlID0gZmx1aWQuaW5pdFN1YmNvbXBvbmVudEltcGwodGhhdCwge3R5cGU6IGludm9rZVNwZWMuZnVuY05hbWV9LCBpbnZva2VTcGVjLmFyZ3MpO1xuICAgICAgICAgICAgLy8gVGhlIGV4aXN0aW5nIGluc3RhbnRpYXRvciByZWNvcmQgd2lsbCBiZSBwcm92aXNpb25hbCwgYWRqdXN0IGl0IHRvIHRha2UgYWNjb3VudCBvZiB0aGUgdHJ1ZSByZXR1cm5cbiAgICAgICAgICAgIC8vIFRPRE86IEluc3RhbnRpYXRvciBjb250ZW50cyBhcmUgZ2VuZXJhbGx5IGV4dHJlbWVseSBpbmNvbXBsZXRlXG4gICAgICAgICAgICB2YXIgcGF0aCA9IGluc3RhbnRpYXRvci5jb21wb3NlUGF0aChpbnN0YW50aWF0b3IuaWRUb1BhdGgodGhhdC5pZCksIG5hbWUpO1xuICAgICAgICAgICAgdmFyIGV4aXN0aW5nID0gaW5zdGFudGlhdG9yLnBhdGhUb0NvbXBvbmVudFtwYXRoXTtcbiAgICAgICAgICAgIC8vIFRoaXMgYnJhbmNoIGRlYWxzIHdpdGggdGhlIGNhc2Ugd2hlcmUgdGhlIGNvbXBvbmVudCBjcmVhdG9yIHJlZ2lzdGVyZWQgYSBjb21wb25lbnQgaW50byBcInBhdGhUb0NvbXBvbmVudFwiXG4gICAgICAgICAgICAvLyB0aGF0IGRvZXMgbm90IGFncmVlIHdpdGggdGhlIGNvbXBvbmVudCB3aGljaCB3YXMgdGhlIHJldHVybiB2YWx1ZS4gV2UgbmVlZCB0byBjbGVhciBvdXQgXCJwYXRoVG9Db21wb25lbnRcIiBidXRcbiAgICAgICAgICAgIC8vIG5vdCBzaHJlZCB0aGUgY29tcG9uZW50IHNpbmNlIG1vc3Qgb2YgaXQgaXMgcHJvYmFibHkgc3RpbGwgdmFsaWRcbiAgICAgICAgICAgIGlmIChleGlzdGluZyAmJiBleGlzdGluZyAhPT0gaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBpbnN0YW50aWF0b3IuY2xlYXJDb21wb25lbnQodGhhdCwgbmFtZSwgZXhpc3RpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlLnR5cGVOYW1lICYmIGluc3RhbmNlLmlkICYmIGluc3RhbmNlICE9PSBleGlzdGluZykge1xuICAgICAgICAgICAgICAgIGluc3RhbnRpYXRvci5yZWNvcmRLbm93bkNvbXBvbmVudCh0aGF0LCBpbnN0YW5jZSwgbmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnN0YW5jZS5kZXN0cm95ID0gZmx1aWQuZmFicmljYXRlRGVzdHJveU1ldGhvZCh0aGF0LCBuYW1lLCBpbnN0YW50aWF0b3IsIGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZsdWlkLmZhaWwoXCJVbnJlY29nbmlzZWQgbWF0ZXJpYWwgaW4gcGxhY2Ugb2Ygc3ViY29tcG9uZW50IFwiICsgbmFtZSArIFwiIC0gbm8gXFxcInR5cGVcXFwiIGZpZWxkIGZvdW5kXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoYXRbbmFtZV0gPSBpbnN0YW5jZTtcbiAgICAgICAgZmx1aWQuZmlyZUV2ZW50KGluc3RhbmNlLCBcImV2ZW50cy5vbkF0dGFjaFwiLCBbaW5zdGFuY2UsIG5hbWUsIHRoYXRdKTtcbiAgICAgICAgZmx1aWQucG9wQWN0aXZpdHkoKTtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH07XG5cbiAgICAvLyB1bnN1cHBvcnRlZCwgbm9uLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLmJpbmREZWZlcnJlZENvbXBvbmVudCA9IGZ1bmN0aW9uICh0aGF0LCBjb21wb25lbnROYW1lLCBjb21wb25lbnQpIHtcbiAgICAgICAgdmFyIGV2ZW50cyA9IGZsdWlkLm1ha2VBcnJheShjb21wb25lbnQuY3JlYXRlT25FdmVudCk7XG4gICAgICAgIGZsdWlkLmVhY2goZXZlbnRzLCBmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgICAgICAgICAgIHZhciBldmVudCA9IGV2ZW50TmFtZS5jaGFyQXQoMCkgPT09IFwie1wiID8gZmx1aWQuZXhwYW5kT3B0aW9ucyhldmVudE5hbWUsIHRoYXQpIDogdGhhdC5ldmVudHNbZXZlbnROYW1lXTtcbiAgICAgICAgICAgIGlmICghZXZlbnQgfHwgIWV2ZW50LmFkZExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgZmx1aWQuZmFpbChcIkVycm9yIGluc3RhbnRpYXRpbmcgY3JlYXRlT25FdmVudCBjb21wb25lbnQgd2l0aCBuYW1lIFwiICsgY29tcG9uZW50TmFtZSArIFwiIG9mIHBhcmVudCBcIiwgdGhhdCwgXCIgc2luY2UgZXZlbnQgc3BlY2lmaWNhdGlvbiBcIiArXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50TmFtZSArIFwiIGNvdWxkIG5vdCBiZSBleHBhbmRlZCB0byBhbiBldmVudCAtIGdvdCBcIiwgZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZlbnQuYWRkTGlzdGVuZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZsdWlkLnB1c2hBY3Rpdml0eShcImluaXREZWZlcnJlZFwiLCBcImluc3RhbnRpYXRpbmcgZGVmZXJyZWQgY29tcG9uZW50ICVjb21wb25lbnROYW1lIG9mIHBhcmVudCAldGhhdCBkdWUgdG8gZXZlbnQgJWV2ZW50TmFtZVwiLFxuICAgICAgICAgICAgICAgICB7Y29tcG9uZW50TmFtZTogY29tcG9uZW50TmFtZSwgdGhhdDogdGhhdCwgZXZlbnROYW1lOiBldmVudE5hbWV9KTtcbiAgICAgICAgICAgICAgICBpZiAodGhhdFtjb21wb25lbnROYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5zdGFudGlhdG9yID0gaWRUb0luc3RhbnRpYXRvclt0aGF0LmlkXTtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFudGlhdG9yLmNsZWFyQ29tcG9uZW50KHRoYXQsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmbHVpZC5pbml0RGVwZW5kZW50KHRoYXQsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgICAgICAgICAgIGZsdWlkLnBvcEFjdGl2aXR5KCk7XG4gICAgICAgICAgICB9LCBudWxsLCBudWxsLCBjb21wb25lbnQucHJpb3JpdHkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gdW5zdXBwb3J0ZWQsIG5vbi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5wcmlvcml0eUZvckNvbXBvbmVudCA9IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudC5wcmlvcml0eT8gY29tcG9uZW50LnByaW9yaXR5IDpcbiAgICAgICAgICAgIChjb21wb25lbnQudHlwZSA9PT0gXCJmbHVpZC50eXBlRm91bnRcIiB8fCBmbHVpZC5oYXNHcmFkZShmbHVpZC5kZWZhdWx0cyhjb21wb25lbnQudHlwZSksIFwiZmx1aWQudHlwZUZvdW50XCIpKT9cbiAgICAgICAgICAgIFwiZmlyc3RcIiA6IHVuZGVmaW5lZDtcbiAgICB9O1xuXG4gICAgZmx1aWQuaW5pdERlcGVuZGVudHMgPSBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgICBmbHVpZC5wdXNoQWN0aXZpdHkoXCJpbml0RGVwZW5kZW50c1wiLCBcImluc3RhbnRpYXRpbmcgZGVwZW5kZW50IGNvbXBvbmVudHMgZm9yIGNvbXBvbmVudCAldGhhdFwiLCB7dGhhdDogdGhhdH0pO1xuICAgICAgICB2YXIgc2hhZG93ID0gZmx1aWQuc2hhZG93Rm9yQ29tcG9uZW50KHRoYXQpO1xuICAgICAgICBzaGFkb3cubWVtYmVyU3RyYXRlZ3kuaW5pdHRlcigpO1xuXG4gICAgICAgIHZhciBvcHRpb25zID0gdGhhdC5vcHRpb25zO1xuICAgICAgICB2YXIgY29tcG9uZW50cyA9IG9wdGlvbnMuY29tcG9uZW50cyB8fCB7fTtcbiAgICAgICAgdmFyIGNvbXBvbmVudFNvcnQgPSB7fTtcblxuICAgICAgICBmbHVpZC5lYWNoKGNvbXBvbmVudHMsIGZ1bmN0aW9uIChjb21wb25lbnQsIG5hbWUpIHtcbiAgICAgICAgICAgIGlmICghY29tcG9uZW50LmNyZWF0ZU9uRXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJpb3JpdHkgPSBmbHVpZC5wcmlvcml0eUZvckNvbXBvbmVudChjb21wb25lbnQpO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudFNvcnRbbmFtZV0gPSBbe2tleTogbmFtZSwgcHJpb3JpdHk6IGZsdWlkLmV2ZW50Lm1hcFByaW9yaXR5KHByaW9yaXR5LCAwKX1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZmx1aWQuYmluZERlZmVycmVkQ29tcG9uZW50KHRoYXQsIG5hbWUsIGNvbXBvbmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgY29tcG9uZW50TGlzdCA9IGZsdWlkLmV2ZW50LnNvcnRMaXN0ZW5lcnMoY29tcG9uZW50U29ydCk7XG4gICAgICAgIGZsdWlkLmVhY2goY29tcG9uZW50TGlzdCwgZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICBmbHVpZC5pbml0RGVwZW5kZW50KHRoYXQsIGVudHJ5LmtleSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNoYWRvdy5pbnZva2VyU3RyYXRlZ3kuaW5pdHRlcigpO1xuICAgICAgICBmbHVpZC5wb3BBY3Rpdml0eSgpO1xuICAgIH07XG5cbiAgICB2YXIgZGVwZW5kZW50U3RvcmUgPSB7fTtcblxuICAgIGZ1bmN0aW9uIHNlYXJjaERlbWFuZHMgKGRlbWFuZGluZ05hbWUsIGNvbnRleHROYW1lcykge1xuICAgICAgICB2YXIgZXhpc3QgPSBkZXBlbmRlbnRTdG9yZVtkZW1hbmRpbmdOYW1lXSB8fCBbXTtcbm91dGVyOiAgZm9yICh2YXIgaSA9IDA7IGkgPCBleGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHJlYyA9IGV4aXN0W2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb250ZXh0TmFtZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICBpZiAocmVjLmNvbnRleHRzW2pdICE9PSBjb250ZXh0TmFtZXNbal0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlYy5zcGVjOyAvLyBqc2xpbnQ6b2tcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpc0RlbWFuZExvZ2dpbmcgPSBmYWxzZTtcbiAgICBmbHVpZC5zZXREZW1hbmRMb2dnaW5nID0gZnVuY3Rpb24gKHNldCkge1xuICAgICAgICBpc0RlbWFuZExvZ2dpbmcgPSBzZXQ7XG4gICAgfTtcblxuICAgIC8vIHVuc3VwcG9ydGVkLCBub24tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQuaXNEZW1hbmRMb2dnaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaXNEZW1hbmRMb2dnaW5nICYmIGZsdWlkLmlzTG9nZ2luZygpO1xuICAgIH07XG5cbiAgICBmbHVpZC5kZW1hbmRzID0gZnVuY3Rpb24gKGRlbWFuZGluZ05hbWUsIGNvbnRleHROYW1lLCBzcGVjKSB7XG4gICAgICAgIHZhciBjb250ZXh0TmFtZXMgPSBmbHVpZC5tYWtlQXJyYXkoY29udGV4dE5hbWUpLnNvcnQoKTtcbiAgICAgICAgaWYgKCFzcGVjKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VhcmNoRGVtYW5kcyhkZW1hbmRpbmdOYW1lLCBjb250ZXh0TmFtZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNwZWMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzcGVjID0ge2FyZ3M6IHNwZWN9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChmbHVpZC5nZXRDYWxsZXJJbmZvICYmIGZsdWlkLmlzRGVtYW5kTG9nZ2luZygpKSB7XG4gICAgICAgICAgICB2YXIgY2FsbGVySW5mbyA9IGZsdWlkLmdldENhbGxlckluZm8oNSk7XG4gICAgICAgICAgICBpZiAoY2FsbGVySW5mbykge1xuICAgICAgICAgICAgICAgIHNwZWMucmVnaXN0ZXJlZEZyb20gPSBjYWxsZXJJbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNwZWMuZGVtYW5kSWQgPSBmbHVpZC5hbGxvY2F0ZUd1aWQoKTtcbiAgICAgICAgdmFyIGV4aXN0ID0gZGVwZW5kZW50U3RvcmVbZGVtYW5kaW5nTmFtZV07XG4gICAgICAgIGlmICghZXhpc3QpIHtcbiAgICAgICAgICAgIGV4aXN0ID0gW107XG4gICAgICAgICAgICBkZXBlbmRlbnRTdG9yZVtkZW1hbmRpbmdOYW1lXSA9IGV4aXN0O1xuICAgICAgICB9XG4gICAgICAgIGV4aXN0LnB1c2goe2NvbnRleHRzOiBjb250ZXh0TmFtZXMsIHNwZWM6IHNwZWN9KTtcbiAgICB9O1xuXG4gICAgLy8gdW5zdXBwb3J0ZWQsIG5vbi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5jb21wYXJlRGVtYW5kcyA9IGZ1bmN0aW9uIChzcGVjYSwgc3BlY2IpIHtcbiAgICAgICAgcmV0dXJuIHNwZWNiLmludGVyc2VjdCAtIHNwZWNhLmludGVyc2VjdDtcbiAgICB9O1xuXG4gICAgLy8gdW5zdXBwb3J0ZWQsIG5vbi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5sb2NhdGVBbGxEZW1hbmRzID0gZnVuY3Rpb24gKHBhcmVudFRoYXQsIGRlbWFuZGluZ05hbWVzKSB7XG4gICAgICAgIHZhciBkZW1hbmRMb2dnaW5nID0gZmx1aWQuaXNEZW1hbmRMb2dnaW5nKGRlbWFuZGluZ05hbWVzKTtcbiAgICAgICAgaWYgKGRlbWFuZExvZ2dpbmcpIHtcbiAgICAgICAgICAgIGZsdWlkLmxvZyhcIlJlc29sdmluZyBkZW1hbmRzIGZvciBmdW5jdGlvbiBuYW1lcyBcIiwgZGVtYW5kaW5nTmFtZXMsIFwiIGluIGNvbnRleHQgb2YgXCIgK1xuICAgICAgICAgICAgICAgIChwYXJlbnRUaGF0PyBcImNvbXBvbmVudCBcIiArIHBhcmVudFRoYXQudHlwZU5hbWUgOiBcIm5vIGNvbXBvbmVudFwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29udGV4dE5hbWVzID0ge307XG4gICAgICAgIHZhciB2aXNpdGVkID0gW107XG4gICAgICAgIHZhciBpbnN0YW50aWF0b3IgPSBmbHVpZC5nZXRJbnN0YW50aWF0b3IocGFyZW50VGhhdCk7XG4gICAgICAgIHZhciB0aGF0U3RhY2sgPSBpbnN0YW50aWF0b3IuZ2V0RnVsbFN0YWNrKHBhcmVudFRoYXQpO1xuICAgICAgICB2aXNpdENvbXBvbmVudHMoaW5zdGFudGlhdG9yLCB0aGF0U3RhY2ssIGZ1bmN0aW9uIChjb21wb25lbnQsIHhuYW1lLCBwYXRoLCB4cGF0aCwgZGVwdGgpIHtcbiAgICAgICAgICAgIC8vIE5CIC0gZG9uJ3QgdXNlIHNoYWRvdydzIGNhY2hlIGhlcmUgYmVjYXVzZSB3ZSBhbGxvdyBmZXdlciBuYW1lcyBmb3IgZGVtYW5kIHJlc29sdXRpb24gdGhhbiBmb3IgdmFsdWUgcmVzb2x1dGlvblxuICAgICAgICAgICAgY29udGV4dE5hbWVzW2NvbXBvbmVudC50eXBlTmFtZV0gPSBkZXB0aDtcbiAgICAgICAgICAgIHZhciBncmFkZU5hbWVzID0gZmx1aWQubWFrZUFycmF5KGZsdWlkLmdldChjb21wb25lbnQsIFtcIm9wdGlvbnNcIiwgXCJncmFkZU5hbWVzXCJdKSk7XG4gICAgICAgICAgICBmbHVpZC5lYWNoKGdyYWRlTmFtZXMsIGZ1bmN0aW9uIChncmFkZU5hbWUpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0TmFtZXNbZ3JhZGVOYW1lXSA9IGRlcHRoO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2aXNpdGVkLnB1c2goY29tcG9uZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChkZW1hbmRMb2dnaW5nKSB7XG4gICAgICAgICAgICBmbHVpZC5sb2coXCJDb21wb25lbnRzIGluIHNjb3BlIGZvciByZXNvbHV0aW9uOlxcblwiICsgZmx1aWQuZHVtcFRoYXRTdGFjayh2aXNpdGVkLCBpbnN0YW50aWF0b3IpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlbWFuZGluZ05hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgcmVjID0gZGVwZW5kZW50U3RvcmVbZGVtYW5kaW5nTmFtZXNbaV1dIHx8IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZWMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICB2YXIgc3BlYyA9IHJlY1tqXTtcbiAgICAgICAgICAgICAgICB2YXIgaG9yaXpvbkxldmVsID0gc3BlYy5zcGVjLmhvcml6b24gPyBjb250ZXh0TmFtZXNbc3BlYy5zcGVjLmhvcml6b25dIDogLTE7XG4gICAgICAgICAgICAgICAgdmFyIHJlY29yZCA9IHtzcGVjOiBzcGVjLCBpbnRlcnNlY3Q6IDAsIHVuY2VzczogMH07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBzcGVjLmNvbnRleHRzLmxlbmd0aDsgKytrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZXB0aCA9IGNvbnRleHROYW1lc1tzcGVjLmNvbnRleHRzW2tdXTtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkW2RlcHRoICE9PSB1bmRlZmluZWQgJiYgZGVwdGggPj0gaG9yaXpvbkxldmVsID8gXCJpbnRlcnNlY3RcIiA6IFwidW5jZXNzXCJdICs9IDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzcGVjLmNvbnRleHRzLmxlbmd0aCA9PT0gMCkgeyAvLyBhbGxvdyB3ZWFrIHByaW9yaXR5IGZvciBjb250ZXh0bGVzcyBtYXRjaGVzXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZC5pbnRlcnNlY3QrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlY29yZC51bmNlc3MgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKHJlY29yZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1hdGNoZXMuc29ydChmbHVpZC5jb21wYXJlRGVtYW5kcyk7XG4gICAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgIH07XG5cbiAgICAvLyB1bnN1cHBvcnRlZCwgbm9uLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLmxvY2F0ZURlbWFuZHMgPSBmdW5jdGlvbiAocGFyZW50VGhhdCwgZGVtYW5kaW5nTmFtZXMpIHtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSBmbHVpZC5sb2NhdGVBbGxEZW1hbmRzKHBhcmVudFRoYXQsIGRlbWFuZGluZ05hbWVzKTtcbiAgICAgICAgdmFyIGRlbWFuZHNwZWMgPSBmbHVpZC5nZXRNZW1iZXJzKG1hdGNoZXMsIFtcInNwZWNcIiwgXCJzcGVjXCJdKTtcbiAgICAgICAgaWYgKGZsdWlkLmlzRGVtYW5kTG9nZ2luZyhkZW1hbmRpbmdOYW1lcykpIHtcbiAgICAgICAgICAgIGlmIChkZW1hbmRzcGVjLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZsdWlkLmxvZyhcIkxvY2F0ZWQgXCIgKyBtYXRjaGVzLmxlbmd0aCArIFwiIHBvdGVudGlhbCBtYXRjaFwiICsgKG1hdGNoZXMubGVuZ3RoID09PSAxPyBcIlwiIDogXCJlc1wiKSArIFwiLCBzZWxlY3RlZCBiZXN0IG1hdGNoIHdpdGggXCIgKyBtYXRjaGVzWzBdLmludGVyc2VjdCArXG4gICAgICAgICAgICAgICAgICAgIFwiIG1hdGNoZWQgY29udGV4dCBuYW1lczogXCIsIGRlbWFuZHNwZWMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZmx1aWQubG9nKFwiTm8gbWF0Y2hlcyBmb3VuZCBmb3IgZGVtYW5kcywgdXNpbmcgZGlyZWN0IGltcGxlbWVudGF0aW9uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZW1hbmRzcGVjO1xuICAgIH07XG5cbiAgICAvKiogRGV0ZXJtaW5lIHRoZSBhcHByb3ByaWF0ZSBkZW1hbmQgc3BlY2lmaWNhdGlvbiBoZWxkIGluIHRoZSBmbHVpZC5kZW1hbmRzIGVudmlyb25tZW50XG4gICAgICogcmVsYXRpdmUgdGhlIHN1cHBsaWVkIGNvbXBvbmVudCBwb3NpdGlvbiBmb3IgdGhlIGZ1bmN0aW9uIG5hbWUocykgZnVuY05hbWVzLlxuICAgICAqL1xuICAgIC8vIHVuc3VwcG9ydGVkLCBub24tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQuZGV0ZXJtaW5lRGVtYW5kcyA9IGZ1bmN0aW9uIChwYXJlbnRUaGF0LCBmdW5jTmFtZXMpIHtcbiAgICAgICAgZnVuY05hbWVzID0gZmx1aWQubWFrZUFycmF5KGZ1bmNOYW1lcyk7XG4gICAgICAgIHZhciBuZXdGdW5jTmFtZSA9IGZ1bmNOYW1lc1swXTtcbiAgICAgICAgdmFyIGRlbWFuZHNwZWMgPSBmbHVpZC5sb2NhdGVEZW1hbmRzKHBhcmVudFRoYXQsIGZ1bmNOYW1lcyk7XG4gICAgICAgIGlmIChkZW1hbmRzcGVjLmxlbmd0aCAmJiBkZW1hbmRzcGVjWzBdLmZ1bmNOYW1lKSB7XG4gICAgICAgICAgICBuZXdGdW5jTmFtZSA9IGRlbWFuZHNwZWNbMF0uZnVuY05hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJC5leHRlbmQodHJ1ZSwge2Z1bmNOYW1lOiBuZXdGdW5jTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogZGVtYW5kc3BlY1swXSA/IGZsdWlkLm1ha2VBcnJheShkZW1hbmRzcGVjWzBdLmFyZ3MpIDogW11cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBiYWNrU3BlY3M6IGRlbWFuZHNwZWMuc2xpY2UoMSkgfSwgLy8gRml4IGZvciBGTFVJRC01MTI2XG4gICAgICAgICAgICBmbHVpZC5jZW5zb3JLZXlzKGRlbWFuZHNwZWNbMF0sIFtcImZ1bmNOYW1lXCIsIFwiYXJnc1wiXSkpO1xuICAgIH07XG4gICAgLy8gXCJvcHRpb25zXCIgaW5jbHVkZXMgLSBwYXNzQXJncywgY29tcG9uZW50UmVjb3JkLCBtZW1iZXJOYW1lIChsYXR0ZXIgdHdvIGZyb20gaW5pdERlcGVuZGVudCByb3V0ZSlcbiAgICAvLyB1bnN1cHBvcnRlZCwgbm9uLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLnJlc29sdmVEZW1hbmRzID0gZnVuY3Rpb24gKHBhcmVudFRoYXQsIGZ1bmNOYW1lcywgaW5pdEFyZ3MsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGRlbWFuZHNwZWMgPSBmbHVpZC5kZXRlcm1pbmVEZW1hbmRzKHBhcmVudFRoYXQsIGZ1bmNOYW1lcyk7XG4gICAgICAgIHJldHVybiBmbHVpZC5lbWJvZHlEZW1hbmRzKHBhcmVudFRoYXQsIGRlbWFuZHNwZWMsIGluaXRBcmdzLCBvcHRpb25zKTtcbiAgICB9O1xuXG4gICAgLy8gdW5zdXBwb3J0ZWQsIG5vbi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC50aGlzaXN0VG9BcHBsaWNhYmxlID0gZnVuY3Rpb24gKHJlY29yZCwgcmVjdGhpcywgdGhhdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXBwbHk6IGZ1bmN0aW9uIChub1RoaXMsIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAvLyBSZXNvbHZlIHRoaXMgbWF0ZXJpYWwgbGF0ZSwgdG8gZGVhbCB3aXRoIGNhc2VzIHdoZXJlIHRoZSB0YXJnZXQgaGFzIG9ubHkganVzdCBiZWVuIGJyb3VnaHQgaW50byBleGlzdGVuY2VcbiAgICAgICAgICAgICAgICAvLyAoZS5nLiBhIGpRdWVyeSB0YXJnZXQgZm9yIHJlbmRlcmVkIG1hdGVyaWFsKSAtIFRPRE86IFBvc3NpYmx5IGltcGxlbWVudCBjYWNoZWQgdmVyc2lvbnMgb2YgdGhlc2UgYXMgd2UgbWlnaHQgZG8gZm9yIGludm9rZXJzXG4gICAgICAgICAgICAgICAgdmFyIHJlc29sdmVkVGhpcyA9IGZsdWlkLmV4cGFuZE9wdGlvbnMocmVjdGhpcywgdGhhdCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZihyZXNvbHZlZFRoaXMpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkVGhpcyA9IGZsdWlkLmdldEdsb2JhbFZhbHVlKHJlc29sdmVkVGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghcmVzb2x2ZWRUaGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsdWlkLmZhaWwoXCJDb3VsZCBub3QgcmVzb2x2ZSByZWZlcmVuY2UgXCIgKyByZWN0aGlzICsgXCIgdG8gYSB2YWx1ZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlc29sdmVkRnVuYyA9IHJlc29sdmVkVGhpc1tyZWNvcmQubWV0aG9kXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mKHJlc29sdmVkRnVuYykgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBmbHVpZC5mYWlsKFwiT2JqZWN0IFwiLCByZXNvbHZlZFRoaXMsIFwiIGF0IHJlZmVyZW5jZSBcIiArIHJlY3RoaXMgKyBcIiBoYXMgbm8gbWVtYmVyIG5hbWVkIFwiICsgcmVjb3JkLm1ldGhvZCArIFwiIHdoaWNoIGlzIGEgZnVuY3Rpb24gXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmbHVpZC5sb2coXCJBcHBseWluZyBhcmd1bWVudHMgXCIsIGFyZ3MsIFwiIHRvIG1ldGhvZCBcIiArIHJlY29yZC5tZXRob2QgKyBcIiBvZiBpbnN0YW5jZSBcIiwgcmVzb2x2ZWRUaGlzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWRGdW5jLmFwcGx5KHJlc29sdmVkVGhpcywgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIGZsdWlkLmNoYW5nZVRvQXBwbGljYWJsZSA9IGZ1bmN0aW9uIChyZWNvcmQsIHRoYXQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFwcGx5OiBmdW5jdGlvbiAobm9UaGlzLCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnNlZCA9IGZsdWlkLnBhcnNlVmFsaWRNb2RlbFJlZmVyZW5jZSh0aGF0LCBcImNoYW5nZVBhdGggbGlzdGVuZXIgcmVjb3JkXCIsIHJlY29yZC5jaGFuZ2VQYXRoKTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBmbHVpZC5leHBhbmRPcHRpb25zKHJlY29yZC52YWx1ZSwgdGhhdCwge30sIHtcImFyZ3VtZW50c1wiOiBhcmdzfSk7XG4gICAgICAgICAgICAgICAgZmx1aWQuZmlyZVNvdXJjZWRDaGFuZ2UocGFyc2VkLmFwcGxpZXIsIHBhcnNlZC5wYXRoLCB2YWx1ZSwgcmVjb3JkLnNvdXJjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIENvbnZlcnQgXCJleG90aWMgcmVjb3Jkc1wiIGludG8gYW4gYXBwbGljYWJsZSBmb3JtIChcInRoaXMvbWV0aG9kXCIgZm9yIEZMVUlELTQ4Nzggb3IgXCJjaGFuZ2VQYXRoXCIgZm9yIEZMVUlELTM2NzQpXG4gICAgLy8gdW5zdXBwb3J0ZWQsIG5vbi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5yZWNvcmRUb0FwcGxpY2FibGUgPSBmdW5jdGlvbiAocmVjb3JkLCB0aGF0KSB7XG4gICAgICAgIGlmIChyZWNvcmQuY2hhbmdlUGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZsdWlkLmNoYW5nZVRvQXBwbGljYWJsZShyZWNvcmQsIHRoYXQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWN0aGlzID0gcmVjb3JkW1widGhpc1wiXTtcbiAgICAgICAgaWYgKHJlY29yZC5tZXRob2QgXiByZWN0aGlzKSB7XG4gICAgICAgICAgICBmbHVpZC5mYWlsKFwiUmVjb3JkIFwiLCB0aGF0LCBcIiBtdXN0IGNvbnRhaW4gYm90aCBlbnRyaWVzIFxcXCJtZXRob2RcXFwiIGFuZCBcXFwidGhpc1xcXCIgaWYgaXQgY29udGFpbnMgZWl0aGVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWNvcmQubWV0aG9kID8gZmx1aWQudGhpc2lzdFRvQXBwbGljYWJsZShyZWNvcmQsIHJlY3RoaXMsIHRoYXQpIDogbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gVE9ETzogbWFrZSBhICpzbGlnaHRseSogbW9yZSBwZXJmb3JtYW50IHZlcnNpb24gb2YgZmx1aWQuaW52b2tlIHRoYXQgcGVyaGFwcyBjYWNoZXMgdGhlIGRlbWFuZHNcbiAgICAvLyBhZnRlciB0aGUgZmlyc3Qgc3VjY2Vzc2Z1bCBpbnZvY2F0aW9uXG4gICAgZmx1aWQuaW52b2tlID0gZnVuY3Rpb24gKGZ1bmN0aW9uTmFtZSwgYXJncywgdGhhdCwgZW52aXJvbm1lbnQpIHtcbiAgICAgICAgZmx1aWQucHVzaEFjdGl2aXR5KFwiaW52b2tlRnVuY1wiLCBcImludm9raW5nIGZ1bmN0aW9uIHdpdGggbmFtZSBcXFwiJWZ1bmN0aW9uTmFtZVxcXCIgZnJvbSBjb21wb25lbnQgJXRoYXRcIiwge2Z1bmN0aW9uTmFtZTogZnVuY3Rpb25OYW1lLCB0aGF0OiB0aGF0fSk7XG4gICAgICAgIHZhciBpbnZva2VTcGVjID0gZmx1aWQucmVzb2x2ZURlbWFuZHModGhhdCwgZnVuY3Rpb25OYW1lLCBmbHVpZC5tYWtlQXJyYXkoYXJncyksIHtwYXNzQXJnczogdHJ1ZX0pO1xuICAgICAgICB2YXIgdG9nbyA9IGZsdWlkLmludm9rZUdsb2JhbEZ1bmN0aW9uKGludm9rZVNwZWMuZnVuY05hbWUsIGludm9rZVNwZWMuYXJncywgZW52aXJvbm1lbnQpO1xuICAgICAgICBmbHVpZC5wb3BBY3Rpdml0eSgpO1xuICAgICAgICByZXR1cm4gdG9nbztcbiAgICB9O1xuXG4gICAgLyoqIE1ha2UgYSBmdW5jdGlvbiB3aGljaCBwZXJmb3JtcyBvbmx5IFwic3RhdGljIHJlZGlzcGF0Y2hcIiBvZiB0aGUgc3VwcGxpZWQgZnVuY3Rpb24gbmFtZSAtXG4gICAgICogdGhhdCBpcywgdGFraW5nIG9ubHkgYWNjb3VudCBvZiB0aGUgY29udGVudHMgb2YgdGhlIFwic3RhdGljIGVudmlyb25tZW50XCIuIFNpbmNlIHRoZSBzdGF0aWNcbiAgICAgKiBlbnZpcm9ubWVudCBpcyBhc3N1bWVkIHRvIGJlIGNvbnN0YW50LCB0aGUgZGlzcGF0Y2ggb2YgdGhlIGNhbGwgd2lsbCBiZSBldmFsdWF0ZWQgYXQgdGhlXG4gICAgICogdGltZSB0aGlzIGNhbGwgaXMgbWFkZSwgYXMgYW4gb3B0aW1pc2F0aW9uLlxuICAgICAqL1xuICAgIC8vIHVuc3VwcG9ydGVkLCBub24tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQubWFrZUZyZWVJbnZva2VyID0gZnVuY3Rpb24gKGZ1bmN0aW9uTmFtZSwgZW52aXJvbm1lbnQpIHtcbiAgICAgICAgdmFyIGRlbWFuZFNwZWMgPSBmbHVpZC5kZXRlcm1pbmVEZW1hbmRzKG51bGwsIGZ1bmN0aW9uTmFtZSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaW52b2tlU3BlYyA9IGZsdWlkLmVtYm9keURlbWFuZHMobnVsbCwgZGVtYW5kU3BlYywgZmx1aWQubWFrZUFycmF5KGFyZ3VtZW50cyksIHtwYXNzQXJnczogdHJ1ZX0pO1xuICAgICAgICAgICAgcmV0dXJuIGZsdWlkLmludm9rZUdsb2JhbEZ1bmN0aW9uKGludm9rZVNwZWMuZnVuY05hbWUsIGludm9rZVNwZWMuYXJncywgZW52aXJvbm1lbnQpO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgYXJnUHJlZml4ID0gXCJ7YXJndW1lbnRzfS5cIjtcblxuICAgIGZsdWlkLnBhcnNlSW50ZWdlciA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIGlzRmluaXRlKHN0cmluZykgJiYgKChzdHJpbmcgJSAxKSA9PT0gMCkgPyBOdW1iZXIoc3RyaW5nKSA6IE5hTjtcbiAgICB9O1xuXG4gICAgZmx1aWQubWFrZUZhc3RJbnZva2VyID0gZnVuY3Rpb24gKGludm9rZVNwZWMsIGZ1bmMpIHtcbiAgICAgICAgdmFyIGFyZ01hcDtcbiAgICAgICAgaWYgKGludm9rZVNwZWMucHJlRXhwYW5kKSB7XG4gICAgICAgICAgICBhcmdNYXAgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW52b2tlU3BlYy5wcmVFeHBhbmQubGVuZ3RoOyArKyBpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gaW52b2tlU3BlYy5wcmVFeHBhbmRbaV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZih2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmluZGV4T2YoXCJ9Lm1vZGVsXCIpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtub0Zhc3Q6IHRydWV9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gXCJ7YXJndW1lbnRzfVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdNYXBbaV0gPSBcIipcIjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZS5pbmRleE9mKGFyZ1ByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmdJbmRleCA9IGZsdWlkLnBhcnNlSW50ZWdlcih2YWx1ZS5zdWJzdHJpbmcoYXJnUHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKGFyZ0luZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7bm9GYXN0OiB0cnVlfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ01hcFtpXSA9IGFyZ0luZGV4OyAvLyB0YXJnZXQgYXJnIHBvcyA9IG9yaWdpbmFsIGFyZyBwb3NcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0QXJncyA9IGludm9rZVNwZWMuYXJncztcbiAgICAgICAgdmFyIGludm9rZSA9IGFyZ01hcCA/IGZ1bmN0aW9uIGludm9rZShhcmdzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIGFyZ01hcCkge1xuICAgICAgICAgICAgICAgIG91dEFyZ3NbaV0gPSBhcmdNYXBbaV0gPT09IFwiKlwiID8gYXJncyA6IGFyZ3NbYXJnTWFwW2ldXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KG51bGwsIG91dEFyZ3MpO1xuICAgICAgICB9IDogZnVuY3Rpb24gaW52b2tlIChhcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGludm9rZTogaW52b2tlXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIHVuc3VwcG9ydGVkLCBub24tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQubWFrZUludm9rZXIgPSBmdW5jdGlvbiAodGhhdCwgaW52b2tlcmVjLCBuYW1lLCBlbnZpcm9ubWVudCkge1xuICAgICAgICB2YXIgZnVuY3Rpb25OYW1lO1xuICAgICAgICBpZiAodHlwZW9mKGludm9rZXJlYykgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmIChpbnZva2VyZWMuY2hhckF0KDApID09PSBcIntcIikgeyAvLyBzaG9ydGhhbmQgY2FzZSBmb3IgZGlyZWN0IGZ1bmN0aW9uIGludm9rZXJzIChGTFVJRC00OTI2KVxuICAgICAgICAgICAgICAgIGludm9rZXJlYyA9IHtmdW5jOiBpbnZva2VyZWN9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWUgPSBpbnZva2VyZWM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlbWFuZHNwZWMgPSBmdW5jdGlvbk5hbWU/IGZsdWlkLmRldGVybWluZURlbWFuZHModGhhdCwgZnVuY3Rpb25OYW1lKSA6IGludm9rZXJlYztcbiAgICAgICAgdmFyIGZhc3RSZWMgPSB7bm9GYXN0OiBpbnZva2VyZWMuZHluYW1pY307XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2VJbnZva2VyICgpIHtcbiAgICAgICAgICAgIGlmIChmbHVpZC5kZWZlYXRMb2dnaW5nID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGZsdWlkLnB1c2hBY3Rpdml0eShcImludm9rZUludm9rZXJcIiwgXCJpbnZva2luZyBpbnZva2VyIHdpdGggbmFtZSAlbmFtZSBhbmQgcmVjb3JkICVyZWNvcmQgZnJvbSBjb21wb25lbnQgJXRoYXRcIiwge25hbWU6IG5hbWUsIHJlY29yZDogaW52b2tlcmVjLCB0aGF0OiB0aGF0fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdG9nbztcbiAgICAgICAgICAgIGlmIChmYXN0UmVjLmludm9rZSkge1xuICAgICAgICAgICAgICAgIHRvZ28gPSBmYXN0UmVjLmludm9rZShhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGZ1bmMgPSBmbHVpZC5yZWNvcmRUb0FwcGxpY2FibGUoaW52b2tlcmVjLCB0aGF0KTtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGZsdWlkLm1ha2VBcnJheShhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIHZhciBpbnZva2VTcGVjID0gZmx1aWQuZW1ib2R5RGVtYW5kcyh0aGF0LCBkZW1hbmRzcGVjLCBhcmdzLCB7cGFzc0FyZ3M6IHRydWV9KTtcbiAgICAgICAgICAgICAgICBmdW5jID0gZnVuYyB8fCAoaW52b2tlU3BlYy5mdW5jTmFtZT8gZmx1aWQuZ2V0R2xvYmFsVmFsdWUoaW52b2tlU3BlYy5mdW5jTmFtZSwgZW52aXJvbm1lbnQpXG4gICAgICAgICAgICAgICAgICAgIDogZmx1aWQuZXhwYW5kT3B0aW9ucyhkZW1hbmRzcGVjLmZ1bmMsIHRoYXQpKTtcbiAgICAgICAgICAgICAgICBpZiAoIWZ1bmMgfHwgIWZ1bmMuYXBwbHkpIHtcbiAgICAgICAgICAgICAgICAgICAgZmx1aWQuZmFpbChcIkVycm9yIGluIGludm9rZXIgcmVjb3JkOiBjb3VsZCBub3QgcmVzb2x2ZSBtZW1iZXJzIGZ1bmMsIGZ1bmNOYW1lIG9yIG1ldGhvZCB0byBhIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9uIC0gZ290IFwiICsgZnVuYyArIFwiIGZyb20gXCIsIGRlbWFuZHNwZWMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZmFzdFJlYy5ub0Zhc3QgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZmFzdFJlYyA9IGZsdWlkLm1ha2VGYXN0SW52b2tlcihpbnZva2VTcGVjLCBmdW5jKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG9nbyA9IGZ1bmMuYXBwbHkobnVsbCwgaW52b2tlU3BlYy5hcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmbHVpZC5kZWZlYXRMb2dnaW5nID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGZsdWlkLnBvcEFjdGl2aXR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG9nbztcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gdW5zdXBwb3J0ZWQsIG5vbi1BUEkgZnVuY3Rpb25cbiAgICAvLyB3ZWlyZCBoaWdoZXItb3JkZXIgZnVuY3Rpb24gc28gdGhhdCB3ZSBjYW4gc3RhaWdodGZvcndhcmRseSBkaXNwYXRjaCBvcmlnaW5hbCBhcmdzIGJhY2sgb250byBsaXN0ZW5lclxuICAgIGZsdWlkLmV2ZW50Lm1ha2VUcmFja2VkTGlzdGVuZXJBZGRlciA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgdmFyIHNoYWRvdyA9IGZsdWlkLnNoYWRvd0ZvckNvbXBvbmVudChzb3VyY2UpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4ge2FkZExpc3RlbmVyOiBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZmx1aWQucmVjb3JkTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBzaGFkb3cpO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5hZGRMaXN0ZW5lci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIHVuc3VwcG9ydGVkLCBub24tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQuZXZlbnQubGlzdGVuZXJFbmdpbmUgPSBmdW5jdGlvbiAoZXZlbnRTcGVjLCBjYWxsYmFjaywgYWRkZXIpIHtcbiAgICAgICAgdmFyIGFyZ3N0cnVjID0ge307XG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrRmlyZSgpIHtcbiAgICAgICAgICAgIHZhciBub3RhbGwgPSBmbHVpZC5maW5kKGV2ZW50U3BlYywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgICAgICAgIGlmIChhcmdzdHJ1Y1trZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIW5vdGFsbCkge1xuICAgICAgICAgICAgICAgIHZhciBvbGRzdHJ1YyA9IGFyZ3N0cnVjO1xuICAgICAgICAgICAgICAgIGFyZ3N0cnVjID0ge307IC8vIGd1YXJkIGFnYWluc3QgdGhlIGNhc2UgdGhlIGNhbGxiYWNrIHBlcnZlcnNlbHkgZmlyZXMgb25lIG9mIGl0cyBwcmVyZXF1aXNpdGVzIChGTFVJRC01MTEyKVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG9sZHN0cnVjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmbHVpZC5lYWNoKGV2ZW50U3BlYywgZnVuY3Rpb24gKGV2ZW50LCBldmVudE5hbWUpIHtcbiAgICAgICAgICAgIGFkZGVyKGV2ZW50KS5hZGRMaXN0ZW5lcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgYXJnc3RydWNbZXZlbnROYW1lXSA9IGZsdWlkLm1ha2VBcnJheShhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGNoZWNrRmlyZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyB1bnN1cHBvcnRlZCwgbm9uLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLmV2ZW50LmRpc3BhdGNoTGlzdGVuZXIgPSBmdW5jdGlvbiAodGhhdCwgbGlzdGVuZXIsIGV2ZW50TmFtZSwgZXZlbnRTcGVjLCBpbmRpcmVjdEFyZ3MpIHtcbiAgICAgICAgdmFyIHRvZ28gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmbHVpZC5wdXNoQWN0aXZpdHkoXCJkaXNwYXRjaExpc3RlbmVyXCIsIFwiZmlyaW5nIHRvIGxpc3RlbmVyIHRvIGV2ZW50IG5hbWVkICVldmVudE5hbWUgb2YgY29tcG9uZW50ICV0aGF0XCIsXG4gICAgICAgICAgICAgICAge2V2ZW50TmFtZTogZXZlbnROYW1lLCB0aGF0OiB0aGF0fSk7XG5cbiAgICAgICAgICAgIHZhciBhcmdzID0gaW5kaXJlY3RBcmdzPyBhcmd1bWVudHNbMF0gOiBmbHVpZC5tYWtlQXJyYXkoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHZhciBkZW1hbmRzcGVjID0gZmx1aWQuZGV0ZXJtaW5lRGVtYW5kcyh0aGF0LCBldmVudE5hbWUpOyAvLyBUT0RPOiBUaGlzIG5hbWUgbWF5IGNvbnRhaW4gYSBuYW1lc3BhY2VcbiAgICAgICAgICAgIGlmIChkZW1hbmRzcGVjLmFyZ3MubGVuZ3RoID09PSAwICYmIGV2ZW50U3BlYy5hcmdzKSB7XG4gICAgICAgICAgICAgICAgZGVtYW5kc3BlYy5hcmdzID0gZXZlbnRTcGVjLmFyZ3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUT0RPOiBjcmVhdGUgYSBcImZhc3QgcGF0aFwiIGhlcmUgYXMgZm9yIGludm9rZXJzLiBFbGltaW5hdGUgcmVkdW5kYW5jeSB3aXRoIGludm9rZXIgY29kZVxuICAgICAgICAgICAgdmFyIHJlc29sdmVkID0gZmx1aWQuZW1ib2R5RGVtYW5kcyh0aGF0LCBkZW1hbmRzcGVjLCBhcmdzLCB7cGFzc0FyZ3M6IHRydWV9KTtcbiAgICAgICAgICAgIHZhciB0b2dvID0gZmx1aWQuZXZlbnQuaW52b2tlTGlzdGVuZXIobGlzdGVuZXIsIHJlc29sdmVkLmFyZ3MpO1xuICAgICAgICAgICAgZmx1aWQucG9wQWN0aXZpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiB0b2dvO1xuICAgICAgICB9O1xuICAgICAgICBmbHVpZC5ldmVudC5pbXBlcnNvbmF0ZUxpc3RlbmVyKGxpc3RlbmVyLCB0b2dvKTtcbiAgICAgICAgcmV0dXJuIHRvZ287XG4gICAgfTtcblxuICAgIC8vIHVuc3VwcG9ydGVkLCBub24tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQuZXZlbnQucmVzb2x2ZVNvZnROYW1lc3BhY2UgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2Yoa2V5KSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbGFzdHBvcyA9IE1hdGgubWF4KGtleS5sYXN0SW5kZXhPZihcIi5cIiksIGtleS5sYXN0SW5kZXhPZihcIn1cIikpO1xuICAgICAgICAgICAgcmV0dXJuIGtleS5zdWJzdHJpbmcobGFzdHBvcyArIDEpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIHVuc3VwcG9ydGVkLCBub24tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQuZXZlbnQucmVzb2x2ZUxpc3RlbmVyUmVjb3JkID0gZnVuY3Rpb24gKGxpc3JlYywgdGhhdCwgZXZlbnROYW1lLCBuYW1lc3BhY2UsIHN0YW5kYXJkKSB7XG4gICAgICAgIHZhciBiYWRSZWMgPSBmdW5jdGlvbiAocmVjb3JkLCBleHRyYSkge1xuICAgICAgICAgICAgZmx1aWQuZmFpbChcIkVycm9yIGluIGxpc3RlbmVyIHJlY29yZCAtIGNvdWxkIG5vdCByZXNvbHZlIHJlZmVyZW5jZSBcIiwgcmVjb3JkLCBcIiB0byBhIGxpc3RlbmVyIG9yIGZpcmVyLiBcIiArXG4gICAgICAgICAgICAgICAgXCJEaWQgeW91IG1pc3Mgb3V0IFxcXCJldmVudHMuXFxcIiB3aGVuIHJlZmVycmluZyB0byBhbiBldmVudCBmaXJlcj9cIiArIGV4dHJhKTtcbiAgICAgICAgfTtcbiAgICAgICAgZmx1aWQucHVzaEFjdGl2aXR5KFwicmVzb2x2ZUxpc3RlbmVyUmVjb3JkXCIsIFwicmVzb2x2aW5nIGxpc3RlbmVyIHJlY29yZCBmb3IgZXZlbnQgbmFtZWQgJWV2ZW50TmFtZSBmb3IgY29tcG9uZW50ICV0aGF0XCIsXG4gICAgICAgICAgICB7ZXZlbnROYW1lOiBldmVudE5hbWUsIHRoYXQ6IHRoYXR9KTtcbiAgICAgICAgdmFyIHJlY29yZHMgPSBmbHVpZC5tYWtlQXJyYXkobGlzcmVjKTtcbiAgICAgICAgdmFyIHRyYW5zUmVjcyA9IGZsdWlkLnRyYW5zZm9ybShyZWNvcmRzLCBmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBGTFVJRC01MjQyIGZpeCAtIHdlIGNvcHkgaGVyZSBzaW5jZSBkaXN0cmlidXRlT3B0aW9ucyBkb2VzIG5vdCBjb3B5IG9wdGlvbnMgYmxvY2tzIHRoYXQgaXQgZGlzdHJpYnV0ZXMgYW5kIHdlIGNhbiBoZW5jZSBjb3JydXB0IHRoZW0uXG4gICAgICAgICAgICAvLyBuZWVkIHRvIGNsYXJpZnkgcG9saWN5IG9uIG9wdGlvbnMgc2hhcmluZyAtIGZvciBzbGlnaHRseSBiZXR0ZXIgZWZmaWNpZW5jeSwgY29weSBzaG91bGQgaGFwcGVuIGR1cmluZyBkaXN0cmlidXRpb24gYW5kIG5vdCBoZXJlXG4gICAgICAgICAgICB2YXIgZXhwYW5kZWQgPSBmbHVpZC5pc1ByaW1pdGl2ZShyZWNvcmQpIHx8IHJlY29yZC5leHBhbmRlciA/IHtsaXN0ZW5lcjogcmVjb3JkfSA6IGZsdWlkLmNvcHkocmVjb3JkKTtcbiAgICAgICAgICAgIHZhciBtZXRob2Rpc3QgPSBmbHVpZC5yZWNvcmRUb0FwcGxpY2FibGUocmVjb3JkLCB0aGF0KTtcbiAgICAgICAgICAgIGlmIChtZXRob2Rpc3QpIHtcbiAgICAgICAgICAgICAgICBleHBhbmRlZC5saXN0ZW5lciA9IG1ldGhvZGlzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4cGFuZGVkLmxpc3RlbmVyID0gZXhwYW5kZWQubGlzdGVuZXIgfHwgZXhwYW5kZWQuZnVuYyB8fCBleHBhbmRlZC5mdW5jTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZXhwYW5kZWQubGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBiYWRSZWMocmVjb3JkLCBcIiBMaXN0ZW5lciByZWNvcmQgbXVzdCBjb250YWluIGEgbWVtYmVyIG5hbWVkIFxcXCJsaXN0ZW5lclxcXCIsIFxcXCJmdW5jXFxcIiwgXFxcImZ1bmNOYW1lXFxcIiBvciBcXFwibWV0aG9kXFxcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzb2Z0TmFtZXNwYWNlID0gcmVjb3JkLm1ldGhvZCA/XG4gICAgICAgICAgICAgICAgZmx1aWQuZXZlbnQucmVzb2x2ZVNvZnROYW1lc3BhY2UocmVjb3JkW1widGhpc1wiXSkgKyBcIi5cIiArIHJlY29yZC5tZXRob2QgOlxuICAgICAgICAgICAgICAgIGZsdWlkLmV2ZW50LnJlc29sdmVTb2Z0TmFtZXNwYWNlKGV4cGFuZGVkLmxpc3RlbmVyKTtcbiAgICAgICAgICAgIGlmICghZXhwYW5kZWQubmFtZXNwYWNlICYmICFuYW1lc3BhY2UgJiYgc29mdE5hbWVzcGFjZSkge1xuICAgICAgICAgICAgICAgIGV4cGFuZGVkLnNvZnROYW1lc3BhY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGV4cGFuZGVkLm5hbWVzcGFjZSA9IChyZWNvcmQuY29tcG9uZW50U291cmNlID8gcmVjb3JkLmNvbXBvbmVudFNvdXJjZSA6IHRoYXQudHlwZU5hbWUpICsgXCIuXCIgKyBzb2Z0TmFtZXNwYWNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gZXhwYW5kZWQubGlzdGVuZXIgPSBmbHVpZC5leHBhbmRPcHRpb25zKGV4cGFuZGVkLmxpc3RlbmVyLCB0aGF0KTtcbiAgICAgICAgICAgIGlmICghbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBiYWRSZWMocmVjb3JkLCBcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmaXJlciA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGxpc3RlbmVyLnR5cGVOYW1lID09PSBcImZsdWlkLmV2ZW50LmZpcmVyXCIpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyLmZpcmU7XG4gICAgICAgICAgICAgICAgZmlyZXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhwYW5kZWQubGlzdGVuZXIgPSAoc3RhbmRhcmQgJiYgKGV4cGFuZGVkLmFyZ3MgfHwgZmlyZXIpKSA/IGZsdWlkLmV2ZW50LmRpc3BhdGNoTGlzdGVuZXIodGhhdCwgbGlzdGVuZXIsIGV2ZW50TmFtZSwgZXhwYW5kZWQpIDogbGlzdGVuZXI7XG4gICAgICAgICAgICByZXR1cm4gZXhwYW5kZWQ7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgdG9nbyA9IHtcbiAgICAgICAgICAgIHJlY29yZHM6IHRyYW5zUmVjcyxcbiAgICAgICAgICAgIGFkZGVyV3JhcHBlcjogc3RhbmRhcmQgPyBmbHVpZC5ldmVudC5tYWtlVHJhY2tlZExpc3RlbmVyQWRkZXIodGhhdCkgOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIGZsdWlkLnBvcEFjdGl2aXR5KCk7XG4gICAgICAgIHJldHVybiB0b2dvO1xuICAgIH07XG5cbiAgICAvLyB1bnN1cHBvcnRlZCwgbm9uLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLmV2ZW50LmV4cGFuZE9uZUV2ZW50ID0gZnVuY3Rpb24gKHRoYXQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBvcmlnaW47XG4gICAgICAgIGlmICh0eXBlb2YoZXZlbnQpID09PSBcInN0cmluZ1wiICYmIGV2ZW50LmNoYXJBdCgwKSAhPT0gXCJ7XCIpIHtcbiAgICAgICAgICAgIC8vIFNob3J0aGFuZCBmb3IgcmVzb2x2aW5nIG9udG8gb3VyIG93biBldmVudHMsIGJ1dCB3aXRoIEdJTkdFUiBXT1JMRCFcbiAgICAgICAgICAgIG9yaWdpbiA9IGZsdWlkLmdldEZvckNvbXBvbmVudCh0aGF0LCBbXCJldmVudHNcIiwgZXZlbnRdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9yaWdpbiA9IGZsdWlkLmV4cGFuZE9wdGlvbnMoZXZlbnQsIHRoYXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3JpZ2luIHx8IG9yaWdpbi50eXBlTmFtZSAhPT0gXCJmbHVpZC5ldmVudC5maXJlclwiKSB7XG4gICAgICAgICAgICBmbHVpZC5mYWlsKFwiRXJyb3IgaW4gZXZlbnQgc3BlY2lmaWNhdGlvbiAtIGNvdWxkIG5vdCByZXNvbHZlIGJhc2UgZXZlbnQgcmVmZXJlbmNlIFwiLCBldmVudCwgXCIgdG8gYW4gZXZlbnQgZmlyZXI6IGdvdCBcIiwgb3JpZ2luKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3JpZ2luO1xuICAgIH07XG5cbiAgICAvLyB1bnN1cHBvcnRlZCwgbm9uLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLmV2ZW50LmV4cGFuZEV2ZW50cyA9IGZ1bmN0aW9uICh0aGF0LCBldmVudCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mKGV2ZW50KSA9PT0gXCJzdHJpbmdcIiA/XG4gICAgICAgICAgICBmbHVpZC5ldmVudC5leHBhbmRPbmVFdmVudCh0aGF0LCBldmVudCkgOlxuICAgICAgICAgICAgZmx1aWQudHJhbnNmb3JtKGV2ZW50LCBmdW5jdGlvbiAob25lRXZlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmx1aWQuZXZlbnQuZXhwYW5kT25lRXZlbnQodGhhdCwgb25lRXZlbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIHVuc3VwcG9ydGVkLCBub24tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQuZXZlbnQucmVzb2x2ZUV2ZW50ID0gZnVuY3Rpb24gKHRoYXQsIGV2ZW50TmFtZSwgZXZlbnRTcGVjKSB7XG4gICAgICAgIGZsdWlkLnB1c2hBY3Rpdml0eShcInJlc29sdmVFdmVudFwiLCBcInJlc29sdmluZyBldmVudCB3aXRoIG5hbWUgJWV2ZW50TmFtZSBhdHRhY2hlZCB0byBjb21wb25lbnQgJXRoYXRcIixcbiAgICAgICAgICAgIHtldmVudE5hbWU6IGV2ZW50TmFtZSwgdGhhdDogdGhhdH0pO1xuICAgICAgICB2YXIgYWRkZXIgPSBmbHVpZC5ldmVudC5tYWtlVHJhY2tlZExpc3RlbmVyQWRkZXIodGhhdCk7XG4gICAgICAgIGlmICh0eXBlb2YoZXZlbnRTcGVjKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZXZlbnRTcGVjID0ge2V2ZW50OiBldmVudFNwZWN9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBldmVudCA9IGV2ZW50U3BlYy5ldmVudCB8fCBldmVudFNwZWMuZXZlbnRzO1xuICAgICAgICBpZiAoIWV2ZW50KSB7XG4gICAgICAgICAgICBmbHVpZC5mYWlsKFwiRXZlbnQgc3BlY2lmaWNhdGlvbiBmb3IgZXZlbnQgd2l0aCBuYW1lIFwiICsgZXZlbnROYW1lICsgXCIgZG9lcyBub3QgaW5jbHVkZSBhIGJhc2UgZXZlbnQgc3BlY2lmaWNhdGlvbjogXCIsIGV2ZW50U3BlYyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3JpZ2luID0gZmx1aWQuZXZlbnQuZXhwYW5kRXZlbnRzKHRoYXQsIGV2ZW50KTtcblxuICAgICAgICB2YXIgaXNNdWx0aXBsZSA9IG9yaWdpbi50eXBlTmFtZSAhPT0gXCJmbHVpZC5ldmVudC5maXJlclwiO1xuICAgICAgICB2YXIgaXNDb21wb3NpdGUgPSBldmVudFNwZWMuYXJncyB8fCBpc011bHRpcGxlO1xuICAgICAgICAvLyBJZiBcImV2ZW50XCIgaXMgbm90IGNvbXBvc2l0ZSwgd2Ugd2FudCB0byBzaGFyZSB0aGUgbGlzdGVuZXIgbGlzdCBhbmQgRklSRSBtZXRob2Qgd2l0aCB0aGUgb3JpZ2luYWxcbiAgICAgICAgLy8gSWYgXCJldmVudFwiIGlzIGNvbXBvc2l0ZSwgd2UgbmVlZCB0byBjcmVhdGUgYSBuZXcgZmlyZXIuIFwiY29tcG9zaXRlXCIgaW5jbHVkZXMgY2FzZSB3aGVyZSBhbnkgYm9pbGluZ1xuICAgICAgICAvLyBvY2N1cnJlZCAtIHRoaXMgd2FzIGltcGxlbWVudGVkIHdyb25nbHkgaW4gMS40LlxuICAgICAgICB2YXIgZmlyZXI7XG4gICAgICAgIGlmIChpc0NvbXBvc2l0ZSkge1xuICAgICAgICAgICAgZmlyZXIgPSBmbHVpZC5tYWtlRXZlbnRGaXJlcih7bmFtZTogXCIgW2NvbXBvc2l0ZV0gXCIgKyBmbHVpZC5ldmVudC5uYW1lRXZlbnQodGhhdCwgZXZlbnROYW1lKX0pO1xuICAgICAgICAgICAgdmFyIGRpc3BhdGNoZXIgPSBmbHVpZC5ldmVudC5kaXNwYXRjaExpc3RlbmVyKHRoYXQsIGZpcmVyLmZpcmUsIGV2ZW50TmFtZSwgZXZlbnRTcGVjLCBpc011bHRpcGxlKTtcbiAgICAgICAgICAgIGlmIChpc011bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgZmx1aWQuZXZlbnQubGlzdGVuZXJFbmdpbmUob3JpZ2luLCBkaXNwYXRjaGVyLCBhZGRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGRlcihvcmlnaW4pLmFkZExpc3RlbmVyKGRpc3BhdGNoZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZmlyZXIgPSB7dHlwZU5hbWU6IFwiZmx1aWQuZXZlbnQuZmlyZXJcIn07IC8vIGpzbGludDpvayAtIGFscmVhZHkgZGVmaW5lZFxuICAgICAgICAgICAgZmlyZXIuZmlyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3V0ZXJBcmdzID0gZmx1aWQubWFrZUFycmF5KGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgZmx1aWQucHVzaEFjdGl2aXR5KFwiZmlyZVN5bnRoZXRpY1wiLCBcImZpcmluZyBzeW50aGV0aWMgZXZlbnQgJWV2ZW50TmFtZSBcIiwge2V2ZW50TmFtZTogZXZlbnROYW1lfSk7XG4gICAgICAgICAgICAgICAgdmFyIHRvZ28gPSBvcmlnaW4uZmlyZS5hcHBseShudWxsLCBvdXRlckFyZ3MpO1xuICAgICAgICAgICAgICAgIGZsdWlkLnBvcEFjdGl2aXR5KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvZ287XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZmlyZXIuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiAobGlzdGVuZXIsIG5hbWVzcGFjZSwgcHJlZGljYXRlLCBwcmlvcml0eSwgc29mdE5hbWVzcGFjZSkge1xuICAgICAgICAgICAgICAgIHZhciBkaXNwYXRjaGVyID0gZmx1aWQuZXZlbnQuZGlzcGF0Y2hMaXN0ZW5lcih0aGF0LCBsaXN0ZW5lciwgZXZlbnROYW1lLCBldmVudFNwZWMpO1xuICAgICAgICAgICAgICAgIGFkZGVyKG9yaWdpbikuYWRkTGlzdGVuZXIoZGlzcGF0Y2hlciwgbmFtZXNwYWNlLCBwcmVkaWNhdGUsIHByaW9yaXR5LCBzb2Z0TmFtZXNwYWNlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmaXJlci5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIG9yaWdpbi5yZW1vdmVMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZsdWlkLnBvcEFjdGl2aXR5KCk7XG4gICAgICAgIHJldHVybiBmaXJlcjtcbiAgICB9O1xuXG4gICAgLyoqIEJFR0lOIHVub2ZmaWNpYWwgSW9DIG1hdGVyaWFsICoqL1xuICAgIC8vIEFsdGhvdWdoIHRoZSBmb2xsb3dpbmcgdGhyZWUgZnVuY3Rpb25zIGFyZSB1bnN1cHBvcnRlZCBhbmQgbm90IHBhcnQgb2YgdGhlIElvQ1xuICAgIC8vIGltcGxlbWVudGF0aW9uIHByb3BlciwgdGhleSBhcmUgc3RpbGwgdXNlZCBpbiB0aGUgcmVuZGVyZXJcbiAgICAvLyBleHBhbmRlciBhcyB3ZWxsIGFzIGluIHNvbWUgb2xkLXN0eWxlIHRlc3RzIGFuZCB2YXJpb3VzIHBsYWNlcyBpbiBDU3BhY2UuXG5cbiAgICAvLyB1bnN1cHBvcnRlZCwgbm9uLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLndpdGhFbnZpcm9ubWVudCA9IGZ1bmN0aW9uIChlbnZBZGQsIGZ1bmMsIHJvb3QpIHtcbiAgICAgICAgcm9vdCA9IHJvb3QgfHwgZmx1aWQuZ2xvYmFsVGhyZWFkTG9jYWwoKTtcbiAgICAgICAgcmV0dXJuIGZsdWlkLnRyeUNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGVudkFkZCkge1xuICAgICAgICAgICAgICAgIHJvb3Rba2V5XSA9IGVudkFkZFtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJC5leHRlbmQocm9vdCwgZW52QWRkKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jKCk7XG4gICAgICAgIH0sIG51bGwsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGVudkFkZCkgeyAvLyBqc2xpbnQ6b2sgZHVwbGljYXRlIFwidmFsdWVcIlxuICAgICAgICAgICAgICAgIGRlbGV0ZSByb290W2tleV07IC8vIFRPRE86IHVzZXJzIG1heSB3YW50IGEgcmVjdXJzaXZlIFwic2NvcGluZ1wiIG1vZGVsXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyB1bnN1cHBvcnRlZCwgTk9OLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLmZldGNoQ29udGV4dFJlZmVyZW5jZSA9IGZ1bmN0aW9uIChwYXJzZWQsIGRpcmVjdE1vZGVsLCBlbnYsIGVsUmVzb2x2ZXIsIGV4dGVybmFsRmV0Y2hlcikge1xuICAgICAgICAvLyBUaGUgXCJlbFJlc29sdmVyXCIgaXMgYSBoYWNrIHRvIG1ha2UgY2VydGFpbiBjb21tb24gaWRpb21zIGluIHByb3RvVHJlZXMgd29yayBjb3JyZWN0bHksIHdoZXJlIGEgY29udGV4dHVhbGlzZWQgRUxcbiAgICAgICAgLy8gcGF0aCBhY3R1YWxseSByZXNvbHZlcyBvbnRvIGEgZnVydGhlciBFTCByZWZlcmVuY2UgcmF0aGVyIHRoYW4gZGlyZWN0bHkgb250byBhIHZhbHVlIHRhcmdldFxuICAgICAgICBpZiAoZWxSZXNvbHZlcikge1xuICAgICAgICAgICAgcGFyc2VkID0gZWxSZXNvbHZlcihwYXJzZWQsIGVudik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJhc2UgPSBwYXJzZWQuY29udGV4dD8gZW52W3BhcnNlZC5jb250ZXh0XSA6IGRpcmVjdE1vZGVsO1xuICAgICAgICBpZiAoIWJhc2UpIHtcbiAgICAgICAgICAgIHZhciByZXNvbHZlRXh0ZXJuYWwgPSBleHRlcm5hbEZldGNoZXIgJiYgZXh0ZXJuYWxGZXRjaGVyKHBhcnNlZCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZUV4dGVybmFsIHx8IGJhc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlZC5ub0RlcmVmZXJlbmNlPyBwYXJzZWQucGF0aCA6IGZsdWlkLmdldChiYXNlLCBwYXJzZWQucGF0aCk7XG4gICAgfTtcblxuICAgIC8vIHVuc3VwcG9ydGVkLCBub24tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQubWFrZUVudmlyb25tZW50RmV0Y2hlciA9IGZ1bmN0aW9uIChkaXJlY3RNb2RlbCwgZWxSZXNvbHZlciwgZW52R2V0dGVyLCBleHRlcm5hbEZldGNoZXIpIHtcbiAgICAgICAgZW52R2V0dGVyID0gZW52R2V0dGVyIHx8IGZsdWlkLmdsb2JhbFRocmVhZExvY2FsO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ocGFyc2VkKSB7XG4gICAgICAgICAgICB2YXIgZW52ID0gZW52R2V0dGVyKCk7XG4gICAgICAgICAgICByZXR1cm4gZmx1aWQuZmV0Y2hDb250ZXh0UmVmZXJlbmNlKHBhcnNlZCwgZGlyZWN0TW9kZWwsIGVudiwgZWxSZXNvbHZlciwgZXh0ZXJuYWxGZXRjaGVyKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqIEVORCBvZiB1bm9mZmljaWFsIElvQyBtYXRlcmlhbCAqKi9cblxuICAgIC8vIHVuc3VwcG9ydGVkLCBub24tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQuY29lcmNlVG9QcmltaXRpdmUgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcgPT09IFwiZmFsc2VcIiA/IGZhbHNlIDogKHN0cmluZyA9PT0gXCJ0cnVlXCIgPyB0cnVlIDpcbiAgICAgICAgICAgIChpc0Zpbml0ZShzdHJpbmcpID8gTnVtYmVyKHN0cmluZykgOiBzdHJpbmcpKTtcbiAgICB9O1xuXG4gICAgLy8gdW5zdXBwb3J0ZWQsIG5vbi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5jb21wYWN0U3RyaW5nVG9SZWMgPSBmdW5jdGlvbiAoc3RyaW5nLCB0eXBlKSB7XG4gICAgICAgIHZhciBvcGVuUG9zID0gc3RyaW5nLmluZGV4T2YoXCIoXCIpO1xuICAgICAgICB2YXIgY2xvc2VQb3MgPSBzdHJpbmcuaW5kZXhPZihcIilcIik7XG4gICAgICAgIGlmIChvcGVuUG9zID09PSAtMSBeIGNsb3NlUG9zID09PSAtMSB8fCBvcGVuUG9zID4gY2xvc2VQb3MpIHtcbiAgICAgICAgICAgIGZsdWlkLmZhaWwoXCJCYWRseS1mb3JtZWQgY29tcGFjdCBcIiArIHR5cGUgKyBcIiByZWNvcmQgd2l0aG91dCBtYXRjaGluZyBwYXJlbnRoZXNlczogXCIsIHN0cmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wZW5Qb3MgIT09IC0xICYmIGNsb3NlUG9zICE9PSAtMSkge1xuICAgICAgICAgICAgdmFyIHByZWZpeCA9IHN0cmluZy5zdWJzdHJpbmcoMCwgb3BlblBvcyk7XG4gICAgICAgICAgICB2YXIgYm9keSA9IHN0cmluZy5zdWJzdHJpbmcob3BlblBvcyArIDEsIGNsb3NlUG9zKTtcbiAgICAgICAgICAgIHZhciBhcmdzID0gZmx1aWQudHJhbnNmb3JtKGJvZHkuc3BsaXQoXCIsXCIpLCAkLnRyaW0sIGZsdWlkLmNvZXJjZVRvUHJpbWl0aXZlKTtcbiAgICAgICAgICAgIHZhciB0b2dvID0ge1xuICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJpbnZva2VyXCIgJiYgcHJlZml4LmNoYXJBdChvcGVuUG9zIC0gMSkgPT09IFwiIVwiKSB7XG4gICAgICAgICAgICAgICAgcHJlZml4ID0gc3RyaW5nLnN1YnN0cmluZygwLCBvcGVuUG9zIC0gMSk7XG4gICAgICAgICAgICAgICAgdG9nby5keW5hbWljID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvZ29bcHJlZml4LmNoYXJBdCgwKSA9PT0gXCJ7XCIgPyBcImZ1bmNcIiA6IFwiZnVuY05hbWVcIl0gPSBwcmVmaXg7XG4gICAgICAgICAgICByZXR1cm4gdG9nbztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSBcImV4cGFuZGVyXCIpIHtcbiAgICAgICAgICAgIGZsdWlkLmZhaWwoXCJCYWRseS1mb3JtZWQgY29tcGFjdCBleHBhbmRlciByZWNvcmQgd2l0aG91dCBwYXJlbnRoZXNlczogXCIsIHN0cmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICB9O1xuXG4gICAgZmx1aWQuZXhwYW5kUHJlZml4ID0gXCJAZXhwYW5kOlwiO1xuICAgIC8vIHVuc3VwcG9ydGVkLCBub24tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQuZXhwYW5kQ29tcGFjdFN0cmluZyA9IGZ1bmN0aW9uIChzdHJpbmcsIGFjdGl2ZSkge1xuICAgICAgICB2YXIgcmVjID0gc3RyaW5nO1xuICAgICAgICBpZiAoc3RyaW5nLmluZGV4T2YoZmx1aWQuZXhwYW5kUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgdmFyIHJlbSA9IHN0cmluZy5zdWJzdHJpbmcoZmx1aWQuZXhwYW5kUHJlZml4Lmxlbmd0aCk7XG4gICAgICAgICAgICByZWMgPSB7XG4gICAgICAgICAgICAgICAgZXhwYW5kZXI6IGZsdWlkLmNvbXBhY3RTdHJpbmdUb1JlYyhyZW0sIFwiZXhwYW5kZXJcIilcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWN0aXZlKSB7XG4gICAgICAgICAgICByZWMgPSBmbHVpZC5jb21wYWN0U3RyaW5nVG9SZWMoc3RyaW5nLCBhY3RpdmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWM7XG4gICAgfTtcblxuICAgIHZhciBzaW5ndWxhclBlblJlY29yZCA9IHtcbiAgICAgICAgbGlzdGVuZXJzOiBcImxpc3RlbmVyXCIsXG4gICAgICAgIG1vZGVsTGlzdGVuZXJzOiBcIm1vZGVsTGlzdGVuZXJcIlxuICAgIH07XG5cbiAgICB2YXIgc2luZ3VsYXJSZWNvcmQgPSAkLmV4dGVuZCh7XG4gICAgICAgIGludm9rZXJzOiBcImludm9rZXJcIlxuICAgIH0sIHNpbmd1bGFyUGVuUmVjb3JkKTtcblxuICAgIC8vIHVuc3VwcG9ydGVkLCBub24tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQuZXhwYW5kQ29tcGFjdFJlYyA9IGZ1bmN0aW9uIChzZWdzLCB0YXJnZXQsIHNvdXJjZSwgdXNlck9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHBlbiA9IHNlZ3MubGVuZ3RoID4gMCA/IHNlZ3Nbc2Vncy5sZW5ndGggLSAxXSA6IFwiXCI7XG4gICAgICAgIHZhciBhY3RpdmUgPSBzaW5ndWxhclJlY29yZFtwZW5dO1xuICAgICAgICBpZiAoIWFjdGl2ZSAmJiBzZWdzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGFjdGl2ZSA9IHNpbmd1bGFyUGVuUmVjb3JkW3NlZ3Nbc2Vncy5sZW5ndGggLSAyXV07IC8vIHN1cHBvcnQgYXJyYXkgb2YgbGlzdGVuZXJzIGFuZCBtb2RlbExpc3RlbmVyc1xuICAgICAgICB9XG4gICAgICAgIGZsdWlkLmVhY2goc291cmNlLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgICAgLy8gVE9ETzogaGFjayBoZXJlIHRvIGF2b2lkIGNvcnJ1cHRpbmcgb2xkLXN0eWxlIG1vZGVsIHJlZmVyZW5jZXMgd2hpY2ggd2VyZSBsaXN0ZWQgd2l0aCBcInByZXNlcnZlXCIgLSBlbGltaW5hdGUgdGhpcyBhbG9uZyB3aXRoIHRoYXQgbWVyZ2VQb2xpY3lcbiAgICAgICAgICAgIGlmIChmbHVpZC5pc1BsYWluT2JqZWN0KHZhbHVlKSAmJiAhZmx1aWQuaXNET01pc2godmFsdWUpICYmICEodXNlck9wdGlvbnMgJiYga2V5ID09PSBcIm1vZGVsXCIgJiYgc2Vncy5sZW5ndGggPT09IDApKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBmbHVpZC5mcmVzaENvbnRhaW5lcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgc2Vncy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgZmx1aWQuZXhwYW5kQ29tcGFjdFJlYyhzZWdzLCB0YXJnZXRba2V5XSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHNlZ3MucG9wKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gZmx1aWQuZXhwYW5kQ29tcGFjdFN0cmluZyh2YWx1ZSwgYWN0aXZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyB1bnN1cHBvcnRlZCwgbm9uLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLmV4cGFuZENvbXBhY3QgPSBmdW5jdGlvbiAob3B0aW9ucywgdXNlck9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHRvZ28gPSB7fTtcbiAgICAgICAgZmx1aWQuZXhwYW5kQ29tcGFjdFJlYyhbXSwgdG9nbywgb3B0aW9ucywgdXNlck9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdG9nbztcbiAgICB9O1xuXG4gICAgLy8gdW5zdXBwb3J0ZWQsIG5vbi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5leHRyYWN0RUwgPSBmdW5jdGlvbiAoc3RyaW5nLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zLkVMc3R5bGUgPT09IFwiQUxMXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5FTHN0eWxlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKHN0cmluZy5jaGFyQXQoMCkgPT09IG9wdGlvbnMuRUxzdHlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmcuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuRUxzdHlsZSA9PT0gXCIke31cIikge1xuICAgICAgICAgICAgdmFyIGkxID0gc3RyaW5nLmluZGV4T2YoXCIke1wiKTtcbiAgICAgICAgICAgIHZhciBpMiA9IHN0cmluZy5sYXN0SW5kZXhPZihcIn1cIik7XG4gICAgICAgICAgICBpZiAoaTEgPT09IDAgJiYgaTIgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5zdWJzdHJpbmcoMiwgaTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIHVuc3VwcG9ydGVkLCBub24tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQuZXh0cmFjdEVMV2l0aENvbnRleHQgPSBmdW5jdGlvbiAoc3RyaW5nLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBFTCA9IGZsdWlkLmV4dHJhY3RFTChzdHJpbmcsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoRUwgJiYgRUwuY2hhckF0KDApID09PSBcIntcIiAmJiBFTC5pbmRleE9mKFwifVwiKSA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmbHVpZC5wYXJzZUNvbnRleHRSZWZlcmVuY2UoRUwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBFTD8ge3BhdGg6IEVMfSA6IEVMO1xuICAgIH07XG5cbiAgICBmbHVpZC5wYXJzZUNvbnRleHRSZWZlcmVuY2UgPSBmdW5jdGlvbiAocmVmZXJlbmNlLCBpbmRleCwgZGVsaW1pdGVyKSB7XG4gICAgICAgIGluZGV4ID0gaW5kZXggfHwgMDtcbiAgICAgICAgdmFyIGVuZGNwb3MgPSByZWZlcmVuY2UuaW5kZXhPZihcIn1cIiwgaW5kZXggKyAxKTtcbiAgICAgICAgaWYgKGVuZGNwb3MgPT09IC0xKSB7XG4gICAgICAgICAgICBmbHVpZC5mYWlsKFwiQ2Fubm90IHBhcnNlIGNvbnRleHQgcmVmZXJlbmNlIFxcXCJcIiArIHJlZmVyZW5jZSArIFwiXFxcIjogTWFsZm9ybWVkIGNvbnRleHQgcmVmZXJlbmNlIHdpdGhvdXQgfVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29udGV4dCA9IHJlZmVyZW5jZS5zdWJzdHJpbmcoaW5kZXggKyAxLCBlbmRjcG9zKTtcbiAgICAgICAgdmFyIGVuZHBvcyA9IGRlbGltaXRlcj8gcmVmZXJlbmNlLmluZGV4T2YoZGVsaW1pdGVyLCBlbmRjcG9zICsgMSkgOiByZWZlcmVuY2UubGVuZ3RoO1xuICAgICAgICB2YXIgcGF0aCA9IHJlZmVyZW5jZS5zdWJzdHJpbmcoZW5kY3BvcyArIDEsIGVuZHBvcyk7XG4gICAgICAgIGlmIChwYXRoLmNoYXJBdCgwKSA9PT0gXCIuXCIpIHtcbiAgICAgICAgICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZygxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge2NvbnRleHQ6IGNvbnRleHQsIHBhdGg6IHBhdGgsIGVuZHBvczogZW5kcG9zfTtcbiAgICB9O1xuXG4gICAgZmx1aWQucmVuZGVyQ29udGV4dFJlZmVyZW5jZSA9IGZ1bmN0aW9uIChwYXJzZWQpIHtcbiAgICAgICAgcmV0dXJuIFwie1wiICsgcGFyc2VkLmNvbnRleHQgKyBcIn1cIiArIChwYXJzZWQucGF0aCA/IFwiLlwiICsgcGFyc2VkLnBhdGggOiBcIlwiKTtcbiAgICB9O1xuXG4gICAgLy8gdW5zdXBwb3J0ZWQsIG5vbi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5yZXNvbHZlQ29udGV4dFZhbHVlID0gZnVuY3Rpb24gKHN0cmluZywgb3B0aW9ucykge1xuICAgICAgICBmdW5jdGlvbiBmZXRjaChwYXJzZWQpIHtcbiAgICAgICAgICAgIGZsdWlkLnB1c2hBY3Rpdml0eShcInJlc29sdmVDb250ZXh0VmFsdWVcIiwgXCJyZXNvbHZpbmcgY29udGV4dCB2YWx1ZSAlc3RyaW5nXCIsIHtzdHJpbmc6IHN0cmluZ30pO1xuICAgICAgICAgICAgdmFyIHRvZ28gPSBvcHRpb25zLmZldGNoZXIocGFyc2VkKTtcbiAgICAgICAgICAgIGZsdWlkLnB1c2hBY3Rpdml0eShcInJlc29sdmVkQ29udGV4dFZhbHVlXCIsIFwicmVzb2x2ZWQgdmFsdWUgJXN0cmluZyB0byB2YWx1ZSAldmFsdWVcIiwge3N0cmluZzogc3RyaW5nLCB2YWx1ZTogdG9nb30pO1xuICAgICAgICAgICAgZmx1aWQucG9wQWN0aXZpdHkoMik7XG4gICAgICAgICAgICByZXR1cm4gdG9nbztcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFyc2VkO1xuICAgICAgICBpZiAob3B0aW9ucy5iYXJlQ29udGV4dFJlZnMgJiYgc3RyaW5nLmNoYXJBdCgwKSA9PT0gXCJ7XCIgJiYgc3RyaW5nLmluZGV4T2YoXCJ9XCIpID4gMCkge1xuICAgICAgICAgICAgcGFyc2VkID0gZmx1aWQucGFyc2VDb250ZXh0UmVmZXJlbmNlKHN0cmluZyk7XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2gocGFyc2VkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLkVMc3R5bGUgJiYgb3B0aW9ucy5FTHN0eWxlICE9PSBcIiR7fVwiKSB7XG4gICAgICAgICAgICBwYXJzZWQgPSBmbHVpZC5leHRyYWN0RUxXaXRoQ29udGV4dChzdHJpbmcsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmZXRjaChwYXJzZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0eXBlb2Yoc3RyaW5nKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdmFyIGkxID0gc3RyaW5nLmluZGV4T2YoXCIke1wiKTtcbiAgICAgICAgICAgIHZhciBpMiA9IHN0cmluZy5pbmRleE9mKFwifVwiLCBpMSArIDIpO1xuICAgICAgICAgICAgaWYgKGkxICE9PSAtMSAmJiBpMiAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RyaW5nLmNoYXJBdChpMSArIDIpID09PSBcIntcIikge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWQgPSBmbHVpZC5wYXJzZUNvbnRleHRSZWZlcmVuY2Uoc3RyaW5nLCBpMSArIDIsIFwifVwiKTtcbiAgICAgICAgICAgICAgICAgICAgaTIgPSBwYXJzZWQuZW5kcG9zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkID0ge3BhdGg6IHN0cmluZy5zdWJzdHJpbmcoaTEgKyAyLCBpMil9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgc3VicyA9IGZldGNoKHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgdmFyIGFsbCA9IChpMSA9PT0gMCAmJiBpMiA9PT0gc3RyaW5nLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IHRlc3QgY2FzZSBmb3IgYWxsIHVuZGVmaW5lZCBzdWJzdGl0dXRpb25cbiAgICAgICAgICAgICAgICBpZiAoc3VicyA9PT0gdW5kZWZpbmVkIHx8IHN1YnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1YnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0cmluZyA9IGFsbD8gc3VicyA6IHN0cmluZy5zdWJzdHJpbmcoMCwgaTEpICsgc3VicyArIHN0cmluZy5zdWJzdHJpbmcoaTIgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfTtcblxuICAgIC8vIHVuc3VwcG9ydGVkLCBOT04tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQuZXhwYW5kRXhwYW5kZXIgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGV4cGFuZGVyID0gZmx1aWQuZ2V0R2xvYmFsVmFsdWUoc291cmNlLmV4cGFuZGVyLnR5cGUgfHwgXCJmbHVpZC5kZWZlcnJlZEludm9rZUNhbGxcIik7XG4gICAgICAgIGlmIChleHBhbmRlcikge1xuICAgICAgICAgICAgcmV0dXJuIGV4cGFuZGVyLmNhbGwobnVsbCwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYXBwZWFycyBzb21ld2hhdCByZXVzYWJsZSwgYnV0IG5vdCBlbnRpcmVseSAtIGl0IHByb2JhYmx5IG5lZWRzIHRvIGJlIHBhY2thZ2VkXG4gICAgLy8gYWxvbmcgd2l0aCB0aGUgcGFydGljdWxhciBcInN0cmF0ZWd5XCIuIFZlcnkgc2ltaWxhciB0byB0aGUgb2xkIFwiZmlsdGVyXCIuLi4gdGhlIFwib3V0ZXIgZHJpdmVyXCIgbmVlZHNcbiAgICAvLyB0byBleGVjdXRlIGl0IHRvIGdldCB0aGUgZmlyc3QgcmVjdXJzaW9uIGdvaW5nIGF0IHRvcCBsZXZlbC4gVGhpcyB3YXMgb25lIG9mIHRoZSBtb3N0IG9kZCByZXN1bHRzXG4gICAgLy8gb2YgdGhlIHJlb3JnYW5pc2F0aW9uLCBzaW5jZSB0aGUgXCJvbGQgd29ya1wiIHNlZW1lZCBtdWNoIG1vcmUgbmF0dXJhbGx5IGV4cHJlc3NlZCBpbiB0ZXJtcyBvZiB2YWx1ZXNcbiAgICAvLyBhbmQgd2hhdCBoYXBwZW5lZCB0byB0aGVtLiBUaGUgXCJuZXcgd29ya1wiIGlzIGV4cHJlc3NlZCBpbiB0ZXJtcyBvZiBwYXRocyBhbmQgaG93IHRvIG1vdmUgYW1vbmdzdCB0aGVtLlxuICAgIGZsdWlkLmZldGNoRXhwYW5kQ2hpbGRyZW4gPSBmdW5jdGlvbiAodGFyZ2V0LCBpLCBzZWdzLCBzb3VyY2UsIG1lcmdlUG9saWN5LCBtaW5pV29ybGQsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHNvdXJjZS5leHBhbmRlciAvKiAmJiBzb3VyY2UuZXhwYW5kZXIudHlwZSAqLykgeyAvLyBwb3NzaWJsZSBleHBhbmRlciBhdCB0b3AgbGV2ZWxcbiAgICAgICAgICAgIHZhciBleHBhbmRlZCA9IGZsdWlkLmV4cGFuZEV4cGFuZGVyKHRhcmdldCwgc291cmNlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmZyZWVSb290IHx8IGZsdWlkLmlzUHJpbWl0aXZlKGV4cGFuZGVkKSB8fCBmbHVpZC5pc0RPTWlzaChleHBhbmRlZCkgfHwgIWZsdWlkLmlzUGxhaW5PYmplY3QoZXhwYW5kZWQpIHx8IChmbHVpZC5pc0FycmF5YWJsZShleHBhbmRlZCkgXiBmbHVpZC5pc0FycmF5YWJsZSh0YXJnZXQpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBleHBhbmRlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyAvLyBtYWtlIGFuIGF0dGVtcHQgdG8gcHJlc2VydmUgdGhlIHJvb3QgcmVmZXJlbmNlIGlmIHBvc3NpYmxlXG4gICAgICAgICAgICAgICAgJC5leHRlbmQodHJ1ZSwgdGFyZ2V0LCBleHBhbmRlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTk9URSEgVGhpcyBleHBlY3RzIHRoYXQgUkhTIGlzIGNvbmNyZXRlISBGb3IgbWF0ZXJpYWwgaW5wdXQgdG8gXCJleHBhbnNpb25cIiB0aGlzIGhhcHBlbnMgdG8gYmUgdGhlIGNhc2UsIGJ1dCBpcyBub3RcbiAgICAgICAgLy8gdHJ1ZSBmb3Igb3RoZXIgYWxnb3JpdGhtcy4gSW5jb25zaXN0ZW50bHksIHRoaXMgYWxnb3JpdGhtIHVzZXMgXCJzb3VyY2VTdHJhdGVneVwiIGJlbG93LiBJbiBmYWN0LCB0aGlzIFwiZmV0Y2hDaGlsZHJlblwiXG4gICAgICAgIC8vIG9wZXJhdGlvbiBsb29rcyBsaWtlIGl0IGlzIGEgZnVuZGFtZW50YWwgcHJpbWl0aXZlIG9mIHRoZSBzeXN0ZW0uIFdlIGRvIGNhbGwgXCJkZWxpdmVyZXJcIiBlYXJseSB3aGljaCBlbmFibGVzIGNvcnJlY3RcbiAgICAgICAgLy8gcmVmZXJlbmNlIHRvIHBhcmVudCBub2RlcyB1cCB0aGUgdHJlZSAtIGhvd2V2ZXIsIGFueW9uZSBwcm9jZXNzaW5nIGEgdHJlZSBJTiBUSEUgQ0hBSU4gcmVxdWlyZXMgdGhhdCBpdCBpcyBwcm9kdWNlZFxuICAgICAgICAvLyBjb25jcmV0ZWx5IGF0IHRoZSBwb2ludCBTVFJBVEVHWSByZXR1cm5zLiBXaGljaCBpbiBmYWN0IGl0IGlzLi4uLi4uLi4uLi4uLi4uXG4gICAgICAgIGZsdWlkLmVhY2goc291cmNlLCBmdW5jdGlvbiAobmV3U291cmNlLCBrZXkpIHtcbiAgICAgICAgICAgIGlmIChuZXdTb3VyY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gdW5kZWZpbmVkOyAvLyBhdm9pZCBldmVyIGRpc3BhdGNoaW5nIHRvIG91cnNlbHZlcyB3aXRoIHVuZGVmaW5lZCBzb3VyY2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gXCJleHBhbmRlclwiKSB7XG4gICAgICAgICAgICAgICAgc2Vnc1tpXSA9IGtleTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnN0cmF0ZWd5KHRhcmdldCwga2V5LCBpICsgMSwgc2Vncywgc291cmNlLCBtZXJnZVBvbGljeSwgbWluaVdvcmxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfTtcblxuICAgIC8vIFRPRE86IFRoaXMgbWV0aG9kIGlzIHVubmVjZXNzYXJ5IGFuZCB3aWxsIHF1YWRyYXRpYyBpbmVmZmljaWVuY3kgaWYgUkhTIGJsb2NrIGlzIG5vdCBjb25jcmV0ZS5cbiAgICAvLyBUaGUgZHJpdmVyIHNob3VsZCBkZXRlY3QgXCJob21vZ2VuZW91cyB1bmktc3RyYXRlZ3kgdHJ1bmRsaW5nXCIgYW5kIGFncmVlIHRvIHByZXNlcnZlIHRoZSBleHRyYVxuICAgIC8vIFwiY3Vyc29yIGFyZ3VtZW50c1wiIHdoaWNoIHNob3VsZCBiZSBhZHZlcnRpc2VkIHNvbWVob3cgKGF0IGxlYXN0IHRoZWlyIG51bWJlcilcbiAgICBmdW5jdGlvbiByZWdlbmVyYXRlQ3Vyc29yIChzb3VyY2UsIHNlZ3MsIGxpbWl0LCBzb3VyY2VTdHJhdGVneSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbWl0OyArKyBpKSB7XG4gICAgICAgICAgICAvLyBjb3B5IHNlZ3MgdG8gYXZvaWQgYWxpYXNpbmcgd2l0aCBGTFVJRC01MjQzXG4gICAgICAgICAgICBzb3VyY2UgPSBzb3VyY2VTdHJhdGVneShzb3VyY2UsIHNlZ3NbaV0sIGksIGZsdWlkLm1ha2VBcnJheShzZWdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9XG5cbiAgICAvLyB1bnN1cHBvcnRlZCwgTk9OLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLmlzVW5leHBhbmRhYmxlID0gZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gZmx1aWQuaXNQcmltaXRpdmUoc291cmNlKSB8fCBmbHVpZC5pc0NvbXBvbmVudChzb3VyY2UpIHx8IHNvdXJjZS5ub2RlVHlwZSAhPT0gdW5kZWZpbmVkIHx8IHNvdXJjZS5qcXVlcnkgfHwgIWZsdWlkLmlzUGxhaW5PYmplY3Qoc291cmNlKTtcbiAgICB9O1xuXG4gICAgLy8gdW5zdXBwb3J0ZWQsIE5PTi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5leHBhbmRTb3VyY2UgPSBmdW5jdGlvbiAob3B0aW9ucywgdGFyZ2V0LCBpLCBzZWdzLCBkZWxpdmVyZXIsIHNvdXJjZSwgcG9saWN5LCBtaW5pV29ybGQsIHJlY3Vyc2UpIHtcbiAgICAgICAgdmFyIGV4cGFuZGVkLCBpc1RydW5rLCBpc0xhdGU7XG4gICAgICAgIHZhciB0aGlzUG9saWN5ID0gZmx1aWQuZGVyZWZNZXJnZVBvbGljeShwb2xpY3kpO1xuICAgICAgICBpZiAodHlwZW9mIChzb3VyY2UpID09PSBcInN0cmluZ1wiICYmICF0aGlzUG9saWN5Lm5vZXhwYW5kKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuZGVmYXVsdEVMIHx8IHNvdXJjZS5jaGFyQXQoMCkgPT09IFwie1wiKSB7IC8vIGhhcmQtY29kZSB0aGlzIGZvciBwZXJmb3JtYW5jZVxuICAgICAgICAgICAgICAgIGZsdWlkLnB1c2hBY3Rpdml0eShcImV4cGFuZENvbnRleHRWYWx1ZVwiLCBcImV4cGFuZGluZyBjb250ZXh0IHZhbHVlICVzb3VyY2UgaGVsZCBhdCBwYXRoICVwYXRoXCIsIHtzb3VyY2U6IHNvdXJjZSwgcGF0aDogZmx1aWQucGF0aC5hcHBseShudWxsLCBzZWdzLnNsaWNlKDAsIGkpKX0pO1xuICAgICAgICAgICAgICAgIGV4cGFuZGVkID0gZmx1aWQucmVzb2x2ZUNvbnRleHRWYWx1ZShzb3VyY2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGZsdWlkLnBvcEFjdGl2aXR5KDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBleHBhbmRlZCA9IHNvdXJjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzUG9saWN5Lm5vZXhwYW5kIHx8IGZsdWlkLmlzVW5leHBhbmRhYmxlKHNvdXJjZSkpIHtcbiAgICAgICAgICAgIGV4cGFuZGVkID0gc291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNvdXJjZS5leHBhbmRlcikge1xuICAgICAgICAgICAgZXhwYW5kZWQgPSBmbHVpZC5leHBhbmRFeHBhbmRlcihkZWxpdmVyZXIsIHNvdXJjZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpc1BvbGljeS5wcmVzZXJ2ZSkge1xuICAgICAgICAgICAgICAgIGV4cGFuZGVkID0gc291cmNlO1xuICAgICAgICAgICAgICAgIGlzTGF0ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBleHBhbmRlZCA9IGZsdWlkLmZyZXNoQ29udGFpbmVyKHNvdXJjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpc1RydW5rID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzTGF0ZSAmJiBleHBhbmRlZCAhPT0gZmx1aWQuTk9fVkFMVUUpIHtcbiAgICAgICAgICAgIGRlbGl2ZXJlcihleHBhbmRlZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVHJ1bmspIHtcbiAgICAgICAgICAgIHJlY3Vyc2UoZXhwYW5kZWQsIHNvdXJjZSwgaSwgc2VncywgcG9saWN5LCBtaW5pV29ybGQgfHwgaXNMYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNMYXRlICYmIGV4cGFuZGVkICE9PSBmbHVpZC5OT19WQUxVRSkge1xuICAgICAgICAgICAgZGVsaXZlcmVyKGV4cGFuZGVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwYW5kZWQ7XG4gICAgfTtcblxuICAgIC8vIHVuc3VwcG9ydGVkLCBOT04tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQubWFrZUV4cGFuZFN0cmF0ZWd5ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlY3Vyc2UgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UsIGksIHNlZ3MsIHBvbGljeSwgbWluaVdvcmxkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmx1aWQuZmV0Y2hFeHBhbmRDaGlsZHJlbih0YXJnZXQsIGkgfHwgMCwgc2VncyB8fCBbXSwgc291cmNlLCBwb2xpY3ksIG1pbmlXb3JsZCwgb3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBzdHJhdGVneSA9IGZ1bmN0aW9uICh0YXJnZXQsIG5hbWUsIGksIHNlZ3MsIHNvdXJjZSwgcG9saWN5LCBtaW5pV29ybGQpIHtcbiAgICAgICAgICAgIGlmIChpID4gZmx1aWQuc3RyYXRlZ3lSZWN1cnNpb25CYWlsb3V0KSB7XG4gICAgICAgICAgICAgICAgZmx1aWQuZmFpbChcIk92ZXJmbG93L2NpcmN1bGFyaXR5IGluIG9wdGlvbnMgZXhwYW5zaW9uLCBjdXJyZW50IHBhdGggaXMgXCIsIHNlZ3MsIFwiIGF0IGRlcHRoIFwiICwgaSwgXCIgLSBwbGVhc2UgZW5zdXJlIG9wdGlvbnMgYXJlIG5vdCBjaXJjdWxhcmx5IGNvbm5lY3RlZCwgb3IgcHJvdGVjdCBmcm9tIGV4cGFuc2lvbiB1c2luZyB0aGUgXFxcIm5vZXhwYW5kXFxcIiBwb2xpY3kgb3IgZXhwYW5kZXJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbWluaVdvcmxkICYmIHRhcmdldC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkgeyAvLyBiYWlsIG91dCBpZiBvdXIgd29yayBoYXMgYWxyZWFkeSBiZWVuIGRvbmVcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0W25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNvdXJjZSA9PT0gdW5kZWZpbmVkKSB7IC8vIHJlY292ZXIgb3VyIHN0YXRlIGluIGNhc2UgdGhpcyBpcyBhbiBleHRlcm5hbCBlbnRyeSBwb2ludFxuICAgICAgICAgICAgICAgIHNvdXJjZSA9IHJlZ2VuZXJhdGVDdXJzb3Iob3B0aW9ucy5zb3VyY2UsIHNlZ3MsIGkgLSAxLCBvcHRpb25zLnNvdXJjZVN0cmF0ZWd5KTtcbiAgICAgICAgICAgICAgICBwb2xpY3kgPSByZWdlbmVyYXRlQ3Vyc29yKG9wdGlvbnMubWVyZ2VQb2xpY3ksIHNlZ3MsIGkgLSAxLCBmbHVpZC5jb25jcmV0ZVRydW5kbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0aGlzU291cmNlID0gb3B0aW9ucy5zb3VyY2VTdHJhdGVneShzb3VyY2UsIG5hbWUsIGksIHNlZ3MpO1xuICAgICAgICAgICAgdmFyIHRoaXNQb2xpY3kgPSBmbHVpZC5jb25jcmV0ZVRydW5kbGVyKHBvbGljeSwgbmFtZSk7XG4gICAgICAgICAgICBmdW5jdGlvbiBkZWxpdmVyZXIodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmbHVpZC5leHBhbmRTb3VyY2Uob3B0aW9ucywgdGFyZ2V0LCBpLCBzZWdzLCBkZWxpdmVyZXIsIHRoaXNTb3VyY2UsIHRoaXNQb2xpY3ksIG1pbmlXb3JsZCwgcmVjdXJzZSk7XG4gICAgICAgIH07XG4gICAgICAgIG9wdGlvbnMucmVjdXJzZSA9IHJlY3Vyc2U7XG4gICAgICAgIG9wdGlvbnMuc3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgICAgICAgcmV0dXJuIHN0cmF0ZWd5O1xuICAgIH07XG5cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsdWlkLm1ha2VFeHBhbmRPcHRpb25zXCIsIHtcbiAgICAgICAgRUxzdHlsZTogICAgICAgICAgXCIke31cIixcbiAgICAgICAgYmFyZUNvbnRleHRSZWZzOiAgdHJ1ZSxcbiAgICAgICAgdGFyZ2V0OiAgICAgICAgICAgZmx1aWQuaW5DcmVhdGlvbk1hcmtlclxuICAgIH0pO1xuXG4gICAgLy8gdW5zdXBwb3J0ZWQsIE5PTi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5tYWtlRXhwYW5kT3B0aW9ucyA9IGZ1bmN0aW9uIChzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBmbHVpZC5yYXdEZWZhdWx0cyhcImZsdWlkLm1ha2VFeHBhbmRPcHRpb25zXCIpLCBvcHRpb25zKTtcbiAgICAgICAgb3B0aW9ucy5kZWZhdWx0RUwgPSBvcHRpb25zLkVMU3R5bGUgPT09IFwiJHt9XCIgJiYgb3B0aW9ucy5iYXJlQ29udGV4dFJlZnM7IC8vIG9wdGltaXNhdGlvbiB0byBoZWxwIGV4cGFuZGVyXG4gICAgICAgIG9wdGlvbnMuZXhwYW5kU291cmNlID0gZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZsdWlkLmV4cGFuZFNvdXJjZShvcHRpb25zLCBudWxsLCAwLCBbXSwgZmx1aWQuaWRlbnRpdHksIHNvdXJjZSwgb3B0aW9ucy5tZXJnZVBvbGljeSwgZmFsc2UpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoIWZsdWlkLmlzVW5leHBhbmRhYmxlKHNvdXJjZSkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuc291cmNlID0gc291cmNlO1xuICAgICAgICAgICAgb3B0aW9ucy50YXJnZXQgPSBmbHVpZC5mcmVzaENvbnRhaW5lcihzb3VyY2UpO1xuICAgICAgICAgICAgb3B0aW9ucy5zb3VyY2VTdHJhdGVneSA9IG9wdGlvbnMuc291cmNlU3RyYXRlZ3kgfHwgZmx1aWQuY29uY3JldGVUcnVuZGxlcjtcbiAgICAgICAgICAgIGZsdWlkLm1ha2VFeHBhbmRTdHJhdGVneShvcHRpb25zKTtcbiAgICAgICAgICAgIG9wdGlvbnMuaW5pdHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnRhcmdldCA9IGZsdWlkLmZldGNoRXhwYW5kQ2hpbGRyZW4ob3B0aW9ucy50YXJnZXQsIDAsIFtdLCBvcHRpb25zLnNvdXJjZSwgb3B0aW9ucy5tZXJnZVBvbGljeSwgZmFsc2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gdGhlc2UgaW5pdCBpbW1lZGlhdGVseSBzaW5jZSB3ZSBtdXN0IGRlbGl2ZXIgYSB2YWxpZCByb290IHRhcmdldFxuICAgICAgICAgICAgb3B0aW9ucy5zdHJhdGVneSA9IGZsdWlkLmNvbmNyZXRlVHJ1bmRsZXI7XG4gICAgICAgICAgICBvcHRpb25zLmluaXR0ZXIgPSBmbHVpZC5pZGVudGl0eTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yoc291cmNlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudGFyZ2V0ID0gb3B0aW9ucy5leHBhbmRTb3VyY2Uoc291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudGFyZ2V0ID0gc291cmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH07XG5cbiAgICBmbHVpZC5leHBhbmQgPSBmdW5jdGlvbiAoc291cmNlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBleHBhbmRPcHRpb25zID0gZmx1aWQubWFrZUV4cGFuZE9wdGlvbnMoc291cmNlLCBvcHRpb25zKTtcbiAgICAgICAgZXhwYW5kT3B0aW9ucy5pbml0dGVyKCk7XG4gICAgICAgIHJldHVybiBleHBhbmRPcHRpb25zLnRhcmdldDtcbiAgICB9O1xuXG4gICAgZmx1aWQucmVnaXN0ZXJOYW1lc3BhY2UoXCJmbHVpZC5leHBhbmRlclwiKTtcblxuICAgIC8qKiBcImxpZ2h0XCIgZXhwYW5kZXJzLCBzdGFydGluZyB3aXRoIHN1cHBvcnQgZnVuY3Rpb25zIGZvciB0aGUgc28tY2FsbGVkIFwiZGVmZXJyZWRDYWxsXCIgZXhwYW5kZXJzLFxuICAgICAgICAgd2hpY2ggbWFrZSBhbiBhcmJpdHJhcnkgZnVuY3Rpb24gY2FsbCAoYWZ0ZXIgZXhwYW5kaW5nIGFyZ3VtZW50cykgYW5kIGFyZSB0aGVuIHJlcGxhY2VkIGluXG4gICAgICAgICB0aGUgY29uZmlndXJhdGlvbiB3aXRoIHRoZSBjYWxsIHJlc3VsdHMuIFRoZXNlIHdpbGwgcHJvYmFibHkgYmUgYWJvbGlzaGVkIGFuZCByZXBsYWNlZCB3aXRoXG4gICAgICAgICBlcXVpdmFsZW50IG1vZGVsIHRyYW5zZm9ybWF0aW9uIG1hY2hpbmVyeSAqKi9cblxuICAgIGZsdWlkLmV4cGFuZGVyLmRlZmVycmVkQ2FsbCA9IGZ1bmN0aW9uIChkZWxpdmVyZXIsIHNvdXJjZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgZXhwYW5kZXIgPSBzb3VyY2UuZXhwYW5kZXI7XG4gICAgICAgIHZhciBhcmdzID0gKCFleHBhbmRlci5hcmdzIHx8IGZsdWlkLmlzQXJyYXlhYmxlKGV4cGFuZGVyLmFyZ3MpKT8gZXhwYW5kZXIuYXJncyA6IGZsdWlkLm1ha2VBcnJheShleHBhbmRlci5hcmdzKTtcbiAgICAgICAgYXJncyA9IG9wdGlvbnMucmVjdXJzZShbXSwgYXJncyk7XG4gICAgICAgIHJldHVybiBmbHVpZC5pbnZva2VHbG9iYWxGdW5jdGlvbihleHBhbmRlci5mdW5jLCBhcmdzKTtcbiAgICB9O1xuXG4gICAgZmx1aWQuZGVmZXJyZWRDYWxsID0gZmx1aWQuZXhwYW5kZXIuZGVmZXJyZWRDYWxsOyAvLyBwdXQgaW4gdG9wIG5hbWVzcGFjZSBmb3IgY29udmVuaWVuY2VcblxuICAgIC8vIFRoaXMgb25lIGlzIG5vdyBwb3NpdGlvbmVkIGFzIHRoZSBcInVuaXZlcnNhbCBleHBhbmRlclwiIC0gZGVmYXVsdCBpZiBubyB0eXBlIHN1cHBsaWVkXG4gICAgZmx1aWQuZGVmZXJyZWRJbnZva2VDYWxsID0gZnVuY3Rpb24gKGRlbGl2ZXJlciwgc291cmNlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBleHBhbmRlciA9IHNvdXJjZS5leHBhbmRlcjtcbiAgICAgICAgdmFyIGFyZ3MgPSBmbHVpZC5tYWtlQXJyYXkoZXhwYW5kZXIuYXJncyk7XG4gICAgICAgIGFyZ3MgPSBvcHRpb25zLnJlY3Vyc2UoW10sIGFyZ3MpOyAvLyBUT0RPOiByaXNrIG9mIGRvdWJsZSBleHBhbnNpb24gaGVyZS4gZW1ib2R5RGVtYW5kcyB3aWxsIHNvbWV0aW1lcyBleHBhbmQsIHNvbWV0aW1lcyBub3QuLi5cbiAgICAgICAgdmFyIGZ1bmNFbnRyeSA9IGV4cGFuZGVyLmZ1bmMgfHwgZXhwYW5kZXIuZnVuY05hbWU7XG4gICAgICAgIHZhciBmdW5jID0gb3B0aW9ucy5leHBhbmRTb3VyY2UoZnVuY0VudHJ5KSB8fCBmbHVpZC5yZWNvcmRUb0FwcGxpY2FibGUoZXhwYW5kZXIsIG9wdGlvbnMuY29udGV4dFRoYXQpO1xuICAgICAgICBpZiAoIWZ1bmMpIHtcbiAgICAgICAgICAgIGZsdWlkLmZhaWwoXCJFcnJvciBpbiBleHBhbmRlciByZWNvcmQgLSBcIiArIGZ1bmNFbnRyeSArIFwiIGNvdWxkIG5vdCBiZSByZXNvbHZlZCB0byBhIGZ1bmN0aW9uIGZvciBjb21wb25lbnQgXCIsIG9wdGlvbnMuY29udGV4dFRoYXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5ID8gZnVuYy5hcHBseShudWxsLCBhcmdzKSA6IGZsdWlkLmludm9rZShmdW5jLCBhcmdzLCBvcHRpb25zLmNvbnRleHRUaGF0KTtcbiAgICB9O1xuXG4gICAgLy8gVGhlIFwibm9leHBhbmRcIiBleHBhbmRlciB3aGljaCBzaW1wbHkgdW53cmFwcyBvbmUgbGV2ZWwgb2YgZXhwYW5zaW9uIGFuZCBjZWFzZXMuXG4gICAgZmx1aWQuZXhwYW5kZXIubm9leHBhbmQgPSBmdW5jdGlvbiAoZGVsaXZlcmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5leHBhbmRlci52YWx1ZSA/IHNvdXJjZS5leHBhbmRlci52YWx1ZSA6IHNvdXJjZS5leHBhbmRlci50cmVlO1xuICAgIH07XG5cbiAgICBmbHVpZC5ub2V4cGFuZCA9IGZsdWlkLmV4cGFuZGVyLm5vZXhwYW5kOyAvLyBUT0RPOiBjaGVjayBuYW1pbmcgYW5kIG5hbWVzcGFjaW5nXG5cblxufSkoalF1ZXJ5LCBmbHVpZF8yXzApO1xuOy8qXG5Db3B5cmlnaHQgMjAwOC0yMDEwIFVuaXZlcnNpdHkgb2YgQ2FtYnJpZGdlXG5Db3B5cmlnaHQgMjAwOC0yMDA5IFVuaXZlcnNpdHkgb2YgVG9yb250b1xuQ29weXJpZ2h0IDIwMTAtMjAxMSBMdWNlbmRvIERldmVsb3BtZW50IEx0ZC5cbkNvcHlyaWdodCAyMDEwLTIwMTQgT0NBRCBVbml2ZXJzaXR5XG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBFZHVjYXRpb25hbCBDb21tdW5pdHkgTGljZW5zZSAoRUNMKSwgVmVyc2lvbiAyLjAgb3IgdGhlIE5ld1xuQlNEIGxpY2Vuc2UuIFlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCBvbmUgdGhlc2VcbkxpY2Vuc2VzLlxuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIEVDTCAyLjAgTGljZW5zZSBhbmQgQlNEIExpY2Vuc2UgYXRcbmh0dHBzOi8vZ2l0aHViLmNvbS9mbHVpZC1wcm9qZWN0L2luZnVzaW9uL3Jhdy9tYXN0ZXIvSW5mdXNpb24tTElDRU5TRS50eHRcbiovXG5cbnZhciBmbHVpZF8yXzAgPSBmbHVpZF8yXzAgfHwge307XG5cbihmdW5jdGlvbiAoJCwgZmx1aWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8qKiBOT1RFOiBUaGUgY29udGVudHMgb2YgdGhpcyBmaWxlIGFyZSBieSBkZWZhdWx0IE5PVCBQQVJUIE9GIFRIRSBQVUJMSUMgRkxVSUQgQVBJIHVubGVzcyBleHBsaWNpdGx5IGFubm90YXRlZCBiZWZvcmUgdGhlIGZ1bmN0aW9uICoqL1xuXG4gICAgLyoqIE1PREVMIEFDQ0VTU09SIEVOR0lORSAqKi9cblxuICAgIC8qKiBTdGFuZGFyZCBzdHJhdGVnaWVzIGZvciByZXNvbHZpbmcgcGF0aCBzZWdtZW50cyAqKi9cblxuICAgIGZsdWlkLm1vZGVsLm1ha2VFbnZpcm9ubWVudFN0cmF0ZWd5ID0gZnVuY3Rpb24gKGVudmlyb25tZW50KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocm9vdCwgc2VnbWVudCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmRleCA9PT0gMCAmJiBlbnZpcm9ubWVudFtzZWdtZW50XSA/XG4gICAgICAgICAgICAgICAgZW52aXJvbm1lbnRbc2VnbWVudF0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIGZsdWlkLm1vZGVsLmRlZmF1bHRDcmVhdG9yU3RyYXRlZ3kgPSBmdW5jdGlvbiAocm9vdCwgc2VnbWVudCkge1xuICAgICAgICBpZiAocm9vdFtzZWdtZW50XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByb290W3NlZ21lbnRdID0ge307XG4gICAgICAgICAgICByZXR1cm4gcm9vdFtzZWdtZW50XTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmbHVpZC5tb2RlbC5kZWZhdWx0RmV0Y2hTdHJhdGVneSA9IGZ1bmN0aW9uIChyb290LCBzZWdtZW50KSB7XG4gICAgICAgIHJldHVybiByb290W3NlZ21lbnRdO1xuICAgIH07XG5cbiAgICBmbHVpZC5tb2RlbC5mdW5jUmVzb2x2ZXJTdHJhdGVneSA9IGZ1bmN0aW9uIChyb290LCBzZWdtZW50KSB7XG4gICAgICAgIGlmIChyb290LnJlc29sdmVQYXRoU2VnbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHJvb3QucmVzb2x2ZVBhdGhTZWdtZW50KHNlZ21lbnQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZsdWlkLm1vZGVsLnRyYXZlcnNlV2l0aFN0cmF0ZWd5ID0gZnVuY3Rpb24gKHJvb3QsIHNlZ3MsIGluaXRQb3MsIGNvbmZpZywgdW5jZXNzKSB7XG4gICAgICAgIHZhciBzdHJhdGVnaWVzID0gY29uZmlnLnN0cmF0ZWdpZXM7XG4gICAgICAgIHZhciBsaW1pdCA9IHNlZ3MubGVuZ3RoIC0gdW5jZXNzO1xuICAgICAgICBmb3IgKHZhciBpID0gaW5pdFBvczsgaSA8IGxpbWl0OyArK2kpIHtcbiAgICAgICAgICAgIGlmICghcm9vdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFjY2VwdGVkO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzdHJhdGVnaWVzLmxlbmd0aDsgKysgaikge1xuICAgICAgICAgICAgICAgIGFjY2VwdGVkID0gc3RyYXRlZ2llc1tqXShyb290LCBzZWdzW2ldLCBpICsgMSwgc2Vncyk7XG4gICAgICAgICAgICAgICAgaWYgKGFjY2VwdGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIE1heSBub3cgc2hvcnQtY2lyY3VpdCB3aXRoIHN0YXRlbGVzcyBzdHJhdGVnaWVzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFjY2VwdGVkID09PSBmbHVpZC5OT19WQUxVRSkge1xuICAgICAgICAgICAgICAgIGFjY2VwdGVkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm9vdCA9IGFjY2VwdGVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb290O1xuICAgIH07XG5cbiAgICAvKiogUmV0dXJucyBib3RoIHRoZSB2YWx1ZSBhbmQgdGhlIHBhdGggb2YgdGhlIHZhbHVlIGhlbGQgYXQgdGhlIHN1cHBsaWVkIEVMIHBhdGggKiovXG4gICAgZmx1aWQubW9kZWwuZ2V0VmFsdWVBbmRTZWdtZW50cyA9IGZ1bmN0aW9uIChyb290LCBFTCwgY29uZmlnLCBpbml0U2Vncykge1xuICAgICAgICByZXR1cm4gZmx1aWQubW9kZWwuYWNjZXNzV2l0aFN0cmF0ZWd5KHJvb3QsIEVMLCBmbHVpZC5OT19WQUxVRSwgY29uZmlnLCBpbml0U2VncywgdHJ1ZSk7XG4gICAgfTtcblxuICAgIC8vIFZlcnkgbGlnaHR3ZWlnaHQgcmVtbmFudCBvZiB0cnVuZGxlciwgb25seSB1c2VkIGluIHJlc29sdmVyc1xuICAgIGZsdWlkLm1vZGVsLm1ha2VUcnVuZGxlciA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZVNlZywgRUwpIHtcbiAgICAgICAgICAgIHJldHVybiBmbHVpZC5tb2RlbC5nZXRWYWx1ZUFuZFNlZ21lbnRzKHZhbHVlU2VnLnJvb3QsIEVMLCBjb25maWcsIHZhbHVlU2VnLnNlZ3MpO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBmbHVpZC5tb2RlbC5nZXRXaXRoU3RyYXRlZ3kgPSBmdW5jdGlvbiAocm9vdCwgRUwsIGNvbmZpZywgaW5pdFNlZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZsdWlkLm1vZGVsLmFjY2Vzc1dpdGhTdHJhdGVneShyb290LCBFTCwgZmx1aWQuTk9fVkFMVUUsIGNvbmZpZywgaW5pdFNlZ3MpO1xuICAgIH07XG5cbiAgICBmbHVpZC5tb2RlbC5zZXRXaXRoU3RyYXRlZ3kgPSBmdW5jdGlvbiAocm9vdCwgRUwsIG5ld1ZhbHVlLCBjb25maWcsIGluaXRTZWdzKSB7XG4gICAgICAgIGZsdWlkLm1vZGVsLmFjY2Vzc1dpdGhTdHJhdGVneShyb290LCBFTCwgbmV3VmFsdWUsIGNvbmZpZywgaW5pdFNlZ3MpO1xuICAgIH07XG5cbiAgICBmbHVpZC5tb2RlbC5hY2Nlc3NXaXRoU3RyYXRlZ3kgPSBmdW5jdGlvbiAocm9vdCwgRUwsIG5ld1ZhbHVlLCBjb25maWcsIGluaXRTZWdzLCByZXR1cm5TZWdzKSB7XG4gICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgd3JpdHRlbiBpbiB0aGlzIHVuZm9ydHVuYXRlIHN0eWxlIGxhcmdlbHkgZm9yIGVmZmljaWVuY3kgcmVhc29ucy4gSW4gbWFueSBjYXNlc1xuICAgICAgICAvLyBpdCBzaG91bGQgYmUgY2FwYWJsZSBvZiBydW5uaW5nIHdpdGggMCBhbGxvY2F0aW9ucyAoRUwgaXMgcHJlcGFyc2VkLCBpbml0U2VncyBpcyBlbXB0eSlcbiAgICAgICAgaWYgKCFmbHVpZC5pc1ByaW1pdGl2ZShFTCkgJiYgIWZsdWlkLmlzQXJyYXlhYmxlKEVMKSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IEVMLnR5cGUgfHwgXCJkZWZhdWx0XCI7XG4gICAgICAgICAgICB2YXIgcmVzb2x2ZXIgPSBjb25maWcucmVzb2x2ZXJzW2tleV07XG4gICAgICAgICAgICBpZiAoIXJlc29sdmVyKSB7XG4gICAgICAgICAgICAgICAgZmx1aWQuZmFpbChcIlVuYWJsZSB0byBmaW5kIHJlc29sdmVyIG9mIHR5cGUgXCIgKyBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRydW5kbGVyID0gZmx1aWQubW9kZWwubWFrZVRydW5kbGVyKGNvbmZpZyk7IC8vIHZlcnkgbGlnaHR3ZWlnaHQgdHJ1bmRsZXIgZm9yIHJlc29sdmVyc1xuICAgICAgICAgICAgdmFyIHZhbHVlU2VnID0ge3Jvb3Q6IHJvb3QsIHNlZ3M6IGluaXRTZWdzfTtcbiAgICAgICAgICAgIHZhbHVlU2VnID0gcmVzb2x2ZXIodmFsdWVTZWcsIEVMLCB0cnVuZGxlcik7XG4gICAgICAgICAgICBpZiAoRUwucGF0aCAmJiB2YWx1ZVNlZykgeyAvLyBldmVyeSByZXNvbHZlciBzdXBwb3J0cyB0aGlzIHBpZWNlIG9mIG91dHB1dCByZXNvbHV0aW9uXG4gICAgICAgICAgICAgICAgdmFsdWVTZWcgPSB0cnVuZGxlcih2YWx1ZVNlZywgRUwucGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuU2VncyA/IHZhbHVlU2VnIDogKHZhbHVlU2VnID8gdmFsdWVTZWcucm9vdCA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmx1aWQubW9kZWwuYWNjZXNzSW1wbChyb290LCBFTCwgbmV3VmFsdWUsIGNvbmZpZywgaW5pdFNlZ3MsIHJldHVyblNlZ3MsIGZsdWlkLm1vZGVsLnRyYXZlcnNlV2l0aFN0cmF0ZWd5KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBJbXBsZW1lbnRhdGlvbiBub3RlczogVGhlIEVMIHBhdGggbWFuaXB1bGF0aW9uIHV0aWxpdGllcyBoZXJlIGFyZSBzb21ld2hhdCBtb3JlIHRob3JvdWdoXG4gICAgLy8gYW5kIGV4cGVuc2l2ZSB2ZXJzaW9ucyBvZiB0aG9zZSBwcm92aWRlZCBpbiBGbHVpZC5qcyAtIHRoZXJlIGlzIHNvbWUgZHVwbGljYXRpb24gb2ZcbiAgICAvLyBmdW5jdGlvbmFsaXR5LiBUaGlzIGlzIGEgdHJhZGVvZmYgYmV0d2VlbiBzdGFiaWxpdHkgYW5kIHBlcmZvcm1hbmNlIC0gdGhlIHZlcnNpb25zIGluXG4gICAgLy8gRmx1aWQuanMgYXJlIHRoZSBtb3N0IGZyZXF1ZW50bHkgdXNlZCBhbmQgZG8gbm90IGltcGxlbWVudCBlc2NhcGluZyBvZiBjaGFyYWN0ZXJzIC5cbiAgICAvLyBhcyBcXC4gYW5kIFxcIGFzIFxcXFwgYXMgdGhlIHZlcnNpb25zIGhlcmUuIFRoZSBpbXBsZW1lbnRhdGlvbnMgaGVyZSBhcmUgbm90XG4gICAgLy8gcGVyZm9ybWFudCBhbmQgYXJlIGxlZnQgaGVyZSBwYXJ0aWFsbHkgYXMgYW4gaW1wbGVtZW50YXRpb24gbm90ZS4gUHJvYmxlbXMgd2lsbFxuICAgIC8vIGFyaXNlIGlmIGNsaWVudHMgbWFuaXB1bGF0ZSBKU09OIHN0cnVjdHVyZXMgY29udGFpbmluZyBcIi5cIiBjaGFyYWN0ZXJzIGluIGtleXMgYXMgaWYgdGhleVxuICAgIC8vIGFyZSBtb2RlbHMuIFRoZSBiYXNpYyB1dGlsaXRpZXMgZmx1aWQucGF0aCgpLCBmbHVpZC5wYXJzZUVMIGFuZCBmbHVpZC5jb21wb3NlUGF0aCBhcmVcbiAgICAvLyB0aGUgb25lcyByZWNvbW1lbmRlZCBmb3IgZ2VuZXJhbCB1c2VycyBhbmQgdGhlIGZvbGxvd2luZyBpbXBsZW1lbnRhdGlvbnMgd2lsbFxuICAgIC8vIGJlIHVwZ3JhZGVkIHRvIHVzZSByZWdleGVzIGluIGZ1dHVyZSB0byBtYWtlIHRoZW0gYmV0dGVyIGFsdGVybmF0aXZlc1xuXG4gICAgZmx1aWQucmVnaXN0ZXJOYW1lc3BhY2UoXCJmbHVpZC5wYXRoVXRpbFwiKTtcblxuICAgIHZhciBnZXRQYXRoU2VnbWVudEltcGwgPSBmdW5jdGlvbiAoYWNjZXB0LCBwYXRoLCBpKSB7XG4gICAgICAgIHZhciBzZWdtZW50ID0gbnVsbDsgLy8gVE9ETzogcmV3cml0ZSB0aGlzIHdpdGggcmVnZXhlcyBhbmQgcmVwbGFjZXNcbiAgICAgICAgaWYgKGFjY2VwdCkge1xuICAgICAgICAgICAgc2VnbWVudCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVzY2FwZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGxpbWl0ID0gcGF0aC5sZW5ndGg7XG4gICAgICAgIGZvciAoOyBpIDwgbGltaXQ7ICsraSkge1xuICAgICAgICAgICAgdmFyIGMgPSBwYXRoLmNoYXJBdChpKTtcbiAgICAgICAgICAgIGlmICghZXNjYXBlZCkge1xuICAgICAgICAgICAgICAgIGlmIChjID09PSBcIi5cIikge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZXNjYXBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlZ21lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudCArPSBjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVzY2FwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoc2VnbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50ICs9IGM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzZWdtZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBhY2NlcHRbMF0gPSBzZWdtZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpO1xuICAgIH07XG5cbiAgICB2YXIgZ2xvYmFsQWNjZXB0ID0gW107IC8vIFRPRE86IHNlcmlvdXMgcmVlbnRyYW5jeSByaXNrIGhlcmUsIHdoeSBpcyB0aGlzIGltcGwgbGlrZSB0aGlzP1xuXG4gICAgLyoqIEEgdmVyc2lvbiBvZiBmbHVpZC5tb2RlbC5wYXJzZUVMIHRoYXQgYXBwbGVzIGVzY2FwaW5nIHJ1bGVzIC0gdGhpcyBhbGxvd3MgcGF0aCBzZWdtZW50c1xuICAgICAqIHRvIGNvbnRhaW4gcGVyaW9kIGNoYXJhY3RlcnMgLiAtIGNoYXJhY3RlcnMgXCJcXFwiIGFuZCBcIn1cIiB3aWxsIGFsc28gYmUgZXNjYXBlZC4gV0FSTklORyAtXG4gICAgICogdGhpcyBjdXJyZW50IGltcGxlbWVudGF0aW9uIGlzIEVYVFJFTUVMWSBzbG93IGNvbXBhcmVkIHRvIGZsdWlkLm1vZGVsLnBhcnNlRUwgYW5kIHNob3VsZFxuICAgICAqIG5vdCBiZSB1c2VkIGluIHBlcmZvcm1hbmNlLXNlbnNpdGl2ZSBhcHBsaWNhdGlvbnMgKi9cbiAgICAvLyBzdXBwb3J0ZWQsIFBVQkxJQyBBUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5wYXRoVXRpbC5wYXJzZUVMID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgdmFyIHRvZ28gPSBbXTtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIGxpbWl0ID0gcGF0aC5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxpbWl0KSB7XG4gICAgICAgICAgICB2YXIgZmlyc3Rkb3QgPSBnZXRQYXRoU2VnbWVudEltcGwoZ2xvYmFsQWNjZXB0LCBwYXRoLCBpbmRleCk7XG4gICAgICAgICAgICB0b2dvLnB1c2goZ2xvYmFsQWNjZXB0WzBdKTtcbiAgICAgICAgICAgIGluZGV4ID0gZmlyc3Rkb3QgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2dvO1xuICAgIH07XG5cbiAgICAvLyBzdXBwb3J0ZWQsIFBVQkxJQyBBUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5wYXRoVXRpbC5jb21wb3NlU2VnbWVudCA9IGZ1bmN0aW9uIChwcmVmaXgsIHRvYXBwZW5kKSB7XG4gICAgICAgIHRvYXBwZW5kID0gdG9hcHBlbmQudG9TdHJpbmcoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2FwcGVuZC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGMgPSB0b2FwcGVuZC5jaGFyQXQoaSk7XG4gICAgICAgICAgICBpZiAoYyA9PT0gXCIuXCIgfHwgYyA9PT0gXCJcXFxcXCIgfHwgYyA9PT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICBwcmVmaXggKz0gXCJcXFxcXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmVmaXggKz0gYztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJlZml4O1xuICAgIH07XG5cbiAgICAvKiogRXNjYXBlcyBhIHNpbmdsZSBwYXRoIHNlZ21lbnQgYnkgcmVwbGFjaW5nIGFueSBjaGFyYWN0ZXIgXCIuXCIsIFwiXFxcIiBvciBcIn1cIiB3aXRoXG4gICAgICogaXRzZWxmIHByZXBlbmRlZCBieSBcXFxuICAgICAqL1xuICAgIC8vIHN1cHBvcnRlZCwgUFVCTElDIEFQSSBmdW5jdGlvblxuICAgIGZsdWlkLnBhdGhVdGlsLmVzY2FwZVNlZ21lbnQgPSBmdW5jdGlvbiAoc2VnbWVudCkge1xuICAgICAgICByZXR1cm4gZmx1aWQucGF0aFV0aWwuY29tcG9zZVNlZ21lbnQoXCJcIiwgc2VnbWVudCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbXBvc2UgYSBwcmVmaXggYW5kIHN1ZmZpeCBFTCBwYXRoLCB3aGVyZSB0aGUgcHJlZml4IGlzIGFscmVhZHkgZXNjYXBlZC5cbiAgICAgKiBQcmVmaXggbWF5IGJlIGVtcHR5LCBidXQgbm90IG51bGwuIFRoZSBzdWZmaXggd2lsbCBiZWNvbWUgZXNjYXBlZC5cbiAgICAgKi9cbiAgICAvLyBzdXBwb3J0ZWQsIFBVQkxJQyBBUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5wYXRoVXRpbC5jb21wb3NlUGF0aCA9IGZ1bmN0aW9uIChwcmVmaXgsIHN1ZmZpeCkge1xuICAgICAgICBpZiAocHJlZml4Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgcHJlZml4ICs9IFwiLlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbHVpZC5wYXRoVXRpbC5jb21wb3NlU2VnbWVudChwcmVmaXgsIHN1ZmZpeCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbXBvc2UgYSBzZXQgb2YgcGF0aCBzZWdtZW50cyBzdXBwbGllZCBhcyBhcmd1bWVudHMgaW50byBhbiBlc2NhcGVkIEVMIGV4cHJlc3Npb24uIEVzY2FwZWQgdmVyc2lvblxuICAgICAqIG9mIGZsdWlkLm1vZGVsLmNvbXBvc2VTZWdtZW50c1xuICAgICAqL1xuXG4gICAgLy8gc3VwcG9ydGVkLCBQVUJMSUMgQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQucGF0aFV0aWwuY29tcG9zZVNlZ21lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGF0aCA9IFwiXCI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKysgaSkge1xuICAgICAgICAgICAgcGF0aCA9IGZsdWlkLnBhdGhVdGlsLmNvbXBvc2VQYXRoKHBhdGgsIGFyZ3VtZW50c1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfTtcblxuICAgIGZsdWlkLm1vZGVsLnVuZXNjYXBlZFBhcnNlciA9IHtcbiAgICAgICAgcGFyc2U6IGZsdWlkLm1vZGVsLnBhcnNlRUwsXG4gICAgICAgIGNvbXBvc2U6IGZsdWlkLm1vZGVsLmNvbXBvc2VTZWdtZW50c1xuICAgIH07XG5cbiAgICAvLyBzdXBwb3J0ZWQsIFBVQkxJQyBBUEkgcmVjb3JkXG4gICAgZmx1aWQubW9kZWwuZGVmYXVsdEdldENvbmZpZyA9IHtcbiAgICAgICAgcGFyc2VyOiBmbHVpZC5tb2RlbC51bmVzY2FwZWRQYXJzZXIsXG4gICAgICAgIHN0cmF0ZWdpZXM6IFtmbHVpZC5tb2RlbC5mdW5jUmVzb2x2ZXJTdHJhdGVneSwgZmx1aWQubW9kZWwuZGVmYXVsdEZldGNoU3RyYXRlZ3ldXG4gICAgfTtcblxuICAgIC8vIHN1cHBvcnRlZCwgUFVCTElDIEFQSSByZWNvcmRcbiAgICBmbHVpZC5tb2RlbC5kZWZhdWx0U2V0Q29uZmlnID0ge1xuICAgICAgICBwYXJzZXI6IGZsdWlkLm1vZGVsLnVuZXNjYXBlZFBhcnNlcixcbiAgICAgICAgc3RyYXRlZ2llczogW2ZsdWlkLm1vZGVsLmZ1bmNSZXNvbHZlclN0cmF0ZWd5LCBmbHVpZC5tb2RlbC5kZWZhdWx0RmV0Y2hTdHJhdGVneSwgZmx1aWQubW9kZWwuZGVmYXVsdENyZWF0b3JTdHJhdGVneV1cbiAgICB9O1xuXG4gICAgZmx1aWQubW9kZWwuZXNjYXBlZFBhcnNlciA9IHtcbiAgICAgICAgcGFyc2U6IGZsdWlkLnBhdGhVdGlsLnBhcnNlRUwsXG4gICAgICAgIGNvbXBvc2U6IGZsdWlkLnBhdGhVdGlsLmNvbXBvc2VTZWdtZW50c1xuICAgIH07XG5cbiAgICAvLyBzdXBwb3J0ZWQsIFBVQkxJQyBBUEkgcmVjb3JkXG4gICAgZmx1aWQubW9kZWwuZXNjYXBlZEdldENvbmZpZyA9IHtcbiAgICAgICAgcGFyc2VyOiBmbHVpZC5tb2RlbC5lc2NhcGVkUGFyc2VyLFxuICAgICAgICBzdHJhdGVnaWVzOiBbZmx1aWQubW9kZWwuZGVmYXVsdEZldGNoU3RyYXRlZ3ldXG4gICAgfTtcblxuICAgIC8vIHN1cHBvcnRlZCwgUFVCTElDIEFQSSByZWNvcmRcbiAgICBmbHVpZC5tb2RlbC5lc2NhcGVkU2V0Q29uZmlnID0ge1xuICAgICAgICBwYXJzZXI6IGZsdWlkLm1vZGVsLmVzY2FwZWRQYXJzZXIsXG4gICAgICAgIHN0cmF0ZWdpZXM6IFtmbHVpZC5tb2RlbC5kZWZhdWx0RmV0Y2hTdHJhdGVneSwgZmx1aWQubW9kZWwuZGVmYXVsdENyZWF0b3JTdHJhdGVneV1cbiAgICB9O1xuXG4gICAgLyoqIE1PREVMIENPTVBPTkVOVCBISUVSQVJDSFkgQU5EIFJFTEFZIFNZU1RFTSAqKi9cblxuICAgIGZsdWlkLmluaXRTaW1wbGVNb2RlbCA9IGZ1bmN0aW9uICh0aGF0LCBvcHRpb25zTW9kZWwpIHtcbiAgICAgICAgdGhhdC5tb2RlbCA9IG9wdGlvbnNNb2RlbCB8fCB7fTtcbiAgICAgICAgcmV0dXJuIHRoYXQubW9kZWw7XG4gICAgfTtcblxuICAgIGZsdWlkLmluaXRSZWxheU1vZGVsID0gZnVuY3Rpb24gKHRoYXQsIG1vZGVsUmVsYXlNb2RlbCkge1xuICAgICAgICByZXR1cm4gbW9kZWxSZWxheU1vZGVsO1xuICAgIH07XG5cbiAgICAvLyBUT0RPOiBUaGlzIHV0aWxpdHkgY29tcGVuc2F0ZXMgZm9yIG91ciBsYWNrIG9mIGNvbnRyb2wgb3ZlciBcIndhdmUgb2YgZXhwbG9zaW9uc1wiIGluaXRpYWxpc2F0aW9uIC0gd2UgbWF5XG4gICAgLy8gY2F0Y2ggYSBtb2RlbCB3aGVuIGl0IGlzIGFwcGFyZW50bHkgXCJjb21wbGV0ZWx5IGluaXRpYWxpc2VkXCIgYW5kIHRoYXQncyB0aGUgYmVzdCB3ZSBjYW4gZG8sIHNpbmNlIHdlIGhhdmVcbiAgICAvLyBtaXNzZWQgaXRzIG93biBpbml0aWFsIHRyYW5zYWN0aW9uXG5cbiAgICBmbHVpZC5pc01vZGVsQ29tcGxldGUgPSBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgICByZXR1cm4gdGhhdC5tb2RlbCAhPT0gZmx1aWQuaW5FdmFsdWF0aW9uTWFya2VyO1xuICAgIH07XG5cbiAgICAvLyBFbmxpc3QgdGhpcyBtb2RlbCBjb21wb25lbnQgYXMgcGFydCBvZiB0aGUgXCJpbml0aWFsIHRyYW5zYWN0aW9uXCIgd2F2ZSAtIG5vdGUgdGhhdCBcInNwZWNpYWwgdHJhbnNhY3Rpb25cIiBpbml0XG4gICAgLy8gaXMgaW5kZXhlZCBieSBjb21wb25lbnQsIG5vdCBieSBhcHBsaWVyLCBhbmQgaGFzIHNwZWNpYWwgcmVjb3JkIHR5cGUgKGNvbXBsZXRlICsgaW5pdE1vZGVsKSwgbm90IHRyYW5zYWN0aW9uXG4gICAgZmx1aWQuZW5saXN0TW9kZWxDb21wb25lbnQgPSBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgICB2YXIgaW5zdGFudGlhdG9yID0gZmx1aWQuZ2V0SW5zdGFudGlhdG9yKHRoYXQpO1xuICAgICAgICB2YXIgZW5saXN0ID0gaW5zdGFudGlhdG9yLm1vZGVsVHJhbnNhY3Rpb25zLmluaXRbdGhhdC5pZF07XG4gICAgICAgIGlmICghZW5saXN0KSB7XG4gICAgICAgICAgICBlbmxpc3QgPSB7XG4gICAgICAgICAgICAgICAgdGhhdDogdGhhdCxcbiAgICAgICAgICAgICAgICBhcHBsaWVyOiBmbHVpZC5nZXRGb3JDb21wb25lbnQodGhhdCwgXCJhcHBsaWVyXCIpLCAvLyByZXF1aXJlZCBmb3IgRkxVSUQtNTUwNCBldmVuIHRob3VnaCBjdXJyZW50bHkgdW51c2VkXG4gICAgICAgICAgICAgICAgY29tcGxldGU6IGZsdWlkLmlzTW9kZWxDb21wbGV0ZSh0aGF0KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGluc3RhbnRpYXRvci5tb2RlbFRyYW5zYWN0aW9ucy5pbml0W3RoYXQuaWRdID0gZW5saXN0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbmxpc3Q7XG4gICAgfTtcblxuICAgIC8vIFV0aWxpdHkgdG8gY29vcmRpbmF0ZSB3aXRoIG91ciBjcnVkZSBcIm9zY2lsbGF0aW9uIHByZXZlbnRpb24gc3lzdGVtXCIgd2hpY2ggbGltaXRzIGVhY2ggbGluayB0byAyIHVwZGF0ZXMgKHByZXN1bWFibHlcbiAgICAvLyBpbiBvcHBvc2l0ZSBkaXJlY3Rpb25zKS4gSW4gdGhlIGNhc2Ugb2YgdGhlIGluaXRpYWwgdHJhbnNhY3Rpb24sIHdlIG5lZWQgdG8gcmVzZXQgdGhlIGNvdW50IGdpdmVuIHRoYXQgZ2VudWluZVxuICAgIC8vIGNoYW5nZXMgYXJlIGFyaXNpbmcgaW4gdGhlIHN5c3RlbSB3aXRoIGVhY2ggbmV3IGVubGlzdGVkIG1vZGVsLiBUT0RPOiBpZiB3ZSBldmVyIGdldCB1c2VycyBvcGVyYXRpbmcgdGhlaXIgb3duXG4gICAgLy8gdHJhbnNhY3Rpb25zLCB0aGluayBvZiBhIHdheSB0byBpbmNvcnBvcmF0ZSB0aGlzIGludG8gdGhhdCB3b3JrZmxvd1xuICAgIGZsdWlkLmNsZWFyTGlua0NvdW50cyA9IGZ1bmN0aW9uICh0cmFuc1JlYywgcmVsYXlzQWxzbykge1xuICAgICAgICBmbHVpZC5lYWNoKHRyYW5zUmVjLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZih2YWx1ZSkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICB0cmFuc1JlY1trZXldID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVsYXlzQWxzbyAmJiB2YWx1ZS5vcHRpb25zICYmIHR5cGVvZih2YWx1ZS5vcHRpb25zLnJlbGF5Q291bnQpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUub3B0aW9ucy5yZWxheUNvdW50ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZsdWlkLnNvcnRDb21wbGV0ZUxhc3QgPSBmdW5jdGlvbiAocmVjYSwgcmVjYikge1xuICAgICAgICByZXR1cm4gKHJlY2EuY29tcGxldGVPbkluaXQgPyAxIDogMCkgLSAocmVjYi5jb21wbGV0ZU9uSW5pdCA/IDEgOiAwKTtcbiAgICB9O1xuXG4gICAgLy8gT3BlcmF0ZSBhbGwgY29vcmRpbmF0ZWQgdHJhbnNhY3Rpb25zIGJ5IGJyaW5naW5nIG1vZGVscyB0byB0aGVpciByZXNwZWN0aXZlIGluaXRpYWwgdmFsdWVzLCBhbmQgdGhlbiBjb21taXQgdGhlbSBhbGxcbiAgICBmbHVpZC5vcGVyYXRlSW5pdGlhbFRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKGluc3RhbnRpYXRvciwgbXJlYykge1xuICAgICAgICB2YXIgdHJhbnNJZCA9IGZsdWlkLmFsbG9jYXRlR3VpZCgpO1xuICAgICAgICB2YXIgdHJhbnNSZWMgPSBmbHVpZC5nZXRNb2RlbFRyYW5zYWN0aW9uUmVjKGluc3RhbnRpYXRvciwgdHJhbnNJZCk7XG4gICAgICAgIHZhciB0cmFuc2FjO1xuICAgICAgICB2YXIgdHJhbnNhY3MgPSBmbHVpZC50cmFuc2Zvcm0obXJlYywgZnVuY3Rpb24gKHJlY2VsKSB7XG4gICAgICAgICAgICB0cmFuc2FjID0gcmVjZWwudGhhdC5hcHBsaWVyLmluaXRpYXRlKFwiaW5pdFwiLCB0cmFuc0lkKTtcbiAgICAgICAgICAgIHRyYW5zUmVjW3JlY2VsLnRoYXQuYXBwbGllci5hcHBsaWVySWRdID0ge3RyYW5zYWN0aW9uOiB0cmFuc2FjfTtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2FjO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBzb3J0IGhhcyB2ZXJ5IGxpdHRsZSBlZmZlY3QgaW4gYW55IGN1cnJlbnQgdGVzdCAoY2FuIGJlIHJlcGxhY2VkIGJ5IG5vLW9wIC0gc2VlIEZMVUlELTUzMzkpIC0gYnV0XG4gICAgICAgIC8vIGF0IGxlYXN0IGNhbid0IGJlIHBlcmZvcm1lZCBpbiByZXZlcnNlIG9yZGVyIChcIkZMVUlELTM2NzQgZXZlbnQgY29vcmRpbmF0aW9uIHRlc3RcIiB3aWxsIGZhaWwpIC0gbmVlZCBtb3JlIGNhc2VzXG4gICAgICAgIHZhciByZWNzID0gZmx1aWQudmFsdWVzKG1yZWMpLnNvcnQoZmx1aWQuc29ydENvbXBsZXRlTGFzdCk7XG4gICAgICAgIGZsdWlkLmVhY2gocmVjcywgZnVuY3Rpb24gKHJlY2VsKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHJlY2VsLnRoYXQ7XG4gICAgICAgICAgICB2YXIgdHJhbnNhYyA9IHRyYW5zYWNzW3RoYXQuaWRdO1xuICAgICAgICAgICAgaWYgKHJlY2VsLmNvbXBsZXRlT25Jbml0KSB7XG4gICAgICAgICAgICAgICAgZmx1aWQuaW5pdE1vZGVsRXZlbnQodGhhdCwgdHJhbnNhYywgdGhhdC5hcHBsaWVyLmNoYW5nZUxpc3RlbmVycy5saXN0ZW5lcnMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmbHVpZC5lYWNoKHJlY2VsLmluaXRNb2RlbHMsIGZ1bmN0aW9uIChpbml0TW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhYy5maXJlQ2hhbmdlUmVxdWVzdCh7dHlwZTogXCJBRERcIiwgc2VnczogW10sIHZhbHVlOiBpbml0TW9kZWx9KTtcbiAgICAgICAgICAgICAgICAgICAgZmx1aWQuY2xlYXJMaW5rQ291bnRzKHRyYW5zUmVjLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzaGFkb3cgPSBmbHVpZC5zaGFkb3dGb3JDb21wb25lbnQodGhhdCk7XG4gICAgICAgICAgICBzaGFkb3cubW9kZWxDb21wbGV0ZSA9IHRydWU7IC8vIHRlY2huaWNhbGx5IHRoaXMgaXMgYSBsaXR0bGUgZWFybHksIGJ1dCB0aGlzIGZsYWcgaXMgb25seSByZWFkIGluIGZsdWlkLmNvbm5lY3RNb2RlbFJlbGF5XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRyYW5zYWMuY29tbWl0KCk7IC8vIGNvbW1pdHRpbmcgb25lIHJlcHJlc2VudGF0aXZlIHRyYW5zYWN0aW9uIHdpbGwgY29tbWl0IHRoZW0gYWxsXG4gICAgfTtcblxuICAgIC8vIFRoaXMgbW9kZWxDb21wb25lbnQgaGFzIG5vdyBjb25jbHVkZWQgaW5pdGlhbGlzYXRpb24gLSBjb21taXQgaXRzIGluaXRpYWxpc2F0aW9uIHRyYW5zYWN0aW9uIGlmIGl0IGlzIHRoZSBsYXN0IHN1Y2ggaW4gdGhlIHdhdmVcbiAgICBmbHVpZC5kZWVubGlzdE1vZGVsQ29tcG9uZW50ID0gZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgICAgdmFyIGluc3RhbnRpYXRvciA9IGZsdWlkLmdldEluc3RhbnRpYXRvcih0aGF0KTtcbiAgICAgICAgdmFyIG1yZWMgPSBpbnN0YW50aWF0b3IubW9kZWxUcmFuc2FjdGlvbnMuaW5pdDtcbiAgICAgICAgdGhhdC5tb2RlbCA9IHVuZGVmaW5lZDsgLy8gQWJ1c2Ugb2YgdGhlIGdpbmdlciBzeXN0ZW0gLSBpbiBmYWN0IGl0IGlzIFwiY3VycmVudGx5IGluIGV2YWx1YXRpb25cIiAtIHdlIG5lZWQgdG8gcmV0dXJuIGEgcHJvcGVyIGluaXRpYWwgbW9kZWwgdmFsdWUgZXZlbiBpZiBubyBpbml0IG9jY3VycmVkIHlldFxuICAgICAgICBtcmVjW3RoYXQuaWRdLmNvbXBsZXRlID0gdHJ1ZTsgLy8gZmxhZyBtZWFucyAtIFwiY29tcGxldGUgYXMgaW4gcmVhZHkgdG8gcGFydGljaXBhdGUgaW4gdGhpcyB0cmFuc2FjdGlvblwiXG4gICAgICAgIHZhciBpbmNvbXBsZXRlID0gZmx1aWQuZmluZF9pZihtcmVjLCBmdW5jdGlvbiAocmVjZWwpIHtcbiAgICAgICAgICAgIHJldHVybiByZWNlbC5jb21wbGV0ZSAhPT0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghaW5jb21wbGV0ZSkge1xuICAgICAgICAgICAgZmx1aWQub3BlcmF0ZUluaXRpYWxUcmFuc2FjdGlvbihpbnN0YW50aWF0b3IsIG1yZWMpO1xuICAgICAgICAgICAgLy8gTkI6IERvbid0IGNhbGwgZmx1aWQuY29uY2x1ZGVUcmFuc2FjdGlvbiBzaW5jZSBcImluaXRcIiBpcyBub3QgYSBzdGFuZGFyZCByZWNvcmQgLSB0aGlzIG9jY3VycyBpbiBjb21taXRSZWxheXMgZm9yIHRoZSBjb3JyZXNwb25kaW5nIGdlbnVpbmUgcmVjb3JkIGFzIHVzdWFsXG4gICAgICAgICAgICBpbnN0YW50aWF0b3IubW9kZWxUcmFuc2FjdGlvbnMuaW5pdCA9IHt9O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZsdWlkLnRyYW5zZm9ybVRvQWRhcHRlciA9IGZ1bmN0aW9uICh0cmFuc2Zvcm0sIHRhcmdldFBhdGgpIHtcbiAgICAgICAgdmFyIGJhc2VkVHJhbnNmb3JtID0ge307XG4gICAgICAgIGJhc2VkVHJhbnNmb3JtW3RhcmdldFBhdGhdID0gdHJhbnNmb3JtO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRyYW5zLCBuZXdWYWx1ZSAvKiwgc291cmNlU2VncywgdGFyZ2V0U2VncyAqLykge1xuICAgICAgICAgICAgLy8gVE9ETzogTW9yZSBlZmZpY2llbnQgbW9kZWwgdGhhdCBjYW4gb25seSBydW4gaW52YWxpZGF0ZWQgcG9ydGlvbiBvZiB0cmFuc2Zvcm0gKG5lZWQgdG8gYWNjZXNzIGNoYW5nZU1hcCBvZiBzb3VyY2UgdHJhbnNhY3Rpb24pXG4gICAgICAgICAgICBmbHVpZC5tb2RlbC50cmFuc2Zvcm1XaXRoUnVsZXMobmV3VmFsdWUsIGJhc2VkVHJhbnNmb3JtLCB7ZmluYWxBcHBsaWVyOiB0cmFuc30pO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBmbHVpZC5wYXJzZU1vZGVsUmVmZXJlbmNlID0gZnVuY3Rpb24gKHRoYXQsIHJlZikge1xuICAgICAgICB2YXIgcGFyc2VkID0gZmx1aWQucGFyc2VDb250ZXh0UmVmZXJlbmNlKHJlZik7XG4gICAgICAgIHBhcnNlZC5zZWdzID0gdGhhdC5hcHBsaWVyLnBhcnNlRUwocGFyc2VkLnBhdGgpO1xuICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgIH07XG5cbiAgICBmbHVpZC5wYXJzZVZhbGlkTW9kZWxSZWZlcmVuY2UgPSBmdW5jdGlvbiAodGhhdCwgbmFtZSwgcmVmKSB7XG4gICAgICAgIHZhciByZWplY3QgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgZmx1aWQuZmFpbChcIkVycm9yIGluIFwiICsgbmFtZSArIFwiOiBcIiArIHJlZiArIG1lc3NhZ2UpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcGFyc2VkLCB0YXJnZXQ7XG4gICAgICAgIGlmIChyZWYuY2hhckF0KDApID09PSBcIntcIikge1xuICAgICAgICAgICAgcGFyc2VkID0gZmx1aWQucGFyc2VNb2RlbFJlZmVyZW5jZSh0aGF0LCByZWYpO1xuICAgICAgICAgICAgaWYgKHBhcnNlZC5zZWdzWzBdICE9PSBcIm1vZGVsXCIpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoXCIgbXVzdCBiZSBhIHJlZmVyZW5jZSBpbnRvIGEgY29tcG9uZW50IG1vZGVsIGJlZ2lubmluZyB3aXRoIFxcXCJtb2RlbFxcXCJcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcnNlZC5tb2RlbFNlZ3MgPSBwYXJzZWQuc2Vncy5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgcGFyc2VkLnBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXJnZXQgPSBmbHVpZC5yZXNvbHZlQ29udGV4dChwYXJzZWQuY29udGV4dCwgdGhhdCk7XG4gICAgICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgICAgIHJlamVjdChcIiBtdXN0IGJlIGEgcmVmZXJlbmNlIHRvIGFuIGV4aXN0aW5nIGNvbXBvbmVudFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldCA9IHRoYXQ7XG4gICAgICAgICAgICBwYXJzZWQgPSB7XG4gICAgICAgICAgICAgICAgcGF0aDogcmVmLFxuICAgICAgICAgICAgICAgIG1vZGVsU2VnczogdGhhdC5hcHBsaWVyLnBhcnNlRUwocmVmKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRhcmdldC5hcHBsaWVyKSB7XG4gICAgICAgICAgICBmbHVpZC5nZXRGb3JDb21wb25lbnQodGFyZ2V0LCBbXCJhcHBsaWVyXCJdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRhcmdldC5hcHBsaWVyKSB7XG4gICAgICAgICAgICByZWplY3QoXCIgbXVzdCBiZSBhIHJlZmVyZW5jZSB0byBhIGNvbXBvbmVudCB3aXRoIGEgQ2hhbmdlQXBwbGllciAoZGVzY2VuZGVkIGZyb20gZmx1aWQubW9kZWxDb21wb25lbnQpXCIpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlZC50aGF0ID0gdGFyZ2V0O1xuICAgICAgICBwYXJzZWQuYXBwbGllciA9IHRhcmdldC5hcHBsaWVyO1xuICAgICAgICAvLyBUT0RPOiByZW1vdmUgdGhpcyB3aGVuIHRoZSBvbGQgQ2hhbmdlQXBwbGllciBpcyBhYm9saXNoZWRcbiAgICAgICAgaWYgKCFwYXJzZWQucGF0aCkge1xuICAgICAgICAgICAgcGFyc2VkLnBhdGggPSB0YXJnZXQuYXBwbGllci5jb21wb3NlU2VnbWVudHMuYXBwbHkobnVsbCwgcGFyc2VkLm1vZGVsU2Vncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9O1xuXG4gICAgLy8gR2V0cyBnbG9iYWwgcmVjb3JkIGZvciBhIHBhcnRpY3VsYXIgdHJhbnNhY3Rpb24gaWQgLSBsb29rcyB1cCBhcHBsaWVyIGlkIHRvIHRyYW5zYWN0aW9uLFxuICAgIC8vIGFzIHdlbGwgYXMgbG9va2luZyB1cCBzb3VyY2UgaWQgKGxpbmtJZCBpbiBiZWxvdykgdG8gY291bnQvdHJ1ZVxuICAgIGZsdWlkLmdldE1vZGVsVHJhbnNhY3Rpb25SZWMgPSBmdW5jdGlvbiAoaW5zdGFudGlhdG9yLCB0cmFuc0lkKSB7XG4gICAgICAgIGlmICghdHJhbnNJZCkge1xuICAgICAgICAgICAgZmx1aWQuZmFpbChcIkNhbm5vdCBnZXQgdHJhbnNhY3Rpb24gcmVjb3JkIHdpdGhvdXQgdHJhbnNhY3Rpb24gaWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRyYW5zUmVjID0gaW5zdGFudGlhdG9yLm1vZGVsVHJhbnNhY3Rpb25zW3RyYW5zSWRdO1xuICAgICAgICBpZiAoIXRyYW5zUmVjICYmICFpbnN0YW50aWF0b3IuZnJlZSkge1xuICAgICAgICAgICAgdHJhbnNSZWMgPSBpbnN0YW50aWF0b3IubW9kZWxUcmFuc2FjdGlvbnNbdHJhbnNJZF0gPSB7fTtcbiAgICAgICAgICAgIHRyYW5zUmVjLmV4dGVybmFsQ2hhbmdlcyA9IHt9OyAvLyBpbmRleCBieSBhcHBsaWVySWQgdG8gY2hhbmdlUGF0aCB0byBsaXN0ZW5lciByZWNvcmRcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJhbnNSZWM7XG4gICAgfTtcblxuICAgIGZsdWlkLnJlY29yZENoYW5nZUxpc3RlbmVyID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgYXBwbGllciwgc291cmNlTGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIHNoYWRvdyA9IGZsdWlkLnNoYWRvd0ZvckNvbXBvbmVudChjb21wb25lbnQpO1xuICAgICAgICBmbHVpZC5yZWNvcmRMaXN0ZW5lcihhcHBsaWVyLm1vZGVsQ2hhbmdlZCwgc291cmNlTGlzdGVuZXIsIHNoYWRvdyk7XG4gICAgfTtcblxuICAgIC8vIFVzZWQgd2l0aCB2YXJpb3VzIGFyZyBjb21iaW5hdGlvbnMgZnJvbSBkaWZmZXJlbnQgc291cmNlcy4gRm9yIHN0YW5kYXJkIFwiaW1wbGljaXQgcmVsYXlcIiBvciBmdWxseSBsZW5zZWQgcmVsYXksXG4gICAgLy8gdGhlIGZpcnN0IDQgYXJncyB3aWxsIGJlIHNldCwgYW5kIFwib3B0aW9uc1wiIHdpbGwgYmUgZW1wdHlcblxuICAgIC8vIEZvciBhIG1vZGVsLWRlcGVuZGVudCByZWxheSwgdGhpcyB3aWxsIGJlIHVzZWQgaW4gdHdvIGhhbHZlcyAtIGZpcnN0bHksIGFsbCBvZiB0aGUgbW9kZWxcbiAgICAvLyBzb3VyY2VzIHdpbGwgYmluZCB0byB0aGUgcmVsYXkgdHJhbnNmb3JtIGRvY3VtZW50IGl0c2VsZi4gSW4gdGhpcyBjYXNlIHRoZSBhcmd1bWVudCBcInRhcmdldEFwcGxpZXJcIiB3aXRoaW4gXCJvcHRpb25zXCIgd2lsbCBiZSBzZXQuXG4gICAgLy8gSW4gdGhpcyBjYXNlLCB0aGUgY29tcG9uZW50IGtub3duIGFzIFwidGFyZ2V0XCIgaXMgcmVhbGx5IHRoZSBzb3VyY2UgLSBpdCBpcyBhIGNvbXBvbmVudCByZWZlcmVuY2UgZGlzY292ZXJlZCBieSBwYXJzaW5nIHRoZVxuICAgIC8vIHJlbGF5IGRvY3VtZW50LlxuXG4gICAgLy8gU2Vjb25kbHksIHRoZSByZWxheSBpdHNlbGYgd2lsbCBzY2hlZHVsZSBhbiBpbnZhbGlkYXRpb24gKGFzIGlmIHJlY2VpdmluZyBjaGFuZ2UgdG8gXCIqXCIgb2YgaXRzIHNvdXJjZSAtIHdoaWNoIG1heSBpbiBtb3N0XG4gICAgLy8gY2FzZXMgYWN0dWFsbHkgYmUgZW1wdHkpIGFuZCBwbGF5IHRocm91Z2ggaXRzIHRyYW5zZHVjZXIuIFwiU291cmNlXCIgY29tcG9uZW50IGl0c2VsZiBpcyBuZXZlciBlbXB0eSwgc2luY2UgaXQgaXMgdXNlZCBmb3IgbGlzdGVuZXJcbiAgICAvLyBkZWdpc3RyYXRpb24gb24gZGVzdHJ1Y3Rpb24gKGNoZWNrIHRoaXMgaXMgY29ycmVjdCBmb3IgZXh0ZXJuYWwgbW9kZWwgcmVsYXkpLiBIb3dldmVyLCBcInNvdXJjZVNlZ3NcIiBtYXkgYmUgZW1wdHkgaW4gdGhlIGNhc2VcbiAgICAvLyB0aGVyZSBpcyBubyBcInNvdXJjZVwiIGNvbXBvbmVudCByZWdpc3RlcmVkIGZvciB0aGUgbGluay4gVGhpcyBjaGFuZ2UgaXMgcGxheWVkIGluIGEgXCJoYWxmLXRyYW5zYWN0aW9uYWxcIiB3YXkgLSB0aGF0IGlzLCB3ZSB3YWl0XG4gICAgLy8gZm9yIGFsbCBvdGhlciBjaGFuZ2VzIGluIHRoZSBzeXN0ZW0gdG8gc2V0dGxlIGJlZm9yZSBwbGF5aW5nIHRoZSByZWxheSBkb2N1bWVudCwgaW4gb3JkZXIgdG8gbWluaW1pc2UgdGhlIGNoYW5jZXMgb2YgbXVsdGlwbGVcbiAgICAvLyBmaXJpbmcgYW5kIGNvcnJ1cHRpb24uIFRoaXMgaXMgZG9uZSB2aWEgdGhlIFwicHJlQ29tbWl0XCIgaG9vayByZWdpc3RlcmVkIGF0IHRvcCBsZXZlbCBpbiBlc3RhYmxpc2hNb2RlbFJlbGF5LiBUaGlzIGxpc3RlbmVyXG4gICAgLy8gaXMgdHJhbnNhY3Rpb25hbCBidXQgaXQgZG9lcyBub3QgcmVxdWlyZSB0aGUgdHJhbnNhY3Rpb24gdG8gY29uY2x1ZGUgaW4gb3JkZXIgdG8gZmlyZSAtIGl0IG1heSBiZSByZXVzZWQgYXMgbWFueSB0aW1lcyBhc1xuICAgIC8vIHJlcXVpcmVkIHdpdGhpbiB0aGUgXCJvdmVyYWxsXCIgdHJhbnNhY3Rpb24gd2hpbHN0IGdlbnVpbmUgKGV4dGVybmFsKSBjaGFuZ2VzIGNvbnRpbnVlIHRvIGFycml2ZS5cblxuICAgIGZsdWlkLnJlZ2lzdGVyRGlyZWN0Q2hhbmdlUmVsYXkgPSBmdW5jdGlvbiAodGFyZ2V0LCB0YXJnZXRTZWdzLCBzb3VyY2UsIHNvdXJjZVNlZ3MsIGxpbmtJZCwgdHJhbnNkdWNlciwgb3B0aW9ucykge1xuICAgICAgICB2YXIgaW5zdGFudGlhdG9yID0gZmx1aWQuZ2V0SW5zdGFudGlhdG9yKHRhcmdldCk7XG4gICAgICAgIHZhciB0YXJnZXRBcHBsaWVyID0gb3B0aW9ucy50YXJnZXRBcHBsaWVyIHx8IHRhcmdldC5hcHBsaWVyOyAvLyBpbXBsaWVzIHRoZSB0YXJnZXQgaXMgYSByZWxheSBkb2N1bWVudFxuICAgICAgICB2YXIgc291cmNlQXBwbGllciA9IG9wdGlvbnMuc291cmNlQXBwbGllciB8fCBzb3VyY2UuYXBwbGllcjsgLy8gaW1wbGllcyB0aGUgc291cmNlIGlzIGEgcmVsYXkgZG9jdW1lbnQgLSBsaXN0ZW5lciB3aWxsIGJlIHRyYW5zYWN0aW9uYWxcbiAgICAgICAgdmFyIGFwcGxpZXJJZCA9IHRhcmdldEFwcGxpZXIuYXBwbGllcklkO1xuICAgICAgICB0YXJnZXRTZWdzID0gZmx1aWQubWFrZUFycmF5KHRhcmdldFNlZ3MpO1xuICAgICAgICBzb3VyY2VTZWdzID0gc291cmNlU2VncyA/IGZsdWlkLm1ha2VBcnJheShzb3VyY2VTZWdzKSA6IHNvdXJjZVNlZ3M7IC8vIHRha2UgY29waWVzIHNpbmNlIG9yaWdpbmFscyB3aWxsIGJlIHRyYXNoZWRcbiAgICAgICAgdmFyIHNvdXJjZUxpc3RlbmVyID0gZnVuY3Rpb24gKG5ld1ZhbHVlLCBvbGRWYWx1ZSwgcGF0aCwgY2hhbmdlUmVxdWVzdCwgdHJhbnMsIGFwcGxpZXIpIHtcbiAgICAgICAgICAgIHZhciB0cmFuc0lkID0gdHJhbnMuaWQ7XG4gICAgICAgICAgICB2YXIgdHJhbnNSZWMgPSBmbHVpZC5nZXRNb2RlbFRyYW5zYWN0aW9uUmVjKGluc3RhbnRpYXRvciwgdHJhbnNJZCk7XG4gICAgICAgICAgICBpZiAoYXBwbGllciAmJiB0cmFucyAmJiAhdHJhbnNSZWNbYXBwbGllci5hcHBsaWVySWRdKSB7IC8vIGRvbid0IHRyYXNoIGV4aXN0aW5nIHJlY29yZCB3aGljaCBtYXkgY29udGFpbiBcIm9wdGlvbnNcIiAoRkxVSUQtNTM5NylcbiAgICAgICAgICAgICAgICB0cmFuc1JlY1thcHBsaWVyLmFwcGxpZXJJZF0gPSB7dHJhbnNhY3Rpb246IHRyYW5zfTsgLy8gZW5saXN0IHRoZSBvdXRlciB1c2VyJ3Mgb3JpZ2luYWwgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBleGlzdGluZyA9IHRyYW5zUmVjW2FwcGxpZXJJZF07XG4gICAgICAgICAgICB0cmFuc1JlY1tsaW5rSWRdID0gdHJhbnNSZWNbbGlua0lkXSB8fCAwO1xuICAgICAgICAgICAgLy8gQ3J1ZGUgXCJvc2NpbGxhdGlvbiBwcmV2ZW50aW9uXCIgc3lzdGVtIGxpbWl0cyBlYWNoIGxpbmsgdG8gbWF4aW11bSBvZiAyIG9wZXJhdGlvbnMgcGVyIGN5Y2xlIChwcmVzdW1hYmx5IGluIG9wcG9zaXRlIGRpcmVjdGlvbnMpXG4gICAgICAgICAgICB2YXIgcmVsYXkgPSB0cnVlOyAvLyBUT0RPOiBTZWUgRkxVSUQtNTMwMyAtIHdlIGN1cnJlbnRseSBkaXNhYmxlIHRoaXMgY2hlY2sgZW50aXJlbHkgdG8gc29sdmUgRkxVSUQtNTI5MyAtIHBlcmhhcHMgd2UgbWlnaHQgcmVtb3ZlIGxpbmsgY291bnRzIGVudGlyZWx5XG4gICAgICAgICAgICBpZiAocmVsYXkpIHtcbiAgICAgICAgICAgICAgICArK3RyYW5zUmVjW2xpbmtJZF07XG4gICAgICAgICAgICAgICAgaWYgKCFleGlzdGluZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3VHJhbnMgPSB0YXJnZXRBcHBsaWVyLmluaXRpYXRlKFwicmVsYXlcIiwgdHJhbnNJZCk7IC8vIG5vbi10b3AtbGV2ZWwgdHJhbnNhY3Rpb24gd2lsbCBkZWZlYXQgcG9zdENvbW1pdFxuICAgICAgICAgICAgICAgICAgICBleGlzdGluZyA9IHRyYW5zUmVjW2FwcGxpZXJJZF0gPSB7dHJhbnNhY3Rpb246IG5ld1RyYW5zLCBvcHRpb25zOiBvcHRpb25zfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zZHVjZXIgJiYgIW9wdGlvbnMudGFyZ2V0QXBwbGllcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBUaGlzIGlzIGp1c3QgZm9yIHNhZmV0eSBidXQgaXMgc3RpbGwgdW51c3VhbCBhbmQgbm93IGFidXNlZC4gVGhlIHRyYW5zZHVjZXIgZG9lc24ndCBuZWVkIHRoZSBcIm5ld1ZhbHVlXCIgc2luY2UgYWxsIHRoZSB0cmFuc2Zvcm0gaW5mb3JtYXRpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gaGFzIGJlZW4gYmFrZWQgaW50byB0aGUgdHJhbnNmb3JtIGRvY3VtZW50IGl0c2VsZi4gSG93ZXZlciwgd2Ugbm93IHJlbHkgb24gdGhpcyBzcGVjaWFsIHNpZ25hbGxpbmcgdmFsdWUgdG8gbWFrZSBzdXJlIHdlIHJlZ2VuZXJhdGUgdHJhbnNmb3JtcyBpbiBcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIFwiZm9yd2FyZEFkYXB0ZXJcIlxuICAgICAgICAgICAgICAgICAgICB0cmFuc2R1Y2VyKGV4aXN0aW5nLnRyYW5zYWN0aW9uLCBvcHRpb25zLnNvdXJjZUFwcGxpZXIgPyB1bmRlZmluZWQgOiBuZXdWYWx1ZSwgc291cmNlU2VncywgdGFyZ2V0U2Vncyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZXdWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLnRyYW5zYWN0aW9uLmZpcmVDaGFuZ2VSZXF1ZXN0KHt0eXBlOiBcIkFERFwiLCBzZWdzOiB0YXJnZXRTZWdzLCB2YWx1ZTogbmV3VmFsdWV9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChzb3VyY2VTZWdzKSB7XG4gICAgICAgICAgICBzb3VyY2VBcHBsaWVyLm1vZGVsQ2hhbmdlZC5hZGRMaXN0ZW5lcih7XG4gICAgICAgICAgICAgICAgaXNSZWxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzZWdzOiBzb3VyY2VTZWdzLFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uYWw6IG9wdGlvbnMudHJhbnNhY3Rpb25hbFxuICAgICAgICAgICAgfSwgc291cmNlTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3VyY2UpIHsgLy8gVE9ETyAtIHdlIGFjdHVhbGx5IG1heSByZXF1aXJlIHRvIHJlZ2lzdGVyIG9uIFRIUkVFIHNvdXJjZXMgaW4gdGhlIGNhc2UgbW9kZWxSZWxheSBpcyBhdHRhY2hlZCB0byBhXG4gICAgICAgICAgICAvLyBjb21wb25lbnQgd2hpY2ggaXMgbmVpdGhlciBzb3VyY2Ugbm9yIHRhcmdldC4gTm90ZSB0aGVyZSB3aWxsIGJlIHByb2JsZW1zIGlmIHNvdXJjZSwgc2F5LCBpcyBkZXN0cm95ZWQgYW5kIHJlY3JlYXRlZCxcbiAgICAgICAgICAgIC8vIGFuZCBob2xkZXIgaXMgbm90IC0gcmVsYXkgd2lsbCBpbiB0aGF0IGNhc2UgYmUgbG9zdC4gTmVlZCB0byBpbnRlZ3JhdGUgcmVsYXkgZXhwcmVzc2lvbnMgd2l0aCBJb0NTUy5cbiAgICAgICAgICAgIGZsdWlkLnJlY29yZENoYW5nZUxpc3RlbmVyKHNvdXJjZSwgc291cmNlQXBwbGllciwgc291cmNlTGlzdGVuZXIpO1xuICAgICAgICAgICAgaWYgKHRhcmdldCAhPT0gc291cmNlKSB7XG4gICAgICAgICAgICAgICAgZmx1aWQucmVjb3JkQ2hhbmdlTGlzdGVuZXIodGFyZ2V0LCBzb3VyY2VBcHBsaWVyLCBzb3VyY2VMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gV2hlbiBjYWxsZWQgZHVyaW5nIHBhcnNpbmcgYSBjb250ZXh0dWFsaXNlZCBtb2RlbCByZWxheSBkb2N1bWVudCwgdGhlc2UgYXJndW1lbnRzIGFyZSByZXZlcnNlZCAtIFwic291cmNlXCIgcmVmZXJzIHRvIHRoZVxuICAgIC8vIGN1cnJlbnQgY29tcG9uZW50LCBhbmQgXCJ0YXJnZXRcIiByZWZlcnMgc3VjY2Vzc2l2ZWx5IHRvIHRoZSB2YXJpb3VzIFwic291cmNlXCIgY29tcG9uZW50cy5cbiAgICAvLyBcIm9wdGlvbnNcIiB3aWxsIGJlIHRyYW5zZm9ybVBhY2thZ2VcbiAgICBmbHVpZC5jb25uZWN0TW9kZWxSZWxheSA9IGZ1bmN0aW9uIChzb3VyY2UsIHNvdXJjZVNlZ3MsIHRhcmdldCwgdGFyZ2V0U2Vncywgb3B0aW9ucykge1xuICAgICAgICB2YXIgbGlua0lkID0gZmx1aWQuYWxsb2NhdGVHdWlkKCk7XG4gICAgICAgIGZ1bmN0aW9uIGVubGlzdENvbXBvbmVudChjb21wb25lbnQpIHtcbiAgICAgICAgICAgIHZhciBlbmxpc3QgPSBmbHVpZC5lbmxpc3RNb2RlbENvbXBvbmVudChjb21wb25lbnQpO1xuXG4gICAgICAgICAgICBpZiAoZW5saXN0LmNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNoYWRvdyA9IGZsdWlkLnNoYWRvd0ZvckNvbXBvbmVudChjb21wb25lbnQpO1xuICAgICAgICAgICAgICAgIGlmIChzaGFkb3cubW9kZWxDb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICBlbmxpc3QuY29tcGxldGVPbkluaXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbmxpc3RDb21wb25lbnQodGFyZ2V0KTtcbiAgICAgICAgZW5saXN0Q29tcG9uZW50KHNvdXJjZSk7IC8vIHJvbGUgb2YgXCJzb3VyY2VcIiBhbmQgXCJ0YXJnZXRcIiBtYXkgaGF2ZSBiZWVuIHN3YXBwZWQgaW4gYSBtb2RlbFJlbGF5IGRvY3VtZW50XG5cbiAgICAgICAgaWYgKG9wdGlvbnMudXBkYXRlKSB7IC8vIGl0IGlzIGEgY2FsbCB2aWEgcGFyc2VJbXBsaWNpdFJlbGF5IGZvciBhIHJlbGF5IGRvY3VtZW50XG4gICAgICAgICAgICBpZiAob3B0aW9ucy50YXJnZXRBcHBsaWVyKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVnaXN0ZXIgY2hhbmdlcyBmcm9tIHRoZSBtb2RlbCBvbnRvIGNoYW5nZXMgdG8gdGhlIG1vZGVsIHJlbGF5IGRvY3VtZW50XG4gICAgICAgICAgICAgICAgZmx1aWQucmVnaXN0ZXJEaXJlY3RDaGFuZ2VSZWxheShzb3VyY2UsIHNvdXJjZVNlZ3MsIHRhcmdldCwgdGFyZ2V0U2VncywgbGlua0lkLCBudWxsLCB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uYWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRBcHBsaWVyOiBvcHRpb25zLnRhcmdldEFwcGxpZXIsXG4gICAgICAgICAgICAgICAgICAgIHJlbGF5Q291bnQ6IG9wdGlvbnMucmVsYXlDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlOiBvcHRpb25zLnVwZGF0ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBwYXJzaW5nIGEgY29udGV4dHVhbGlzZWQgTVIsIHNraXAgdGhlIFwib3J0aG9nb25hbFwiIHJlZ2lzdHJhdGlvbiAtIGluc3RlYWRcbiAgICAgICAgICAgICAgICAvLyByZWdpc3RlciB0aGUgXCJoYWxmLXRyYW5zYWN0aW9uYWxcIiBsaXN0ZW5lciB3aGljaCBiaW5kcyBjaGFuZ2VzIGZyb20gdGhlIHJlbGF5IGl0c2VsZiBvbnRvIHRoZSB0YXJnZXRcbiAgICAgICAgICAgICAgICBmbHVpZC5yZWdpc3RlckRpcmVjdENoYW5nZVJlbGF5KHRhcmdldCwgdGFyZ2V0U2Vncywgc291cmNlLCBbXSwgbGlua0lkK1wiLXRyYW5zZm9ybVwiLCBvcHRpb25zLmZvcndhcmRBZGFwdGVyLCB7dHJhbnNhY3Rpb25hbDogdHJ1ZSwgc291cmNlQXBwbGllcjogb3B0aW9ucy5mb3J3YXJkQXBwbGllcn0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgeyAvLyBtb3JlIGVmZmljaWVudCBicmFuY2ggd2hlcmUgcmVsYXkgaXMgdW5jb250ZXh0dWFsaXNlZFxuICAgICAgICAgICAgZmx1aWQucmVnaXN0ZXJEaXJlY3RDaGFuZ2VSZWxheSh0YXJnZXQsIHRhcmdldFNlZ3MsIHNvdXJjZSwgc291cmNlU2VncywgbGlua0lkLCBvcHRpb25zLmZvcndhcmRBZGFwdGVyLCB7dHJhbnNhY3Rpb25hbDogZmFsc2V9KTtcbiAgICAgICAgICAgIGlmIChzb3VyY2VTZWdzKSB7XG4gICAgICAgICAgICAgICAgZmx1aWQucmVnaXN0ZXJEaXJlY3RDaGFuZ2VSZWxheShzb3VyY2UsIHNvdXJjZVNlZ3MsIHRhcmdldCwgdGFyZ2V0U2VncywgbGlua0lkLCBvcHRpb25zLmJhY2t3YXJkQWRhcHRlciwge3RyYW5zYWN0aW9uYWw6IGZhbHNlfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZmx1aWQubW9kZWwuZ3VhcmRlZEFkYXB0ZXIgPSBmdW5jdGlvbiAoY29tcG9uZW50VGhhdCwgY29uZCwgZnVuYywgYXJncykge1xuICAgICAgICAvLyBUT0RPOiBXZSBjYW4ndCB1c2UgZmx1aWQuaXNNb2RlbENvbXBsZXRlIGhlcmUgYmVjYXVzZSBvZiB0aGUgYnJva2VuIGhhbGYtdHJhbnNhY3Rpb25hbCBzeXN0ZW0gLSBpdCBtYXkgYXBwZWFyIHRoYXQgbW9kZWwgaGFzIGFycml2ZWQgaGFsZndheSB0aHJvdWdoIGluaXQgdHJhbnNhY3Rpb25cbiAgICAgICAgdmFyIGlzSW5pdCA9IGNvbXBvbmVudFRoYXQubW9kZWxSZWxheSA9PT0gZmx1aWQuaW5FdmFsdWF0aW9uTWFya2VyO1xuICAgICAgICB2YXIgY29uZFZhbHVlID0gY29uZFtpc0luaXQgPyBcImluaXRcIiA6IFwibGl2ZVwiXTtcbiAgICAgICAgaWYgKGNvbmRWYWx1ZSkge1xuICAgICAgICAgICAgZnVuYy5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmbHVpZC5tYWtlVHJhbnNmb3JtUGFja2FnZSA9IGZ1bmN0aW9uIChjb21wb25lbnRUaGF0LCB0cmFuc2Zvcm0sIHNvdXJjZVBhdGgsIHRhcmdldFBhdGgsIGZvcndhcmRDb25kLCBiYWNrd2FyZENvbmQpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB7XG4gICAgICAgICAgICBmb3J3YXJkSG9sZGVyOiB7bW9kZWw6IHRyYW5zZm9ybX0sXG4gICAgICAgICAgICBiYWNrd2FyZEhvbGRlcjoge21vZGVsOiBudWxsfVxuICAgICAgICB9O1xuICAgICAgICB0aGF0LmdlbmVyYXRlQWRhcHRlcnMgPSBmdW5jdGlvbiAodHJhbnMpIHtcbiAgICAgICAgICAgIC8vIGNhbid0IGNvbW1pdCBcImhhbGYtdHJhbnNhY3Rpb25cIiBvciBldmVudHMgd2lsbCBmaXJlIC0gdmlvbGF0ZSBlbmNhcHN1bGF0aW9uIGluIHRoaXMgd2F5XG4gICAgICAgICAgICB0aGF0LmZvcndhcmRBZGFwdGVySW1wbCA9IGZsdWlkLnRyYW5zZm9ybVRvQWRhcHRlcih0cmFucyA/IHRyYW5zLm5ld0hvbGRlci5tb2RlbCA6IHRoYXQuZm9yd2FyZEhvbGRlci5tb2RlbCwgdGFyZ2V0UGF0aCk7XG4gICAgICAgICAgICBpZiAoc291cmNlUGF0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoYXQuYmFja3dhcmRIb2xkZXIubW9kZWwgPSBmbHVpZC5tb2RlbC50cmFuc2Zvcm0uaW52ZXJ0Q29uZmlndXJhdGlvbih0cmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgIHRoYXQuYmFja3dhcmRBZGFwdGVySW1wbCA9IGZsdWlkLnRyYW5zZm9ybVRvQWRhcHRlcih0aGF0LmJhY2t3YXJkSG9sZGVyLm1vZGVsLCBzb3VyY2VQYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhhdC5mb3J3YXJkQWRhcHRlciA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgbmV3VmFsdWUpIHsgLy8gY3JlYXRlIGEgc3RhYmxlIGZ1bmN0aW9uIHJlZmVyZW5jZSBmb3IgdGhpcyBwb3NzaWJseSBjaGFuZ2luZyBhZGFwdGVyXG4gICAgICAgICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoYXQuZ2VuZXJhdGVBZGFwdGVycygpOyAvLyBUT0RPOiBRdWljayBmaXggZm9yIGluY29ycmVjdCBzY2hlZHVsaW5nIG9mIGludmFsaWRhdGlvbi90cmFuc2R1Y2luZ1xuICAgICAgICAgICAgICAgIC8vIFwiaXQgc28gaGFwcGVuc1wiIHRoYXQgZmx1aWQucmVnaXN0ZXJEaXJlY3RDaGFuZ2VSZWxheSBpbnZva2VzIHVzIHdpdGggZW1wdHkgbmV3VmFsdWUgaW4gdGhlIGNhc2Ugb2YgaW52YWxpZGF0aW9uIC0+IHRyYW5zZHVjdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmx1aWQubW9kZWwuZ3VhcmRlZEFkYXB0ZXIoY29tcG9uZW50VGhhdCwgZm9yd2FyZENvbmQsIHRoYXQuZm9yd2FyZEFkYXB0ZXJJbXBsLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBmaXJlZCBmcm9tIGZsdWlkLm1vZGVsLnVwZGF0ZVJlbGF5cyB2aWEgaW52YWxpZGF0b3IgZXZlbnRcbiAgICAgICAgdGhhdC5ydW5UcmFuc2Zvcm0gPSBmdW5jdGlvbiAodHJhbnMpIHtcbiAgICAgICAgICAgIHRyYW5zLmNvbW1pdCgpOyAvLyB0aGlzIHdpbGwgcmVhY2ggdGhlIHNwZWNpYWwgXCJoYWxmLXRyYW5zYWN0aW9uYWwgbGlzdGVuZXJcIiByZWdpc3RlcmVkIGluIGZsdWlkLmNvbm5lY3RNb2RlbFJlbGF5LFxuICAgICAgICAgICAgLy8gYnJhbmNoIHdpdGggb3B0aW9ucy50YXJnZXRBcHBsaWVyIC0gYnkgY29tbWl0dGluZyB0aGUgdHJhbnNhY3Rpb24sIHdlIHVwZGF0ZSB0aGUgcmVsYXkgZG9jdW1lbnQgaW4gYnVsayBhbmQgdGhlbiBjYXVzZVxuICAgICAgICAgICAgLy8gaXQgdG8gZXhlY3V0ZSAodmlhIFwidHJhbnNkdWNlclwiKVxuICAgICAgICAgICAgdHJhbnMucmVzZXQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhhdC5mb3J3YXJkQXBwbGllciA9IGZsdWlkLm1ha2VOZXdDaGFuZ2VBcHBsaWVyKHRoYXQuZm9yd2FyZEhvbGRlcik7XG4gICAgICAgIHRoYXQuZm9yd2FyZEFwcGxpZXIuaXNSZWxheUFwcGxpZXIgPSB0cnVlOyAvLyBzcGVjaWFsIGFubm90YXRpb24gc28gdGhlc2UgY2FuIGJlIGRpc2NvdmVyZWQgaW4gdGhlIHRyYW5zYWN0aW9uIHJlY29yZFxuICAgICAgICB0aGF0LmludmFsaWRhdG9yID0gZmx1aWQubWFrZUV2ZW50RmlyZXIoe25hbWU6IFwiSW52YWxpZGF0b3IgZm9yIG1vZGVsIHJlbGF5IHdpdGggYXBwbGllciBcIiArIHRoYXQuZm9yd2FyZEFwcGxpZXIuYXBwbGllcklkfSk7XG4gICAgICAgIGlmIChzb3VyY2VQYXRoICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGF0LmJhY2t3YXJkQXBwbGllciA9IGZsdWlkLm1ha2VOZXdDaGFuZ2VBcHBsaWVyKHRoYXQuYmFja3dhcmRIb2xkZXIpO1xuICAgICAgICAgICAgdGhhdC5iYWNrd2FyZEFkYXB0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZmx1aWQubW9kZWwuZ3VhcmRlZEFkYXB0ZXIoY29tcG9uZW50VGhhdCwgYmFja3dhcmRDb25kLCB0aGF0LmJhY2t3YXJkQWRhcHRlckltcGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoYXQudXBkYXRlID0gdGhhdC5pbnZhbGlkYXRvci5maXJlOyAvLyBuZWNlc3Nhcnkgc28gdGhhdCBib3RoIHJvdXRlcyB0byBmbHVpZC5jb25uZWN0TW9kZWxSZWxheSBmcm9tIGhlcmUgaGl0IHRoZSBmaXJzdCBicmFuY2hcbiAgICAgICAgdmFyIGltcGxpY2l0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHJlbGF5Q291bnQ6IDAsIC8vIHRoaXMgY291bnQgaXMgdXBkYXRlZCBpbiBmbHVpZC5tb2RlbC51cGRhdGVSZWxheXNcbiAgICAgICAgICAgIHRhcmdldEFwcGxpZXI6IHRoYXQuZm9yd2FyZEFwcGxpZXIsIC8vIHRoaXMgc3BlY2lhbCBmaWVsZCBpZGVudGlmaWVzIHVzIHRvIGZsdWlkLmNvbm5lY3RNb2RlbFJlbGF5XG4gICAgICAgICAgICB1cGRhdGU6IHRoYXQudXBkYXRlLFxuICAgICAgICAgICAgcmVmQ291bnQ6IDBcbiAgICAgICAgfTtcbiAgICAgICAgdGhhdC5mb3J3YXJkSG9sZGVyLm1vZGVsID0gZmx1aWQucGFyc2VJbXBsaWNpdFJlbGF5KGNvbXBvbmVudFRoYXQsIHRyYW5zZm9ybSwgW10sIGltcGxpY2l0T3B0aW9ucyk7XG4gICAgICAgIHRoYXQucmVmQ291bnQgPSBpbXBsaWNpdE9wdGlvbnMucmVmQ291bnQ7XG4gICAgICAgIHRoYXQuZ2VuZXJhdGVBZGFwdGVycygpO1xuICAgICAgICB0aGF0LmludmFsaWRhdG9yLmFkZExpc3RlbmVyKHRoYXQuZ2VuZXJhdGVBZGFwdGVycyk7XG4gICAgICAgIHRoYXQuaW52YWxpZGF0b3IuYWRkTGlzdGVuZXIodGhhdC5ydW5UcmFuc2Zvcm0pO1xuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICB9O1xuXG4gICAgZmx1aWQuc2luZ2xlVHJhbnNmb3JtVG9GdWxsID0gZnVuY3Rpb24gKHNpbmdsZVRyYW5zZm9ybSkge1xuICAgICAgICB2YXIgd2l0aFBhdGggPSAkLmV4dGVuZCh0cnVlLCB7dmFsdWVQYXRoOiBcIlwifSwgc2luZ2xlVHJhbnNmb3JtKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFwiXCI6IHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHdpdGhQYXRoXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIGZsdWlkLm1vZGVsLnJlbGF5Q29uZGl0aW9ucyA9IHtcbiAgICAgICAgaW5pdE9ubHk6IHtpbml0OiB0cnVlLCAgbGl2ZTogZmFsc2V9LFxuICAgICAgICBsaXZlT25seToge2luaXQ6IGZhbHNlLCBsaXZlOiB0cnVlfSxcbiAgICAgICAgbmV2ZXI6ICAgIHtpbml0OiBmYWxzZSwgbGl2ZTogZmFsc2V9LFxuICAgICAgICBhbHdheXM6ICAge2luaXQ6IHRydWUsICBsaXZlOiB0cnVlfVxuICAgIH07XG5cbiAgICBmbHVpZC5tb2RlbC5wYXJzZVJlbGF5Q29uZGl0aW9uID0gZnVuY3Rpb24gKGNvbmRpdGlvbikge1xuICAgICAgICByZXR1cm4gZmx1aWQubW9kZWwucmVsYXlDb25kaXRpb25zW2NvbmRpdGlvbiB8fCBcImFsd2F5c1wiXTtcbiAgICB9O1xuXG4gICAgZmx1aWQucGFyc2VNb2RlbFJlbGF5ID0gZnVuY3Rpb24gKHRoYXQsIG1ycmVjKSB7XG4gICAgICAgIHZhciBwYXJzZWRTb3VyY2UgPSBtcnJlYy5zb3VyY2UgPyBmbHVpZC5wYXJzZVZhbGlkTW9kZWxSZWZlcmVuY2UodGhhdCwgXCJtb2RlbFJlbGF5IHJlY29yZCBtZW1iZXIgXFxcInNvdXJjZVxcXCJcIiwgbXJyZWMuc291cmNlKSA6XG4gICAgICAgICAgICB7cGF0aDogbnVsbCwgbW9kZWxTZWdzOiBudWxsfTtcbiAgICAgICAgdmFyIHBhcnNlZFRhcmdldCA9IGZsdWlkLnBhcnNlVmFsaWRNb2RlbFJlZmVyZW5jZSh0aGF0LCBcIm1vZGVsUmVsYXkgcmVjb3JkIG1lbWJlciBcXFwidGFyZ2V0XFxcIlwiLCBtcnJlYy50YXJnZXQpO1xuXG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSBtcnJlYy5zaW5nbGVUcmFuc2Zvcm0gPyBmbHVpZC5zaW5nbGVUcmFuc2Zvcm1Ub0Z1bGwobXJyZWMuc2luZ2xlVHJhbnNmb3JtKSA6IG1ycmVjLnRyYW5zZm9ybTtcbiAgICAgICAgaWYgKCF0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIGZsdWlkLmZhaWwoXCJDYW5ub3QgcGFyc2UgbW9kZWxSZWxheSByZWNvcmQgd2l0aG91dCBlbGVtZW50IFxcXCJzaW5nbGVUcmFuc2Zvcm1cXFwiIG9yIFxcXCJ0cmFuc2Zvcm1cXFwiOlwiLCBtcnJlYyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZvcndhcmRDb25kID0gZmx1aWQubW9kZWwucGFyc2VSZWxheUNvbmRpdGlvbihtcnJlYy5mb3J3YXJkKSwgYmFja3dhcmRDb25kID0gZmx1aWQubW9kZWwucGFyc2VSZWxheUNvbmRpdGlvbihtcnJlYy5iYWNrd2FyZCk7XG4gICAgICAgIHZhciB0cmFuc2Zvcm1QYWNrYWdlID0gZmx1aWQubWFrZVRyYW5zZm9ybVBhY2thZ2UodGhhdCwgdHJhbnNmb3JtLCBwYXJzZWRTb3VyY2UucGF0aCwgcGFyc2VkVGFyZ2V0LnBhdGgsIGZvcndhcmRDb25kLCBiYWNrd2FyZENvbmQpO1xuICAgICAgICBpZiAodHJhbnNmb3JtUGFja2FnZS5yZWZDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gVGhpcyBmaXJzdCBjYWxsIGJpbmRzIGNoYW5nZXMgZW1pdHRlZCBmcm9tIHRoZSByZWxheSBlbmRzIHRvIGVhY2ggb3RoZXIsIHN5bmNocm9ub3VzbHlcbiAgICAgICAgICAgIGZsdWlkLmNvbm5lY3RNb2RlbFJlbGF5KHBhcnNlZFNvdXJjZS50aGF0IHx8IHRoYXQsIHBhcnNlZFNvdXJjZS5tb2RlbFNlZ3MsIHBhcnNlZFRhcmdldC50aGF0LCBwYXJzZWRUYXJnZXQubW9kZWxTZWdzLCB7XG4gICAgICAgICAgICAgICAgZm9yd2FyZEFkYXB0ZXI6IHRyYW5zZm9ybVBhY2thZ2UuZm9yd2FyZEFkYXB0ZXIsXG4gICAgICAgICAgICAgICAgYmFja3dhcmRBZGFwdGVyOiB0cmFuc2Zvcm1QYWNrYWdlLmJhY2t3YXJkQWRhcHRlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGlzIHNlY29uZCBjYWxsIGJpbmRzIGNoYW5nZXMgZW1pdHRlZCBmcm9tIHRoZSByZWxheSBkb2N1bWVudCBpdHNlbGYgb250byB0aGUgcmVsYXkgZW5kcyAodXNpbmcgdGhlIFwiaGFsZi10cmFuc2FjdGlvbmFsIHN5c3RlbVwiKVxuICAgICAgICAgICAgZmx1aWQuY29ubmVjdE1vZGVsUmVsYXkocGFyc2VkU291cmNlLnRoYXQgfHwgdGhhdCwgcGFyc2VkU291cmNlLm1vZGVsU2VncywgcGFyc2VkVGFyZ2V0LnRoYXQsIHBhcnNlZFRhcmdldC5tb2RlbFNlZ3MsIHRyYW5zZm9ybVBhY2thZ2UpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZsdWlkLnBhcnNlSW1wbGljaXRSZWxheSA9IGZ1bmN0aW9uICh0aGF0LCBtb2RlbFJlYywgc2Vncywgb3B0aW9ucykge1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIGlmICh0eXBlb2YobW9kZWxSZWMpID09PSBcInN0cmluZ1wiICYmIG1vZGVsUmVjLmNoYXJBdCgwKSA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICAgIHZhciBwYXJzZWQgPSBmbHVpZC5wYXJzZU1vZGVsUmVmZXJlbmNlKHRoYXQsIG1vZGVsUmVjKTtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBmbHVpZC5yZXNvbHZlQ29udGV4dChwYXJzZWQuY29udGV4dCwgdGhhdCk7XG4gICAgICAgICAgICBpZiAocGFyc2VkLnNlZ3NbMF0gPT09IFwibW9kZWxcIikge1xuICAgICAgICAgICAgICAgIHZhciBtb2RlbFNlZ3MgPSBwYXJzZWQuc2Vncy5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICArK29wdGlvbnMucmVmQ291bnQ7XG4gICAgICAgICAgICAgICAgZmx1aWQuY29ubmVjdE1vZGVsUmVsYXkodGhhdCwgc2VncywgdGFyZ2V0LCBtb2RlbFNlZ3MsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGZsdWlkLmdldEZvckNvbXBvbmVudCh0YXJnZXQsIHBhcnNlZC5zZWdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChmbHVpZC5pc1ByaW1pdGl2ZShtb2RlbFJlYykgfHwgIWZsdWlkLmlzUGxhaW5PYmplY3QobW9kZWxSZWMpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG1vZGVsUmVjO1xuICAgICAgICB9IGVsc2UgaWYgKG1vZGVsUmVjLmV4cGFuZGVyICYmIGZsdWlkLmlzUGxhaW5PYmplY3QobW9kZWxSZWMuZXhwYW5kZXIpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGZsdWlkLmV4cGFuZE9wdGlvbnMobW9kZWxSZWMsIHRoYXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBmbHVpZC5mcmVzaENvbnRhaW5lcihtb2RlbFJlYyk7XG4gICAgICAgICAgICBmbHVpZC5lYWNoKG1vZGVsUmVjLCBmdW5jdGlvbiAoaW5uZXJWYWx1ZSwga2V5KSB7XG4gICAgICAgICAgICAgICAgc2Vncy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgdmFyIGlubmVyVHJhbnMgPSBmbHVpZC5wYXJzZUltcGxpY2l0UmVsYXkodGhhdCwgaW5uZXJWYWx1ZSwgc2Vncywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyVHJhbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZVtrZXldID0gaW5uZXJUcmFucztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2Vncy5wb3AoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuXG5cbiAgICAvLyBDb25jbHVkZSB0aGUgdHJhbnNhY3Rpb24gYnkgZmlyaW5nIHRvIGFsbCBleHRlcm5hbCBsaXN0ZW5lcnMgaW4gcHJpb3JpdHkgb3JkZXJcbiAgICBmbHVpZC5tb2RlbC5ub3RpZnlFeHRlcm5hbCA9IGZ1bmN0aW9uICh0cmFuc1JlYykge1xuICAgICAgICB2YXIgYWxsQ2hhbmdlcyA9IHRyYW5zUmVjID8gZmx1aWQudmFsdWVzKHRyYW5zUmVjLmV4dGVybmFsQ2hhbmdlcykgOiBbXTtcbiAgICAgICAgYWxsQ2hhbmdlcy5zb3J0KGZsdWlkLnByaW9yaXR5Q29tcGFyYXRvcik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsQ2hhbmdlcy5sZW5ndGg7ICsrIGkpIHtcbiAgICAgICAgICAgIHZhciBjaGFuZ2UgPSBhbGxDaGFuZ2VzW2ldO1xuICAgICAgICAgICAgdmFyIHRhcmdldEFwcGxpZXIgPSBjaGFuZ2UuYXJnc1s1XTsgLy8gTk9URTogVGhpcyBhcmd1bWVudCBnZXRzIGhlcmUgdmlhIGZsdWlkLm1vZGVsLnN0b3JlRXh0ZXJuYWxDaGFuZ2UgZnJvbSBmbHVpZC5ub3RpZnlNb2RlbENoYW5nZXNcbiAgICAgICAgICAgIGlmICghdGFyZ2V0QXBwbGllci5kZXN0cm95ZWQpIHsgLy8gM3JkIHBvaW50IG9mIGd1YXJkaW5nIGZvciBGTFVJRC01NTkyXG4gICAgICAgICAgICAgICAgY2hhbmdlLmxpc3RlbmVyLmFwcGx5KG51bGwsIGNoYW5nZS5hcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmbHVpZC5jbGVhckxpbmtDb3VudHModHJhbnNSZWMsIHRydWUpOyAvLyBcIm9wdGlvbnNcIiBzdHJ1Y3R1cmVzIGZvciByZWxheUNvdW50IGFyZSBhbGlhc2VkXG4gICAgfTtcblxuICAgIGZsdWlkLm1vZGVsLmNvbW1pdFJlbGF5cyA9IGZ1bmN0aW9uIChpbnN0YW50aWF0b3IsIHRyYW5zYWN0aW9uSWQpIHtcbiAgICAgICAgdmFyIHRyYW5zUmVjID0gaW5zdGFudGlhdG9yLm1vZGVsVHJhbnNhY3Rpb25zW3RyYW5zYWN0aW9uSWRdO1xuICAgICAgICBmbHVpZC5lYWNoKHRyYW5zUmVjLCBmdW5jdGlvbiAodHJhbnNFbCkge1xuICAgICAgICAvLyBFWFBMQUlOOiBUaGlzIG11c3QgY29tbWl0IEFMTCBjdXJyZW50IHRyYW5zYWN0aW9ucywgbm90IGp1c3QgdGhvc2UgZm9yIHJlbGF5cyAtIHdoeT9cbiAgICAgICAgICAgIGlmICh0cmFuc0VsLnRyYW5zYWN0aW9uKSB7IC8vIHNvbWUgZW50cmllcyBhcmUgbGlua3NcbiAgICAgICAgICAgICAgICB0cmFuc0VsLnRyYW5zYWN0aW9uLmNvbW1pdChcInJlbGF5XCIpO1xuICAgICAgICAgICAgICAgIHRyYW5zRWwudHJhbnNhY3Rpb24ucmVzZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZsdWlkLm1vZGVsLnVwZGF0ZVJlbGF5cyA9IGZ1bmN0aW9uIChpbnN0YW50aWF0b3IsIHRyYW5zYWN0aW9uSWQpIHtcbiAgICAgICAgdmFyIHRyYW5zUmVjID0gaW5zdGFudGlhdG9yLm1vZGVsVHJhbnNhY3Rpb25zW3RyYW5zYWN0aW9uSWRdO1xuICAgICAgICB2YXIgdXBkYXRlcyA9IDA7XG4gICAgICAgIGZsdWlkLmVhY2godHJhbnNSZWMsIGZ1bmN0aW9uICh0cmFuc0VsKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBpbnRlZ3JhdGUgdGhlIFwic291cmNlXCIgaWYgYW55IGludG8gdGhpcyBjb21wdXRhdGlvbiwgYW5kIGZpcmUgdGhlIHJlbGF5IGlmIGl0IGhhcyBjaGFuZ2VkIC0gcGVyaGFwcyBieSBhZGRpbmcgYSBsaXN0ZW5lclxuICAgICAgICAgICAgLy8gdG8gaXQgdGhhdCB1cGRhdGVzIGNoYW5nZVJlY29yZC5jaGFuZ2VzIChhc3N1bWluZyB3ZSBjYW4gZmluZCBpdClcbiAgICAgICAgICAgIGlmICh0cmFuc0VsLm9wdGlvbnMgJiYgdHJhbnNFbC50cmFuc2FjdGlvbiAmJiB0cmFuc0VsLnRyYW5zYWN0aW9uLmNoYW5nZVJlY29yZC5jaGFuZ2VzID4gMCAmJiB0cmFuc0VsLm9wdGlvbnMucmVsYXlDb3VudCA8IDIgJiYgdHJhbnNFbC5vcHRpb25zLnVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHRyYW5zRWwub3B0aW9ucy5yZWxheUNvdW50Kys7XG4gICAgICAgICAgICAgICAgZmx1aWQuY2xlYXJMaW5rQ291bnRzKHRyYW5zUmVjKTtcbiAgICAgICAgICAgICAgICB0cmFuc0VsLm9wdGlvbnMudXBkYXRlKHRyYW5zRWwudHJhbnNhY3Rpb24sIHRyYW5zUmVjKTtcbiAgICAgICAgICAgICAgICArK3VwZGF0ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdXBkYXRlcztcbiAgICB9O1xuXG4gICAgZmx1aWQuZXN0YWJsaXNoTW9kZWxSZWxheSA9IGZ1bmN0aW9uICh0aGF0LCBvcHRpb25zTW9kZWwsIG9wdGlvbnNNTCwgb3B0aW9uc01SLCBhcHBsaWVyKSB7XG4gICAgICAgIGZsdWlkLm1lcmdlTW9kZWxMaXN0ZW5lcnModGhhdCwgb3B0aW9uc01MKTtcblxuICAgICAgICB2YXIgZW5saXN0ID0gZmx1aWQuZW5saXN0TW9kZWxDb21wb25lbnQodGhhdCk7XG4gICAgICAgIGZsdWlkLmVhY2gob3B0aW9uc01SLCBmdW5jdGlvbiAobXJyZWMpIHtcbiAgICAgICAgICAgIGZsdWlkLnBhcnNlTW9kZWxSZWxheSh0aGF0LCBtcnJlYyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBpbml0TW9kZWxzID0gZmx1aWQudHJhbnNmb3JtKG9wdGlvbnNNb2RlbCwgZnVuY3Rpb24gKG1vZGVsUmVjKSB7XG4gICAgICAgICAgICByZXR1cm4gZmx1aWQucGFyc2VJbXBsaWNpdFJlbGF5KHRoYXQsIG1vZGVsUmVjLCBbXSwge3JlZkNvdW50OiAwfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBlbmxpc3QuaW5pdE1vZGVscyA9IGluaXRNb2RlbHM7XG5cbiAgICAgICAgdmFyIGluc3RhbnRpYXRvciA9IGZsdWlkLmdldEluc3RhbnRpYXRvcih0aGF0KTtcblxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVSZWxheXModHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIHdoaWxlIChmbHVpZC5tb2RlbC51cGRhdGVSZWxheXMoaW5zdGFudGlhdG9yLCB0cmFuc2FjdGlvbi5pZCkgPiAwKXt9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjb21taXRSZWxheXModHJhbnNhY3Rpb24sIGFwcGxpZXIsIGNvZGUpIHtcbiAgICAgICAgICAgIGlmIChjb2RlICE9PSBcInJlbGF5XCIpIHsgLy8gZG9uJ3QgY29tbWl0IHJlbGF5cyBpZiB0aGlzIGNvbW1pdCBpcyBhbHJlYWR5IGEgcmVsYXkgY29tbWl0XG4gICAgICAgICAgICAgICAgZmx1aWQubW9kZWwuY29tbWl0UmVsYXlzKGluc3RhbnRpYXRvciwgdHJhbnNhY3Rpb24uaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY29uY2x1ZGVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgYXBwbGllciwgY29kZSkge1xuICAgICAgICAgICAgaWYgKGNvZGUgIT09IFwicmVsYXlcIikge1xuICAgICAgICAgICAgICAgIGZsdWlkLm1vZGVsLm5vdGlmeUV4dGVybmFsKGluc3RhbnRpYXRvci5tb2RlbFRyYW5zYWN0aW9uc1t0cmFuc2FjdGlvbi5pZF0pO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBpbnN0YW50aWF0b3IubW9kZWxUcmFuc2FjdGlvbnNbdHJhbnNhY3Rpb24uaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYXBwbGllci5wcmVDb21taXQuYWRkTGlzdGVuZXIodXBkYXRlUmVsYXlzKTtcbiAgICAgICAgYXBwbGllci5wcmVDb21taXQuYWRkTGlzdGVuZXIoY29tbWl0UmVsYXlzKTtcbiAgICAgICAgYXBwbGllci5wb3N0Q29tbWl0LmFkZExpc3RlbmVyKGNvbmNsdWRlVHJhbnNhY3Rpb24pO1xuXG4gICAgICAgIGZsdWlkLmRlZW5saXN0TW9kZWxDb21wb25lbnQodGhhdCk7XG5cbiAgICAgICAgcmV0dXJuIGFwcGxpZXIuaG9sZGVyLm1vZGVsO1xuICAgIH07XG5cbiAgICAvLyBHcmFkZSBjb21tb24gdG8gXCJvbGRcIiBhbmQgXCJuZXdcIiBtb2RlbCBjb21wb25lbnRzXG4gICAgZmx1aWQuZGVmYXVsdHMoXCJmbHVpZC5jb21tb25Nb2RlbENvbXBvbmVudFwiLCB7XG4gICAgICAgIGdyYWRlTmFtZXM6IFtcImZsdWlkLmxpdHRsZUNvbXBvbmVudFwiLCBcImF1dG9Jbml0XCJdLFxuICAgICAgICBtZXJnZVBvbGljeToge1xuICAgICAgICAgICAgbW9kZWxMaXN0ZW5lcnM6IGZsdWlkLm1ha2VNZXJnZUxpc3RlbmVyc1BvbGljeShmbHVpZC5hcnJheUNvbmNhdFBvbGljeSlcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gc3VwcG9ydGVkLCBQVUJMSUMgQVBJIGdyYWRlXG4gICAgZmx1aWQuZGVmYXVsdHMoXCJmbHVpZC5tb2RlbENvbXBvbmVudFwiLCB7XG4gICAgICAgIGdyYWRlTmFtZXM6IFtcImZsdWlkLmNvbW1vbk1vZGVsQ29tcG9uZW50XCIsIFwiYXV0b0luaXRcIl0sXG4gICAgICAgIG1lbWJlcnM6IHtcbiAgICAgICAgICAgIG1vZGVsOiBcIkBleHBhbmQ6Zmx1aWQuaW5pdFNpbXBsZU1vZGVsKHt0aGF0fSwge3RoYXR9Lm9wdGlvbnMubW9kZWwpXCIsXG4gICAgICAgICAgICBhcHBsaWVyOiBcIkBleHBhbmQ6Zmx1aWQubWFrZUNoYW5nZUFwcGxpZXIoe3RoYXR9Lm1vZGVsLCB7dGhhdH0ub3B0aW9ucy5jaGFuZ2VBcHBsaWVyT3B0aW9ucylcIixcbiAgICAgICAgICAgIG1vZGVsTGlzdGVuZXJzOiBcIkBleHBhbmQ6Zmx1aWQubWVyZ2VNb2RlbExpc3RlbmVycyh7dGhhdH0sIHt0aGF0fS5vcHRpb25zLm1vZGVsTGlzdGVuZXJzKVwiXG4gICAgICAgIH0sXG4gICAgICAgIG1lcmdlUG9saWN5OiB7XG4gICAgICAgICAgICBtb2RlbDogXCJwcmVzZXJ2ZVwiXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIHN1cHBvcnRlZCwgUFVCTElDIEFQSSBncmFkZVxuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmx1aWQubW9kZWxSZWxheUNvbXBvbmVudFwiLCB7XG4gICAgICAgIGdyYWRlTmFtZXM6IFtcImZsdWlkLmNvbW1vbk1vZGVsQ29tcG9uZW50XCIsIFwiZmx1aWQuZXZlbnRlZENvbXBvbmVudFwiLCBcImF1dG9Jbml0XCJdLFxuICAgICAgICBjaGFuZ2VBcHBsaWVyT3B0aW9uczoge1xuICAgICAgICAgICAgcmVsYXlTdHlsZTogdHJ1ZSxcbiAgICAgICAgICAgIGN1bGxVbmNoYW5nZWQ6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgbWVtYmVyczoge1xuICAgICAgICAgICAgbW9kZWw6IFwiQGV4cGFuZDpmbHVpZC5pbml0UmVsYXlNb2RlbCh7dGhhdH0sIHt0aGF0fS5tb2RlbFJlbGF5KVwiLFxuICAgICAgICAgICAgYXBwbGllcjogXCJAZXhwYW5kOmZsdWlkLm1ha2VOZXdDaGFuZ2VBcHBsaWVyKHt0aGF0fSwge3RoYXR9Lm9wdGlvbnMuY2hhbmdlQXBwbGllck9wdGlvbnMpXCIsXG4gICAgICAgICAgICBtb2RlbFJlbGF5OiBcIkBleHBhbmQ6Zmx1aWQuZXN0YWJsaXNoTW9kZWxSZWxheSh7dGhhdH0sIHt0aGF0fS5vcHRpb25zLm1vZGVsLCB7dGhhdH0ub3B0aW9ucy5tb2RlbExpc3RlbmVycywge3RoYXR9Lm9wdGlvbnMubW9kZWxSZWxheSwge3RoYXR9LmFwcGxpZXIpXCJcbiAgICAgICAgfSxcbiAgICAgICAgbWVyZ2VQb2xpY3k6IHtcbiAgICAgICAgICAgIG1vZGVsOiB7XG4gICAgICAgICAgICAgICAgbm9leHBhbmQ6IHRydWUsXG4gICAgICAgICAgICAgICAgZnVuYzogZmx1aWQuYXJyYXlDb25jYXRQb2xpY3lcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtb2RlbFJlbGF5OiB7XG4gICAgICAgICAgICAgICAgbm9leHBhbmQ6IHRydWUsXG4gICAgICAgICAgICAgICAgZnVuYzogZmx1aWQuYXJyYXlDb25jYXRQb2xpY3lcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gc3VwcG9ydGVkLCBQVUJMSUMgQVBJIHJlY29yZFxuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmx1aWQuc3RhbmRhcmRDb21wb25lbnRcIiwge1xuICAgICAgICBncmFkZU5hbWVzOiBbXCJmbHVpZC5tb2RlbENvbXBvbmVudFwiLCBcImZsdWlkLmV2ZW50ZWRDb21wb25lbnRcIiwgXCJhdXRvSW5pdFwiXVxuICAgIH0pO1xuXG4gICAgLy8gc3VwcG9ydGVkLCBQVUJMSUMgQVBJIHJlY29yZFxuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmx1aWQuc3RhbmRhcmRSZWxheUNvbXBvbmVudFwiLCB7XG4gICAgICAgIGdyYWRlTmFtZXM6IFtcImZsdWlkLm1vZGVsUmVsYXlDb21wb25lbnRcIiwgXCJhdXRvSW5pdFwiXVxuICAgIH0pO1xuXG4gICAgZmx1aWQubW9kZWxDaGFuZ2VkVG9DaGFuZ2UgPSBmdW5jdGlvbiAoaXNOZXdBcHBsaWVyLCBhcmdzKSB7XG4gICAgICAgIHZhciBuZXdNb2RlbCA9IGFyZ3NbMF0sIG9sZE1vZGVsID0gYXJnc1sxXSwgcGF0aCA9IGFyZ3NbM107IC8vIGluIDR0aCBwb3NpdGlvbiBmb3Igb2xkIGFwcGxpZXJcbiAgICAgICAgcmV0dXJuIGlzTmV3QXBwbGllciA/IHtcbiAgICAgICAgICAgIHZhbHVlOiBhcmdzWzBdLFxuICAgICAgICAgICAgb2xkVmFsdWU6IGFyZ3NbMV0sXG4gICAgICAgICAgICBwYXRoOiBhcmdzWzJdXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgICB2YWx1ZTogZmx1aWQuZ2V0KG5ld01vZGVsLCBwYXRoKSxcbiAgICAgICAgICAgIG9sZFZhbHVlOiBmbHVpZC5nZXQob2xkTW9kZWwsIHBhdGgpLFxuICAgICAgICAgICAgcGF0aDogcGF0aFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBmbHVpZC5yZXNvbHZlTW9kZWxMaXN0ZW5lciA9IGZ1bmN0aW9uICh0aGF0LCByZWNvcmQsIGlzTmV3QXBwbGllcikge1xuICAgICAgICB2YXIgdG9nbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChmbHVpZC5pc0Rlc3Ryb3llZCh0aGF0KSkgeyAvLyBmaXJzdCBndWFyZGluZyBwb2ludCB0byByZXNvbHZlIEZMVUlELTU1OTJcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2hhbmdlID0gZmx1aWQubW9kZWxDaGFuZ2VkVG9DaGFuZ2UoaXNOZXdBcHBsaWVyLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbY2hhbmdlXTtcbiAgICAgICAgICAgIHZhciBsb2NhbFJlY29yZCA9IHtjaGFuZ2U6IGNoYW5nZSwgXCJhcmd1bWVudHNcIjogYXJnc307XG4gICAgICAgICAgICBpZiAocmVjb3JkLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBhcmdzID0gZmx1aWQuZXhwYW5kT3B0aW9ucyhyZWNvcmQuYXJncywgdGhhdCwge30sIGxvY2FsUmVjb3JkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZsdWlkLmV2ZW50Lmludm9rZUxpc3RlbmVyKHJlY29yZC5saXN0ZW5lciwgZmx1aWQubWFrZUFycmF5KGFyZ3MpKTtcbiAgICAgICAgfTtcbiAgICAgICAgZmx1aWQuZXZlbnQuaW1wZXJzb25hdGVMaXN0ZW5lcihyZWNvcmQubGlzdGVuZXIsIHRvZ28pO1xuICAgICAgICByZXR1cm4gdG9nbztcbiAgICB9O1xuXG4gICAgZmx1aWQubWVyZ2VNb2RlbExpc3RlbmVycyA9IGZ1bmN0aW9uICh0aGF0LCBsaXN0ZW5lcnMpIHtcbiAgICAgICAgdmFyIGxpc3RlbmVyQ291bnQgPSAwO1xuICAgICAgICBmbHVpZC5lYWNoKGxpc3RlbmVycywgZnVuY3Rpb24gKHZhbHVlLCBwYXRoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0ge1xuICAgICAgICAgICAgICAgICAgICBmdW5jTmFtZTogdmFsdWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlY29yZHMgPSBmbHVpZC5ldmVudC5yZXNvbHZlTGlzdGVuZXJSZWNvcmQodmFsdWUsIHRoYXQsIFwibW9kZWxMaXN0ZW5lcnNcIiwgbnVsbCwgZmFsc2UpO1xuICAgICAgICAgICAgdmFyIHBhcnNlZCA9IGZsdWlkLnBhcnNlVmFsaWRNb2RlbFJlZmVyZW5jZSh0aGF0LCBcIm1vZGVsTGlzdGVuZXJzIGVudHJ5XCIsIHBhdGgpO1xuICAgICAgICAgICAgdmFyIGlzTmV3QXBwbGllciA9IHBhcnNlZC5hcHBsaWVyLnByZUNvbW1pdDtcbiAgICAgICAgICAgIC8vIEJ5cGFzcyBmbHVpZC5ldmVudC5kaXNwYXRjaExpc3RlbmVyIGJ5IG1lYW5zIG9mIFwic3RhbmRhcmQgPSBmYWxzZVwiIGFuZCBlbnRlciBvdXIgY3VzdG9tIHdvcmtmbG93IGluY2x1ZGluZyBleHBhbmRpbmcgXCJjaGFuZ2VcIjpcbiAgICAgICAgICAgIGZsdWlkLmVhY2gocmVjb3Jkcy5yZWNvcmRzLCBmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZ1bmMgPSBmbHVpZC5yZXNvbHZlTW9kZWxMaXN0ZW5lcih0aGF0LCByZWNvcmQsIGlzTmV3QXBwbGllcik7XG4gICAgICAgICAgICAgICAgdmFyIHNwZWMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyOiBmdW5jLCAvLyBmb3IgaW5pdE1vZGVsRXZlbnRcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJJbmRleDogbGlzdGVuZXJDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgc2VnczogcGFyc2VkLm1vZGVsU2VncyxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogcGFyc2VkLnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1ZGVTb3VyY2U6IHJlY29yZC5pbmNsdWRlU291cmNlLFxuICAgICAgICAgICAgICAgICAgICBleGNsdWRlU291cmNlOiByZWNvcmQuZXhjbHVkZVNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHk6IHJlY29yZC5wcmlvcml0eSxcbiAgICAgICAgICAgICAgICAgICAgZ3VhcmRTb3VyY2U6IHJlY29yZC5ndWFyZFNvdXJjZSwgLy8gY29tcGF0aWJpbGl0eSBmb3Igb2Jzb2xldGUgc3lzdGVtIC0gd2lsbCByZW1vdmUgd2l0aCBvbGQgYXBwbGllclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbmFsOiB0cnVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICArK2xpc3RlbmVyQ291bnQ7XG4gICAgICAgICAgICAgICAgaWYgKHJlY29yZC5ndWFyZFNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICBmbHVpZC5hZGRTb3VyY2VHdWFyZGVkTGlzdGVuZXIocGFyc2VkLmFwcGxpZXIsIHNwZWMsIHJlY29yZC5ndWFyZFNvdXJjZSwgZnVuYywgXCJtb2RlbENoYW5nZWRcIiwgcmVjb3JkLm5hbWVzcGFjZSwgcmVjb3JkLnNvZnROYW1lc3BhY2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZC5hcHBsaWVyLm1vZGVsQ2hhbmdlZC5hZGRMaXN0ZW5lcihzcGVjLCBmdW5jLCByZWNvcmQubmFtZXNwYWNlLCByZWNvcmQuc29mdE5hbWVzcGFjZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZmx1aWQucmVjb3JkQ2hhbmdlTGlzdGVuZXIodGhhdCwgcGFyc2VkLmFwcGxpZXIsIGZ1bmMpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGluaXRNb2RlbEV2ZW50KCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOZXdBcHBsaWVyICYmIGZsdWlkLmlzTW9kZWxDb21wbGV0ZShwYXJzZWQudGhhdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0cmFucyA9IHBhcnNlZC5hcHBsaWVyLmluaXRpYXRlKFwiaW5pdFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsdWlkLmluaXRNb2RlbEV2ZW50KHRoYXQsIHRyYW5zLCBbc3BlY10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnMuY29tbWl0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoYXQgIT09IHBhcnNlZC50aGF0ICYmICFmbHVpZC5pc01vZGVsQ29tcGxldGUodGhhdCkpIHsgLy8gVE9ETzogVXNlIEZMVUlELTQ4ODMgXCJsYXRjaGVkIGV2ZW50c1wiIHdoZW4gYXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGNvbmZ1c2UgdGhlIGVuZCB1c2VyIGJ5IGZpcmluZyB0aGVpciBsaXN0ZW5lciBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBjb25zdHJ1Y3RlZFxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBCZXR0ZXIgZGV0ZWN0aW9uIHRoYW4gdGhpcyBpcyByZXF1cmVkIC0gd2UgYXNzdW1lIHRoYXQgdGhlIHRhcmdldCBjb21wb25lbnQgd2lsbCBub3QgYmUgZGlzY292ZXJlZCBhcyBwYXJ0XG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIHRoZSBpbml0aWFsIHRyYW5zYWN0aW9uIHdhdmUsIGJ1dCBpZiBpdCBpcywgaXQgd2lsbCBnZXQgYSBkb3VibGUgbm90aWZpY2F0aW9uIC0gd2UgcmVhbGx5IG5lZWQgXCJ3YXZlIG9mIGV4cGxvc2lvbnNcIlxuICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSB3ZSBhcmUgY3VycmVudGx5IHRvbyBlYXJseSBpbiBpbml0aWFsaXNhdGlvbiBvZiBUSElTIGNvbXBvbmVudCBpbiBvcmRlciB0byB0ZWxsIGlmIG90aGVyIHdpbGwgYmUgZm91bmRcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5kZXBlbmRlbnRseS5cbiAgICAgICAgICAgICAgICAgICAgdGhhdC5ldmVudHMub25DcmVhdGUuYWRkTGlzdGVuZXIoaW5pdE1vZGVsRXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG5cbiAgICAvKiogQ0hBTkdFIEFQUExJRVIgKiovXG5cbiAgICAvKiogQ09NTU9OIFVUSUxJVElFUyBjb21tb24gYmV0d2VlbiBvbGQgYW5kIG5ldyBDaGFuZ2VBcHBsaWVycyAqKi9cblxuICAgIC8qKiBBZGQgYSBsaXN0ZW5lciB0byBhIENoYW5nZUFwcGxpZXIgZXZlbnQgdGhhdCBvbmx5IGFjdHMgaW4gdGhlIGNhc2UgdGhlIGV2ZW50XG4gICAgICogaGFzIG5vdCBjb21lIGZyb20gdGhlIHNwZWNpZmllZCBzb3VyY2UgKHR5cGljYWxseSBvdXJzZWxmKVxuICAgICAqIEBwYXJhbSBtb2RlbEV2ZW50IEFuIG1vZGVsIGV2ZW50IGhlbGQgYnkgYSBjaGFuZ2VBcHBsaWVyICh0eXBpY2FsbHkgYXBwbGllci5tb2RlbENoYW5nZWQpXG4gICAgICogQHBhcmFtIHBhdGggVGhlIHBhdGggc3BlY2lmaWNhdGlvbiB0byBsaXN0ZW4gdG9cbiAgICAgKiBAcGFyYW0gc291cmNlIFRoZSBzb3VyY2UgdmFsdWUgdG8gZXhjbHVkZSAoZGlyZWN0IGVxdWFsaXR5IHVzZWQpXG4gICAgICogQHBhcmFtIGZ1bmMgVGhlIGxpc3RlbmVyIHRvIGJlIG5vdGlmaWVkIG9mIGEgY2hhbmdlXG4gICAgICogQHBhcmFtIFtldmVudE5hbWVdIC0gb3B0aW9uYWwgLSB0aGUgZXZlbnQgbmFtZSB0byBiZSBsaXN0ZW5lZCB0byAtIGRlZmF1bHRzIHRvIFwibW9kZWxDaGFuZ2VkXCJcbiAgICAgKiBAcGFyYW0gW25hbWVzcGFjZV0gLSBvcHRpb25hbCAtIHRoZSBldmVudCBuYW1lc3BhY2VcbiAgICAgKi9cbiAgICBmbHVpZC5hZGRTb3VyY2VHdWFyZGVkTGlzdGVuZXIgPSBmdW5jdGlvbihhcHBsaWVyLCBwYXRoLCBzb3VyY2UsIGZ1bmMsIGV2ZW50TmFtZSwgbmFtZXNwYWNlLCBzb2Z0TmFtZXNwYWNlKSB7XG4gICAgICAgIGV2ZW50TmFtZSA9IGV2ZW50TmFtZSB8fCBcIm1vZGVsQ2hhbmdlZFwiO1xuICAgICAgICB2YXIgd3JhcHBlZCA9IGZ1bmN0aW9uIChuZXdWYWx1ZSwgb2xkVmFsdWUsIHBhdGgsIGNoYW5nZXMpIHsgLy8gVE9ETzogYWRhcHQgc2lnbmF0dXJlXG4gICAgICAgICAgICBpZiAoIWFwcGxpZXIuaGFzQ2hhbmdlU291cmNlKHNvdXJjZSwgY2hhbmdlcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBmbHVpZC5ldmVudC5pbXBlcnNvbmF0ZUxpc3RlbmVyKGZ1bmMsIHdyYXBwZWQpO1xuICAgICAgICBhcHBsaWVyW2V2ZW50TmFtZV0uYWRkTGlzdGVuZXIocGF0aCwgd3JhcHBlZCwgbmFtZXNwYWNlLCBzb2Z0TmFtZXNwYWNlKTtcbiAgICB9O1xuXG4gICAgLyoqIENvbnZlbmllbmNlIG1ldGhvZCB0byBmaXJlIGEgY2hhbmdlIGV2ZW50IHRvIGEgc3BlY2lmaWVkIGFwcGxpZXIsIGluY2x1ZGluZ1xuICAgICAqIGEgc3VwcGxpZWQgXCJzb3VyY2VcIiBpZGVudGlmaWVkIChwZXJoYXBzIGZvciB1c2Ugd2l0aCBhZGRTb3VyY2VHdWFyZGVkTGlzdGVuZXIpXG4gICAgICovXG4gICAgZmx1aWQuZmlyZVNvdXJjZWRDaGFuZ2UgPSBmdW5jdGlvbiAoYXBwbGllciwgcGF0aCwgdmFsdWUsIHNvdXJjZSkge1xuICAgICAgICBhcHBsaWVyLmZpcmVDaGFuZ2VSZXF1ZXN0KHtcbiAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBzb3VyY2U6IHNvdXJjZVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqIERpc3BhdGNoZXMgYSBsaXN0IG9mIGNoYW5nZXMgdG8gdGhlIHN1cHBsaWVkIGFwcGxpZXIgKi9cbiAgICBmbHVpZC5yZXF1ZXN0Q2hhbmdlcyA9IGZ1bmN0aW9uIChhcHBsaWVyLCBjaGFuZ2VzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbmdlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgYXBwbGllci5maXJlQ2hhbmdlUmVxdWVzdChjaGFuZ2VzW2ldKTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIC8vIEF1dG9tYXRpY2FsbHkgYWRhcHRzIHJlcXVlc3RDaGFuZ2Ugb250byBmaXJlQ2hhbmdlUmVxdWVzdFxuICAgIGZsdWlkLmJpbmRSZXF1ZXN0Q2hhbmdlID0gZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgICAgLy8gVGhlIG5hbWUgXCJyZXF1ZXN0Q2hhbmdlXCIgd2lsbCBiZSBkZXByZWNhdGVkIGluIDEuNSwgcmVtb3ZlZCBpbiAyLjBcbiAgICAgICAgdGhhdC5yZXF1ZXN0Q2hhbmdlID0gdGhhdC5jaGFuZ2UgPSBmdW5jdGlvbiAocGF0aCwgdmFsdWUsIHR5cGUpIHtcbiAgICAgICAgICAgIHZhciBjaGFuZ2VSZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGF0LmZpcmVDaGFuZ2VSZXF1ZXN0KGNoYW5nZVJlcXVlc3QpO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBmbHVpZC5pZGVudGlmeUNoYW5nZUxpc3RlbmVyID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBmbHVpZC5ldmVudC5pZGVudGlmeUxpc3RlbmVyKGxpc3RlbmVyKSB8fCBsaXN0ZW5lcjtcbiAgICB9O1xuXG5cbiAgICAvKiogTkVXIENIQU5HRUFQUExJRVIgSU1QTEVNRU5UQVRJT04gKFdpbGwgYmUgZGVmYXVsdCBpbiBJbmZ1c2lvbiAyLjAgb253YXJkcyAqKi9cblxuICAgIGZsdWlkLnR5cGVDb2RlID0gZnVuY3Rpb24gKHRvdGVzdCkge1xuICAgICAgICByZXR1cm4gZmx1aWQuaXNQcmltaXRpdmUodG90ZXN0KSB8fCAhZmx1aWQuaXNQbGFpbk9iamVjdCh0b3Rlc3QpID8gXCJwcmltaXRpdmVcIiA6XG4gICAgICAgICAgICBmbHVpZC5pc0FycmF5YWJsZSh0b3Rlc3QpID8gXCJhcnJheVwiIDogXCJvYmplY3RcIjtcbiAgICB9O1xuXG4gICAgZmx1aWQubW9kZWwuaXNDaGFuZ2VkUGF0aCA9IGZ1bmN0aW9uIChjaGFuZ2VNYXAsIHNlZ3MpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gc2Vncy5sZW5ndGg7ICsrIGkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YoY2hhbmdlTWFwKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPCBzZWdzLmxlbmd0aCAmJiBjaGFuZ2VNYXApIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VNYXAgPSBjaGFuZ2VNYXBbc2Vnc1tpXV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBmbHVpZC5tb2RlbC5zZXRDaGFuZ2VkUGF0aCA9IGZ1bmN0aW9uIChvcHRpb25zLCBzZWdzLCB2YWx1ZSkge1xuICAgICAgICB2YXIgbm90ZVBhdGggPSBmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICBzZWdzLnVuc2hpZnQocmVjb3JkKTtcbiAgICAgICAgICAgIGZsdWlkLm1vZGVsLnNldFNpbXBsZShvcHRpb25zLCBzZWdzLCB2YWx1ZSk7XG4gICAgICAgICAgICBzZWdzLnNoaWZ0KCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICghZmx1aWQubW9kZWwuaXNDaGFuZ2VkUGF0aChvcHRpb25zLmNoYW5nZU1hcCwgc2VncykpIHtcbiAgICAgICAgICAgICsrb3B0aW9ucy5jaGFuZ2VzO1xuICAgICAgICAgICAgbm90ZVBhdGgoXCJjaGFuZ2VNYXBcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmbHVpZC5tb2RlbC5pc0NoYW5nZWRQYXRoKG9wdGlvbnMuZGVsdGFNYXAsIHNlZ3MpKSB7XG4gICAgICAgICAgICArK29wdGlvbnMuZGVsdGFzO1xuICAgICAgICAgICAgbm90ZVBhdGgoXCJkZWx0YU1hcFwiKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmbHVpZC5tb2RlbC5mZXRjaENoYW5nZUNoaWxkcmVuID0gZnVuY3Rpb24gKHRhcmdldCwgaSwgc2Vncywgc291cmNlLCBvcHRpb25zKSB7XG4gICAgICAgIGZsdWlkLmVhY2goc291cmNlLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgICAgc2Vnc1tpXSA9IGtleTtcbiAgICAgICAgICAgIGZsdWlkLm1vZGVsLmFwcGx5Q2hhbmdlU3RyYXRlZ3kodGFyZ2V0LCBrZXksIGksIHNlZ3MsIHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHNlZ3MubGVuZ3RoID0gaTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIENhbGxlZCB3aXRoIHR3byBwcmltaXRpdmVzIHdoaWNoIGFyZSBjb21wYXJlZCBmb3IgZXF1YWxpdHkuIFRoaXMgdGFrZXMgYWNjb3VudCBvZiBcImZsb2F0aW5nIHBvaW50IHNsb3BcIiB0byBhdm9pZFxuICAgIC8vIGNvbnRpbnVpbmcgdG8gcHJvcGFnYXRlIGludmVydGVkIHZhbHVlcyBhcyBjaGFuZ2VzXG4gICAgLy8gVE9ETzogcmVwbGFjZSB3aXRoIGEgcGx1Z2dhYmxlIGltcGxlbWVudGF0aW9uXG4gICAgZmx1aWQubW9kZWwuaXNTYW1lVmFsdWUgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICBpZiAodHlwZW9mKGEpICE9PSBcIm51bWJlclwiIHx8IHR5cGVvZihiKSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuIGEgPT09IGI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVsRXJyb3IgPSBNYXRoLmFicygoYSAtIGIpIC8gYik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbEVycm9yIDwgMWUtMTI7IC8vIDY0LWJpdCBmbG9hdHMgaGF2ZSBhcHByb3ggMTYgZGlnaXRzIGFjY3VyYWN5LCB0aGlzIHNob3VsZCBkZWFsIHdpdGggbW9zdCByZWFzb25hYmxlIHRyYW5zZm9ybXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmbHVpZC5tb2RlbC5hcHBseUNoYW5nZVN0cmF0ZWd5ID0gZnVuY3Rpb24gKHRhcmdldCwgbmFtZSwgaSwgc2Vncywgc291cmNlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB0YXJnZXRTbG90ID0gdGFyZ2V0W25hbWVdO1xuICAgICAgICB2YXIgc291cmNlQ29kZSA9IGZsdWlkLnR5cGVDb2RlKHNvdXJjZSk7XG4gICAgICAgIHZhciB0YXJnZXRDb2RlID0gZmx1aWQudHlwZUNvZGUodGFyZ2V0U2xvdCk7XG4gICAgICAgIHZhciBjaGFuZ2VkVmFsdWUgPSBmbHVpZC5OT19WQUxVRTtcbiAgICAgICAgaWYgKHNvdXJjZUNvZGUgPT09IFwicHJpbWl0aXZlXCIpIHtcbiAgICAgICAgICAgIGlmICghZmx1aWQubW9kZWwuaXNTYW1lVmFsdWUodGFyZ2V0U2xvdCwgc291cmNlKSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZWRWYWx1ZSA9IHNvdXJjZTtcbiAgICAgICAgICAgICAgICArK29wdGlvbnMudW5jaGFuZ2VkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRhcmdldENvZGUgIT09IHNvdXJjZUNvZGUgfHwgc291cmNlQ29kZSA9PT0gXCJhcnJheVwiICYmIHNvdXJjZS5sZW5ndGggIT09IHRhcmdldFNsb3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBSSCBpcyBub3QgcHJpbWl0aXZlIC0gYXJyYXkgb3Igb2JqZWN0IGFuZCBtaXNtYXRjaGluZyBvciBhbnkgYXJyYXkgcmV3cml0ZVxuICAgICAgICAgICAgY2hhbmdlZFZhbHVlID0gZmx1aWQuZnJlc2hDb250YWluZXIoc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlZFZhbHVlICE9PSBmbHVpZC5OT19WQUxVRSkge1xuICAgICAgICAgICAgdGFyZ2V0W25hbWVdID0gY2hhbmdlZFZhbHVlO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2hhbmdlTWFwKSB7XG4gICAgICAgICAgICAgICAgZmx1aWQubW9kZWwuc2V0Q2hhbmdlZFBhdGgob3B0aW9ucywgc2Vncywgb3B0aW9ucy5pbnZlcnNlID8gXCJERUxFVEVcIiA6IFwiQUREXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzb3VyY2VDb2RlICE9PSBcInByaW1pdGl2ZVwiKSB7XG4gICAgICAgICAgICBmbHVpZC5tb2RlbC5mZXRjaENoYW5nZUNoaWxkcmVuKHRhcmdldFtuYW1lXSwgaSArIDEsIHNlZ3MsIHNvdXJjZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZmx1aWQubW9kZWwuc3RlcFRhcmdldEFjY2VzcyA9IGZ1bmN0aW9uICh0YXJnZXQsIHR5cGUsIHNlZ3MsIHN0YXJ0cG9zLCBlbmRwb3MsIG9wdGlvbnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0cG9zOyBpIDwgZW5kcG9zOyArKyBpKSB7XG4gICAgICAgICAgICB2YXIgb2xkVHJ1bmsgPSB0YXJnZXRbc2Vnc1tpXV07XG4gICAgICAgICAgICB0YXJnZXQgPSBmbHVpZC5tb2RlbC50cmF2ZXJzZVdpdGhTdHJhdGVneSh0YXJnZXQsIHNlZ3MsIGksIG9wdGlvbnNbdHlwZSA9PT0gXCJBRERcIiA/IFwicmVzb2x2ZXJTZXRDb25maWdcIiA6IFwicmVzb2x2ZXJHZXRDb25maWdcIl0sXG4gICAgICAgICAgICAgICAgc2Vncy5sZW5ndGggLSBpIC0gMSk7XG4gICAgICAgICAgICBpZiAob2xkVHJ1bmsgIT09IHRhcmdldCAmJiBvcHRpb25zLmNoYW5nZU1hcCkge1xuICAgICAgICAgICAgICAgIGZsdWlkLm1vZGVsLnNldENoYW5nZWRQYXRoKG9wdGlvbnMsIHNlZ3Muc2xpY2UoMCwgaSArIDEpLCBcIkFERFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge3Jvb3Q6IHRhcmdldCwgbGFzdDogc2Vnc1tlbmRwb3NdfTtcbiAgICB9O1xuXG4gICAgZmx1aWQubW9kZWwuZGVmYXVsdEFjY2Vzc29yQ29uZmlnID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIG9wdGlvbnMucmVzb2x2ZXJTZXRDb25maWcgPSBvcHRpb25zLnJlc29sdmVyU2V0Q29uZmlnIHx8IGZsdWlkLm1vZGVsLmRlZmF1bHRTZXRDb25maWc7XG4gICAgICAgIG9wdGlvbnMucmVzb2x2ZXJHZXRDb25maWcgPSBvcHRpb25zLnJlc29sdmVyR2V0Q29uZmlnIHx8IGZsdWlkLm1vZGVsLmRlZmF1bHRHZXRDb25maWc7XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH07XG5cbiAgICAvLyBBZnRlciB0aGUgMS41IHJlbGVhc2UsIHRoaXMgd2lsbCByZXBsYWNlIHRoZSBvbGQgXCJhcHBseUNoYW5nZVJlcXVlc3RcIlxuICAgIC8vIENoYW5nZXM6IFwiTUVSR0VcIiBhY3Rpb24gYWJvbGlzaGVkXG4gICAgLy8gQUREL0RFTEVURSBhdCByb290IGNhbiBiZSBkZXN0cnVjdGl2ZVxuICAgIC8vIGNoYW5nZXMgdHJhY2tlZCBpbiBvcHRpb25hbCBmaW5hbCBhcmd1bWVudCBob2xkaW5nIFwiY2hhbmdlTWFwOiB7fSwgY2hhbmdlczogMCwgdW5jaGFuZ2VkOiAwXCJcbiAgICBmbHVpZC5tb2RlbC5hcHBseUhvbGRlckNoYW5nZVJlcXVlc3QgPSBmdW5jdGlvbiAoaG9sZGVyLCByZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBmbHVpZC5tb2RlbC5kZWZhdWx0QWNjZXNzb3JDb25maWcob3B0aW9ucyk7XG4gICAgICAgIG9wdGlvbnMuZGVsdGFNYXAgPSBvcHRpb25zLmNoYW5nZU1hcCA/IHt9IDogbnVsbDtcbiAgICAgICAgb3B0aW9ucy5kZWx0YXMgPSAwO1xuICAgICAgICB2YXIgbGVuZ3RoID0gcmVxdWVzdC5zZWdzLmxlbmd0aDtcbiAgICAgICAgdmFyIHBlbiwgYXRSb290ID0gbGVuZ3RoID09PSAwO1xuICAgICAgICBpZiAoYXRSb290KSB7XG4gICAgICAgICAgICBwZW4gPSB7cm9vdDogaG9sZGVyLCBsYXN0OiBcIm1vZGVsXCJ9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFob2xkZXIubW9kZWwpIHtcbiAgICAgICAgICAgICAgICBob2xkZXIubW9kZWwgPSB7fTtcbiAgICAgICAgICAgICAgICBmbHVpZC5tb2RlbC5zZXRDaGFuZ2VkUGF0aChvcHRpb25zLCBbXSwgb3B0aW9ucy5pbnZlcnNlID8gXCJERUxFVEVcIiA6IFwiQUREXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGVuID0gZmx1aWQubW9kZWwuc3RlcFRhcmdldEFjY2Vzcyhob2xkZXIubW9kZWwsIHJlcXVlc3QudHlwZSwgcmVxdWVzdC5zZWdzLCAwLCBsZW5ndGggLSAxLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVxdWVzdC50eXBlID09PSBcIkFERFwiKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSByZXF1ZXN0LnZhbHVlO1xuICAgICAgICAgICAgdmFyIHNlZ3MgPSBmbHVpZC5tYWtlQXJyYXkocmVxdWVzdC5zZWdzKTtcbiAgICAgICAgICAgIGZsdWlkLm1vZGVsLmFwcGx5Q2hhbmdlU3RyYXRlZ3kocGVuLnJvb3QsIHBlbi5sYXN0LCBsZW5ndGggLSAxLCBzZWdzLCB2YWx1ZSwgb3B0aW9ucywgYXRSb290KTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXF1ZXN0LnR5cGUgPT09IFwiREVMRVRFXCIpIHtcbiAgICAgICAgICAgIGlmIChwZW4ucm9vdCAmJiBwZW4ucm9vdFtwZW4ubGFzdF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBwZW4ucm9vdFtwZW4ubGFzdF07XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2hhbmdlTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsdWlkLm1vZGVsLnNldENoYW5nZWRQYXRoKG9wdGlvbnMsIHJlcXVlc3Quc2VncywgXCJERUxFVEVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmx1aWQuZmFpbChcIlVucmVjb2duaXNlZCBjaGFuZ2UgdHlwZSBvZiBcIiArIHJlcXVlc3QudHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuZGVsdGFzID8gb3B0aW9ucy5kZWx0YU1hcCA6IG51bGw7XG4gICAgfTtcbiAgICBcbiAgICAvKiogQ29tcGFyZSB0d28gbW9kZWxzIGZvciBlcXVhbGl0eSB1c2luZyBhIGRlZXAgYWxnb3JpdGhtLiBJdCBpcyBhc3N1bWVkIHRoYXQgYm90aCBtb2RlbHMgYXJlIEpTT04tZXF1aXZhbGVudCBhbmQgZG9cbiAgICAgKiBub3QgY29udGFpbiBjaXJjdWxhciBsaW5rcy5cbiAgICAgKiBAcGFyYW0gbW9kZWxhIFRoZSBmaXJzdCBtb2RlbCB0byBiZSBjb21wYXJlZFxuICAgICAqIEBwYXJhbSBtb2RlbGIgVGhlIHNlY29uZCBtb2RlbCB0byBiZSBjb21wYXJlZFxuICAgICAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9IElmIHN1cHBsaWVkLCB3aWxsIHJlY2VpdmUgYSBtYXAgYW5kIHN1bW1hcnkgb2YgdGhlIGNoYW5nZSBjb250ZW50IGJldHdlZW4gdGhlIG9iamVjdHMuIFN0cnVjdHVyZSBpczpcbiAgICAgKiAgICAgY2hhbmdlTWFwOiB7T2JqZWN0L1N0cmluZ30gQW4gaXNvbW9ycGhpYyBtYXAgb2YgdGhlIG9iamVjdCBzdHJ1Y3R1cmVzIHRvIHZhbHVlcyBcIkFERFwiIG9yIFwiREVMRVRFXCIgaW5kaWNhdGluZ1xuICAgICAqIHRoYXQgdmFsdWVzIGhhdmUgYmVlbiBhZGRlZC9yZW1vdmVkIGF0IHRoYXQgbG9jYXRpb24uIE5vdGUgdGhhdCBpbiB0aGUgY2FzZSB0aGUgb2JqZWN0IHN0cnVjdHVyZSBkaWZmZXJzIGF0IHRoZSByb290LCA8Y29kZT5jaGFuZ2VNYXA8L2NvZGU+IHdpbGwgaG9sZFxuICAgICAqIHRoZSBwbGFpbiBTdHJpbmcgdmFsdWUgXCJBRERcIiBvciBcIkRFTEVURVwiXG4gICAgICogICAgIGNoYW5nZXM6IHtJbnRlZ2VyfSBDb3VudHMgdGhlIG51bWJlciBvZiBjaGFuZ2VzIGJldHdlZW4gdGhlIG9iamVjdHMgLSBUaGUgdHdvIG9iamVjdHMgYXJlIGlkZW50aWNhbCBpZmYgPGNvZGU+Y2hhbmdlcyA9PT0gMDwvY29kZT4uXG4gICAgICogICAgIHVuY2hhbmdlZDoge0ludGVnZXJ9IENvdW50cyB0aGUgbnVtYmVyIG9mIGxlYWYgKHByaW1pdGl2ZSkgdmFsdWVzIGF0IHdoaWNoIHRoZSB0d28gb2JqZWN0cyBhcmUgaWRlbnRpY2FsLiBOb3RlIHRoYXQgdGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gd2lsbFxuICAgICAqIGRvdWJsZS1jb3VudCwgdGhpcyBzdW1tYXJ5IHNob3VsZCBiZSBjb25zaWRlcmVkIGluZGljYXRpdmUgcmF0aGVyIHRoYW4gcHJlY2lzZS5cbiAgICAgKiBAcmV0dXJuIDxjb2RlPnRydWU8L2NvZGU+IGlmIHRoZSBtb2RlbHMgYXJlIGlkZW50aWNhbFxuICAgICAqL1xuICAgIC8vIFRPRE86IFRoaXMgYWxnb3JpdGhtIGlzIHF1aXRlIGluZWZmaWNpZW50IGluIHRoYXQgYm90aCBtb2RlbHMgd2lsbCBiZSBjb3BpZWQgb25jZSBlYWNoXG4gICAgLy8gc3VwcG9ydGVkLCBQVUJMSUMgQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQubW9kZWwuZGlmZiA9IGZ1bmN0aW9uIChtb2RlbGEsIG1vZGVsYiwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7Y2hhbmdlczogMCwgdW5jaGFuZ2VkOiAwLCBjaGFuZ2VNYXA6IHt9fTsgLy8gY3VycmVudCBhbGdvcml0aG0gY2FuJ3QgYXZvaWQgdGhlIGV4cGVuc2Ugb2YgY2hhbmdlTWFwXG4gICAgICAgIHZhciB0eXBlYSA9IGZsdWlkLnR5cGVDb2RlKG1vZGVsYSk7XG4gICAgICAgIHZhciB0eXBlYiA9IGZsdWlkLnR5cGVDb2RlKG1vZGVsYik7XG4gICAgICAgIHZhciB0b2dvO1xuICAgICAgICBpZiAodHlwZWEgPT09IFwicHJpbWl0aXZlXCIgJiYgdHlwZWIgPT09IFwicHJpbWl0aXZlXCIpIHtcbiAgICAgICAgICAgIHRvZ28gPSBmbHVpZC5tb2RlbC5pc1NhbWVWYWx1ZShtb2RlbGEsIG1vZGVsYik7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZWEgPT09IFwicHJpbWl0aXZlXCIgXiB0eXBlYiA9PT0gXCJwcmltaXRpdmVcIikge1xuICAgICAgICAgICAgdG9nbyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQXBwbHkgYm90aCBmb3J3YXJkIGFuZCByZXZlcnNlIGNoYW5nZXMgLSBpZiBubyBjaGFuZ2VzIGVpdGhlciB3YXksIG1vZGVscyBhcmUgaWRlbnRpY2FsXG4gICAgICAgICAgICAvLyBcIkFERFwiIHJlcG9ydGVkIGluIHRoZSByZXZlcnNlIGRpcmVjdGlvbiBtdXN0IGJlIGFjY291bnRlZCBhcyBhIFwiREVMRVRFXCJcbiAgICAgICAgICAgIHZhciBob2xkZXJhID0ge1xuICAgICAgICAgICAgICAgIG1vZGVsOiBmbHVpZC5jb3B5KG1vZGVsYSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmbHVpZC5tb2RlbC5hcHBseUhvbGRlckNoYW5nZVJlcXVlc3QoaG9sZGVyYSwge3ZhbHVlOiBtb2RlbGIsIHNlZ3M6IFtdLCB0eXBlOiBcIkFERFwifSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB2YXIgaG9sZGVyYiA9IHtcbiAgICAgICAgICAgICAgICBtb2RlbDogZmx1aWQuY29weShtb2RlbGIpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgb3B0aW9ucy5pbnZlcnNlID0gdHJ1ZTtcbiAgICAgICAgICAgIGZsdWlkLm1vZGVsLmFwcGx5SG9sZGVyQ2hhbmdlUmVxdWVzdChob2xkZXJiLCB7dmFsdWU6IG1vZGVsYSwgc2VnczogW10sIHR5cGU6IFwiQUREXCJ9LCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRvZ28gPSBvcHRpb25zLmNoYW5nZXMgPT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvZ28gPT09IGZhbHNlICYmIG9wdGlvbnMuY2hhbmdlcyA9PT0gMCkgeyAvLyBjYXRjaCBhbGwgcHJpbWl0aXZlIGNhc2VzXG4gICAgICAgICAgICBvcHRpb25zLmNoYW5nZXMgPSAxO1xuICAgICAgICAgICAgb3B0aW9ucy5jaGFuZ2VNYXAgPSBtb2RlbGIgPT09IHVuZGVmaW5lZCA/IFwiREVMRVRFXCIgOiBcIkFERFwiO1xuICAgICAgICB9IGVsc2UgaWYgKHRvZ28gPT09IHRydWUgJiYgb3B0aW9ucy51bmNoYW5nZWQgPT09IDApIHtcbiAgICAgICAgICAgIG9wdGlvbnMudW5jaGFuZ2VkID0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9nbztcbiAgICB9O1xuXG4gICAgLy8gSGVyZSB3ZSBvbmx5IHN1cHBvcnQgZm9yIG5vdyB2ZXJ5IHNpbXBsZSBleHByZXNzaW9ucyB3aGljaCBoYXZlIGF0IG1vc3Qgb25lXG4gICAgLy8gd2lsZGNhcmQgd2hpY2ggbXVzdCBhcHBlYXIgaW4gdGhlIGZpbmFsIHNlZ21lbnRcbiAgICBmbHVpZC5tYXRjaENoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlTWFwLCBzcGVjU2VncywgbmV3SG9sZGVyKSB7XG4gICAgICAgIHZhciByb290ID0gbmV3SG9sZGVyLm1vZGVsO1xuICAgICAgICB2YXIgbWFwID0gY2hhbmdlTWFwO1xuICAgICAgICB2YXIgb3V0U2VncyA9IFtcIm1vZGVsXCJdO1xuICAgICAgICB2YXIgd2lsZGNhcmQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHRvZ28gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGVjU2Vncy5sZW5ndGg7ICsrIGkpIHtcbiAgICAgICAgICAgIHZhciBzZWcgPSBzcGVjU2Vnc1tpXTtcbiAgICAgICAgICAgIGlmIChzZWcgPT09IFwiKlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IHNwZWNTZWdzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgd2lsZGNhcmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZsdWlkLmZhaWwoXCJXaWxkY2FyZCBzcGVjaWZpY2F0aW9uIGluIG1vZGVsQ2hhbmdlZCBsaXN0ZW5lciBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgdGhlIGZpbmFsIHBhdGggc2VnbWVudDogXCIgKyBzcGVjU2Vncy5qb2luKFwiLlwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRTZWdzLnB1c2goc2VnKTtcbiAgICAgICAgICAgICAgICBtYXAgPSBmbHVpZC5pc1ByaW1pdGl2ZShtYXApID8gbWFwIDogbWFwW3NlZ107XG4gICAgICAgICAgICAgICAgcm9vdCA9IHJvb3QgPyByb290W3NlZ10gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcCkge1xuICAgICAgICAgICAgaWYgKHdpbGRjYXJkKSB7XG4gICAgICAgICAgICAgICAgZmx1aWQuZWFjaChyb290LCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICB0b2dvLnB1c2gob3V0U2Vncy5jb25jYXQoa2V5KSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvZ28ucHVzaChvdXRTZWdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9nbztcbiAgICB9O1xuXG4gICAgZmx1aWQuc3RvcmVFeHRlcm5hbENoYW5nZSA9IGZ1bmN0aW9uICh0cmFuc1JlYywgYXBwbGllciwgaW52YWxpZFBhdGgsIHNwZWMsIGFyZ3MpIHtcbiAgICAgICAgdmFyIHBhdGhTdHJpbmcgPSBhcHBsaWVyLmNvbXBvc2VTZWdtZW50cy5hcHBseShudWxsLCBpbnZhbGlkUGF0aCk7XG4gICAgICAgIHZhciBrZXlTZWdzID0gW2FwcGxpZXIuYXBwbGllcklkLCBmbHVpZC5ldmVudC5pZGVudGlmeUxpc3RlbmVyKHNwZWMubGlzdGVuZXIpLCBzcGVjLmxpc3RlbmVySW5kZXgsIHBhdGhTdHJpbmddO1xuICAgICAgICB2YXIga2V5U3RyaW5nID0ga2V5U2Vncy5qb2luKFwifFwiKTtcbiAgICAgICAgLy8gVGhlc2UgYXJlIHVuYm90dGxlZCBpbiBmbHVpZC5jb25jbHVkZVRyYW5zYWN0aW9uXG4gICAgICAgIHRyYW5zUmVjLmV4dGVybmFsQ2hhbmdlc1trZXlTdHJpbmddID0ge2xpc3RlbmVyOiBzcGVjLmxpc3RlbmVyLCBwcmlvcml0eTogc3BlYy5wcmlvcml0eSwgYXJnczogYXJnc307XG4gICAgfTtcbiAgICBcbiAgICBmbHVpZC5pc0V4Y2x1ZGVkQ2hhbmdlU291cmNlID0gZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBzcGVjKSB7XG4gICAgICAgIGlmICghc3BlYy5leGNsdWRlU291cmNlKSB7IC8vIG1lcmdlTW9kZWxMaXN0ZW5lcnMgaW5pdE1vZGVsRXZlbnQgZmFicmljYXRlcyBhIGZha2Ugc3BlYyB0aGF0IGJ5cGFzc2VzIHByb2Nlc3NpbmdcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXhjbHVkZWQgPSBzcGVjLmV4Y2x1ZGVTb3VyY2VbXCIqXCJdO1xuICAgICAgICBmb3IgKHZhciBzb3VyY2UgaW4gdHJhbnNhY3Rpb24uc291cmNlcykge1xuICAgICAgICAgICAgaWYgKHNwZWMuZXhjbHVkZVNvdXJjZVtzb3VyY2VdKSB7XG4gICAgICAgICAgICAgICAgZXhjbHVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNwZWMuaW5jbHVkZVNvdXJjZVtzb3VyY2VdKSB7XG4gICAgICAgICAgICAgICAgZXhjbHVkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhjbHVkZWQ7XG4gICAgfTtcblxuICAgIGZsdWlkLm5vdGlmeU1vZGVsQ2hhbmdlcyA9IGZ1bmN0aW9uIChsaXN0ZW5lcnMsIGNoYW5nZU1hcCwgbmV3SG9sZGVyLCBvbGRIb2xkZXIsIGNoYW5nZVJlcXVlc3QsIHRyYW5zYWN0aW9uLCBhcHBsaWVyLCB0aGF0KSB7XG4gICAgICAgIHZhciBpbnN0YW50aWF0b3IgPSBmbHVpZC5nZXRJbnN0YW50aWF0b3IodGhhdCk7XG4gICAgICAgIHZhciB0cmFuc1JlYyA9IHRyYW5zYWN0aW9uICYmIGZsdWlkLmdldE1vZGVsVHJhbnNhY3Rpb25SZWMoaW5zdGFudGlhdG9yLCB0cmFuc2FjdGlvbi5pZCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgKysgaSkge1xuICAgICAgICAgICAgdmFyIHNwZWMgPSBsaXN0ZW5lcnNbaV07XG4gICAgICAgICAgICB2YXIgaW52YWxpZFBhdGhzID0gZmx1aWQubWF0Y2hDaGFuZ2VzKGNoYW5nZU1hcCwgc3BlYy5zZWdzLCBuZXdIb2xkZXIpO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpbnZhbGlkUGF0aHMubGVuZ3RoOyArKyBqKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFwcGxpZXIuZGVzdHJveWVkKSB7IC8vIDJuZCBndWFyZGluZyBwb2ludCBmb3IgRkxVSUQtNTU5MlxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBpbnZhbGlkUGF0aCA9IGludmFsaWRQYXRoc1tqXTtcbiAgICAgICAgICAgICAgICBzcGVjLmxpc3RlbmVyID0gZmx1aWQuZXZlbnQucmVzb2x2ZUxpc3RlbmVyKHNwZWMubGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IHByb2Nlc3MgbmFtZXNwYWNlIGFuZCBzb2Z0TmFtZXNwYWNlIHJ1bGVzLCBhbmQgcHJvcGFnYXRlIFwic291cmNlc1wiIGluIDR0aCBhcmd1bWVudFxuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW2ZsdWlkLm1vZGVsLmdldFNpbXBsZShuZXdIb2xkZXIsIGludmFsaWRQYXRoKSwgZmx1aWQubW9kZWwuZ2V0U2ltcGxlKG9sZEhvbGRlciwgaW52YWxpZFBhdGgpLCBpbnZhbGlkUGF0aC5zbGljZSgxKSwgY2hhbmdlUmVxdWVzdCwgdHJhbnNhY3Rpb24sIGFwcGxpZXJdO1xuICAgICAgICAgICAgICAgIC8vIEZMVUlELTU0ODk6IERvIG5vdCBub3RpZnkgb2YgbnVsbCBjaGFuZ2VzIHdoaWNoIHdlcmUgcmVwb3J0ZWQgYXMgYSByZXN1bHQgb2YgaW52YWxpZGF0aW5nIGEgaGlnaGVyIHBhdGhcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBXZSBjYW4gaW1wcm92ZSBncmVhdGx5IG9uIGVmZmljaWVuY3kgYnkgaSkgcmVwb3J0aW5nIGEgc3BlY2lhbCBjb2RlIGZyb20gZmx1aWQubWF0Y2hDaGFuZ2VzIHdoaWNoIHNpZ25hbHMgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBpbnZhbGlkYXRpbmcgYSBoaWdoZXIgYW5kIGxvd2VyIHBhdGgsXG4gICAgICAgICAgICAgICAgLy8gaWkpIGltcHJvdmluZyBmbHVpZC5tb2RlbC5kaWZmIHRvIGNyZWF0ZSBmZXdlciBpbnRlcm1lZGlhdGUgc3RydWN0dXJlcyBhbmQgbm8gY29waWVzXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogVGhlIHJlbGF5IGludmFsaWRhdGlvbiBzeXN0ZW0gaXMgYnJva2VuIGFuZCBtdXN0IGFsd2F5cyBiZSBub3RpZmllZCAoYnJhbmNoIDEpIC0gc2luY2Ugb3VyIG9sZC9uZXcgdmFsdWUgZGV0ZWN0aW9uIGlzIGJhc2VkIG9uIHRoZSB3cm9uZyAoZ2xvYmFsKSB0aW1lcG9pbnRzIGluIHRoZSB0cmFuc2FjdGlvbiBoZXJlLFxuICAgICAgICAgICAgICAgIC8vIHJhdGhlciB0aGFuIHRoZSBcImxhc3QgcmVjZWl2ZWQgbW9kZWxcIiBieSB0aGUgaG9sZGVyIG9mIHRoZSB0cmFuc2Zvcm0gZG9jdW1lbnRcbiAgICAgICAgICAgICAgICBpZiAoIXNwZWMuaXNSZWxheSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXNOdWxsID0gZmx1aWQubW9kZWwuZGlmZihhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZUV4Y2x1ZGVkID0gZmx1aWQuaXNFeGNsdWRlZENoYW5nZVNvdXJjZSh0cmFuc2FjdGlvbiwgc3BlYyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VFeGNsdWRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zUmVjICYmICFzcGVjLmlzUmVsYXkgJiYgc3BlYy50cmFuc2FjdGlvbmFsKSB7IC8vIGJvdHRsZSB1cCBnZW51aW5lIGV4dGVybmFsIGNoYW5nZXMgc28gd2UgY2FuIHNvcnQgYW5kIGRlZHVwZSB0aGVtIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgIGZsdWlkLnN0b3JlRXh0ZXJuYWxDaGFuZ2UodHJhbnNSZWMsIGFwcGxpZXIsIGludmFsaWRQYXRoLCBzcGVjLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzcGVjLmxpc3RlbmVyLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmbHVpZC5iaW5kRUxNZXRob2RzID0gZnVuY3Rpb24gKGFwcGxpZXIpIHtcbiAgICAgICAgYXBwbGllci5wYXJzZUVMID0gZnVuY3Rpb24gKEVMKSB7XG4gICAgICAgICAgICByZXR1cm4gZmx1aWQubW9kZWwucGF0aFRvU2VnbWVudHMoRUwsIGFwcGxpZXIub3B0aW9ucy5yZXNvbHZlclNldENvbmZpZyk7XG4gICAgICAgIH07XG4gICAgICAgIGFwcGxpZXIuY29tcG9zZVNlZ21lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGFwcGxpZXIub3B0aW9ucy5yZXNvbHZlclNldENvbmZpZy5wYXJzZXIuY29tcG9zZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBmbHVpZC5pbml0TW9kZWxFdmVudCA9IGZ1bmN0aW9uICh0aGF0LCB0cmFucywgbGlzdGVuZXJzKSB7XG4gICAgICAgIGZsdWlkLm5vdGlmeU1vZGVsQ2hhbmdlcyhsaXN0ZW5lcnMsIFwiQUREXCIsIHRyYW5zLm9sZEhvbGRlciwgZmx1aWQuZW1wdHlIb2xkZXIsIG51bGwsIHRyYW5zLCB0aGF0KTtcbiAgICB9O1xuXG4gICAgZmx1aWQuZW1wdHlIb2xkZXIgPSB7IG1vZGVsOiB1bmRlZmluZWQgfTtcblxuICAgIGZsdWlkLm1ha2VOZXdDaGFuZ2VBcHBsaWVyID0gZnVuY3Rpb24gKGhvbGRlciwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gZmx1aWQubW9kZWwuZGVmYXVsdEFjY2Vzc29yQ29uZmlnKG9wdGlvbnMpO1xuICAgICAgICB2YXIgYXBwbGllcklkID0gZmx1aWQuYWxsb2NhdGVHdWlkKCk7XG4gICAgICAgIHZhciB0aGF0ID0ge1xuICAgICAgICAgICAgYXBwbGllcklkOiBhcHBsaWVySWQsXG4gICAgICAgICAgICBob2xkZXI6IGhvbGRlcixcbiAgICAgICAgICAgIGNoYW5nZUxpc3RlbmVyczoge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyczogW10sXG4gICAgICAgICAgICAgICAgdHJhbnNMaXN0ZW5lcnM6IFtdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgICAgIG1vZGVsQ2hhbmdlZDoge30sXG4gICAgICAgICAgICBwcmVDb21taXQ6IGZsdWlkLm1ha2VFdmVudEZpcmVyKHtuYW1lOiBcInByZUNvbW1pdCBldmVudCBmb3IgQ2hhbmdlQXBwbGllciBcIiB9KSxcbiAgICAgICAgICAgIHBvc3RDb21taXQ6IGZsdWlkLm1ha2VFdmVudEZpcmVyKHtuYW1lOiBcInBvc3RDb21taXQgZXZlbnQgZm9yIENoYW5nZUFwcGxpZXIgXCJ9KVxuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBwcmVGaXJlQ2hhbmdlUmVxdWVzdChjaGFuZ2VSZXF1ZXN0KSB7XG4gICAgICAgICAgICBpZiAoIWNoYW5nZVJlcXVlc3QudHlwZSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZVJlcXVlc3QudHlwZSA9IFwiQUREXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGFuZ2VSZXF1ZXN0LnNlZ3MgPSBjaGFuZ2VSZXF1ZXN0LnNlZ3MgfHwgdGhhdC5wYXJzZUVMKGNoYW5nZVJlcXVlc3QucGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhhdC5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5wcmVDb21taXQuZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhhdC5wb3N0Q29tbWl0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoYXQuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhhdC5tb2RlbENoYW5nZWQuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiAoc3BlYywgbGlzdGVuZXIsIG5hbWVzcGFjZSwgc29mdE5hbWVzcGFjZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZihzcGVjKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHNwZWMgPSB7cGF0aDogc3BlY307XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNwZWMgPSBmbHVpZC5jb3B5KHNwZWMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3BlYy5pZCA9IGZsdWlkLmV2ZW50LmlkZW50aWZ5TGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgICAgICAgc3BlYy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gICAgICAgICAgICBzcGVjLnNvZnROYW1lc3BhY2UgPSBzb2Z0TmFtZXNwYWNlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZihsaXN0ZW5lcikgPT09IFwic3RyaW5nXCIpIHsgLy8gVE9ETzogcmVwbGljYXRlIHRoaXMgbm9uc2Vuc2UgZnJvbSBGbHVpZC5qcyB1bnRpbCB3ZSByZW1lbWJlciBpdHMgcHVycG9zZVxuICAgICAgICAgICAgICAgIGxpc3RlbmVyID0ge2dsb2JhbE5hbWU6IGxpc3RlbmVyfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNwZWMubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgICAgICAgIGlmIChzcGVjLnRyYW5zYWN0aW9uYWwgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgc3BlYy50cmFuc2FjdGlvbmFsID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNwZWMuc2VncyA9IHNwZWMuc2VncyB8fCB0aGF0LnBhcnNlRUwoc3BlYy5wYXRoKTtcbiAgICAgICAgICAgIHZhciBjb2xsZWN0aW9uID0gdGhhdC5jaGFuZ2VMaXN0ZW5lcnNbc3BlYy50cmFuc2FjdGlvbmFsID8gXCJ0cmFuc0xpc3RlbmVyc1wiIDogXCJsaXN0ZW5lcnNcIl07XG4gICAgICAgICAgICBzcGVjLmV4Y2x1ZGVTb3VyY2UgPSBmbHVpZC5hcnJheVRvSGFzaChmbHVpZC5tYWtlQXJyYXkoc3BlYy5leGNsdWRlU291cmNlIHx8IChzcGVjLmluY2x1ZGVTb3VyY2UgPyBcIipcIiA6IHVuZGVmaW5lZCkpKTtcbiAgICAgICAgICAgIHNwZWMuaW5jbHVkZVNvdXJjZSA9IGZsdWlkLmFycmF5VG9IYXNoKGZsdWlkLm1ha2VBcnJheShzcGVjLmluY2x1ZGVTb3VyY2UpKTtcbiAgICAgICAgICAgIHNwZWMucHJpb3JpdHkgPSBmbHVpZC5ldmVudC5tYXBQcmlvcml0eShzcGVjLnByaW9yaXR5LCBjb2xsZWN0aW9uLmxlbmd0aCk7XG4gICAgICAgICAgICBjb2xsZWN0aW9uLnB1c2goc3BlYyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoYXQubW9kZWxDaGFuZ2VkLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICB2YXIgaWQgPSBmbHVpZC5ldmVudC5pZGVudGlmeUxpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIHZhciBuYW1lc3BhY2UgPSB0eXBlb2YobGlzdGVuZXIpID09PSBcInN0cmluZ1wiID8gbGlzdGVuZXI6IG51bGw7XG4gICAgICAgICAgICB2YXIgcmVtb3ZlUHJlZCA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjb3JkLmlkID09PSBpZCB8fCByZWNvcmQubmFtZXNwYWNlID09PSBuYW1lc3BhY2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZmx1aWQucmVtb3ZlX2lmKHRoYXQuY2hhbmdlTGlzdGVuZXJzLmxpc3RlbmVycywgcmVtb3ZlUHJlZCk7XG4gICAgICAgICAgICBmbHVpZC5yZW1vdmVfaWYodGhhdC5jaGFuZ2VMaXN0ZW5lcnMudHJhbnNMaXN0ZW5lcnMsIHJlbW92ZVByZWQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGF0Lm1vZGVsQ2hhbmdlZC5pc1JlbGF5RXZlbnQgPSB0cnVlOyAvLyBUT0RPOiBjaGVhcCBoZWxwZXIgZm9yIElvQyB0ZXN0aW5nIGZyYW1ld29yayAtIHJlbW92ZSB3aGVuIG9sZCBDaGFuZ2VBcHBsaWVyIGdvZXNcbiAgICAgICAgdGhhdC5maXJlQ2hhbmdlUmVxdWVzdCA9IGZ1bmN0aW9uIChjaGFuZ2VSZXF1ZXN0KSB7XG4gICAgICAgICAgICB2YXIgYXRpb24gPSB0aGF0LmluaXRpYXRlKCk7XG4gICAgICAgICAgICBhdGlvbi5maXJlQ2hhbmdlUmVxdWVzdChjaGFuZ2VSZXF1ZXN0KTtcbiAgICAgICAgICAgIGF0aW9uLmNvbW1pdCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQuaW5pdGlhdGUgPSBmdW5jdGlvbiAoc291cmNlLCB0cmFuc2FjdGlvbklkKSB7XG4gICAgICAgICAgICBzb3VyY2UgPSBzb3VyY2UgfHwgXCJsb2NhbFwiO1xuICAgICAgICAgICAgdmFyIGRlZmVhdFBvc3QgPSBzb3VyY2UgPT09IFwicmVsYXlcIjsgLy8gZGVmZWF0UG9zdCBpcyBzdXBwbGllZCBmb3IgYWxsIG5vbi10b3AtbGV2ZWwgdHJhbnNhY3Rpb25zXG4gICAgICAgICAgICB2YXIgdHJhbnMgPSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2VJZDogZmx1aWQuYWxsb2NhdGVHdWlkKCksIC8vIGZvciBkZWJ1Z2dpbmcgb25seVxuICAgICAgICAgICAgICAgIGlkOiB0cmFuc2FjdGlvbklkIHx8IGZsdWlkLmFsbG9jYXRlR3VpZCgpLFxuICAgICAgICAgICAgICAgIHNvdXJjZXM6IHt9LFxuICAgICAgICAgICAgICAgIGNoYW5nZVJlY29yZDoge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlclNldENvbmZpZzogb3B0aW9ucy5yZXNvbHZlclNldENvbmZpZywgLy8gaGVyZSB0byBhY3QgYXMgXCJvcHRpb25zXCIgaW4gYXBwbHlIb2xkZXJDaGFuZ2VSZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVyR2V0Q29uZmlnOiBvcHRpb25zLnJlc29sdmVyR2V0Q29uZmlnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0cmFucy5vbGRIb2xkZXIgPSBob2xkZXI7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zLm5ld0hvbGRlciA9IHsgbW9kZWw6IGZsdWlkLmNvcHkoaG9sZGVyLm1vZGVsKSB9O1xuICAgICAgICAgICAgICAgICAgICB0cmFucy5jaGFuZ2VSZWNvcmQuY2hhbmdlcyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zLmNoYW5nZVJlY29yZC51bmNoYW5nZWQgPSAwOyAvLyBqdXN0IGZvciB0eXBlIGNvbnNpc3RlbmN5IC0gd2UgZG9uJ3QgdXNlIHRoZXNlIHZhbHVlcyBpbiB0aGUgQ2hhbmdlQXBwbGllclxuICAgICAgICAgICAgICAgICAgICB0cmFucy5jaGFuZ2VSZWNvcmQuY2hhbmdlTWFwID0ge307XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb21taXQ6IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQucHJlQ29tbWl0LmZpcmUodHJhbnMsIHRoYXQsIGNvZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnMuY2hhbmdlUmVjb3JkLmNoYW5nZXMgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2xkSG9sZGVyID0ge21vZGVsOiBob2xkZXIubW9kZWx9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLm1vZGVsID0gdHJhbnMubmV3SG9sZGVyLm1vZGVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmx1aWQubm90aWZ5TW9kZWxDaGFuZ2VzKHRoYXQuY2hhbmdlTGlzdGVuZXJzLnRyYW5zTGlzdGVuZXJzLCB0cmFucy5jaGFuZ2VSZWNvcmQuY2hhbmdlTWFwLCBob2xkZXIsIG9sZEhvbGRlciwgbnVsbCwgdHJhbnMsIHRoYXQsIGhvbGRlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkZWZlYXRQb3N0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnBvc3RDb21taXQuZmlyZSh0cmFucywgdGhhdCwgY29kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZpcmVDaGFuZ2VSZXF1ZXN0OiBmdW5jdGlvbiAoY2hhbmdlUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICBwcmVGaXJlQ2hhbmdlUmVxdWVzdChjaGFuZ2VSZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlUmVxdWVzdC50cmFuc2FjdGlvbklkID0gdHJhbnMuaWQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWx0YU1hcCA9IGZsdWlkLm1vZGVsLmFwcGx5SG9sZGVyQ2hhbmdlUmVxdWVzdCh0cmFucy5uZXdIb2xkZXIsIGNoYW5nZVJlcXVlc3QsIHRyYW5zLmNoYW5nZVJlY29yZCk7XG4gICAgICAgICAgICAgICAgICAgIGZsdWlkLm5vdGlmeU1vZGVsQ2hhbmdlcyh0aGF0LmNoYW5nZUxpc3RlbmVycy5saXN0ZW5lcnMsIGRlbHRhTWFwLCB0cmFucy5uZXdIb2xkZXIsIGhvbGRlciwgY2hhbmdlUmVxdWVzdCwgdHJhbnMsIHRoYXQsIGhvbGRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRyYW5zLnNvdXJjZXNbc291cmNlXSA9IHRydWU7XG4gICAgICAgICAgICB0cmFucy5yZXNldCgpO1xuICAgICAgICAgICAgZmx1aWQuYmluZFJlcXVlc3RDaGFuZ2UodHJhbnMpO1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zO1xuICAgICAgICB9O1xuICAgICAgICB0aGF0Lmhhc0NoYW5nZVNvdXJjZSA9IGZ1bmN0aW9uIChzb3VyY2UsIGNoYW5nZXMpIHsgLy8gY29tcGF0aWJpbGl0eSBmb3Igb2xkIEFQSVxuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZXMgPyBjaGFuZ2VzW3NvdXJjZV0gOiBmYWxzZTtcbiAgICAgICAgfTtcblxuICAgICAgICBmbHVpZC5iaW5kUmVxdWVzdENoYW5nZSh0aGF0KTtcbiAgICAgICAgZmx1aWQuYmluZEVMTWV0aG9kcyh0aGF0KTtcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfTtcblxuXG4gICAgLyoqIE9MRCBDSEFOR0VBUFBMSUVSIElNUExFTUVOVEFUSU9OIChJbmZ1c2lvbiAxLjUgYW5kIGJlZm9yZSAtIHRoaXMgd2lsbCBiZSByZW1vdmVkIG9uIEZsdWlkIDIuMCkgKiovXG5cbiAgICAvKiogUGFyc2VzIGEgcGF0aCBzZWdtZW50LCBmb2xsb3dpbmcgZXNjYXBpbmcgcnVsZXMsIHN0YXJ0aW5nIGZyb20gY2hhcmFjdGVyIGluZGV4IGkgaW4gdGhlIHN1cHBsaWVkIHBhdGggKi9cbiAgICBmbHVpZC5wYXRoVXRpbC5nZXRQYXRoU2VnbWVudCA9IGZ1bmN0aW9uIChwYXRoLCBpKSB7XG4gICAgICAgIGdldFBhdGhTZWdtZW50SW1wbChnbG9iYWxBY2NlcHQsIHBhdGgsIGkpO1xuICAgICAgICByZXR1cm4gZ2xvYmFsQWNjZXB0WzBdO1xuICAgIH07XG5cbiAgICAvKiogUmV0dXJucyBqdXN0IHRoZSBoZWFkIHNlZ21lbnQgb2YgYW4gRUwgcGF0aCAqL1xuICAgIGZsdWlkLnBhdGhVdGlsLmdldEhlYWRQYXRoID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGZsdWlkLnBhdGhVdGlsLmdldFBhdGhTZWdtZW50KHBhdGgsIDApO1xuICAgIH07XG5cbiAgICAvKiogUmV0dXJucyBhbGwgb2YgYW4gRUwgcGF0aCBtaW51cyBpdHMgZmlyc3Qgc2VnbWVudCAtIGlmIHRoZSBwYXRoIGNvbnNpc3RzIG9mIGp1c3Qgb25lIHNlZ21lbnQsIHJldHVybnMgXCJcIiAqL1xuICAgIGZsdWlkLnBhdGhVdGlsLmdldEZyb21IZWFkUGF0aCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIHZhciBmaXJzdGRvdCA9IGdldFBhdGhTZWdtZW50SW1wbChudWxsLCBwYXRoLCAwKTtcbiAgICAgICAgcmV0dXJuIGZpcnN0ZG90ID09PSBwYXRoLmxlbmd0aCA/IFwiXCIgOiBwYXRoLnN1YnN0cmluZyhmaXJzdGRvdCArIDEpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBsYXN0RG90SW5kZXgocGF0aCkge1xuICAgICAgICAvLyBUT0RPOiBwcm9wZXIgZXNjYXBpbmcgcnVsZXNcbiAgICAgICAgcmV0dXJuIHBhdGgubGFzdEluZGV4T2YoXCIuXCIpO1xuICAgIH1cblxuICAgIC8qKiBSZXR1cm5zIGFsbCBvZiBhbiBFTCBwYXRoIG1pbnVzIGl0cyBmaW5hbCBzZWdtZW50IC0gaWYgdGhlIHBhdGggY29uc2lzdHMgb2YganVzdCBvbmUgc2VnbWVudCwgcmV0dXJucyBcIlwiIC1cbiAgICAgKiBXQVJOSU5HIC0gdGhpcyBtZXRob2QgZG9lcyBub3QgZm9sbG93IGVzY2FwaW5nIHJ1bGVzICovXG4gICAgZmx1aWQucGF0aFV0aWwuZ2V0VG9UYWlsUGF0aCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIHZhciBsYXN0ZG90ID0gbGFzdERvdEluZGV4KHBhdGgpO1xuICAgICAgICByZXR1cm4gbGFzdGRvdCA9PT0gLTEgPyBcIlwiIDogcGF0aC5zdWJzdHJpbmcoMCwgbGFzdGRvdCk7XG4gICAgfTtcblxuICAgIC8qKiBSZXR1cm5zIHRoZSB2ZXJ5IGxhc3QgcGF0aCBjb21wb25lbnQgb2YgYW4gRUwgcGF0aFxuICAgICAqIFdBUk5JTkcgLSB0aGlzIG1ldGhvZCBkb2VzIG5vdCBmb2xsb3cgZXNjYXBpbmcgcnVsZXMgKi9cbiAgICBmbHVpZC5wYXRoVXRpbC5nZXRUYWlsUGF0aCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIHZhciBsYXN0ZG90ID0gbGFzdERvdEluZGV4KHBhdGgpO1xuICAgICAgICByZXR1cm4gZmx1aWQucGF0aFV0aWwuZ2V0UGF0aFNlZ21lbnQocGF0aCwgbGFzdGRvdCArIDEpO1xuICAgIH07XG5cbiAgICAvKiogSGVscGZ1bCB1dGlsaXR5IGZvciB1c2UgaW4gcmVzb2x2ZXJzIC0gbWF0Y2hlcyBhIHBhdGggd2hpY2ggaGFzIGFscmVhZHkgYmVlblxuICAgICAgKiBwYXJzZWQgaW50byBzZWdtZW50cyAqKi9cblxuICAgIGZsdWlkLnBhdGhVdGlsLm1hdGNoU2VnbWVudHMgPSBmdW5jdGlvbiAodG9NYXRjaCwgc2Vncywgc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAoZW5kIC0gc3RhcnQgIT09IHRvTWF0Y2gubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArKyBpKSB7XG4gICAgICAgICAgICBpZiAoc2Vnc1tpXSAhPT0gdG9NYXRjaFtpIC0gc3RhcnRdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICAvKiogRGV0ZXJtaW5lIHRoZSBwYXRoIGJ5IHdoaWNoIGEgZ2l2ZW4gcGF0aCBpcyBuZXN0ZWQgd2l0aGluIGFub3RoZXIgKiovXG4gICAgLy8gVE9ETzogVGhpcyB1dGlsaXR5IGlzIG5vdCB1c2VkIGluIHRoZSBmcmFtZXdvcmssIGFuZCB3aWxsIGNlYXNlIHRvIGJlIHVzZWZ1bCBpbiBjbGllbnQgY29kZVxuICAgIC8vIG9uY2Ugd2UgbW92ZSBvdmVyIHRvIHRoZSBkZWNsYXJhdGl2ZSBzeXN0ZW0gZm9yIGNoYW5nZSBiaW5kaW5nXG4gICAgZmx1aWQucGF0aFV0aWwuZ2V0RXhjZXNzUGF0aCA9IGZ1bmN0aW9uIChiYXNlLCBsb25nZXIpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gbG9uZ2VyLmluZGV4T2YoYmFzZSk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gMCkge1xuICAgICAgICAgICAgZmx1aWQuZmFpbChcIlBhdGggXCIgKyBiYXNlICsgXCIgaXMgbm90IGEgcHJlZml4IG9mIHBhdGggXCIgKyBsb25nZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYXNlLmxlbmd0aCA9PT0gbG9uZ2VyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvbmdlcltiYXNlLmxlbmd0aF0gIT09IFwiLlwiKSB7XG4gICAgICAgICAgICBmbHVpZC5mYWlsKFwiUGF0aCBcIiArIGJhc2UgKyBcIiBpcyBub3QgcHJvcGVybHkgbmVzdGVkIGluIHBhdGggXCIgKyBsb25nZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb25nZXIuc3Vic3RyaW5nKGJhc2UubGVuZ3RoICsgMSk7XG4gICAgfTtcblxuICAgIC8qKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBwYXJ0aWN1bGFyIEVMIHBhdGggbWF0Y2hlcyBhIGdpdmVuIHBhdGggc3BlY2lmaWNhdGlvbi5cbiAgICAgKiBUaGUgc3BlY2lmaWNhdGlvbiBjb25zaXN0cyBvZiBhIHBhdGggd2l0aCBvcHRpb25hbCB3aWxkY2FyZCBzZWdtZW50cyByZXByZXNlbnRlZCBieSBcIipcIi5cbiAgICAgKiBAcGFyYW0gc3BlYyAoc3RyaW5nKSBUaGUgc3BlY2lmaWNhdGlvbiB0byBiZSBtYXRjaGVkXG4gICAgICogQHBhcmFtIHBhdGggKHN0cmluZykgVGhlIHBhdGggdG8gYmUgdGVzdGVkXG4gICAgICogQHBhcmFtIGV4YWN0IChib29sZWFuKSBXaGV0aGVyIHRoZSBwYXRoIG11c3QgZXhhY3RseSBtYXRjaCB0aGUgbGVuZ3RoIG9mIHRoZSBzcGVjaWZpY2F0aW9uIGluXG4gICAgICogdGVybXMgb2YgcGF0aCBzZWdtZW50cyBpbiBvcmRlciB0byBjb3VudCBhcyBtYXRjaC4gSWYgZXhhY3QgaXMgZmFsc3ksIHNob3J0IHNwZWNpZmljYXRpb25zIHdpbGxcbiAgICAgKiBtYXRjaCBhbGwgbG9uZ2VyIHBhdGhzIGFzIGlmIHRoZXkgd2VyZSBwYWRkZWQgb3V0IHdpdGggXCIqXCIgc2VnbWVudHNcbiAgICAgKiBAcmV0dXJuIChhcnJheSBvZiBzdHJpbmcpIFRoZSBwYXRoIHNlZ21lbnRzIHdoaWNoIG1hdGNoZWQgdGhlIHNwZWNpZmljYXRpb24sIG9yIDxjb2RlPm51bGw8L2NvZGU+IGlmIHRoZXJlIHdhcyBubyBtYXRjaFxuICAgICAqL1xuXG4gICAgZmx1aWQucGF0aFV0aWwubWF0Y2hQYXRoID0gZnVuY3Rpb24gKHNwZWMsIHBhdGgsIGV4YWN0KSB7XG4gICAgICAgIHZhciB0b2dvID0gW107XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAoKChwYXRoID09PSBcIlwiKSBeIChzcGVjID09PSBcIlwiKSkgJiYgZXhhY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZMVUlELTQ2MjUgLSBzeW1tZXRyeSBvbiBzcGVjIGFuZCBwYXRoIGlzIGFjdHVhbGx5IHVuZGVzaXJhYmxlLCBidXQgdGhpc1xuICAgICAgICAgICAgLy8gcXVpY2tseSBhdm9pZHMgYXQgbGVhc3QgbWlzc2VkIG5vdGlmaWNhdGlvbnMgLSBpbXByb3ZlZCAoYnV0IHNsb3dlcilcbiAgICAgICAgICAgIC8vIGltcGxlbWVudGF0aW9uIHNob3VsZCBleHBsb2RlIGNvbXBvc2l0ZSBjaGFuZ2VzXG4gICAgICAgICAgICBpZiAoIXNwZWMgfHwgIXBhdGgpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzcGVjaGVhZCA9IGZsdWlkLnBhdGhVdGlsLmdldEhlYWRQYXRoKHNwZWMpO1xuICAgICAgICAgICAgdmFyIHBhdGhoZWFkID0gZmx1aWQucGF0aFV0aWwuZ2V0SGVhZFBhdGgocGF0aCk7XG4gICAgICAgICAgICAvLyBpZiB3ZSBmYWlsIHRvIG1hdGNoIG9uIGEgc3BlY2lmaWMgY29tcG9uZW50LCBmYWlsLlxuICAgICAgICAgICAgaWYgKHNwZWNoZWFkICE9PSBcIipcIiAmJiBzcGVjaGVhZCAhPT0gcGF0aGhlYWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvZ28ucHVzaChwYXRoaGVhZCk7XG4gICAgICAgICAgICBzcGVjID0gZmx1aWQucGF0aFV0aWwuZ2V0RnJvbUhlYWRQYXRoKHNwZWMpO1xuICAgICAgICAgICAgcGF0aCA9IGZsdWlkLnBhdGhVdGlsLmdldEZyb21IZWFkUGF0aChwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9nbztcbiAgICB9O1xuXG4gICAgZmx1aWQubW9kZWwuaXNOdWxsQ2hhbmdlID0gZnVuY3Rpb24gKG1vZGVsLCByZXF1ZXN0LCByZXNvbHZlckdldENvbmZpZykge1xuICAgICAgICBpZiAocmVxdWVzdC50eXBlID09PSBcIkFERFwiICYmICFyZXF1ZXN0LmZvcmNlQ2hhbmdlKSB7XG4gICAgICAgICAgICB2YXIgZXhpc3RpbmcgPSBmbHVpZC5nZXQobW9kZWwsIHJlcXVlc3Quc2VncywgcmVzb2x2ZXJHZXRDb25maWcpO1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nID09PSByZXF1ZXN0LnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqIEFwcGxpZXMgdGhlIHN1cHBsaWVkIENoYW5nZVJlcXVlc3Qgb2JqZWN0IGRpcmVjdGx5IHRvIHRoZSBzdXBwbGllZCBtb2RlbC5cbiAgICAgKi9cblxuICAgIGZsdWlkLm1vZGVsLmFwcGx5Q2hhbmdlUmVxdWVzdCA9IGZ1bmN0aW9uIChtb2RlbCwgcmVxdWVzdCwgcmVzb2x2ZXJTZXRDb25maWcpIHtcbiAgICAgICAgdmFyIHBlbiA9IGZsdWlkLm1vZGVsLmFjY2Vzc1dpdGhTdHJhdGVneShtb2RlbCwgcmVxdWVzdC5wYXRoLCBmbHVpZC5WQUxVRSwgcmVzb2x2ZXJTZXRDb25maWcgfHwgZmx1aWQubW9kZWwuZGVmYXVsdFNldENvbmZpZywgbnVsbCwgdHJ1ZSk7XG4gICAgICAgIHZhciBsYXN0ID0gcGVuLnNlZ3NbcGVuLnNlZ3MubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgaWYgKHJlcXVlc3QudHlwZSA9PT0gXCJBRERcIiB8fCByZXF1ZXN0LnR5cGUgPT09IFwiTUVSR0VcIikge1xuICAgICAgICAgICAgaWYgKHBlbi5zZWdzLmxlbmd0aCA9PT0gMCB8fCAocmVxdWVzdC50eXBlID09PSBcIk1FUkdFXCIgJiYgcGVuLnJvb3RbbGFzdF0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QudHlwZSA9PT0gXCJBRERcIikge1xuICAgICAgICAgICAgICAgICAgICBmbHVpZC5jbGVhcihwZW4ucm9vdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICQuZXh0ZW5kKHRydWUsIHBlbi5zZWdzLmxlbmd0aCA9PT0gMCA/IHBlbi5yb290IDogcGVuLnJvb3RbbGFzdF0sIHJlcXVlc3QudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVuLnJvb3RbbGFzdF0gPSByZXF1ZXN0LnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlcXVlc3QudHlwZSA9PT0gXCJERUxFVEVcIikge1xuICAgICAgICAgICAgaWYgKHBlbi5zZWdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGZsdWlkLmNsZWFyKHBlbi5yb290KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBwZW4ucm9vdFtsYXN0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBVdGlsaXR5IHVzZWQgZm9yIHNvdXJjZSB0cmFja2luZyBpbiBjaGFuZ2VBcHBsaWVyXG5cbiAgICBmdW5jdGlvbiBzb3VyY2VXcmFwTW9kZWxDaGFuZ2VkKG1vZGVsQ2hhbmdlZCwgdGhyZWFkTG9jYWwpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjaGFuZ2VSZXF1ZXN0KSB7XG4gICAgICAgICAgICB2YXIgc291cmNlcyA9IHRocmVhZExvY2FsKCkuc291cmNlcztcbiAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGNoYW5nZVJlcXVlc3Quc291cmNlIHx8IFwiXCI7XG4gICAgICAgICAgICBmbHVpZC50cnlDYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZXNbc291cmNlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZXNbc291cmNlXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICsrc291cmNlc1tzb3VyY2VdO1xuICAgICAgICAgICAgICAgIG1vZGVsQ2hhbmdlZC5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgIH0sIG51bGwsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC0tc291cmNlc1tzb3VyY2VdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG5cbiAgICAvKiogVGhlIGNvcmUgY3JlYXRvciBmdW5jdGlvbiBjb25zdHJ1Y3RpbmcgQ2hhbmdlQXBwbGllcnMuIFNlZSBBUEkgZG9jdW1lbnRhdGlvblxuICAgICAqIGF0IGh0dHA6Ly93aWtpLmZsdWlkcHJvamVjdC5vcmcvZGlzcGxheS9mbHVpZC9DaGFuZ2VBcHBsaWVyK0FQSSBmb3IgdGhlIHZhcmlvdXNcbiAgICAgKiBvcHRpb25zIHN1cHBvcnRlZCBpbiB0aGUgb3B0aW9ucyBzdHJ1Y3R1cmUgKi9cblxuICAgIGZsdWlkLm1ha2VDaGFuZ2VBcHBsaWVyID0gZnVuY3Rpb24gKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBmbHVpZC5tYWtlSG9sZGVyQ2hhbmdlQXBwbGllcih7bW9kZWw6IG1vZGVsfSwgb3B0aW9ucyk7XG4gICAgfTtcblxuICAgIC8qKiBNYWtlIGEgXCJuZXctc3R5bGVcIiBDaGFuZ2VBcHBsaWVyIHRoYXQgYWxsb3dzIHRoZSBiYXNlIG1vZGVsIHJlZmVyZW5jZSB0byBiZSBvdmVyd3JpdHRlbi4gVGhpcyBpc1xuICAgICAqICByZS1yZWFkIG9uIGV2ZXJ5IGFjY2VzcyBmcm9tIHRoZSBvYmplY3QgXCJob2xkZXJcIiAoaW4gdHlwaWNhbCB1c2FnZSwgdGhlIGNvbXBvbmVudCBvd25pbmcgdGhlXG4gICAgICogIENoYW5nZUFwcGxpZXIpLiBUaGlzIGltcGxlbWVudGF0aW9uIHdpbGwgYmUgcmVtb3ZlZCBhZnRlciB0aGUgMS41IHJlbGVhc2UgKi9cblxuICAgIGZsdWlkLm1ha2VIb2xkZXJDaGFuZ2VBcHBsaWVyID0gZnVuY3Rpb24gKGhvbGRlciwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gZmx1aWQubW9kZWwuZGVmYXVsdEFjY2Vzc29yQ29uZmlnKG9wdGlvbnMpO1xuICAgICAgICB2YXIgYmFzZUV2ZW50cyA9IHtcbiAgICAgICAgICAgIGd1YXJkczogZmx1aWQubWFrZUV2ZW50RmlyZXIoe3ByZXZlbnRhYmxlOiB0cnVlLCBuYW1lOiBcImd1YXJkIGV2ZW50XCJ9KSxcbiAgICAgICAgICAgIHBvc3RHdWFyZHM6IGZsdWlkLm1ha2VFdmVudEZpcmVyKHtwcmV2ZW50YWJsZTogdHJ1ZSwgbmFtZTogXCJwb3N0R3VhcmQgZXZlbnRcIn0pLFxuICAgICAgICAgICAgbW9kZWxDaGFuZ2VkOiBmbHVpZC5tYWtlRXZlbnRGaXJlcih7bmFtZTogXCJtb2RlbENoYW5nZWQgZXZlbnRcIn0pXG4gICAgICAgIH07XG4gICAgICAgIHZhciB0aHJlYWRMb2NhbCA9IGZsdWlkLnRocmVhZExvY2FsKGZ1bmN0aW9uKCkgeyByZXR1cm4ge3NvdXJjZXM6IHt9fTt9KTtcbiAgICAgICAgdmFyIHRoYXQgPSB7XG4gICAgICAgIC8vIEZvciBub3csIHdlIGRvbid0IHVzZSBcImlkXCIgdG8gYXZvaWQgY29uZnVzaW5nIGNvbXBvbmVudCBkZXRlY3Rpb24gd2hpY2ggdXNlc1xuICAgICAgICAvLyBhIHNpbXBsZSBhbGdvcml0aG0gbG9va2luZyBmb3IgdGhhdCBmaWVsZFxuICAgICAgICAgICAgYXBwbGllcklkOiBmbHVpZC5hbGxvY2F0ZUd1aWQoKSxcbiAgICAgICAgICAgIGhvbGRlcjogaG9sZGVyLFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgICAgIGRlc3Ryb3k6IGZsdWlkLmlkZW50aXR5IC8vIGR1bW15IGZ1bmN0aW9uIHRvIGF2b2lkIGNvbmZ1c2luZyBGTFVJRC01NTkyIGNvZGUgLSB3ZSBkb24ndCBzdXBwb3J0IHRoaXMgc3VidGxldHkgZm9yIG9sZCBhcHBsaWVyc1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIG1ha2VHdWFyZFdyYXBwZXIoY3VsbFVuY2hhbmdlZCkge1xuICAgICAgICAgICAgaWYgKCFjdWxsVW5jaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdG9nbyA9IGZ1bmN0aW9uIChndWFyZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAobW9kZWwsIGNoYW5nZVJlcXVlc3QsIGludGVybmFsQXBwbGllcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb2xkUmV0ID0gZ3VhcmQobW9kZWwsIGNoYW5nZVJlcXVlc3QsIGludGVybmFsQXBwbGllcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRSZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmx1aWQubW9kZWwuaXNOdWxsQ2hhbmdlKG1vZGVsLCBjaGFuZ2VSZXF1ZXN0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvZ28uY3VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB0b2dvO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gd3JhcExpc3RlbmVyKGxpc3RlbmVyLCBzcGVjKSB7XG4gICAgICAgICAgICB2YXIgcGF0aFNwZWMgPSBzcGVjO1xuICAgICAgICAgICAgdmFyIHRyYW5zYWN0aW9uYWwgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBwcmlvcml0eSA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIChzcGVjKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHNwZWMgPSB7cGF0aDogc3BlY307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXRoU3BlYyA9IHNwZWMucGF0aDtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uYWwgPSBzcGVjLnRyYW5zYWN0aW9uYWw7XG4gICAgICAgICAgICBpZiAoc3BlYy5wcmlvcml0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcHJpb3JpdHkgPSBzcGVjLnByaW9yaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhdGhTcGVjLmNoYXJBdCgwKSA9PT0gXCIhXCIpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbmFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwYXRoU3BlYyA9IHBhdGhTcGVjLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB3cmFwcGVkID0gZnVuY3Rpb24gKGNoYW5nZVBhdGgsIGZpcmVTcGVjLCBhY2N1bSkge1xuICAgICAgICAgICAgICAgIHZhciBndWlkID0gZmx1aWQuZXZlbnQuaWRlbnRpZnlMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgdmFyIGV4aXN0ID0gZmlyZVNwZWMuZ3VpZHNbZ3VpZF07XG4gICAgICAgICAgICAgICAgaWYgKCFleGlzdCB8fCAhYWNjdW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gZmx1aWQucGF0aFV0aWwubWF0Y2hQYXRoKHBhdGhTcGVjLCBjaGFuZ2VQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVjb3JkID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoU3BlYzogcGF0aFNwZWMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXI6IGxpc3RlbmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW9yaXR5OiBwcmlvcml0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbmFsOiB0cmFuc2FjdGlvbmFsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFjY3VtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkLmFjY3VtdWxhdGUgPSBbYWNjdW1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmlyZVNwZWMuZ3VpZHNbZ3VpZF0gPSByZWNvcmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sbGVjdGlvbiA9IHRyYW5zYWN0aW9uYWwgPyBcInRyYW5zTGlzdGVuZXJzXCIgOiBcImxpc3RlbmVyc1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyZVNwZWNbY29sbGVjdGlvbl0ucHVzaChyZWNvcmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyZVNwZWMuYWxsLnB1c2gocmVjb3JkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhY2N1bSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWV4aXN0LmFjY3VtdWxhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0LmFjY3VtdWxhdGUgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBleGlzdC5hY2N1bXVsYXRlLnB1c2goYWNjdW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmbHVpZC5ldmVudC5pbXBlcnNvbmF0ZUxpc3RlbmVyKGxpc3RlbmVyLCB3cmFwcGVkKTtcbiAgICAgICAgICAgIHJldHVybiB3cmFwcGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZmlyZUZyb21TcGVjKG5hbWUsIGZpcmVTcGVjLCBhcmdzLCBjYXRlZ29yeSwgd3JhcHBlcikge1xuICAgICAgICAgICAgcmV0dXJuIGJhc2VFdmVudHNbbmFtZV0uZmlyZVRvTGlzdGVuZXJzKGZpcmVTcGVjW2NhdGVnb3J5XSwgYXJncywgd3JhcHBlcik7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBmaXJlQ29tcGFyYXRvcihyZWNBLCByZWNCKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVjQS5wcmlvcml0eSAtIHJlY0IucHJpb3JpdHk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwcmVwYXJlRmlyZUV2ZW50KG5hbWUsIGNoYW5nZVBhdGgsIGZpcmVTcGVjLCBhY2N1bSkge1xuICAgICAgICAgICAgYmFzZUV2ZW50c1tuYW1lXS5maXJlKGNoYW5nZVBhdGgsIGZpcmVTcGVjLCBhY2N1bSk7XG4gICAgICAgICAgICBmaXJlU3BlYy5hbGwuc29ydChmaXJlQ29tcGFyYXRvcik7XG4gICAgICAgICAgICBmaXJlU3BlYy5saXN0ZW5lcnMuc29ydChmaXJlQ29tcGFyYXRvcik7XG4gICAgICAgICAgICBmaXJlU3BlYy50cmFuc0xpc3RlbmVycy5zb3J0KGZpcmVDb21wYXJhdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG1ha2VGaXJlU3BlYygpIHtcbiAgICAgICAgICAgIHJldHVybiB7Z3VpZHM6IHt9LCBhbGw6IFtdLCBsaXN0ZW5lcnM6IFtdLCB0cmFuc0xpc3RlbmVyczogW119O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0RmlyZVNwZWMobmFtZSwgY2hhbmdlUGF0aCkge1xuICAgICAgICAgICAgdmFyIGZpcmVTcGVjID0gbWFrZUZpcmVTcGVjKCk7XG4gICAgICAgICAgICBwcmVwYXJlRmlyZUV2ZW50KG5hbWUsIGNoYW5nZVBhdGgsIGZpcmVTcGVjKTtcbiAgICAgICAgICAgIHJldHVybiBmaXJlU3BlYztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGZpcmVFdmVudChuYW1lLCBjaGFuZ2VQYXRoLCBhcmdzLCB3cmFwcGVyKSB7XG4gICAgICAgICAgICB2YXIgZmlyZVNwZWMgPSBnZXRGaXJlU3BlYyhuYW1lLCBjaGFuZ2VQYXRoKTtcbiAgICAgICAgICAgIHJldHVybiBmaXJlRnJvbVNwZWMobmFtZSwgZmlyZVNwZWMsIGFyZ3MsIFwiYWxsXCIsIHdyYXBwZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYWRhcHRMaXN0ZW5lcih0aGF0LCBuYW1lKSB7XG4gICAgICAgICAgICB0aGF0W25hbWVdID0ge1xuICAgICAgICAgICAgICAgIGFkZExpc3RlbmVyOiBmdW5jdGlvbiAoc3BlYywgbGlzdGVuZXIsIG5hbWVzcGFjZSwgc29mdE5hbWVzcGFjZSkge1xuICAgICAgICAgICAgICAgICAgICBiYXNlRXZlbnRzW25hbWVdLmFkZExpc3RlbmVyKHdyYXBMaXN0ZW5lcihsaXN0ZW5lciwgc3BlYyksIG5hbWVzcGFjZSwgbnVsbCwgbnVsbCwgc29mdE5hbWVzcGFjZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lcjogZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2VFdmVudHNbbmFtZV0ucmVtb3ZlTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgYWRhcHRMaXN0ZW5lcih0aGF0LCBcImd1YXJkc1wiKTtcbiAgICAgICAgYWRhcHRMaXN0ZW5lcih0aGF0LCBcInBvc3RHdWFyZHNcIik7XG4gICAgICAgIGFkYXB0TGlzdGVuZXIodGhhdCwgXCJtb2RlbENoYW5nZWRcIik7XG5cbiAgICAgICAgZnVuY3Rpb24gcHJlRmlyZUNoYW5nZVJlcXVlc3QoY2hhbmdlUmVxdWVzdCkge1xuICAgICAgICAgICAgaWYgKCFjaGFuZ2VSZXF1ZXN0LnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VSZXF1ZXN0LnR5cGUgPSBcIkFERFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hhbmdlUmVxdWVzdC5zZWdzID0gdGhhdC5wYXJzZUVMKGNoYW5nZVJlcXVlc3QucGF0aCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYmFyZUFwcGxpZXIgPSB7XG4gICAgICAgICAgICBmaXJlQ2hhbmdlUmVxdWVzdDogZnVuY3Rpb24gKGNoYW5nZVJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICB0aGF0LmZpcmVDaGFuZ2VSZXF1ZXN0KGNoYW5nZVJlcXVlc3QsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBmbHVpZC5iaW5kUmVxdWVzdENoYW5nZShiYXJlQXBwbGllcik7XG5cbiAgICAgICAgdGhhdC5maXJlQ2hhbmdlUmVxdWVzdCA9IGZ1bmN0aW9uIChjaGFuZ2VSZXF1ZXN0KSB7XG4gICAgICAgICAgICBwcmVGaXJlQ2hhbmdlUmVxdWVzdChjaGFuZ2VSZXF1ZXN0KTtcbiAgICAgICAgICAgIHZhciBhdGlvbiA9IHRoYXQuaW5pdGlhdGUoKTtcbiAgICAgICAgICAgIGF0aW9uLmZpcmVDaGFuZ2VSZXF1ZXN0KGNoYW5nZVJlcXVlc3QpO1xuICAgICAgICAgICAgYXRpb24uY29tbWl0KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5maXJlQ2hhbmdlUmVxdWVzdCA9IHNvdXJjZVdyYXBNb2RlbENoYW5nZWQodGhhdC5maXJlQ2hhbmdlUmVxdWVzdCwgdGhyZWFkTG9jYWwpO1xuICAgICAgICBmbHVpZC5iaW5kUmVxdWVzdENoYW5nZSh0aGF0KTtcbiAgICAgICAgZmx1aWQuYmluZEVMTWV0aG9kcyh0aGF0KTtcblxuICAgICAgICAvLyBUT0RPOiBtb2RlbENoYW5nZWQgaGFzIGJlZW4gbW92ZWQgdG8gbmV3IG1vZGVsIGZvciBmaXJpbmcuIE9uY2Ugd2UgYWJvbGlzaCBcImd1YXJkc1wiLCBmaXJlQWdnbG9tZXJhdGVkIGNhbiBnbyB0b28uXG4gICAgICAgIC8vIFBvc3NpYmx5IGFsc28gYWxsIHRoZSBwcmVwYXJlRmlyZUV2ZW50L3dyYXBMaXN0ZW5lci9maXJlU3BlYyBub25zZW5zZSB0b28uXG4gICAgICAgIGZ1bmN0aW9uIGZpcmVBZ2dsb21lcmF0ZWQoZXZlbnROYW1lLCBmb3JtTmFtZSwgY2hhbmdlcywgYXJncywgYWNjcG9zLCBtYXRjaHBvcykge1xuICAgICAgICAgICAgdmFyIGZpcmVTcGVjID0gbWFrZUZpcmVTcGVjKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYW5nZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBwcmVwYXJlRmlyZUV2ZW50KGV2ZW50TmFtZSwgY2hhbmdlc1tpXS5wYXRoLCBmaXJlU3BlYywgY2hhbmdlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZpcmVTcGVjW2Zvcm1OYW1lXS5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIHZhciBzcGVjID0gZmlyZVNwZWNbZm9ybU5hbWVdW2pdO1xuICAgICAgICAgICAgICAgIGlmIChhY2Nwb3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBhcmdzW2FjY3Bvc10gPSBzcGVjLmFjY3VtdWxhdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtYXRjaHBvcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbbWF0Y2hwb3NdID0gc3BlYy5tYXRjaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IHNwZWMubGlzdGVuZXIuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoYXQuaW5pdGlhdGUgPSBmdW5jdGlvbiAobmV3TW9kZWwpIHtcbiAgICAgICAgICAgIHZhciBjYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBjaGFuZ2VzID0gW107XG4gICAgICAgICAgICBpZiAob3B0aW9ucy50aGluKSB7XG4gICAgICAgICAgICAgICAgbmV3TW9kZWwgPSBob2xkZXIubW9kZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdNb2RlbCA9IG5ld01vZGVsIHx8IHt9O1xuICAgICAgICAgICAgICAgIGZsdWlkLm1vZGVsLmNvcHlNb2RlbChuZXdNb2RlbCwgaG9sZGVyLm1vZGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBjb21taXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9sZE1vZGVsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IGZpcmVBZ2dsb21lcmF0ZWQoXCJwb3N0R3VhcmRzXCIsIFwidHJhbnNMaXN0ZW5lcnNcIiwgY2hhbmdlcywgW25ld01vZGVsLCBudWxsLCBhdGlvbl0sIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmV0ID09PSBmYWxzZSB8fCBjYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy50aGluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRNb2RlbCA9IGhvbGRlci5tb2RlbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZE1vZGVsID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBmbHVpZC5tb2RlbC5jb3B5TW9kZWwob2xkTW9kZWwsIGhvbGRlci5tb2RlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbHVpZC5jbGVhcihob2xkZXIubW9kZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmx1aWQubW9kZWwuY29weU1vZGVsKGhvbGRlci5tb2RlbCwgbmV3TW9kZWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpcmVBZ2dsb21lcmF0ZWQoXCJtb2RlbENoYW5nZWRcIiwgXCJhbGxcIiwgY2hhbmdlcywgW2hvbGRlci5tb2RlbCwgb2xkTW9kZWwsIG51bGwsIG51bGxdLCAyLCAzKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZpcmVDaGFuZ2VSZXF1ZXN0OiBmdW5jdGlvbiAoY2hhbmdlUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICBwcmVGaXJlQ2hhbmdlUmVxdWVzdChjaGFuZ2VSZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuY3VsbFVuY2hhbmdlZCAmJiBmbHVpZC5tb2RlbC5pc051bGxDaGFuZ2UoaG9sZGVyLm1vZGVsLCBjaGFuZ2VSZXF1ZXN0LCBvcHRpb25zLnJlc29sdmVyR2V0Q29uZmlnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciB3cmFwcGVyID0gbWFrZUd1YXJkV3JhcHBlcihvcHRpb25zLmN1bGxVbmNoYW5nZWQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJldmVudCA9IGZpcmVFdmVudChcImd1YXJkc1wiLCBjaGFuZ2VSZXF1ZXN0LnBhdGgsIFtuZXdNb2RlbCwgY2hhbmdlUmVxdWVzdCwgYXRpb25dLCB3cmFwcGVyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZlbnQgPT09IGZhbHNlICYmICEod3JhcHBlciAmJiB3cmFwcGVyLmN1bGxlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHdyYXBwZXIgJiYgd3JhcHBlci5jdWxsZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmx1aWQubW9kZWwuYXBwbHlDaGFuZ2VSZXF1ZXN0KG5ld01vZGVsLCBjaGFuZ2VSZXF1ZXN0LCBvcHRpb25zLnJlc29sdmVyU2V0Q29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goY2hhbmdlUmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBhdGlvbi5maXJlQ2hhbmdlUmVxdWVzdCA9IHNvdXJjZVdyYXBNb2RlbENoYW5nZWQoYXRpb24uZmlyZUNoYW5nZVJlcXVlc3QsIHRocmVhZExvY2FsKTtcbiAgICAgICAgICAgIGZsdWlkLmJpbmRSZXF1ZXN0Q2hhbmdlKGF0aW9uKTtcblxuICAgICAgICAgICAgcmV0dXJuIGF0aW9uO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQuaGFzQ2hhbmdlU291cmNlID0gZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRocmVhZExvY2FsKCkuc291cmNlc1tzb3VyY2VdID4gMDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICB9O1xuXG4gICAgLyoqIE9sZCBcIlN1cGVyQXBwbGllclwiIGltcGxlbWVudGF0aW9uIC0gd2lsbCBiZSByZW1vdmVkIGluIDEuNSAqKi9cblxuICAgIGZsdWlkLm1ha2VTdXBlckFwcGxpZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdWJBcHBsaWVycyA9IFtdO1xuICAgICAgICB2YXIgdGhhdCA9IHt9O1xuICAgICAgICB0aGF0LmFkZFN1YkFwcGxpZXIgPSBmdW5jdGlvbiAocGF0aCwgc3ViQXBwbGllcikge1xuICAgICAgICAgICAgc3ViQXBwbGllcnMucHVzaCh7cGF0aDogcGF0aCwgc3ViQXBwbGllcjogc3ViQXBwbGllcn0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGF0LmZpcmVDaGFuZ2VSZXF1ZXN0ID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3ViQXBwbGllcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGF0aCA9IHN1YkFwcGxpZXJzW2ldLnBhdGg7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QucGF0aC5pbmRleE9mKHBhdGgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdWJwYXRoID0gcmVxdWVzdC5wYXRoLnN1YnN0cmluZyhwYXRoLmxlbmd0aCArIDEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3ViUmVxdWVzdCA9IGZsdWlkLmNvcHkocmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICAgIHN1YlJlcXVlc3QucGF0aCA9IHN1YnBhdGg7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IERlYWwgd2l0aCB0aGUgYXMgeWV0IHVuc3VwcG9ydGVkIGNhc2Ugb2YgYW4gRUwgcnZhbHVlIERBUlxuICAgICAgICAgICAgICAgICAgICBzdWJBcHBsaWVyc1tpXS5zdWJBcHBsaWVyLmZpcmVDaGFuZ2VSZXF1ZXN0KHN1YlJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZmx1aWQuYmluZFJlcXVlc3RDaGFuZ2UodGhhdCk7XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgIH07XG5cbiAgICBmbHVpZC5hdHRhY2hNb2RlbCA9IGZ1bmN0aW9uIChiYXNlTW9kZWwsIHBhdGgsIG1vZGVsKSB7XG4gICAgICAgIHZhciBzZWdzID0gZmx1aWQubW9kZWwucGFyc2VFTChwYXRoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdzLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICAgICAgdmFyIHNlZyA9IHNlZ3NbaV07XG4gICAgICAgICAgICB2YXIgc3ViTW9kZWwgPSBiYXNlTW9kZWxbc2VnXTtcbiAgICAgICAgICAgIGlmICghc3ViTW9kZWwpIHtcbiAgICAgICAgICAgICAgICBiYXNlTW9kZWxbc2VnXSA9IHN1Yk1vZGVsID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiYXNlTW9kZWwgPSBzdWJNb2RlbDtcbiAgICAgICAgfVxuICAgICAgICBiYXNlTW9kZWxbc2Vnc1tzZWdzLmxlbmd0aCAtIDFdXSA9IG1vZGVsO1xuICAgIH07XG5cbiAgICBmbHVpZC5hc3NlbWJsZU1vZGVsID0gZnVuY3Rpb24gKG1vZGVsU3BlYykge1xuICAgICAgICB2YXIgbW9kZWwgPSB7fTtcbiAgICAgICAgdmFyIHN1cGVyQXBwbGllciA9IGZsdWlkLm1ha2VTdXBlckFwcGxpZXIoKTtcbiAgICAgICAgdmFyIHRvZ28gPSB7bW9kZWw6IG1vZGVsLCBhcHBsaWVyOiBzdXBlckFwcGxpZXJ9O1xuICAgICAgICBmb3IgKHZhciBwYXRoIGluIG1vZGVsU3BlYykge1xuICAgICAgICAgICAgdmFyIHJlYyA9IG1vZGVsU3BlY1twYXRoXTtcbiAgICAgICAgICAgIGZsdWlkLmF0dGFjaE1vZGVsKG1vZGVsLCBwYXRoLCByZWMubW9kZWwpO1xuICAgICAgICAgICAgaWYgKHJlYy5hcHBsaWVyKSB7XG4gICAgICAgICAgICAgICAgc3VwZXJBcHBsaWVyLmFkZFN1YkFwcGxpZXIocGF0aCwgcmVjLmFwcGxpZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2dvO1xuICAgIH07XG5cbn0pKGpRdWVyeSwgZmx1aWRfMl8wKTtcbjsvKlxuQ29weXJpZ2h0IDIwMTAgVW5pdmVyc2l0eSBvZiBUb3JvbnRvXG5Db3B5cmlnaHQgMjAxMC0yMDExIE9DQUQgVW5pdmVyc2l0eVxuXG5MaWNlbnNlZCB1bmRlciB0aGUgRWR1Y2F0aW9uYWwgQ29tbXVuaXR5IExpY2Vuc2UgKEVDTCksIFZlcnNpb24gMi4wIG9yIHRoZSBOZXdcbkJTRCBsaWNlbnNlLiBZb3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggb25lIHRoZXNlXG5MaWNlbnNlcy5cblxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBFQ0wgMi4wIExpY2Vuc2UgYW5kIEJTRCBMaWNlbnNlIGF0XG5odHRwczovL2dpdGh1Yi5jb20vZmx1aWQtcHJvamVjdC9pbmZ1c2lvbi9yYXcvbWFzdGVyL0luZnVzaW9uLUxJQ0VOU0UudHh0XG4qL1xuXG52YXIgZmx1aWRfMl8wID0gZmx1aWRfMl8wIHx8IHt9O1xudmFyIGZsdWlkID0gZmx1aWQgfHwgZmx1aWRfMl8wO1xuXG4oZnVuY3Rpb24gKCQsIGZsdWlkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBmbHVpZC5yZWdpc3Rlck5hbWVzcGFjZShcImZsdWlkLm1vZGVsLnRyYW5zZm9ybVwiKTtcblxuICAgIC8qKiBHcmFkZSBkZWZpbml0aW9ucyBmb3Igc3RhbmRhcmQgdHJhbnNmb3JtYXRpb24gZnVuY3Rpb24gaGllcmFyY2h5ICoqL1xuXG4gICAgZmx1aWQuZGVmYXVsdHMoXCJmbHVpZC50cmFuc2Zvcm1GdW5jdGlvblwiLCB7XG4gICAgICAgIGdyYWRlTmFtZXM6IFwiZmx1aWQuZnVuY3Rpb25cIlxuICAgIH0pO1xuXG4gICAgLy8gdXNlcyBzdGFuZGFyZCBsYXlvdXQgYW5kIHdvcmtmbG93IGludm9sdmluZyBpbnB1dFBhdGhcbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsdWlkLnN0YW5kYXJkSW5wdXRUcmFuc2Zvcm1GdW5jdGlvblwiLCB7XG4gICAgICAgIGdyYWRlTmFtZXM6IFwiZmx1aWQudHJhbnNmb3JtRnVuY3Rpb25cIlxuICAgIH0pO1xuXG4gICAgZmx1aWQuZGVmYXVsdHMoXCJmbHVpZC5zdGFuZGFyZE91dHB1dFRyYW5zZm9ybUZ1bmN0aW9uXCIsIHtcbiAgICAgICAgZ3JhZGVOYW1lczogXCJmbHVpZC50cmFuc2Zvcm1GdW5jdGlvblwiXG4gICAgfSk7XG5cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsdWlkLm11bHRpSW5wdXRUcmFuc2Zvcm1GdW5jdGlvblwiLCB7XG4gICAgICAgIGdyYWRlTmFtZXM6IFwiZmx1aWQudHJhbnNmb3JtRnVuY3Rpb25cIlxuICAgIH0pO1xuXG4gICAgLy8gdXNlcyB0aGUgc3RhbmRhcmQgbGF5b3V0IGFuZCB3b3JrZmxvdyBpbnZvbHZpbmcgaW5wdXRQYXRoIGFuZCBvdXRwdXRQYXRoXG4gICAgZmx1aWQuZGVmYXVsdHMoXCJmbHVpZC5zdGFuZGFyZFRyYW5zZm9ybUZ1bmN0aW9uXCIsIHtcbiAgICAgICAgZ3JhZGVOYW1lczogW1wiZmx1aWQuc3RhbmRhcmRJbnB1dFRyYW5zZm9ybUZ1bmN0aW9uXCIsIFwiZmx1aWQuc3RhbmRhcmRPdXRwdXRUcmFuc2Zvcm1GdW5jdGlvblwiXVxuICAgIH0pO1xuXG4gICAgZmx1aWQuZGVmYXVsdHMoXCJmbHVpZC5sZW5zXCIsIHtcbiAgICAgICAgZ3JhZGVOYW1lczogXCJmbHVpZC50cmFuc2Zvcm1GdW5jdGlvblwiLFxuICAgICAgICBpbnZlcnRDb25maWd1cmF0aW9uOiBudWxsXG4gICAgICAgIC8vIHRoaXMgZnVuY3Rpb24gbWV0aG9kIHJldHVybnMgXCJpbnZlcnRlZCBjb25maWd1cmF0aW9uXCIgcmF0aGVyIHRoYW4gYWN0dWFsbHkgcGVyZm9ybWluZyBpbnZlcnNpb25cbiAgICAgICAgLy8gVE9ETzogaGFybW9uaXNlIHdpdGggc3RyYXRlZ3kgdXNlZCBpbiBWaWRlb1BsYXllcl9mcmFtZXdvcmsuanNcbiAgICB9KTtcblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAqIEJhc2UgdXRpbGl0aWVzIGZvciB0cmFuc2Zvcm1lcnMgKlxuICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIC8vIHVuc3VwcG9ydGVkLCBOT04tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQubW9kZWwudHJhbnNmb3JtLnBhdGhUb1J1bGUgPSBmdW5jdGlvbiAoaW5wdXRQYXRoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZsdWlkLnRyYW5zZm9ybXMudmFsdWVcIixcbiAgICAgICAgICAgICAgICBpbnB1dFBhdGg6IGlucHV0UGF0aFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvLyB1bnN1cHBvcnRlZCwgTk9OLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLm1vZGVsLnRyYW5zZm9ybS5saXRlcmFsVmFsdWVUb1J1bGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZmx1aWQudHJhbnNmb3Jtcy5saXRlcmFsVmFsdWVcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqIEFjY2VwdHMgdHdvIGZ1bGx5IGVzY2FwZWQgcGF0aHMsIGVpdGhlciBvZiB3aGljaCBtYXkgYmUgZW1wdHkgb3IgbnVsbCAqKi9cbiAgICBmbHVpZC5tb2RlbC5jb21wb3NlUGF0aHMgPSBmdW5jdGlvbiAocHJlZml4LCBzdWZmaXgpIHtcbiAgICAgICAgcHJlZml4ID0gcHJlZml4ID09PSAwID8gXCIwXCIgOiBwcmVmaXggfHwgXCJcIjtcbiAgICAgICAgc3VmZml4ID0gc3VmZml4ID09PSAwID8gXCIwXCIgOiBzdWZmaXggfHwgXCJcIjtcbiAgICAgICAgcmV0dXJuICFwcmVmaXggPyBzdWZmaXggOiAoIXN1ZmZpeCA/IHByZWZpeCA6IHByZWZpeCArIFwiLlwiICsgc3VmZml4KTtcbiAgICB9O1xuXG4gICAgZmx1aWQubW9kZWwudHJhbnNmb3JtLmFjY3VtdWxhdGVJbnB1dFBhdGggPSBmdW5jdGlvbiAoaW5wdXRQYXRoLCB0cmFuc2Zvcm0sIHBhdGhzKSB7XG4gICAgICAgIGlmIChpbnB1dFBhdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGF0aHMucHVzaChmbHVpZC5tb2RlbC5jb21wb3NlUGF0aHModHJhbnNmb3JtLmlucHV0UHJlZml4LCBpbnB1dFBhdGgpKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmbHVpZC5tb2RlbC50cmFuc2Zvcm0uYWNjdW11bGF0ZVN0YW5kYXJkSW5wdXRQYXRoID0gZnVuY3Rpb24gKGlucHV0LCB0cmFuc2Zvcm1TcGVjLCB0cmFuc2Zvcm0sIHBhdGhzKSB7XG4gICAgICAgIGZsdWlkLm1vZGVsLnRyYW5zZm9ybS5nZXRWYWx1ZSh1bmRlZmluZWQsIHRyYW5zZm9ybVNwZWNbaW5wdXRdLCB0cmFuc2Zvcm0pO1xuICAgICAgICBmbHVpZC5tb2RlbC50cmFuc2Zvcm0uYWNjdW11bGF0ZUlucHV0UGF0aCh0cmFuc2Zvcm1TcGVjW2lucHV0ICsgXCJQYXRoXCJdLCB0cmFuc2Zvcm0sIHBhdGhzKTtcbiAgICB9O1xuXG4gICAgZmx1aWQubW9kZWwudHJhbnNmb3JtLmFjY3VtdWxhdGVNdWx0aUlucHV0UGF0aHMgPSBmdW5jdGlvbiAoaW5wdXRWYXJpYWJsZXMsIHRyYW5zZm9ybVNwZWMsIHRyYW5zZm9ybSwgcGF0aHMpIHtcbiAgICAgICAgZmx1aWQuZWFjaChpbnB1dFZhcmlhYmxlcywgZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgICAgIGZsdWlkLm1vZGVsLnRyYW5zZm9ybS5hY2N1bXVsYXRlU3RhbmRhcmRJbnB1dFBhdGgoaywgdHJhbnNmb3JtU3BlYywgdHJhbnNmb3JtLCBwYXRocyk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmbHVpZC5tb2RlbC50cmFuc2Zvcm0uZ2V0VmFsdWUgPSBmdW5jdGlvbiAoaW5wdXRQYXRoLCB2YWx1ZSwgdHJhbnNmb3JtKSB7XG4gICAgICAgIHZhciB0b2dvO1xuICAgICAgICBpZiAoaW5wdXRQYXRoICE9PSB1bmRlZmluZWQpIHsgLy8gTkI6IFdlIG1heSBvbmUgZGF5IHdhbnQgdG8gcmV2ZXJzZSB0aGUgY3JhenkgalF1ZXJ5LWxpa2UgY29udmVudGlvbiB0aGF0IFwibm8gcGF0aCBtZWFucyByb290IHBhdGhcIlxuICAgICAgICAgICAgdG9nbyA9IGZsdWlkLmdldCh0cmFuc2Zvcm0uc291cmNlLCBmbHVpZC5tb2RlbC5jb21wb3NlUGF0aHModHJhbnNmb3JtLmlucHV0UHJlZml4LCBpbnB1dFBhdGgpLCB0cmFuc2Zvcm0ucmVzb2x2ZXJHZXRDb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2dvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRvZ28gPSBmbHVpZC5pc1ByaW1pdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHRyYW5zZm9ybS5leHBhbmQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2dvO1xuICAgIH07XG5cbiAgICAvLyBkaXN0aW5ndWlzaGVkIHZhbHVlIHdoaWNoIGluZGljYXRlcyB0aGF0IGEgdHJhbnNmb3JtYXRpb24gcnVsZSBzdXBwbGllZCBhXG4gICAgLy8gbm9uLWRlZmF1bHQgb3V0cHV0IHBhdGgsIGFuZCBzbyB0aGUgdXNlciBzaG91bGQgYmUgcHJldmVudGVkIGZyb20gbWFraW5nIHVzZSBvZiBpdFxuICAgIC8vIGluIGEgY29tcG91bmQgdHJhbnNmb3JtIGRlZmluaXRpb25cbiAgICBmbHVpZC5tb2RlbC50cmFuc2Zvcm0uTk9OREVGQVVMVF9PVVRQVVRfUEFUSF9SRVRVUk4gPSB7fTtcblxuICAgIGZsdWlkLm1vZGVsLnRyYW5zZm9ybS5zZXRWYWx1ZSA9IGZ1bmN0aW9uICh1c2VyT3V0cHV0UGF0aCwgdmFsdWUsIHRyYW5zZm9ybSkge1xuICAgICAgICAvLyBhdm9pZCBjcm9zc2xpbmtpbmcgdG8gaW5wdXQgb2JqZWN0IC0gdGhpcyBtaWdodCBiZSBjb250cm9sbGVkIGJ5IGEgXCJub2NvcHlcIiBvcHRpb24gaW4gZnV0dXJlXG4gICAgICAgIHZhciB0b3NldCA9IGZsdWlkLmNvcHkodmFsdWUpO1xuICAgICAgICB2YXIgb3V0cHV0UGF0aCA9IGZsdWlkLm1vZGVsLmNvbXBvc2VQYXRocyh0cmFuc2Zvcm0ub3V0cHV0UHJlZml4LCB1c2VyT3V0cHV0UGF0aCk7XG4gICAgICAgIC8vIFRPRE86IGN1c3RvbSByZXNvbHZlciBjb25maWcgaGVyZSB0byBjcmVhdGUgbm9uLWhhc2ggb3V0cHV0IG1vZGVsIHN0cnVjdHVyZVxuICAgICAgICBpZiAodG9zZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdHJhbnNmb3JtLmFwcGxpZXIucmVxdWVzdENoYW5nZShvdXRwdXRQYXRoLCB0b3NldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVzZXJPdXRwdXRQYXRoID8gZmx1aWQubW9kZWwudHJhbnNmb3JtLk5PTkRFRkFVTFRfT1VUUFVUX1BBVEhfUkVUVVJOIDogdG9zZXQ7XG4gICAgfTtcblxuICAgIC8qIFJlc29sdmVzIHRoZSA8a2V5PiBnaXZlbiBhcyBwYXJhbWV0ZXIgYnkgbG9va2luZyB1cCB0aGUgcGF0aCA8a2V5PlBhdGggaW4gdGhlIG9iamVjdFxuICAgICAqIHRvIGJlIHRyYW5zZm9ybWVkLiBJZiBub3QgcHJlc2VudCwgaXQgcmVzb2x2ZXMgdGhlIDxrZXk+IGJ5IHVzaW5nIHRoZSBsaXRlcmFsIHZhbHVlIGlmIHByaW1pdGl2ZSxcbiAgICAgKiBvciBleHBhbmRpbmcgb3RoZXJ3aXNlLiA8ZGVmPiBkZWZpbmVzIHRoZSBkZWZhdWx0IHZhbHVlIGlmIHVuYWJsZXRvIHJlc29sdmUgdGhlIGtleS4gSWYgbm9cbiAgICAgKiBkZWZhdWx0IHZhbHVlIGlzIGdpdmVuIHVuZGVmaW5lZCBpcyByZXR1cm5lZFxuICAgICAqL1xuICAgIGZsdWlkLm1vZGVsLnRyYW5zZm9ybS5yZXNvbHZlUGFyYW0gPSBmdW5jdGlvbiAodHJhbnNmb3JtU3BlYywgdHJhbnNmb3JtLCBrZXksIGRlZikge1xuICAgICAgICB2YXIgdmFsID0gZmx1aWQubW9kZWwudHJhbnNmb3JtLmdldFZhbHVlKHRyYW5zZm9ybVNwZWNba2V5ICsgXCJQYXRoXCJdLCB0cmFuc2Zvcm1TcGVjW2tleV0sIHRyYW5zZm9ybSk7XG4gICAgICAgIHJldHVybiAodmFsICE9PSB1bmRlZmluZWQpID8gdmFsIDogZGVmO1xuICAgIH07XG5cbiAgICAvLyBDb21wdXRlIGEgXCJtYXRjaCBzY29yZVwiIGJldHdlZW4gdHdvIHBpZWNlcyBvZiBtb2RlbCBtYXRlcmlhbCwgd2l0aCAwIGluZGljYXRpbmcgYSBjb21wbGV0ZSBtaXNtYXRjaCwgYW5kXG4gICAgLy8gaGlnaGVyIHZhbHVlcyBpbmRpY2F0aW5nIGluY3JlYXNpbmdseSBnb29kIG1hdGNoZXNcbiAgICBmbHVpZC5tb2RlbC50cmFuc2Zvcm0ubWF0Y2hWYWx1ZSA9IGZ1bmN0aW9uIChleHBlY3RlZCwgYWN0dWFsLCBwYXJ0aWFsTWF0Y2hlcykge1xuICAgICAgICB2YXIgc3RhdHMgPSB7Y2hhbmdlczogMCwgdW5jaGFuZ2VkOiAwLCBjaGFuZ2VNYXA6IHt9fTtcbiAgICAgICAgZmx1aWQubW9kZWwuZGlmZihleHBlY3RlZCwgYWN0dWFsLCBzdGF0cyk7XG4gICAgICAgIC8vIGkpIGEgcGFpciB3aXRoIDAgbWF0Y2hlcyBjb3VudHMgZm9yIDAgaW4gYWxsIGNhc2VzXG4gICAgICAgIC8vIGlpKSB3aXRob3V0IFwicGFydGlhbCBtYXRjaCBtb2RlXCIgKHRoZSBkZWZhdWx0KSwgd2Ugc2ltcGx5IGNvdW50IG1hdGNoZXMsIHdpdGggYW55IG1pc21hdGNoIGdpdmluZyAwXG4gICAgICAgIC8vIGlpaSkgd2l0aCBcInBhcnRpYWwgbWF0Y2ggbW9kZVwiLCBhIFwicGVyZmVjdCBzY29yZVwiIGluIHRoZSB0b3AgMjQgYml0cyBpc1xuICAgICAgICAvLyBwZW5hbGlzZWQgZm9yIGVhY2ggbWlzbWF0Y2gsIHdpdGggYSBwb3NpdGl2ZSBzY29yZSBvZiBtYXRjaGVzIHN0b3JlIGluIHRoZSBib3R0b20gMjQgYml0c1xuICAgICAgICByZXR1cm4gc3RhdHMudW5jaGFuZ2VkID09PSAwID8gMFxuICAgICAgICAgICAgOiAocGFydGlhbE1hdGNoZXMgPyAweGZmZmZmZjAwMDAwMCAtIDB4MTAwMDAwMCAqIHN0YXRzLmNoYW5nZXMgKyBzdGF0cy51bmNoYW5nZWQgOlxuICAgICAgICAgICAgKHN0YXRzLmNoYW5nZXMgPyAwIDogMHhmZmZmZmYwMDAwMDAgKyBzdGF0cy51bmNoYW5nZWQpKTtcbiAgICB9O1xuXG4gICAgZmx1aWQuZmlyc3REZWZpbmVkID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgPT09IHVuZGVmaW5lZCA/IGIgOiBhO1xuICAgIH07XG5cblxuICAgIC8vIFRPRE86IHByZWZpeEFwcGxpZXIgaXMgYSB0cmFuc2Zvcm0gd2hpY2ggaXMgY3VycmVudGx5IHVudXNlZCBhbmQgdW50ZXN0ZWRcbiAgICBmbHVpZC5tb2RlbC50cmFuc2Zvcm0ucHJlZml4QXBwbGllciA9IGZ1bmN0aW9uICh0cmFuc2Zvcm1TcGVjLCB0cmFuc2Zvcm0pIHtcbiAgICAgICAgaWYgKHRyYW5zZm9ybVNwZWMuaW5wdXRQcmVmaXgpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybS5pbnB1dFByZWZpeE9wLnB1c2godHJhbnNmb3JtU3BlYy5pbnB1dFByZWZpeCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYW5zZm9ybVNwZWMub3V0cHV0UHJlZml4KSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm0ub3V0cHV0UHJlZml4T3AucHVzaCh0cmFuc2Zvcm1TcGVjLm91dHB1dFByZWZpeCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNmb3JtLmV4cGFuZCh0cmFuc2Zvcm1TcGVjLnZhbHVlKTtcbiAgICAgICAgaWYgKHRyYW5zZm9ybVNwZWMuaW5wdXRQcmVmaXgpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybS5pbnB1dFByZWZpeE9wLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFuc2Zvcm1TcGVjLm91dHB1dFByZWZpeCkge1xuICAgICAgICAgICAgdHJhbnNmb3JtLm91dHB1dFByZWZpeE9wLnBvcCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmx1aWQubW9kZWwudHJhbnNmb3JtLnByZWZpeEFwcGxpZXJcIiwge1xuICAgICAgICBncmFkZU5hbWVzOiBbXCJmbHVpZC50cmFuc2Zvcm1GdW5jdGlvblwiXVxuICAgIH0pO1xuXG4gICAgLy8gdW5zdXBwb3J0ZWQsIE5PTi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5tb2RlbC5tYWtlUGF0aFN0YWNrID0gZnVuY3Rpb24gKHRyYW5zZm9ybSwgcHJlZml4TmFtZSkge1xuICAgICAgICB2YXIgc3RhY2sgPSB0cmFuc2Zvcm1bcHJlZml4TmFtZSArIFwiU3RhY2tcIl0gPSBbXTtcbiAgICAgICAgdHJhbnNmb3JtW3ByZWZpeE5hbWVdID0gXCJcIjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHB1c2g6IGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3UGF0aCA9IGZsdWlkLm1vZGVsLmNvbXBvc2VQYXRocyh0cmFuc2Zvcm1bcHJlZml4TmFtZV0sIHByZWZpeCk7XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaCh0cmFuc2Zvcm1bcHJlZml4TmFtZV0pO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybVtwcmVmaXhOYW1lXSA9IG5ld1BhdGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtW3ByZWZpeE5hbWVdID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIGZsdWlkLm1vZGVsLnRyYW5zZm9ybS5hbGlhc1N0YW5kYXJkSW5wdXQgPSBmdW5jdGlvbiAodHJhbnNmb3JtU3BlYykge1xuICAgICAgICByZXR1cm4geyAvLyBhbGlhcyBpbnB1dCBhbmQgdmFsdWUsIGFuZCB0aGVpciBwYXRoc1xuICAgICAgICAgICAgdmFsdWU6IHRyYW5zZm9ybVNwZWMudmFsdWUgPT09IHVuZGVmaW5lZCA/IHRyYW5zZm9ybVNwZWMuaW5wdXQgOiB0cmFuc2Zvcm1TcGVjLnZhbHVlLFxuICAgICAgICAgICAgdmFsdWVQYXRoOiB0cmFuc2Zvcm1TcGVjLnZhbHVlUGF0aCA9PT0gdW5kZWZpbmVkID8gdHJhbnNmb3JtU3BlYy5pbnB1dFBhdGggOiB0cmFuc2Zvcm1TcGVjLnZhbHVlUGF0aFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvLyB1bnN1cHBvcnRlZCwgTk9OLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLm1vZGVsLnRyYW5zZm9ybS5kb1RyYW5zZm9ybSA9IGZ1bmN0aW9uICh0cmFuc2Zvcm1TcGVjLCB0cmFuc2Zvcm0sIHRyYW5zZm9ybU9wdHMpIHtcbiAgICAgICAgdmFyIGV4cGRlZiA9IHRyYW5zZm9ybU9wdHMuZGVmYXVsdHM7XG4gICAgICAgIHZhciB0cmFuc2Zvcm1GbiA9IGZsdWlkLmdldEdsb2JhbFZhbHVlKHRyYW5zZm9ybU9wdHMudHlwZU5hbWUpO1xuICAgICAgICBpZiAodHlwZW9mKHRyYW5zZm9ybUZuKSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBmbHVpZC5mYWlsKFwiVHJhbnNmb3JtYXRpb24gcmVjb3JkIHNwZWNpZmllcyB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbiB3aXRoIG5hbWUgXCIgK1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybVNwZWMudHlwZSArIFwiIHdoaWNoIGlzIG5vdCBhIGZ1bmN0aW9uIC0gXCIsIHRyYW5zZm9ybUZuKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZsdWlkLmhhc0dyYWRlKGV4cGRlZiwgXCJmbHVpZC50cmFuc2Zvcm1GdW5jdGlvblwiKSkge1xuICAgICAgICAgICAgLy8gSWYgbm8gc3VpdGFibGUgZ3JhZGUgaXMgc2V0IHVwLCBhc3N1bWUgdGhhdCBpdCBpcyBpbnRlbmRlZCB0byBiZSB1c2VkIGFzIGEgc3RhbmRhcmRUcmFuc2Zvcm1GdW5jdGlvblxuICAgICAgICAgICAgZXhwZGVmID0gZmx1aWQuZGVmYXVsdHMoXCJmbHVpZC5zdGFuZGFyZFRyYW5zZm9ybUZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0cmFuc2Zvcm1BcmdzID0gW3RyYW5zZm9ybVNwZWMsIHRyYW5zZm9ybV07XG4gICAgICAgIGlmIChmbHVpZC5oYXNHcmFkZShleHBkZWYsIFwiZmx1aWQuc3RhbmRhcmRJbnB1dFRyYW5zZm9ybUZ1bmN0aW9uXCIpKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVIb2xkZXIgPSBmbHVpZC5tb2RlbC50cmFuc2Zvcm0uYWxpYXNTdGFuZGFyZElucHV0KHRyYW5zZm9ybVNwZWMpO1xuICAgICAgICAgICAgdmFyIGV4cGFuZGVkID0gZmx1aWQubW9kZWwudHJhbnNmb3JtLmdldFZhbHVlKHZhbHVlSG9sZGVyLnZhbHVlUGF0aCwgdmFsdWVIb2xkZXIudmFsdWUsIHRyYW5zZm9ybSk7XG5cbiAgICAgICAgICAgIHRyYW5zZm9ybUFyZ3MudW5zaGlmdChleHBhbmRlZCk7XG4gICAgICAgICAgICAvLyBpZiB0aGUgZnVuY3Rpb24gaGFzIG5vIGlucHV0LCB0aGUgcmVzdWx0IGlzIGNvbnNpZGVyZWQgdW5kZWZpbmVkLCBhbmQgdGhpcyBpcyByZXR1cm5lZFxuICAgICAgICAgICAgaWYgKGV4cGFuZGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGZsdWlkLmhhc0dyYWRlKGV4cGRlZiwgXCJmbHVpZC5tdWx0aUlucHV0VHJhbnNmb3JtRnVuY3Rpb25cIikpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dHMgPSB7fTtcbiAgICAgICAgICAgIGZsdWlkLmVhY2goZXhwZGVmLmlucHV0VmFyaWFibGVzLCBmdW5jdGlvbiAodiwgaykge1xuICAgICAgICAgICAgICAgIGlucHV0c1trXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gZmx1aWQubW9kZWwudHJhbnNmb3JtLmdldFZhbHVlKHRyYW5zZm9ybVNwZWNbayArIFwiUGF0aFwiXSwgdHJhbnNmb3JtU3BlY1trXSwgdHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgbm8gbWF0Y2gsIGFzc2lnbiBkZWZhdWx0IGlmIG9uZSBleGlzdHMgKHYgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQgPSAoaW5wdXQgPT09IHVuZGVmaW5lZCAmJiB2ICE9PSBudWxsKSA/IHYgOiBpbnB1dDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRyYW5zZm9ybUFyZ3MudW5zaGlmdChpbnB1dHMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0cmFuc2Zvcm1lZCA9IHRyYW5zZm9ybUZuLmFwcGx5KG51bGwsIHRyYW5zZm9ybUFyZ3MpO1xuICAgICAgICBpZiAoZmx1aWQuaGFzR3JhZGUoZXhwZGVmLCBcImZsdWlkLnN0YW5kYXJkT3V0cHV0VHJhbnNmb3JtRnVuY3Rpb25cIikpIHtcbiAgICAgICAgICAgIC8vIFwiZG9PdXRwdXRcIiBmbGFnIGlzIGN1cnJlbnRseSBzZXQgbm93aGVyZSwgYnV0IGNvdWxkIGJlIHVzZWQgaW4gZnV0dXJlXG4gICAgICAgICAgICB2YXIgb3V0cHV0UGF0aCA9IHRyYW5zZm9ybVNwZWMub3V0cHV0UGF0aCAhPT0gdW5kZWZpbmVkID8gdHJhbnNmb3JtU3BlYy5vdXRwdXRQYXRoIDogKHRyYW5zZm9ybU9wdHMuZG9PdXRwdXQgPyBcIlwiIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGlmIChvdXRwdXRQYXRoICE9PSB1bmRlZmluZWQgJiYgdHJhbnNmb3JtZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vSWYgb3V0cHV0UGF0aCBpcyBnaXZlbiBpbiB0aGUgZXhwYW5kZXIgd2Ugd2FudCB0bzpcbiAgICAgICAgICAgICAgICAvLyAoMSkgb3V0cHV0IHRvIHRoZSBkb2N1bWVudFxuICAgICAgICAgICAgICAgIC8vICgyKSByZXR1cm4gdW5kZWZpbmVkLCB0byBlbnN1cmUgdGhhdCBleHBhbmRlcnMgaGlnaGVyIHVwIGluIHRoZSBoaWVyYXJjaHkgZG9lc24ndCBhdHRlbXB0IHRvIG91dHB1dCBpdCBhZ2FpblxuICAgICAgICAgICAgICAgIGZsdWlkLm1vZGVsLnRyYW5zZm9ybS5zZXRWYWx1ZSh0cmFuc2Zvcm1TcGVjLm91dHB1dFBhdGgsIHRyYW5zZm9ybWVkLCB0cmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZDtcbiAgICB9O1xuXG4gICAgLy8gdW5zdXBwb3J0ZWQsIE5PTi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5tb2RlbC50cmFuc2Zvcm0uZXhwYW5kV2lsZGNhcmRzID0gZnVuY3Rpb24gKHRyYW5zZm9ybSwgc291cmNlKSB7XG4gICAgICAgIGZsdWlkLmVhY2goc291cmNlLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgICAgdmFyIHEgPSB0cmFuc2Zvcm0ucXVldWVkVHJhbnNmb3JtcztcbiAgICAgICAgICAgIHRyYW5zZm9ybS5wYXRoT3AucHVzaChmbHVpZC5wYXRoVXRpbC5lc2NhcGVTZWdtZW50KGtleS50b1N0cmluZygpKSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmx1aWQucGF0aFV0aWwubWF0Y2hQYXRoKHFbaV0ubWF0Y2hQYXRoLCB0cmFuc2Zvcm0ucGF0aCwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVzQ29weSA9IGZsdWlkLmNvcHkocVtpXS50cmFuc2Zvcm1TcGVjKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVzQ29weS5pbnB1dFBhdGggPT09IHVuZGVmaW5lZCB8fCBmbHVpZC5tb2RlbC50cmFuc2Zvcm0uaGFzV2lsZGNhcmQoZXNDb3B5LmlucHV0UGF0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVzQ29weS5pbnB1dFBhdGggPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGFsbG93IHNvbWUga2luZCBvZiBpbnRlcnBvbGF0aW9uIGZvciBvdXRwdXQgcGF0aFxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBBbHNvLCB3ZSBub3cgcmVxdWlyZSBvdXRwdXRQYXRoIHRvIGJlIHNwZWNpZmllZCBpbiB0aGVzZSBjYXNlcyBmb3Igb3V0cHV0IHRvIGJlIHByb2R1Y2VkIGFzIHdlbGwuLiBJcyB0aGF0IHNvbWV0aGluZyB3ZSB3YW50IHRvIGNvbnRpbnVlIHdpdGg/XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybS5pbnB1dFByZWZpeE9wLnB1c2godHJhbnNmb3JtLnBhdGgpO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0ub3V0cHV0UHJlZml4T3AucHVzaCh0cmFuc2Zvcm0ucGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1PcHRzID0gZmx1aWQubW9kZWwudHJhbnNmb3JtLmxvb2t1cFR5cGUoZXNDb3B5LnR5cGUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gZmx1aWQubW9kZWwudHJhbnNmb3JtLmRvVHJhbnNmb3JtKGVzQ29weSwgdHJhbnNmb3JtLCB0cmFuc2Zvcm1PcHRzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbHVpZC5tb2RlbC50cmFuc2Zvcm0uc2V0VmFsdWUobnVsbCwgcmVzdWx0LCB0cmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybS5vdXRwdXRQcmVmaXhPcC5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtLmlucHV0UHJlZml4T3AucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFmbHVpZC5pc1ByaW1pdGl2ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBmbHVpZC5tb2RlbC50cmFuc2Zvcm0uZXhwYW5kV2lsZGNhcmRzKHRyYW5zZm9ybSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhbnNmb3JtLnBhdGhPcC5wb3AoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIHVuc3VwcG9ydGVkLCBOT04tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQubW9kZWwudHJhbnNmb3JtLmhhc1dpbGRjYXJkID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZihwYXRoKSA9PT0gXCJzdHJpbmdcIiAmJiBwYXRoLmluZGV4T2YoXCIqXCIpICE9PSAtMTtcbiAgICB9O1xuXG4gICAgLy8gdW5zdXBwb3J0ZWQsIE5PTi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5tb2RlbC50cmFuc2Zvcm0ubWF5YmVQdXNoV2lsZGNhcmQgPSBmdW5jdGlvbiAodHJhbnNmb3JtU3BlYywgdHJhbnNmb3JtKSB7XG4gICAgICAgIHZhciBodyA9IGZsdWlkLm1vZGVsLnRyYW5zZm9ybS5oYXNXaWxkY2FyZDtcbiAgICAgICAgdmFyIG1hdGNoUGF0aDtcbiAgICAgICAgaWYgKGh3KHRyYW5zZm9ybVNwZWMuaW5wdXRQYXRoKSkge1xuICAgICAgICAgICAgbWF0Y2hQYXRoID0gZmx1aWQubW9kZWwuY29tcG9zZVBhdGhzKHRyYW5zZm9ybS5pbnB1dFByZWZpeCwgdHJhbnNmb3JtU3BlYy5pbnB1dFBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGh3KHRyYW5zZm9ybS5vdXRwdXRQcmVmaXgpIHx8IGh3KHRyYW5zZm9ybVNwZWMub3V0cHV0UGF0aCkpIHtcbiAgICAgICAgICAgIG1hdGNoUGF0aCA9IGZsdWlkLm1vZGVsLmNvbXBvc2VQYXRocyh0cmFuc2Zvcm0ub3V0cHV0UHJlZml4LCB0cmFuc2Zvcm1TcGVjLm91dHB1dFBhdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoUGF0aCkge1xuICAgICAgICAgICAgdHJhbnNmb3JtLnF1ZXVlZFRyYW5zZm9ybXMucHVzaCh7dHJhbnNmb3JtU3BlYzogdHJhbnNmb3JtU3BlYywgb3V0cHV0UHJlZml4OiB0cmFuc2Zvcm0ub3V0cHV0UHJlZml4LCBpbnB1dFByZWZpeDogdHJhbnNmb3JtLmlucHV0UHJlZml4LCBtYXRjaFBhdGg6IG1hdGNoUGF0aH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBmbHVpZC5tb2RlbC5zb3J0QnlLZXlMZW5ndGggPSBmdW5jdGlvbiAoaW5PYmplY3QpIHtcbiAgICAgICAgdmFyIGtleXMgPSBmbHVpZC5rZXlzKGluT2JqZWN0KTtcbiAgICAgICAgcmV0dXJuIGtleXMuc29ydChmbHVpZC5jb21wYXJlU3RyaW5nTGVuZ3RoKHRydWUpKTtcbiAgICB9O1xuXG4gICAgLy8gVGhyZWUgaGFuZGxlciBmdW5jdGlvbnMgb3BlcmF0aW5nIHRoZSAoY3VycmVudGx5KSB0aHJlZSBkaWZmZXJlbnQgcHJvY2Vzc2luZyBtb2Rlc1xuICAgIC8vIHVuc3VwcG9ydGVkLCBOT04tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQubW9kZWwudHJhbnNmb3JtLmhhbmRsZVRyYW5zZm9ybVN0cmF0ZWd5ID0gZnVuY3Rpb24gKHRyYW5zZm9ybVNwZWMsIHRyYW5zZm9ybSwgdHJhbnNmb3JtT3B0cykge1xuICAgICAgICBpZiAoZmx1aWQubW9kZWwudHJhbnNmb3JtLm1heWJlUHVzaFdpbGRjYXJkKHRyYW5zZm9ybVNwZWMsIHRyYW5zZm9ybSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmbHVpZC5tb2RlbC50cmFuc2Zvcm0uZG9UcmFuc2Zvcm0odHJhbnNmb3JtU3BlYywgdHJhbnNmb3JtLCB0cmFuc2Zvcm1PcHRzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gdW5zdXBwb3J0ZWQsIE5PTi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5tb2RlbC50cmFuc2Zvcm0uaGFuZGxlSW52ZXJ0U3RyYXRlZ3kgPSBmdW5jdGlvbiAodHJhbnNmb3JtU3BlYywgdHJhbnNmb3JtLCB0cmFuc2Zvcm1PcHRzKSB7XG4gICAgICAgIHZhciBpbnZlcnRvciA9IHRyYW5zZm9ybU9wdHMuZGVmYXVsdHMgJiYgdHJhbnNmb3JtT3B0cy5kZWZhdWx0cy5pbnZlcnRDb25maWd1cmF0aW9uO1xuICAgICAgICBpZiAoaW52ZXJ0b3IpIHtcbiAgICAgICAgICAgIHZhciBpbnZlcnRlZCA9IGZsdWlkLmludm9rZUdsb2JhbEZ1bmN0aW9uKGludmVydG9yLCBbdHJhbnNmb3JtU3BlYywgdHJhbnNmb3JtXSk7XG4gICAgICAgICAgICB0cmFuc2Zvcm0uaW52ZXJ0ZWQucHVzaChpbnZlcnRlZCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gdW5zdXBwb3J0ZWQsIE5PTi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5tb2RlbC50cmFuc2Zvcm0uaGFuZGxlQ29sbGVjdFN0cmF0ZWd5ID0gZnVuY3Rpb24gKHRyYW5zZm9ybVNwZWMsIHRyYW5zZm9ybSwgdHJhbnNmb3JtT3B0cykge1xuICAgICAgICB2YXIgZGVmYXVsdHMgPSB0cmFuc2Zvcm1PcHRzLmRlZmF1bHRzO1xuICAgICAgICB2YXIgc3RhbmRhcmRJbnB1dCA9IGZsdWlkLmhhc0dyYWRlKGRlZmF1bHRzLCBcImZsdWlkLnN0YW5kYXJkSW5wdXRUcmFuc2Zvcm1GdW5jdGlvblwiKTtcbiAgICAgICAgdmFyIG11bHRpSW5wdXQgPSBmbHVpZC5oYXNHcmFkZShkZWZhdWx0cywgXCJmbHVpZC5tdWx0aUlucHV0VHJhbnNmb3JtRnVuY3Rpb25cIik7XG5cbiAgICAgICAgaWYgKHN0YW5kYXJkSW5wdXQpIHtcbiAgICAgICAgICAgIGZsdWlkLm1vZGVsLnRyYW5zZm9ybS5hY2N1bXVsYXRlU3RhbmRhcmRJbnB1dFBhdGgoXCJpbnB1dFwiLCB0cmFuc2Zvcm1TcGVjLCB0cmFuc2Zvcm0sIHRyYW5zZm9ybS5pbnB1dFBhdGhzKTtcbiAgICAgICAgfSBlbHNlIGlmIChtdWx0aUlucHV0KSB7XG4gICAgICAgICAgICBmbHVpZC5tb2RlbC50cmFuc2Zvcm0uYWNjdW11bGF0ZU11bHRpSW5wdXRQYXRocyhkZWZhdWx0cy5pbnB1dFZhcmlhYmxlcywgdHJhbnNmb3JtU3BlYywgdHJhbnNmb3JtLCB0cmFuc2Zvcm0uaW5wdXRQYXRocyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgY29sbGVjdG9yID0gZGVmYXVsdHMuY29sbGVjdElucHV0UGF0aHM7XG4gICAgICAgICAgICBpZiAoY29sbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbGxlY3RlZCA9IGZsdWlkLm1ha2VBcnJheShmbHVpZC5pbnZva2VHbG9iYWxGdW5jdGlvbihjb2xsZWN0b3IsIFt0cmFuc2Zvcm1TcGVjLCB0cmFuc2Zvcm1dKSk7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtLmlucHV0UGF0aHMgPSB0cmFuc2Zvcm0uaW5wdXRQYXRocy5jb25jYXQoY29sbGVjdGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmbHVpZC5tb2RlbC50cmFuc2Zvcm0ubG9va3VwVHlwZSA9IGZ1bmN0aW9uICh0eXBlTmFtZSwgdHJhbnNmb3JtU3BlYykge1xuICAgICAgICBpZiAoIXR5cGVOYW1lKSB7XG4gICAgICAgICAgICBmbHVpZC5mYWlsKFwiVHJhbnNmb3JtYXRpb24gcmVjb3JkIGlzIG1pc3NpbmcgYSB0eXBlIG5hbWU6IFwiLCB0cmFuc2Zvcm1TcGVjKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZU5hbWUuaW5kZXhPZihcIi5cIikgPT09IC0xKSB7XG4gICAgICAgICAgICB0eXBlTmFtZSA9IFwiZmx1aWQudHJhbnNmb3Jtcy5cIiArIHR5cGVOYW1lO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkZWZhdWx0cyA9IGZsdWlkLmRlZmF1bHRzKHR5cGVOYW1lKTtcbiAgICAgICAgcmV0dXJuIHsgZGVmYXVsdHM6IGRlZmF1bHRzLCB0eXBlTmFtZTogdHlwZU5hbWV9O1xuICAgIH07XG4gICAgXG4gICAgLy8gQSB1dGlsaXR5IHdoaWNoIGlzIGhlbHBmdWwgaW4gY29tcHV0aW5nIGludmVyc2VzIGludm9sdmluZyBjb21wb3VuZCB2YWx1ZXMuIFxuICAgIC8vIEZvciBleGFtcGxlLCB3aXRoIHRoZSB2YWx1ZU1hcHBlciwgY29tcG91bmQgaW5wdXQgdmFsdWVzIGFyZSBhY2NlcHRlZCBhcyBsaXRlcmFscyBpbXBsaWNpdGx5LFxuICAgIC8vIHdoZXJlYXMgYXMgb3V0cHV0IHZhbHVlcyB0aGV5IG11c3QgYmUgZXNjYXBlZC4gVGhpcyB1dGlsaXR5IGVzY2FwZXMgYSB2YWx1ZSBpZiBpdCBpcyBub3QgcHJpbWl0aXZlLlxuICAgIGZsdWlkLm1vZGVsLnRyYW5zZm9ybS5saXRlcmFsaXNlVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGZsdWlkLmlzUHJpbWl0aXZlKHZhbHVlKSA/IHZhbHVlIDoge1xuICAgICAgICAgICAgbGl0ZXJhbFZhbHVlOiB2YWx1ZVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvLyB1bnN1cHBvcnRlZCwgTk9OLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLm1vZGVsLnRyYW5zZm9ybS5wcm9jZXNzUnVsZSA9IGZ1bmN0aW9uIChydWxlLCB0cmFuc2Zvcm0pIHtcbiAgICAgICAgaWYgKHR5cGVvZihydWxlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcnVsZSA9IGZsdWlkLm1vZGVsLnRyYW5zZm9ybS5wYXRoVG9SdWxlKHJ1bGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNwZWNpYWwgZGlzcGVuc2F0aW9uIHRvIGFsbG93IFwibGl0ZXJhbFZhbHVlXCIgdG8gZXNjYXBlIGFueSB2YWx1ZVxuICAgICAgICBlbHNlIGlmIChydWxlLmxpdGVyYWxWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBydWxlID0gZmx1aWQubW9kZWwudHJhbnNmb3JtLmxpdGVyYWxWYWx1ZVRvUnVsZShydWxlLmxpdGVyYWxWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRvZ287XG4gICAgICAgIGlmIChydWxlLnRyYW5zZm9ybSkge1xuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybVNwZWMsIHRyYW5zZm9ybU9wdHM7XG5cbiAgICAgICAgICAgIGlmIChmbHVpZC5pc0FycmF5YWJsZShydWxlLnRyYW5zZm9ybSkpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgdHJhbnNmb3JtIGhvbGRzIGFuIGFycmF5LCBlYWNoIHRyYW5zZm9ybWVyIHdpdGhpbiB0aGF0IGlzIHJlc3BvbnNpYmxlIGZvciBpdHMgb3duIG91dHB1dFxuICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1zID0gcnVsZS50cmFuc2Zvcm07XG4gICAgICAgICAgICAgICAgdG9nbyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtU3BlYyA9IHRyYW5zZm9ybXNbaV07XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybU9wdHMgPSBmbHVpZC5tb2RlbC50cmFuc2Zvcm0ubG9va3VwVHlwZSh0cmFuc2Zvcm1TcGVjLnR5cGUpO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0udHJhbnNmb3JtSGFuZGxlcih0cmFuc2Zvcm1TcGVjLCB0cmFuc2Zvcm0sIHRyYW5zZm9ybU9wdHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZWxzZSB3ZSBqdXN0IGhhdmUgYSBub3JtYWwgc2luZ2xlIHRyYW5zZm9ybSB3aGljaCB3aWxsIHJldHVybiAndW5kZWZpbmVkJyBhcyBhIGZsYWcgdG8gZGVmZWF0IGNhc2NhZGluZyBvdXRwdXRcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1TcGVjID0gcnVsZS50cmFuc2Zvcm07XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtT3B0cyA9IGZsdWlkLm1vZGVsLnRyYW5zZm9ybS5sb29rdXBUeXBlKHRyYW5zZm9ybVNwZWMudHlwZSk7XG4gICAgICAgICAgICAgICAgdG9nbyA9IHRyYW5zZm9ybS50cmFuc2Zvcm1IYW5kbGVyKHRyYW5zZm9ybVNwZWMsIHRyYW5zZm9ybSwgdHJhbnNmb3JtT3B0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgcnVsZSBpcyBhbiBhcnJheSwgc2F2ZSBwYXRoIGZvciBsYXRlciB1c2UgaW4gc2NoZW1hIHN0cmF0ZWd5IG9uIGZpbmFsIGFwcGxpZXIgKHNvIG91dHB1dCB3aWxsIGJlIGludGVycHJldGVkIGFzIGFycmF5KVxuICAgICAgICBpZiAoZmx1aWQuaXNBcnJheWFibGUocnVsZSkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybS5jb2xsZWN0ZWRGbGF0U2NoZW1hT3B0cyA9IHRyYW5zZm9ybS5jb2xsZWN0ZWRGbGF0U2NoZW1hT3B0cyB8fCB7fTtcbiAgICAgICAgICAgIHRyYW5zZm9ybS5jb2xsZWN0ZWRGbGF0U2NoZW1hT3B0c1t0cmFuc2Zvcm0ub3V0cHV0UHJlZml4XSA9IFwiYXJyYXlcIjtcbiAgICAgICAgfVxuICAgICAgICBmbHVpZC5lYWNoKHJ1bGUsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtLm91dHB1dFByZWZpeE9wLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB2YXIgdG9nbyA9IHRyYW5zZm9ybS5leHBhbmQodmFsdWUsIHRyYW5zZm9ybSk7XG4gICAgICAgICAgICAgICAgLy8gVmFsdWUgZXhwYW5kZXJzIGFuZCBhcnJheXMgYXMgcnVsZXMgaW1wbGljaXRseSBvdXRwdXRzLCB1bmxlc3MgdGhleSBoYXZlIG5vdGhpbmcgKHVuZGVmaW5lZCkgdG8gb3V0cHV0XG4gICAgICAgICAgICAgICAgaWYgKHRvZ28gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBmbHVpZC5tb2RlbC50cmFuc2Zvcm0uc2V0VmFsdWUobnVsbCwgdG9nbywgdHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5zdXJlIHRoYXQgZXhwYW5kZXJzIGZ1cnRoZXIgdXAgZG9lcyBub3QgdHJ5IHRvIG91dHB1dCB0aGlzIHZhbHVlIGFzIHdlbGwuXG4gICAgICAgICAgICAgICAgICAgIHRvZ28gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybS5vdXRwdXRQcmVmaXhPcC5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0b2dvO1xuICAgIH07XG5cbiAgICAvLyB1bnN1cHBvcnRlZCwgTk9OLUFQSSBmdW5jdGlvblxuICAgIC8vIDNyZCBhcmcgaXMgZGlzdXNlZCBieSB0aGUgZnJhbWV3b3JrIGFuZCBhbHdheXMgZGVmYXVsdHMgdG8gZmx1aWQubW9kZWwudHJhbnNmb3JtLnByb2Nlc3NSdWxlXG4gICAgZmx1aWQubW9kZWwudHJhbnNmb3JtLm1ha2VTdHJhdGVneSA9IGZ1bmN0aW9uICh0cmFuc2Zvcm0sIGhhbmRsZUZuLCB0cmFuc2Zvcm1Gbikge1xuICAgICAgICB0cmFuc2Zvcm1GbiA9IHRyYW5zZm9ybUZuIHx8IGZsdWlkLm1vZGVsLnRyYW5zZm9ybS5wcm9jZXNzUnVsZTtcbiAgICAgICAgdHJhbnNmb3JtLmV4cGFuZCA9IGZ1bmN0aW9uIChydWxlcykge1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybUZuKHJ1bGVzLCB0cmFuc2Zvcm0pO1xuICAgICAgICB9O1xuICAgICAgICB0cmFuc2Zvcm0ub3V0cHV0UHJlZml4T3AgPSBmbHVpZC5tb2RlbC5tYWtlUGF0aFN0YWNrKHRyYW5zZm9ybSwgXCJvdXRwdXRQcmVmaXhcIik7XG4gICAgICAgIHRyYW5zZm9ybS5pbnB1dFByZWZpeE9wID0gZmx1aWQubW9kZWwubWFrZVBhdGhTdGFjayh0cmFuc2Zvcm0sIFwiaW5wdXRQcmVmaXhcIik7XG4gICAgICAgIHRyYW5zZm9ybS50cmFuc2Zvcm1IYW5kbGVyID0gaGFuZGxlRm47XG4gICAgfTtcblxuICAgIGZsdWlkLm1vZGVsLnRyYW5zZm9ybS5pbnZlcnRDb25maWd1cmF0aW9uID0gZnVuY3Rpb24gKHJ1bGVzKSB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSB7XG4gICAgICAgICAgICBpbnZlcnRlZDogW11cbiAgICAgICAgfTtcbiAgICAgICAgZmx1aWQubW9kZWwudHJhbnNmb3JtLm1ha2VTdHJhdGVneSh0cmFuc2Zvcm0sIGZsdWlkLm1vZGVsLnRyYW5zZm9ybS5oYW5kbGVJbnZlcnRTdHJhdGVneSk7XG4gICAgICAgIHRyYW5zZm9ybS5leHBhbmQocnVsZXMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0uaW52ZXJ0ZWRcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgZmx1aWQubW9kZWwudHJhbnNmb3JtLmNvbGxlY3RJbnB1dFBhdGhzID0gZnVuY3Rpb24gKHJ1bGVzKSB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSB7XG4gICAgICAgICAgICBpbnB1dFBhdGhzOiBbXVxuICAgICAgICB9O1xuICAgICAgICBmbHVpZC5tb2RlbC50cmFuc2Zvcm0ubWFrZVN0cmF0ZWd5KHRyYW5zZm9ybSwgZmx1aWQubW9kZWwudHJhbnNmb3JtLmhhbmRsZUNvbGxlY3RTdHJhdGVneSk7XG4gICAgICAgIHRyYW5zZm9ybS5leHBhbmQocnVsZXMpO1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtLmlucHV0UGF0aHM7XG4gICAgfTtcblxuICAgIC8vIHVuc3VwcG9ydGVkLCBOT04tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQubW9kZWwudHJhbnNmb3JtLmZsYXRTY2hlbWFTdHJhdGVneSA9IGZ1bmN0aW9uIChmbGF0U2NoZW1hLCBnZXRDb25maWcpIHtcbiAgICAgICAgdmFyIGtleXMgPSBmbHVpZC5tb2RlbC5zb3J0QnlLZXlMZW5ndGgoZmxhdFNjaGVtYSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocm9vdCwgc2VnbWVudCwgaW5kZXgsIHNlZ3MpIHtcbiAgICAgICAgICAgIHZhciBwYXRoID0gZ2V0Q29uZmlnLnBhcnNlci5jb21wb3NlLmFwcGx5KG51bGwsIHNlZ3Muc2xpY2UoMCwgaW5kZXgpKTtcbiAgICAgICAgICAvLyBUT0RPOiBjbGVhcmx5IHRoaXMgaW1wbGVtZW50YXRpb24gY291bGQgYmUgbXVjaCBtb3JlIGVmZmljaWVudFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGZsdWlkLnBhdGhVdGlsLm1hdGNoUGF0aChrZXksIHBhdGgsIHRydWUpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbGF0U2NoZW1hW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvLyB1bnN1cHBvcnRlZCwgTk9OLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLm1vZGVsLnRyYW5zZm9ybS5kZWZhdWx0U2NoZW1hVmFsdWUgPSBmdW5jdGlvbiAoc2NoZW1hVmFsdWUpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBmbHVpZC5pc1ByaW1pdGl2ZShzY2hlbWFWYWx1ZSkgPyBzY2hlbWFWYWx1ZSA6IHNjaGVtYVZhbHVlLnR5cGU7XG4gICAgICAgIHJldHVybiB0eXBlID09PSBcImFycmF5XCIgPyBbXSA6IHt9O1xuICAgIH07XG5cbiAgICAvLyB1bnN1cHBvcnRlZCwgTk9OLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLm1vZGVsLnRyYW5zZm9ybS5pc29tb3JwaGljU2NoZW1hU3RyYXRlZ3kgPSBmdW5jdGlvbiAoc291cmNlLCBnZXRDb25maWcpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyb290LCBzZWdtZW50LCBpbmRleCwgc2Vncykge1xuICAgICAgICAgICAgdmFyIGV4aXN0aW5nID0gZmx1aWQuZ2V0KHNvdXJjZSwgc2Vncy5zbGljZSgwLCBpbmRleCksIGdldENvbmZpZyk7XG4gICAgICAgICAgICByZXR1cm4gZmx1aWQuaXNBcnJheWFibGUoZXhpc3RpbmcpID8gXCJhcnJheVwiIDogXCJvYmplY3RcIjtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gdW5zdXBwb3J0ZWQsIE5PTi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5tb2RlbC50cmFuc2Zvcm0uZGVjb2RlU3RyYXRlZ3kgPSBmdW5jdGlvbiAoc291cmNlLCBvcHRpb25zLCBnZXRDb25maWcpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuaXNvbW9ycGhpYykge1xuICAgICAgICAgICAgcmV0dXJuIGZsdWlkLm1vZGVsLnRyYW5zZm9ybS5pc29tb3JwaGljU2NoZW1hU3RyYXRlZ3koc291cmNlLCBnZXRDb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuZmxhdFNjaGVtYSkge1xuICAgICAgICAgICAgcmV0dXJuIGZsdWlkLm1vZGVsLnRyYW5zZm9ybS5mbGF0U2NoZW1hU3RyYXRlZ3kob3B0aW9ucy5mbGF0U2NoZW1hLCBnZXRDb25maWcpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIHVuc3VwcG9ydGVkLCBOT04tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQubW9kZWwudHJhbnNmb3JtLnNjaGVtYVRvQ3JlYXRvclN0cmF0ZWd5ID0gZnVuY3Rpb24gKHN0cmF0ZWd5KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocm9vdCwgc2VnbWVudCwgaW5kZXgsIHNlZ3MpIHtcbiAgICAgICAgICAgIGlmIChyb290W3NlZ21lbnRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2NoZW1hVmFsdWUgPSBzdHJhdGVneShyb290LCBzZWdtZW50LCBpbmRleCwgc2Vncyk7XG4gICAgICAgICAgICAgICAgcm9vdFtzZWdtZW50XSA9IGZsdWlkLm1vZGVsLnRyYW5zZm9ybS5kZWZhdWx0U2NoZW1hVmFsdWUoc2NoZW1hVmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiByb290W3NlZ21lbnRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvKiogVHJhbnNmb3JtcyBhIG1vZGVsIGJ5IGEgc2VxdWVuY2Ugb2YgcnVsZXMuIFBhcmFtZXRlcnMgYXMgZm9yIGZsdWlkLm1vZGVsLnRyYW5zZm9ybSxcbiAgICAgKiBvbmx5IHdpdGggYW4gYXJyYXkgYWNjZXB0ZWQgZm9yIFwicnVsZXNcIlxuICAgICAqL1xuICAgIGZsdWlkLm1vZGVsLnRyYW5zZm9ybS5zZXF1ZW5jZSA9IGZ1bmN0aW9uIChzb3VyY2UsIHJ1bGVzLCBvcHRpb25zKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHNvdXJjZSA9IGZsdWlkLm1vZGVsLnRyYW5zZm9ybShzb3VyY2UsIHJ1bGVzW2ldLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIH07XG5cbiAgICBmbHVpZC5tb2RlbC5jb21wYXJlQnlQYXRoTGVuZ3RoID0gZnVuY3Rpb24gKGNoYW5nZWEsIGNoYW5nZWIpIHtcbiAgICAgICAgdmFyIHBkaWZmID0gY2hhbmdlYS5wYXRoLmxlbmd0aCAtIGNoYW5nZWIucGF0aC5sZW5ndGg7XG4gICAgICAgIHJldHVybiBwZGlmZiA9PT0gMCA/IGNoYW5nZWEuc2VxdWVuY2UgLSBjaGFuZ2ViLnNlcXVlbmNlIDogcGRpZmY7XG4gICAgfTtcblxuICAgLyoqIEZpcmVzIGFuIGFjY3VtdWxhdGVkIHNldCBvZiBjaGFuZ2UgcmVxdWVzdHMgaW4gaW5jcmVhc2luZyBvcmRlciBvZiB0YXJnZXQgcGF0aGxlbmd0aFxuICAgICAqL1xuICAgIGZsdWlkLm1vZGVsLmZpcmVTb3J0ZWRDaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMsIGFwcGxpZXIpIHtcbiAgICAgICAgY2hhbmdlcy5zb3J0KGZsdWlkLm1vZGVsLmNvbXBhcmVCeVBhdGhMZW5ndGgpO1xuICAgICAgICBmbHVpZC5yZXF1ZXN0Q2hhbmdlcyhhcHBsaWVyLCBjaGFuZ2VzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBhIG1vZGVsIGJhc2VkIG9uIGEgc3BlY2lmaWVkIGV4cGFuc2lvbiBydWxlcyBvYmplY3RzLlxuICAgICAqIFJ1bGVzIG9iamVjdHMgdGFrZSB0aGUgZm9ybSBvZjpcbiAgICAgKiAgIHtcbiAgICAgKiAgICAgICBcInRhcmdldC5wYXRoXCI6IFwidmFsdWUuZWwucGF0aFwiIHx8IHtcbiAgICAgKiAgICAgICAgICB0cmFuc2Zvcm06IHtcbiAgICAgKiAgICAgICAgICAgICAgdHlwZTogXCJ0cmFuc2Zvcm0uZnVuY3Rpb24ucGF0aFwiLFxuICAgICAqICAgICAgICAgICAgICAgLi4uXG4gICAgICogICAgICAgICAgIH1cbiAgICAgKiAgICAgICB9XG4gICAgICogICB9XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIHRoZSBtb2RlbCB0byB0cmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcnVsZXMgYSBydWxlcyBvYmplY3QgY29udGFpbmluZyBpbnN0cnVjdGlvbnMgb24gaG93IHRvIHRyYW5zZm9ybSB0aGUgbW9kZWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBhIHNldCBvZiBydWxlcyBnb3Zlcm5pbmcgdGhlIHRyYW5zZm9ybWF0aW9ucy4gQXQgcHJlc2VudCB0aGlzIG1heSBjb250YWluXG4gICAgICogdGhlIHZhbHVlcyA8Y29kZT5pc29tb3JwaGljOiB0cnVlPC9jb2RlPiBpbmRpY2F0aW5nIHRoYXQgdGhlIG91dHB1dCBtb2RlbCBpcyB0byBiZSBnb3Zlcm5lZCBieSB0aGVcbiAgICAgKiBzYW1lIHNjaGVtYSBmb3VuZCBpbiB0aGUgaW5wdXQgbW9kZWwsIG9yIDxjb2RlPmZsYXRTY2hlbWE8L2NvZGU+IGhvbGRpbmcgYSBmbGF0IHNjaGVtYSBvYmplY3Qgd2hpY2hcbiAgICAgKiBjb25zaXN0cyBvZiBhIGhhc2ggb2YgRUwgcGF0aCBzcGVjaWZpY2F0aW9ucyB3aXRoIHdpbGRjYXJkcywgdG8gdGhlIHZhbHVlcyBcImFycmF5XCIvXCJvYmplY3RcIiBkZWZpbmluZ1xuICAgICAqIHRoZSBzY2hlbWEgdG8gYmUgdXNlZCB0byBjb25zdHJ1Y3QgbWlzc2luZyB0cnVuayB2YWx1ZXMuXG4gICAgICovXG4gICAgZmx1aWQubW9kZWwudHJhbnNmb3JtV2l0aFJ1bGVzID0gZnVuY3Rpb24gKHNvdXJjZSwgcnVsZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgdmFyIGdldENvbmZpZyA9IGZsdWlkLm1vZGVsLmVzY2FwZWRHZXRDb25maWc7XG5cbiAgICAgICAgdmFyIHNjaGVtYVN0cmF0ZWd5ID0gZmx1aWQubW9kZWwudHJhbnNmb3JtLmRlY29kZVN0cmF0ZWd5KHNvdXJjZSwgb3B0aW9ucywgZ2V0Q29uZmlnKTtcblxuICAgICAgICB2YXIgdHJhbnNmb3JtID0ge1xuICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICB0YXJnZXQ6IHtcbiAgICAgICAgICAgICAgICBtb2RlbDogc2NoZW1hU3RyYXRlZ3kgPyBmbHVpZC5tb2RlbC50cmFuc2Zvcm0uZGVmYXVsdFNjaGVtYVZhbHVlKHNjaGVtYVN0cmF0ZWd5KG51bGwsIFwiXCIsIDAsIFtcIlwiXSkpIDoge31cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNvbHZlckdldENvbmZpZzogZ2V0Q29uZmlnLFxuICAgICAgICAgICAgY29sbGVjdGVkRmxhdFNjaGVtYU9wdHM6IHVuZGVmaW5lZCwgLy8gdG8gaG9sZCBvcHRpb25zIGZvciBmbGF0IHNjaGVtYSBjb2xsZWN0ZWQgZHVyaW5nIHRyYW5zZm9ybXNcbiAgICAgICAgICAgIHF1ZXVlZENoYW5nZXM6IFtdLFxuICAgICAgICAgICAgcXVldWVkVHJhbnNmb3JtczogW10gLy8gVE9ETzogVGhpcyBpcyB1c2VkIG9ubHkgYnkgd2lsZGNhcmQgYXBwbGllciAtIGV4cGxhaW4gaXRzIG9wZXJhdGlvblxuICAgICAgICB9O1xuICAgICAgICBmbHVpZC5tb2RlbC50cmFuc2Zvcm0ubWFrZVN0cmF0ZWd5KHRyYW5zZm9ybSwgZmx1aWQubW9kZWwudHJhbnNmb3JtLmhhbmRsZVRyYW5zZm9ybVN0cmF0ZWd5KTtcbiAgICAgICAgdHJhbnNmb3JtLmFwcGxpZXIgPSB7XG4gICAgICAgICAgICBmaXJlQ2hhbmdlUmVxdWVzdDogZnVuY3Rpb24gKGNoYW5nZVJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VSZXF1ZXN0LnNlcXVlbmNlID0gdHJhbnNmb3JtLnF1ZXVlZENoYW5nZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybS5xdWV1ZWRDaGFuZ2VzLnB1c2goY2hhbmdlUmVxdWVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZsdWlkLmJpbmRSZXF1ZXN0Q2hhbmdlKHRyYW5zZm9ybS5hcHBsaWVyKTtcblxuICAgICAgICB0cmFuc2Zvcm0uZXhwYW5kKHJ1bGVzKTtcblxuICAgICAgICB2YXIgc2V0Q29uZmlnID0gZmx1aWQuY29weShmbHVpZC5tb2RlbC5lc2NhcGVkU2V0Q29uZmlnKTtcbiAgICAgICAgLy8gTW9kaWZ5IHNjaGVtYVN0cmF0ZWd5IGlmIHdlIGNvbGxlY3RlZCBmbGF0IHNjaGVtYSBvcHRpb25zIGZvciB0aGUgc2V0Q29uZmlnIG9mIGZpbmFsQXBwbGllclxuICAgICAgICBpZiAodHJhbnNmb3JtLmNvbGxlY3RlZEZsYXRTY2hlbWFPcHRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICQuZXh0ZW5kKHRyYW5zZm9ybS5jb2xsZWN0ZWRGbGF0U2NoZW1hT3B0cywgb3B0aW9ucy5mbGF0U2NoZW1hKTtcbiAgICAgICAgICAgIHNjaGVtYVN0cmF0ZWd5ID0gZmx1aWQubW9kZWwudHJhbnNmb3JtLmZsYXRTY2hlbWFTdHJhdGVneSh0cmFuc2Zvcm0uY29sbGVjdGVkRmxhdFNjaGVtYU9wdHMsIGdldENvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0Q29uZmlnLnN0cmF0ZWdpZXMgPSBbZmx1aWQubW9kZWwuZGVmYXVsdEZldGNoU3RyYXRlZ3ksIHNjaGVtYVN0cmF0ZWd5ID8gZmx1aWQubW9kZWwudHJhbnNmb3JtLnNjaGVtYVRvQ3JlYXRvclN0cmF0ZWd5KHNjaGVtYVN0cmF0ZWd5KVxuICAgICAgICAgICAgICAgIDogZmx1aWQubW9kZWwuZGVmYXVsdENyZWF0b3JTdHJhdGVneV07XG4gICAgICAgIHRyYW5zZm9ybS5maW5hbEFwcGxpZXIgPSBvcHRpb25zLmZpbmFsQXBwbGllciB8fCBmbHVpZC5tYWtlTmV3Q2hhbmdlQXBwbGllcih0cmFuc2Zvcm0udGFyZ2V0LCB7cmVzb2x2ZXJTZXRDb25maWc6IHNldENvbmZpZ30pO1xuXG4gICAgICAgIGlmICh0cmFuc2Zvcm0ucXVldWVkVHJhbnNmb3Jtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm0udHlwZVN0YWNrID0gW107XG4gICAgICAgICAgICB0cmFuc2Zvcm0ucGF0aE9wID0gZmx1aWQubW9kZWwubWFrZVBhdGhTdGFjayh0cmFuc2Zvcm0sIFwicGF0aFwiKTtcbiAgICAgICAgICAgIGZsdWlkLm1vZGVsLnRyYW5zZm9ybS5leHBhbmRXaWxkY2FyZHModHJhbnNmb3JtLCBzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIGZsdWlkLm1vZGVsLmZpcmVTb3J0ZWRDaGFuZ2VzKHRyYW5zZm9ybS5xdWV1ZWRDaGFuZ2VzLCB0cmFuc2Zvcm0uZmluYWxBcHBsaWVyKTtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybS50YXJnZXQubW9kZWw7XG4gICAgfTtcblxuICAgICQuZXh0ZW5kKGZsdWlkLm1vZGVsLnRyYW5zZm9ybVdpdGhSdWxlcywgZmx1aWQubW9kZWwudHJhbnNmb3JtKTtcbiAgICBmbHVpZC5tb2RlbC50cmFuc2Zvcm0gPSBmbHVpZC5tb2RlbC50cmFuc2Zvcm1XaXRoUnVsZXM7XG5cbiAgICAvKiogVXRpbGl0eSBmdW5jdGlvbiB0byBwcm9kdWNlIGEgc3RhbmRhcmQgb3B0aW9ucyB0cmFuc2Zvcm1hdGlvbiByZWNvcmQgZm9yIGEgc2luZ2xlIHNldCBvZiBydWxlcyAqKi9cbiAgICBmbHVpZC50cmFuc2Zvcm1PbmUgPSBmdW5jdGlvbiAocnVsZXMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybU9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lcjogXCJmbHVpZC5tb2RlbC50cmFuc2Zvcm1XaXRoUnVsZXNcIixcbiAgICAgICAgICAgICAgICBjb25maWc6IHJ1bGVzXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8qKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIHByb2R1Y2UgYSBzdGFuZGFyZCBvcHRpb25zIHRyYW5zZm9ybWF0aW9uIHJlY29yZCBmb3IgbXVsdGlwbGUgcnVsZXMgdG8gYmUgYXBwbGllZCBpbiBzZXF1ZW5jZSAqKi9cbiAgICBmbHVpZC50cmFuc2Zvcm1NYW55ID0gZnVuY3Rpb24gKHJ1bGVzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1PcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtZXI6IFwiZmx1aWQubW9kZWwudHJhbnNmb3JtLnNlcXVlbmNlXCIsXG4gICAgICAgICAgICAgICAgY29uZmlnOiBydWxlc1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG5cbn0pKGpRdWVyeSwgZmx1aWRfMl8wKTtcbjsvKlxuQ29weXJpZ2h0IDIwMTAgVW5pdmVyc2l0eSBvZiBUb3JvbnRvXG5Db3B5cmlnaHQgMjAxMC0yMDExIE9DQUQgVW5pdmVyc2l0eVxuQ29weXJpZ2h0IDIwMTMgUmFpc2luZyB0aGUgRmxvb3IgLSBJbnRlcm5hdGlvbmFsXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBFZHVjYXRpb25hbCBDb21tdW5pdHkgTGljZW5zZSAoRUNMKSwgVmVyc2lvbiAyLjAgb3IgdGhlIE5ld1xuQlNEIGxpY2Vuc2UuIFlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCBvbmUgdGhlc2VcbkxpY2Vuc2VzLlxuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIEVDTCAyLjAgTGljZW5zZSBhbmQgQlNEIExpY2Vuc2UgYXRcbmh0dHBzOi8vZ2l0aHViLmNvbS9mbHVpZC1wcm9qZWN0L2luZnVzaW9uL3Jhdy9tYXN0ZXIvSW5mdXNpb24tTElDRU5TRS50eHRcbiovXG5cbnZhciBmbHVpZF8yXzAgPSBmbHVpZF8yXzAgfHwge307XG52YXIgZmx1aWQgPSBmbHVpZCB8fCBmbHVpZF8yXzA7XG5cbihmdW5jdGlvbiAoJCwgZmx1aWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGZsdWlkLnJlZ2lzdGVyTmFtZXNwYWNlKFwiZmx1aWQubW9kZWwudHJhbnNmb3JtXCIpO1xuICAgIGZsdWlkLnJlZ2lzdGVyTmFtZXNwYWNlKFwiZmx1aWQudHJhbnNmb3Jtc1wiKTtcblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICogU3RhbmRhcmQgdHJhbnNmb3JtZXIgZnVuY3Rpb25zICpcbiAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmx1aWQudHJhbnNmb3Jtcy52YWx1ZVwiLCB7XG4gICAgICAgIGdyYWRlTmFtZXM6IFwiZmx1aWQuc3RhbmRhcmRUcmFuc2Zvcm1GdW5jdGlvblwiLFxuICAgICAgICBpbnZlcnRDb25maWd1cmF0aW9uOiBcImZsdWlkLnRyYW5zZm9ybXMudmFsdWUuaW52ZXJ0XCJcbiAgICB9KTtcblxuICAgIGZsdWlkLnRyYW5zZm9ybXMudmFsdWUgPSBmbHVpZC5pZGVudGl0eTtcblxuICAgIGZsdWlkLnRyYW5zZm9ybXMudmFsdWUuaW52ZXJ0ID0gZnVuY3Rpb24gKHRyYW5zZm9ybVNwZWMsIHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHZhciB0b2dvID0gZmx1aWQuY29weSh0cmFuc2Zvcm1TcGVjKTtcbiAgICAgICAgLy8gVE9ETzogdGhpcyB3aWxsIG5vdCBiZWhhdmUgY29ycmVjdGx5IGluIHRoZSBmYWNlIG9mIGNvbXBvdW5kIFwidmFsdWVcIiB3aGljaCBjb250YWluc1xuICAgICAgICAvLyBmdXJ0aGVyIHRyYW5zZm9ybXNcbiAgICAgICAgdG9nby5pbnB1dFBhdGggPSBmbHVpZC5tb2RlbC5jb21wb3NlUGF0aHModHJhbnNmb3JtZXIub3V0cHV0UHJlZml4LCB0cmFuc2Zvcm1TcGVjLm91dHB1dFBhdGgpO1xuICAgICAgICB0b2dvLm91dHB1dFBhdGggPSBmbHVpZC5tb2RlbC5jb21wb3NlUGF0aHModHJhbnNmb3JtZXIuaW5wdXRQcmVmaXgsIHRyYW5zZm9ybVNwZWMuaW5wdXRQYXRoKTtcbiAgICAgICAgcmV0dXJuIHRvZ287XG4gICAgfTtcblxuICAgIC8vIEV4cG9ydCB0aGUgdXNlIG9mIHRoZSBcInZhbHVlXCIgdHJhbnNmb3JtIHVuZGVyIHRoZSBcImlkZW50aXR5XCIgbmFtZSBmb3IgRkxVSUQtNTI5M1xuICAgIGZsdWlkLnRyYW5zZm9ybXMuaWRlbnRpdHkgPSBmbHVpZC50cmFuc2Zvcm1zLnZhbHVlO1xuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmx1aWQudHJhbnNmb3Jtcy5pZGVudGl0eVwiLCB7XG4gICAgICAgIGdyYWRlTmFtZXM6IFwiZmx1aWQudHJhbnNmb3Jtcy52YWx1ZVwiXG4gICAgfSk7XG5cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsdWlkLnRyYW5zZm9ybXMubGl0ZXJhbFZhbHVlXCIsIHtcbiAgICAgICAgZ3JhZGVOYW1lczogXCJmbHVpZC5zdGFuZGFyZE91dHB1dFRyYW5zZm9ybUZ1bmN0aW9uXCJcbiAgICB9KTtcblxuICAgIGZsdWlkLnRyYW5zZm9ybXMubGl0ZXJhbFZhbHVlID0gZnVuY3Rpb24gKHRyYW5zZm9ybVNwZWMpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybVNwZWMudmFsdWU7XG4gICAgfTtcblxuXG4gICAgZmx1aWQuZGVmYXVsdHMoXCJmbHVpZC50cmFuc2Zvcm1zLmFycmF5VmFsdWVcIiwge1xuICAgICAgICBncmFkZU5hbWVzOiBcImZsdWlkLnN0YW5kYXJkVHJhbnNmb3JtRnVuY3Rpb25cIlxuICAgIH0pO1xuXG4gICAgZmx1aWQudHJhbnNmb3Jtcy5hcnJheVZhbHVlID0gZmx1aWQubWFrZUFycmF5O1xuXG5cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsdWlkLnRyYW5zZm9ybXMuY291bnRcIiwge1xuICAgICAgICBncmFkZU5hbWVzOiBcImZsdWlkLnN0YW5kYXJkVHJhbnNmb3JtRnVuY3Rpb25cIlxuICAgIH0pO1xuXG4gICAgZmx1aWQudHJhbnNmb3Jtcy5jb3VudCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZmx1aWQubWFrZUFycmF5KHZhbHVlKS5sZW5ndGg7XG4gICAgfTtcblxuXG4gICAgZmx1aWQuZGVmYXVsdHMoXCJmbHVpZC50cmFuc2Zvcm1zLnJvdW5kXCIsIHtcbiAgICAgICAgZ3JhZGVOYW1lczogXCJmbHVpZC5zdGFuZGFyZFRyYW5zZm9ybUZ1bmN0aW9uXCJcbiAgICB9KTtcblxuICAgIGZsdWlkLnRyYW5zZm9ybXMucm91bmQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUpO1xuICAgIH07XG5cblxuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmx1aWQudHJhbnNmb3Jtcy5kZWxldGVcIiwge1xuICAgICAgICBncmFkZU5hbWVzOiBcImZsdWlkLnRyYW5zZm9ybUZ1bmN0aW9uXCJcbiAgICB9KTtcblxuICAgIGZsdWlkLnRyYW5zZm9ybXNbXCJkZWxldGVcIl0gPSBmdW5jdGlvbiAodHJhbnNmb3JtU3BlYywgdHJhbnNmb3JtZXIpIHtcbiAgICAgICAgdmFyIG91dHB1dFBhdGggPSBmbHVpZC5tb2RlbC5jb21wb3NlUGF0aHModHJhbnNmb3JtZXIub3V0cHV0UHJlZml4LCB0cmFuc2Zvcm1TcGVjLm91dHB1dFBhdGgpO1xuICAgICAgICB0cmFuc2Zvcm1lci5hcHBsaWVyLnJlcXVlc3RDaGFuZ2Uob3V0cHV0UGF0aCwgbnVsbCwgXCJERUxFVEVcIik7XG4gICAgfTtcblxuXG4gICAgZmx1aWQuZGVmYXVsdHMoXCJmbHVpZC50cmFuc2Zvcm1zLmZpcnN0VmFsdWVcIiwge1xuICAgICAgICBncmFkZU5hbWVzOiBcImZsdWlkLnRyYW5zZm9ybUZ1bmN0aW9uXCJcbiAgICB9KTtcblxuICAgIGZsdWlkLnRyYW5zZm9ybXMuZmlyc3RWYWx1ZSA9IGZ1bmN0aW9uICh0cmFuc2Zvcm1TcGVjLCB0cmFuc2Zvcm1lcikge1xuICAgICAgICBpZiAoIXRyYW5zZm9ybVNwZWMudmFsdWVzIHx8ICF0cmFuc2Zvcm1TcGVjLnZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZsdWlkLmZhaWwoXCJmaXJzdFZhbHVlIHRyYW5zZm9ybWVyIHJlcXVpcmVzIGFuIGFycmF5IG9mIHZhbHVlcyBhdCBwYXRoIG5hbWVkIFxcXCJ2YWx1ZXNcXFwiLCBzdXBwbGllZFwiLCB0cmFuc2Zvcm1TcGVjKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybVNwZWMudmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0cmFuc2Zvcm1TcGVjLnZhbHVlc1tpXTtcbiAgICAgICAgICAgIC8vIFRPRE86IHByb2JsZW0gaGVyZSAtIGFsbCBvZiB0aGVzZSB0cmFuc2Zvcm1zIHdpbGwgaGF2ZSB0aGVpciBzaWRlLWVmZmVjdHMgKHNldFZhbHVlKSBldmVuIGlmIG9ubHkgb25lIGlzIGNob3NlblxuICAgICAgICAgICAgdmFyIGV4cGFuZGVkID0gdHJhbnNmb3JtZXIuZXhwYW5kKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChleHBhbmRlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cGFuZGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmx1aWQudHJhbnNmb3Jtcy5saW5lYXJTY2FsZVwiLCB7XG4gICAgICAgIGdyYWRlTmFtZXM6IFsgXCJmbHVpZC5tdWx0aUlucHV0VHJhbnNmb3JtRnVuY3Rpb25cIiwgXCJmbHVpZC5zdGFuZGFyZE91dHB1dFRyYW5zZm9ybUZ1bmN0aW9uXCIsIFwiZmx1aWQubGVuc1wiIF0sXG4gICAgICAgIGludmVydENvbmZpZ3VyYXRpb246IFwiZmx1aWQudHJhbnNmb3Jtcy5saW5lYXJTY2FsZS5pbnZlcnRcIixcbiAgICAgICAgaW5wdXRWYXJpYWJsZXM6IHtcbiAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgZmFjdG9yOiAxLFxuICAgICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qIHNpbXBsZSBsaW5lYXIgdHJhbnNmb3JtYXRpb24gKi9cbiAgICBmbHVpZC50cmFuc2Zvcm1zLmxpbmVhclNjYWxlID0gZnVuY3Rpb24gKGlucHV0cykge1xuICAgICAgICB2YXIgdmFsdWUgPSBpbnB1dHMudmFsdWUoKTtcbiAgICAgICAgdmFyIGZhY3RvciA9IGlucHV0cy5mYWN0b3IoKTtcbiAgICAgICAgdmFyIG9mZnNldCA9IGlucHV0cy5vZmZzZXQoKTtcblxuICAgICAgICBpZiAodHlwZW9mKHZhbHVlKSAhPT0gXCJudW1iZXJcIiB8fCB0eXBlb2YoZmFjdG9yKSAhPT0gXCJudW1iZXJcIiB8fCB0eXBlb2Yob2Zmc2V0KSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWUgKiBmYWN0b3IgKyBvZmZzZXQ7XG4gICAgfTtcblxuICAgIC8qIFRPRE86IFRoaXMgaW52ZXJzaW9uIGRvZXNuJ3Qgd29yayBpZiB0aGUgdmFsdWUgYW5kIGZhY3RvcnMgYXJlIGdpdmVuIGFzIHBhdGhzIGluIHRoZSBzb3VyY2UgbW9kZWwgKi9cbiAgICBmbHVpZC50cmFuc2Zvcm1zLmxpbmVhclNjYWxlLmludmVydCA9IGZ1bmN0aW9uICAodHJhbnNmb3JtU3BlYywgdHJhbnNmb3JtZXIpIHtcbiAgICAgICAgdmFyIHRvZ28gPSBmbHVpZC5jb3B5KHRyYW5zZm9ybVNwZWMpO1xuXG4gICAgICAgIGlmICh0b2dvLmZhY3Rvcikge1xuICAgICAgICAgICAgdG9nby5mYWN0b3IgPSAodG9nby5mYWN0b3IgPT09IDApID8gMCA6IDEgLyB0b2dvLmZhY3RvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9nby5vZmZzZXQpIHtcbiAgICAgICAgICAgIHRvZ28ub2Zmc2V0ID0gLSB0b2dvLm9mZnNldCAqICh0b2dvLmZhY3RvciAhPT0gdW5kZWZpbmVkID8gdG9nby5mYWN0b3IgOiAxKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBUaGlzIHJ1YmJpc2ggc2hvdWxkIGJlIGRvbmUgYnkgdGhlIGludmVyc2lvbiBtYWNoaW5lcnkgYnkgaXRzZWxmLiBXZSBzaG91bGRuJ3QgaGF2ZSB0byByZXBlYXQgaXQgaW4gZXZlcnlcbiAgICAgICAgLy8gaW52ZXJzaW9uIHJ1bGVcbiAgICAgICAgdG9nby52YWx1ZVBhdGggPSBmbHVpZC5tb2RlbC5jb21wb3NlUGF0aHModHJhbnNmb3JtZXIub3V0cHV0UHJlZml4LCB0cmFuc2Zvcm1TcGVjLm91dHB1dFBhdGgpO1xuICAgICAgICB0b2dvLm91dHB1dFBhdGggPSBmbHVpZC5tb2RlbC5jb21wb3NlUGF0aHModHJhbnNmb3JtZXIuaW5wdXRQcmVmaXgsIHRyYW5zZm9ybVNwZWMudmFsdWVQYXRoKTtcbiAgICAgICAgcmV0dXJuIHRvZ287XG4gICAgfTtcblxuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmx1aWQudHJhbnNmb3Jtcy5iaW5hcnlPcFwiLCB7XG4gICAgICAgIGdyYWRlTmFtZXM6IFsgXCJmbHVpZC5tdWx0aUlucHV0VHJhbnNmb3JtRnVuY3Rpb25cIiwgXCJmbHVpZC5zdGFuZGFyZE91dHB1dFRyYW5zZm9ybUZ1bmN0aW9uXCIgXSxcbiAgICAgICAgaW5wdXRWYXJpYWJsZXM6IHtcbiAgICAgICAgICAgIGxlZnQ6IG51bGwsXG4gICAgICAgICAgICByaWdodDogbnVsbFxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBmbHVpZC50cmFuc2Zvcm1zLmJpbmFyeUxvb2t1cCA9IHtcbiAgICAgICAgXCI9PT1cIjogZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgPT09IGI7IH0sXG4gICAgICAgIFwiIT09XCI6IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhICE9PSBiOyB9LFxuICAgICAgICBcIjw9XCI6IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhIDw9IGI7IH0sXG4gICAgICAgIFwiPFwiOiBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSA8IGI7IH0sXG4gICAgICAgIFwiPj1cIjogZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgPj0gYjsgfSxcbiAgICAgICAgXCI+XCI6IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhID4gYjsgfSxcbiAgICAgICAgXCIrXCI6IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhICsgYjsgfSxcbiAgICAgICAgXCItXCI6IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhIC0gYjsgfSxcbiAgICAgICAgXCIqXCI6IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhICogYjsgfSxcbiAgICAgICAgXCIvXCI6IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhIC8gYjsgfSxcbiAgICAgICAgXCIlXCI6IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhICUgYjsgfSxcbiAgICAgICAgXCImJlwiOiBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSAmJiBiOyB9LFxuICAgICAgICBcInx8XCI6IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhIHx8IGI7IH1cbiAgICB9O1xuXG4gICAgZmx1aWQudHJhbnNmb3Jtcy5iaW5hcnlPcCA9IGZ1bmN0aW9uIChpbnB1dHMsIHRyYW5zZm9ybVNwZWMsIHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHZhciBsZWZ0ID0gaW5wdXRzLmxlZnQoKTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gaW5wdXRzLnJpZ2h0KCk7XG5cbiAgICAgICAgdmFyIG9wZXJhdG9yID0gZmx1aWQubW9kZWwudHJhbnNmb3JtLmdldFZhbHVlKHVuZGVmaW5lZCwgdHJhbnNmb3JtU3BlYy5vcGVyYXRvciwgdHJhbnNmb3JtZXIpO1xuXG4gICAgICAgIHZhciBmdW4gPSBmbHVpZC50cmFuc2Zvcm1zLmJpbmFyeUxvb2t1cFtvcGVyYXRvcl07XG4gICAgICAgIHJldHVybiAoZnVuID09PSB1bmRlZmluZWQgfHwgbGVmdCA9PT0gdW5kZWZpbmVkIHx8IHJpZ2h0ID09PSB1bmRlZmluZWQpID9cbiAgICAgICAgICAgIHVuZGVmaW5lZCA6IGZ1bihsZWZ0LCByaWdodCk7XG4gICAgfTtcblxuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmx1aWQudHJhbnNmb3Jtcy5jb25kaXRpb25cIiwge1xuICAgICAgICBncmFkZU5hbWVzOiBbIFwiZmx1aWQubXVsdGlJbnB1dFRyYW5zZm9ybUZ1bmN0aW9uXCIsIFwiZmx1aWQuc3RhbmRhcmRPdXRwdXRUcmFuc2Zvcm1GdW5jdGlvblwiIF0sXG4gICAgICAgIGlucHV0VmFyaWFibGVzOiB7XG4gICAgICAgICAgICBcInRydWVcIjogbnVsbCxcbiAgICAgICAgICAgIFwiZmFsc2VcIjogbnVsbCxcbiAgICAgICAgICAgIFwiY29uZGl0aW9uXCI6IG51bGxcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZmx1aWQudHJhbnNmb3Jtcy5jb25kaXRpb24gPSBmdW5jdGlvbiAoaW5wdXRzKSB7XG4gICAgICAgIHZhciBjb25kaXRpb24gPSBpbnB1dHMuY29uZGl0aW9uKCk7XG4gICAgICAgIGlmIChjb25kaXRpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5wdXRzW2NvbmRpdGlvbiA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiXSgpO1xuICAgIH07XG5cblxuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmx1aWQudHJhbnNmb3Jtcy52YWx1ZU1hcHBlclwiLCB7XG4gICAgICAgIGdyYWRlTmFtZXM6IFtcImZsdWlkLnRyYW5zZm9ybUZ1bmN0aW9uXCIsIFwiZmx1aWQubGVuc1wiXSxcbiAgICAgICAgaW52ZXJ0Q29uZmlndXJhdGlvbjogXCJmbHVpZC50cmFuc2Zvcm1zLnZhbHVlTWFwcGVyLmludmVydFwiLFxuICAgICAgICBjb2xsZWN0SW5wdXRQYXRoczogXCJmbHVpZC50cmFuc2Zvcm1zLnZhbHVlTWFwcGVyLmNvbGxlY3RcIlxuICAgIH0pO1xuICAgIFxuICAgIFxuICAgIC8vIHVuc3VwcG9ydGVkLCBOT04tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQubW9kZWwudHJhbnNmb3JtLmNvbXBhcmVNYXRjaGVzID0gZnVuY3Rpb24gKHNwZWNhLCBzcGVjYikge1xuICAgICAgICByZXR1cm4gc3BlY2IubWF0Y2hWYWx1ZSAtIHNwZWNhLm1hdGNoVmFsdWU7XG4gICAgfTtcblxuICAgIC8vIHVuc3VwcG9ydGVkLCBOT04tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQubW9kZWwudHJhbnNmb3JtLm1hdGNoVmFsdWVNYXBwZXJGdWxsID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIHRyYW5zZm9ybVNwZWMsIHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHZhciBvID0gdHJhbnNmb3JtU3BlYy5vcHRpb25zO1xuICAgICAgICBpZiAoby5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGZsdWlkLmZhaWwoXCJ2YWx1ZU1hcHBlciBzdXBwbGllZCBlbXB0eSBsaXN0IG9mIG9wdGlvbnM6IFwiLCB0cmFuc2Zvcm1TcGVjKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF0Y2hQb3dlciA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG8ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb24gPSBvW2ldO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZmx1aWQuZmlyc3REZWZpbmVkKGZsdWlkLm1vZGVsLnRyYW5zZm9ybS5nZXRWYWx1ZShvcHRpb24uaW5wdXRQYXRoLCB1bmRlZmluZWQsIHRyYW5zZm9ybWVyKSxcbiAgICAgICAgICAgICAgICBvdXRlclZhbHVlKTtcbiAgICAgICAgICAgIHZhciBtYXRjaFZhbHVlID0gZmx1aWQubW9kZWwudHJhbnNmb3JtLm1hdGNoVmFsdWUob3B0aW9uLnVuZGVmaW5lZElucHV0VmFsdWUgPyB1bmRlZmluZWQgOlxuICAgICAgICAgICAgICAgIChvcHRpb24uaW5wdXRWYWx1ZSA9PT0gdW5kZWZpbmVkID8gdHJhbnNmb3JtU3BlYy5kZWZhdWx0SW5wdXRWYWx1ZSA6IG9wdGlvbi5pbnB1dFZhbHVlKSwgdmFsdWUsIHRyYW5zZm9ybVNwZWMucGFydGlhbE1hdGNoZXMgfHwgb3B0aW9uLnBhcnRpYWxNYXRjaGVzKTtcbiAgICAgICAgICAgIG1hdGNoUG93ZXJbaV0gPSB7aW5kZXg6IGksIG1hdGNoVmFsdWU6IG1hdGNoVmFsdWV9O1xuICAgICAgICB9XG4gICAgICAgIG1hdGNoUG93ZXIuc29ydChmbHVpZC5tb2RlbC50cmFuc2Zvcm0uY29tcGFyZU1hdGNoZXMpO1xuICAgICAgICByZXR1cm4gKG1hdGNoUG93ZXJbMF0ubWF0Y2hWYWx1ZSA8PSAwIHx8IG8ubGVuZ3RoID4gMSAmJiBtYXRjaFBvd2VyWzBdLm1hdGNoVmFsdWUgPT09IG1hdGNoUG93ZXJbMV0ubWF0Y2hWYWx1ZSkgPyAtMSA6IG1hdGNoUG93ZXJbMF0uaW5kZXg7XG4gICAgfTtcblxuICAgIGZsdWlkLnRyYW5zZm9ybXMudmFsdWVNYXBwZXIgPSBmdW5jdGlvbiAodHJhbnNmb3JtU3BlYywgdHJhbnNmb3JtZXIpIHtcbiAgICAgICAgaWYgKCF0cmFuc2Zvcm1TcGVjLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIGZsdWlkLmZhaWwoXCJ2YWx1ZU1hcHBlciByZXF1aXJlcyBhIGxpc3Qgb3IgaGFzaCBvZiBvcHRpb25zIGF0IHBhdGggbmFtZWQgXFxcIm9wdGlvbnNcXFwiLCBzdXBwbGllZCBcIiwgdHJhbnNmb3JtU3BlYyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlID0gZmx1aWQubW9kZWwudHJhbnNmb3JtLmdldFZhbHVlKHRyYW5zZm9ybVNwZWMuaW5wdXRQYXRoLCB1bmRlZmluZWQsIHRyYW5zZm9ybWVyKTtcbiAgICAgICAgdmFyIGRlcmVmID0gZmx1aWQuaXNBcnJheWFibGUodHJhbnNmb3JtU3BlYy5vcHRpb25zKSA/IC8vIGxvbmcgZm9ybSB3aXRoIGxpc3Qgb2YgcmVjb3Jkc1xuICAgICAgICAgICAgZnVuY3Rpb24gKHRlc3RWYWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBmbHVpZC5tb2RlbC50cmFuc2Zvcm0ubWF0Y2hWYWx1ZU1hcHBlckZ1bGwodGVzdFZhbCwgdHJhbnNmb3JtU3BlYywgdHJhbnNmb3JtZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleCA9PT0gLTEgPyBudWxsIDogdHJhbnNmb3JtU3BlYy5vcHRpb25zW2luZGV4XTtcbiAgICAgICAgICAgIH0gOlxuICAgICAgICAgICAgZnVuY3Rpb24gKHRlc3RWYWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtU3BlYy5vcHRpb25zW3Rlc3RWYWxdO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICB2YXIgaW5kZXhlZCA9IGRlcmVmKHZhbHVlKTtcbiAgICAgICAgaWYgKCFpbmRleGVkKSB7XG4gICAgICAgICAgICAvLyBpZiBubyBicmFuY2ggbWF0Y2hlcywgdHJ5IGFnYWluIHVzaW5nIHRoaXMgdmFsdWUgLSBXQVJOSU5HLCB0aGlzIHNlcmlvdXNseVxuICAgICAgICAgICAgLy8gdGhyZWF0ZW5zIGludmVydGliaWxpdHlcbiAgICAgICAgICAgIGluZGV4ZWQgPSBkZXJlZih0cmFuc2Zvcm1TcGVjLmRlZmF1bHRJbnB1dFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWluZGV4ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvdXRwdXRQYXRoID0gaW5kZXhlZC5vdXRwdXRQYXRoID09PSB1bmRlZmluZWQgPyB0cmFuc2Zvcm1TcGVjLmRlZmF1bHRPdXRwdXRQYXRoIDogaW5kZXhlZC5vdXRwdXRQYXRoO1xuICAgICAgICB0cmFuc2Zvcm1lci5vdXRwdXRQcmVmaXhPcC5wdXNoKG91dHB1dFBhdGgpO1xuICAgICAgICB2YXIgb3V0cHV0VmFsdWU7XG4gICAgICAgIGlmIChmbHVpZC5pc1ByaW1pdGl2ZShpbmRleGVkKSkge1xuICAgICAgICAgICAgb3V0cHV0VmFsdWUgPSBpbmRleGVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgdW5kZWZpbmVkT3V0cHV0VmFsdWUgaXMgc2V0LCBvdXRwdXRWYWx1ZSBzaG91bGQgYmUgdW5kZWZpbmVkXG4gICAgICAgICAgICBpZiAoaW5kZXhlZC51bmRlZmluZWRPdXRwdXRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIG91dHB1dFZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBnZXQgdmFsdWUgZnJvbSBvdXRwdXRWYWx1ZSBvciBvdXRwdXRWYWx1ZVBhdGguIElmIG5vbmUgaXMgZm91bmQgc2V0IHRoZSBvdXRwdXRWYWx1ZSB0byBiZSB0aGF0IG9mIGRlZmF1bHRPdXRwdXRWYWx1ZSAob3IgdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIG91dHB1dFZhbHVlID0gZmx1aWQubW9kZWwudHJhbnNmb3JtLnJlc29sdmVQYXJhbShpbmRleGVkLCB0cmFuc2Zvcm1lciwgXCJvdXRwdXRWYWx1ZVwiLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIG91dHB1dFZhbHVlID0gKG91dHB1dFZhbHVlID09PSB1bmRlZmluZWQpID8gdHJhbnNmb3JtU3BlYy5kZWZhdWx0T3V0cHV0VmFsdWUgOiBvdXRwdXRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBvdXRwdXQgaWYgb3V0cHV0UGF0aCBvciBkZWZhdWx0T3V0cHV0UGF0aCBoYXZlIGJlZW4gc3BlY2lmaWVkIGFuZCB0aGUgcmVsZXZhbnQgY2hpbGQgaGFzbid0IGRvbmUgdGhlIG91dHB1dHRpbmdcbiAgICAgICAgaWYgKHR5cGVvZihvdXRwdXRQYXRoKSA9PT0gXCJzdHJpbmdcIiAmJiBvdXRwdXRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmbHVpZC5tb2RlbC50cmFuc2Zvcm0uc2V0VmFsdWUodW5kZWZpbmVkLCBvdXRwdXRWYWx1ZSwgdHJhbnNmb3JtZXIsIHRyYW5zZm9ybVNwZWMubWVyZ2UpO1xuICAgICAgICAgICAgb3V0cHV0VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNmb3JtZXIub3V0cHV0UHJlZml4T3AucG9wKCk7XG4gICAgICAgIHJldHVybiBvdXRwdXRWYWx1ZTtcbiAgICB9O1xuXG4gICAgZmx1aWQudHJhbnNmb3Jtcy52YWx1ZU1hcHBlci5pbnZlcnQgPSBmdW5jdGlvbiAodHJhbnNmb3JtU3BlYywgdHJhbnNmb3JtZXIpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBbXTtcbiAgICAgICAgdmFyIHRvZ28gPSB7XG4gICAgICAgICAgICB0eXBlOiBcImZsdWlkLnRyYW5zZm9ybXMudmFsdWVNYXBwZXJcIixcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGlzQXJyYXkgPSBmbHVpZC5pc0FycmF5YWJsZSh0cmFuc2Zvcm1TcGVjLm9wdGlvbnMpO1xuICAgICAgICB2YXIgZmluZEN1c3RvbSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gZmx1aWQuZmluZCh0cmFuc2Zvcm1TcGVjLm9wdGlvbnMsIGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgYW55Q3VzdG9tT3V0cHV0ID0gZmluZEN1c3RvbShcIm91dHB1dFBhdGhcIik7XG4gICAgICAgIHZhciBhbnlDdXN0b21JbnB1dCA9IGZpbmRDdXN0b20oXCJpbnB1dFBhdGhcIik7XG4gICAgICAgIGlmICghYW55Q3VzdG9tT3V0cHV0KSB7XG4gICAgICAgICAgICB0b2dvLmlucHV0UGF0aCA9IGZsdWlkLm1vZGVsLmNvbXBvc2VQYXRocyh0cmFuc2Zvcm1lci5vdXRwdXRQcmVmaXgsIHRyYW5zZm9ybVNwZWMuZGVmYXVsdE91dHB1dFBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYW55Q3VzdG9tSW5wdXQpIHtcbiAgICAgICAgICAgIHRvZ28uZGVmYXVsdE91dHB1dFBhdGggPSBmbHVpZC5tb2RlbC5jb21wb3NlUGF0aHModHJhbnNmb3JtZXIuaW5wdXRQcmVmaXgsIHRyYW5zZm9ybVNwZWMuaW5wdXRQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVmID0gZmx1aWQuZmlyc3REZWZpbmVkO1xuICAgICAgICBmbHVpZC5lYWNoKHRyYW5zZm9ybVNwZWMub3B0aW9ucywgZnVuY3Rpb24gKG9wdGlvbiwga2V5KSB7XG4gICAgICAgICAgICB2YXIgb3V0T3B0aW9uID0ge307XG4gICAgICAgICAgICB2YXIgb3JpZ0lucHV0VmFsdWUgPSBkZWYoaXNBcnJheSA/IG9wdGlvbi5pbnB1dFZhbHVlIDoga2V5LCB0cmFuc2Zvcm1TcGVjLmRlZmF1bHRJbnB1dFZhbHVlKTtcbiAgICAgICAgICAgIGlmIChvcmlnSW5wdXRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZmx1aWQuZmFpbChcIkZhaWx1cmUgaW52ZXJ0aW5nIGNvbmZpZ3VyYXRpb24gZm9yIHZhbHVlTWFwcGVyIC0gaW5wdXRWYWx1ZSBjb3VsZCBub3QgYmUgcmVzb2x2ZWQgZm9yIHJlY29yZCBcIiArIGtleSArIFwiOiBcIiwgdHJhbnNmb3JtU3BlYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRPcHRpb24ub3V0cHV0VmFsdWUgPSBmbHVpZC5tb2RlbC50cmFuc2Zvcm0ubGl0ZXJhbGlzZVZhbHVlKG9yaWdJbnB1dFZhbHVlKTtcbiAgICAgICAgICAgIHZhciBvcmlnT3V0cHV0VmFsdWUgPSBkZWYob3B0aW9uLm91dHB1dFZhbHVlLCB0cmFuc2Zvcm1TcGVjLmRlZmF1bHRPdXRwdXRWYWx1ZSk7XG4gICAgICAgICAgICBvdXRPcHRpb24uaW5wdXRWYWx1ZSA9IGZsdWlkLm1vZGVsLnRyYW5zZm9ybS5nZXRWYWx1ZShvcHRpb24ub3V0cHV0VmFsdWVQYXRoLCBvcmlnT3V0cHV0VmFsdWUsIHRyYW5zZm9ybWVyKTtcbiAgICAgICAgICAgIGlmIChhbnlDdXN0b21PdXRwdXQpIHtcbiAgICAgICAgICAgICAgICBvdXRPcHRpb24uaW5wdXRQYXRoID0gZmx1aWQubW9kZWwuY29tcG9zZVBhdGhzKHRyYW5zZm9ybWVyLm91dHB1dFByZWZpeCwgZGVmKG9wdGlvbi5vdXRwdXRQYXRoLCB0cmFuc2Zvcm1TcGVjLm91dHB1dFBhdGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbnlDdXN0b21JbnB1dCkge1xuICAgICAgICAgICAgICAgIG91dE9wdGlvbi5vdXRwdXRQYXRoID0gZmx1aWQubW9kZWwuY29tcG9zZVBhdGhzKHRyYW5zZm9ybWVyLmlucHV0UHJlZml4LCBkZWYob3B0aW9uLmlucHV0UGF0aCwgdHJhbnNmb3JtU3BlYy5pbnB1dFBhdGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb24ub3V0cHV0VmFsdWVQYXRoKSB7XG4gICAgICAgICAgICAgICAgb3V0T3B0aW9uLmlucHV0VmFsdWVQYXRoID0gb3B0aW9uLm91dHB1dFZhbHVlUGF0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnMucHVzaChvdXRPcHRpb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRvZ287XG4gICAgfTtcblxuICAgIGZsdWlkLnRyYW5zZm9ybXMudmFsdWVNYXBwZXIuY29sbGVjdCA9IGZ1bmN0aW9uICh0cmFuc2Zvcm1TcGVjLCB0cmFuc2Zvcm1lcikge1xuICAgICAgICB2YXIgdG9nbyA9IFtdO1xuICAgICAgICBmbHVpZC5tb2RlbC50cmFuc2Zvcm0uYWNjdW11bGF0ZUlucHV0UGF0aCh0cmFuc2Zvcm1TcGVjLmlucHV0UGF0aCwgdHJhbnNmb3JtZXIsIHRvZ28pO1xuICAgICAgICBmbHVpZC5lYWNoKHRyYW5zZm9ybVNwZWMub3B0aW9ucywgZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICAgICAgZmx1aWQubW9kZWwudHJhbnNmb3JtLmFjY3VtdWxhdGVJbnB1dFBhdGgob3B0aW9uLmlucHV0UGF0aCwgdHJhbnNmb3JtZXIsIHRvZ28pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRvZ287XG4gICAgfTtcblxuICAgIC8qIC0tLS0tLS0tIGFycmF5VG9TZXRNZW1iZXJzaGlwIGFuZCBzZXRNZW1iZXJzaGlwVG9BcnJheSAtLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsdWlkLnRyYW5zZm9ybXMuYXJyYXlUb1NldE1lbWJlcnNoaXBcIiwge1xuICAgICAgICBncmFkZU5hbWVzOiBbXCJmbHVpZC5zdGFuZGFyZElucHV0VHJhbnNmb3JtRnVuY3Rpb25cIiwgXCJmbHVpZC5sZW5zXCJdLFxuICAgICAgICBpbnZlcnRDb25maWd1cmF0aW9uOiBcImZsdWlkLnRyYW5zZm9ybXMuYXJyYXlUb1NldE1lbWJlcnNoaXAuaW52ZXJ0XCJcbiAgICB9KTtcblxuXG4gICAgZmx1aWQudHJhbnNmb3Jtcy5hcnJheVRvU2V0TWVtYmVyc2hpcCA9IGZ1bmN0aW9uICh2YWx1ZSwgdHJhbnNmb3JtU3BlYywgdHJhbnNmb3JtZXIpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0cmFuc2Zvcm1TcGVjLm9wdGlvbnM7XG5cbiAgICAgICAgaWYgKCF2YWx1ZSB8fCAhZmx1aWQuaXNBcnJheWFibGUodmFsdWUpKSB7XG4gICAgICAgICAgICBmbHVpZC5mYWlsKFwiYXJyYXlUb1NldE1lbWJlcnNoaXAgZGlkbid0IGZpbmQgYXJyYXkgYXQgaW5wdXRQYXRoIG5vciBwYXNzZWQgYXMgdmFsdWUuXCIsIHRyYW5zZm9ybVNwZWMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICAgICAgZmx1aWQuZmFpbChcImFycmF5VG9TZXRNZW1iZXJzaGlwIHJlcXVpcmVzIGFuIG9wdGlvbnMgYmxvY2sgc2V0XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRyYW5zZm9ybVNwZWMucHJlc2VudFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybVNwZWMucHJlc2VudFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmFuc2Zvcm1TcGVjLm1pc3NpbmdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1TcGVjLm1pc3NpbmdWYWx1ZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZmx1aWQuZWFjaChvcHRpb25zLCBmdW5jdGlvbiAob3V0UGF0aCwga2V5KSB7XG4gICAgICAgICAgICAvLyB3cml0ZSB0byBvdXRwdXQgcGF0aCBnaXZlbiBpbiBvcHRpb25zIHRoZSB2YWx1ZSA8cHJlc2VudFZhbHVlPiBvciA8bWlzc2luZ1ZhbHVlPiBkZXBlbmRpbmcgb24gd2hldGhlciBrZXkgaXMgZm91bmQgaW4gdXNlciBpbnB1dFxuICAgICAgICAgICAgdmFyIG91dFZhbCA9ICgkLmluQXJyYXkoa2V5LCB2YWx1ZSkgIT09IC0xKSA/IHRyYW5zZm9ybVNwZWMucHJlc2VudFZhbHVlIDogdHJhbnNmb3JtU3BlYy5taXNzaW5nVmFsdWU7XG4gICAgICAgICAgICBmbHVpZC5tb2RlbC50cmFuc2Zvcm0uc2V0VmFsdWUob3V0UGF0aCwgb3V0VmFsLCB0cmFuc2Zvcm1lcik7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUT0RPOiBXaHkgZG9lcyB0aGlzIHRyYW5zZm9ybSBtYWtlIG5vIHJldHVybj9cbiAgICB9O1xuXG4gICAgZmx1aWQudHJhbnNmb3Jtcy5hcnJheVRvU2V0TWVtYmVyc2hpcC5pbnZlcnQgPSBmdW5jdGlvbiAodHJhbnNmb3JtU3BlYywgdHJhbnNmb3JtZXIpIHtcbiAgICAgICAgdmFyIHRvZ28gPSBmbHVpZC5jb3B5KHRyYW5zZm9ybVNwZWMpO1xuICAgICAgICBkZWxldGUgdG9nby5pbnB1dFBhdGg7XG4gICAgICAgIHRvZ28udHlwZSA9IFwiZmx1aWQudHJhbnNmb3Jtcy5zZXRNZW1iZXJzaGlwVG9BcnJheVwiO1xuICAgICAgICB0b2dvLm91dHB1dFBhdGggPSBmbHVpZC5tb2RlbC5jb21wb3NlUGF0aHModHJhbnNmb3JtZXIuaW5wdXRQcmVmaXgsIHRyYW5zZm9ybVNwZWMuaW5wdXRQYXRoKTtcbiAgICAgICAgdmFyIG5ld09wdGlvbnMgPSB7fTtcbiAgICAgICAgZmx1aWQuZWFjaCh0cmFuc2Zvcm1TcGVjLm9wdGlvbnMsIGZ1bmN0aW9uIChwYXRoLCBvbGRLZXkpIHtcbiAgICAgICAgICAgIHZhciBuZXdLZXkgPSBmbHVpZC5tb2RlbC5jb21wb3NlUGF0aHModHJhbnNmb3JtZXIub3V0cHV0UHJlZml4LCBwYXRoKTtcbiAgICAgICAgICAgIG5ld09wdGlvbnNbbmV3S2V5XSA9IG9sZEtleTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRvZ28ub3B0aW9ucyA9IG5ld09wdGlvbnM7XG4gICAgICAgIHJldHVybiB0b2dvO1xuICAgIH07XG5cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsdWlkLnRyYW5zZm9ybXMuc2V0TWVtYmVyc2hpcFRvQXJyYXlcIiwge1xuICAgICAgICBncmFkZU5hbWVzOiBbXCJmbHVpZC5zdGFuZGFyZE91dHB1dFRyYW5zZm9ybUZ1bmN0aW9uXCJdXG4gICAgfSk7XG5cbiAgICBmbHVpZC50cmFuc2Zvcm1zLnNldE1lbWJlcnNoaXBUb0FycmF5ID0gZnVuY3Rpb24gKHRyYW5zZm9ybVNwZWMsIHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdHJhbnNmb3JtU3BlYy5vcHRpb25zO1xuXG4gICAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICAgICAgZmx1aWQuZmFpbChcInNldE1lbWJlcnNoaXBUb0FycmF5IHJlcXVpcmVzIGFuIG9wdGlvbnMgYmxvY2sgc3BlY2lmaWVkXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRyYW5zZm9ybVNwZWMucHJlc2VudFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybVNwZWMucHJlc2VudFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmFuc2Zvcm1TcGVjLm1pc3NpbmdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1TcGVjLm1pc3NpbmdWYWx1ZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG91dHB1dEFyciA9IFtdO1xuICAgICAgICBmbHVpZC5lYWNoKG9wdGlvbnMsIGZ1bmN0aW9uIChhcnJWYWwsIGluUGF0aCkge1xuICAgICAgICAgICAgdmFyIHZhbCA9IGZsdWlkLm1vZGVsLnRyYW5zZm9ybS5nZXRWYWx1ZShpblBhdGgsIHVuZGVmaW5lZCwgdHJhbnNmb3JtZXIpO1xuICAgICAgICAgICAgaWYgKHZhbCA9PT0gdHJhbnNmb3JtU3BlYy5wcmVzZW50VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRBcnIucHVzaChhcnJWYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG91dHB1dEFycjtcbiAgICB9O1xuXG4gICAgLyogLS0tLS0tLS0gb2JqZWN0VG9BcnJheSBhbmQgYXJyYXlUb09iamVjdCAtLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyB0aGUgZ2l2ZW4gYXJyYXkgdG8gYW4gb2JqZWN0LlxuICAgICAqIFVzZXMgdGhlIHRyYW5zZm9ybVNwZWMub3B0aW9ucy5rZXkgdmFsdWVzIGZyb20gZWFjaCBvYmplY3Qgd2l0aGluIHRoZSBhcnJheSBhcyBuZXcga2V5cy5cbiAgICAgKlxuICAgICAqIEZvciBleGFtcGxlLCB3aXRoIHRyYW5zZm9ybVNwZWMua2V5ID0gXCJuYW1lXCIgYW5kIGFuIGlucHV0IG9iamVjdCBsaWtlIHRoaXM6XG4gICAgICpcbiAgICAgKiB7XG4gICAgICogICBiOiBbXG4gICAgICogICAgIHsgbmFtZTogYjEsIHY6IHYxIH0sXG4gICAgICogICAgIHsgbmFtZTogYjIsIHY6IHYyIH1cbiAgICAgKiAgIF1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBUaGUgb3V0cHV0IHdpbGwgYmU6XG4gICAgICoge1xuICAgICAqICAgYjoge1xuICAgICAqICAgICBiMToge1xuICAgICAqICAgICAgIHY6IHYxXG4gICAgICogICAgIH1cbiAgICAgKiAgIH0sXG4gICAgICogICB7XG4gICAgICogICAgIGIyOiB7XG4gICAgICogICAgICAgdjogdjJcbiAgICAgKiAgICAgfVxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBmbHVpZC5tb2RlbC50cmFuc2Zvcm0uYXBwbHlQYXRocyA9IGZ1bmN0aW9uIChvcGVyYXRpb24sIHBhdGhPcCwgcGF0aHMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRocy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gXCJwdXNoXCIpIHtcbiAgICAgICAgICAgICAgICBwYXRoT3AucHVzaChwYXRoc1tpXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhdGhPcC5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmbHVpZC5tb2RlbC50cmFuc2Zvcm0uZXhwYW5kSW5uZXJWYWx1ZXMgPSBmdW5jdGlvbiAoaW5wdXRQYXRoLCBvdXRwdXRQYXRoLCB0cmFuc2Zvcm1lciwgaW5uZXJWYWx1ZXMpIHtcbiAgICAgICAgdmFyIGlucHV0UHJlZml4T3AgPSB0cmFuc2Zvcm1lci5pbnB1dFByZWZpeE9wO1xuICAgICAgICB2YXIgb3V0cHV0UHJlZml4T3AgPSB0cmFuc2Zvcm1lci5vdXRwdXRQcmVmaXhPcDtcbiAgICAgICAgdmFyIGFwcGx5ID0gZmx1aWQubW9kZWwudHJhbnNmb3JtLmFwcGx5UGF0aHM7XG5cbiAgICAgICAgYXBwbHkoXCJwdXNoXCIsIGlucHV0UHJlZml4T3AsIGlucHV0UGF0aCk7XG4gICAgICAgIGFwcGx5KFwicHVzaFwiLCBvdXRwdXRQcmVmaXhPcCwgb3V0cHV0UGF0aCk7XG4gICAgICAgIHZhciBleHBhbmRlZCA9IHt9O1xuICAgICAgICBmbHVpZC5lYWNoKGlubmVyVmFsdWVzLCBmdW5jdGlvbiAoaW5uZXJWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIGV4cGFuZGVkSW5uZXIgPSB0cmFuc2Zvcm1lci5leHBhbmQoaW5uZXJWYWx1ZSk7XG4gICAgICAgICAgICBpZiAoIWZsdWlkLmlzUHJpbWl0aXZlKGV4cGFuZGVkSW5uZXIpKSB7XG4gICAgICAgICAgICAgICAgJC5leHRlbmQodHJ1ZSwgZXhwYW5kZWQsIGV4cGFuZGVkSW5uZXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBleHBhbmRlZCA9IGV4cGFuZGVkSW5uZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBhcHBseShcInBvcFwiLCBvdXRwdXRQcmVmaXhPcCwgb3V0cHV0UGF0aCk7XG4gICAgICAgIGFwcGx5KFwicG9wXCIsIGlucHV0UHJlZml4T3AsIGlucHV0UGF0aCk7XG5cbiAgICAgICAgcmV0dXJuIGV4cGFuZGVkO1xuICAgIH07XG5cblxuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmx1aWQudHJhbnNmb3Jtcy5hcnJheVRvT2JqZWN0XCIsIHtcbiAgICAgICAgZ3JhZGVOYW1lczogW1wiZmx1aWQuc3RhbmRhcmRUcmFuc2Zvcm1GdW5jdGlvblwiLCBcImZsdWlkLmxlbnNcIiBdLFxuICAgICAgICBpbnZlcnRDb25maWd1cmF0aW9uOiBcImZsdWlkLnRyYW5zZm9ybXMuYXJyYXlUb09iamVjdC5pbnZlcnRcIlxuICAgIH0pO1xuXG4gICAgZmx1aWQudHJhbnNmb3Jtcy5hcnJheVRvT2JqZWN0ID0gZnVuY3Rpb24gKGFyciwgdHJhbnNmb3JtU3BlYywgdHJhbnNmb3JtZXIpIHtcbiAgICAgICAgaWYgKHRyYW5zZm9ybVNwZWMua2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZsdWlkLmZhaWwoXCJhcnJheVRvT2JqZWN0IHJlcXVpcmVzIGEgJ2tleScgb3B0aW9uLlwiLCB0cmFuc2Zvcm1TcGVjKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZsdWlkLmlzQXJyYXlhYmxlKGFycikpIHtcbiAgICAgICAgICAgIGZsdWlkLmZhaWwoXCJhcnJheVRvT2JqZWN0IGRpZG4ndCBmaW5kIGFycmF5IGF0IGlucHV0UGF0aC5cIiwgdHJhbnNmb3JtU3BlYyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld0hhc2ggPSB7fTtcbiAgICAgICAgdmFyIHBpdm90ID0gdHJhbnNmb3JtU3BlYy5rZXk7XG5cbiAgICAgICAgZmx1aWQuZWFjaChhcnIsIGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAgICAgICAvLyBjaGVjayB0aGF0IHdlIGhhdmUgYSBwaXZvdCBlbnRyeSBpbiB0aGUgb2JqZWN0IGFuZCBpdCdzIGEgdmFsaWQgdHlwZTpcbiAgICAgICAgICAgIHZhciBuZXdLZXkgPSB2W3Bpdm90XTtcbiAgICAgICAgICAgIHZhciBrZXlUeXBlID0gdHlwZW9mKG5ld0tleSk7XG4gICAgICAgICAgICBpZiAoa2V5VHlwZSAhPT0gXCJzdHJpbmdcIiAmJiBrZXlUeXBlICE9PSBcImJvb2xlYW5cIiAmJiBrZXlUeXBlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgZmx1aWQuZmFpbChcImFycmF5VG9PYmplY3QgZW5jb3VudGVyZWQgdW50cmFuc2Zvcm1hYmxlIGFycmF5IGR1ZSB0byBtaXNzaW5nIG9yIGludmFsaWQga2V5XCIsIHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdXNlIHRoZSB2YWx1ZSBvZiB0aGUga2V5IGVsZW1lbnQgYXMga2V5IGFuZCB1c2UgdGhlIHJlbWFpbmluZyBjb250ZW50IGFzIHZhbHVlXG4gICAgICAgICAgICB2YXIgY29udGVudCA9IGZsdWlkLmNvcHkodik7XG4gICAgICAgICAgICBkZWxldGUgY29udGVudFtwaXZvdF07XG4gICAgICAgICAgICAvLyBmaXggc3ViIEFycmF5cyBpZiBuZWVkZWQ6XG4gICAgICAgICAgICBpZiAodHJhbnNmb3JtU3BlYy5pbm5lclZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IGZsdWlkLm1vZGVsLnRyYW5zZm9ybS5leHBhbmRJbm5lclZhbHVlcyhbdHJhbnNmb3JtZXIuaW5wdXRQcmVmaXgsIHRyYW5zZm9ybVNwZWMuaW5wdXRQYXRoLCBrLnRvU3RyaW5nKCldLFxuICAgICAgICAgICAgICAgICAgICBbbmV3S2V5XSwgdHJhbnNmb3JtZXIsIHRyYW5zZm9ybVNwZWMuaW5uZXJWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdIYXNoW25ld0tleV0gPSBjb250ZW50O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ld0hhc2g7XG4gICAgfTtcblxuICAgIGZsdWlkLnRyYW5zZm9ybXMuYXJyYXlUb09iamVjdC5pbnZlcnQgPSBmdW5jdGlvbiAodHJhbnNmb3JtU3BlYywgdHJhbnNmb3JtZXIpIHtcbiAgICAgICAgdmFyIHRvZ28gPSBmbHVpZC5jb3B5KHRyYW5zZm9ybVNwZWMpO1xuICAgICAgICB0b2dvLnR5cGUgPSBcImZsdWlkLnRyYW5zZm9ybXMub2JqZWN0VG9BcnJheVwiO1xuICAgICAgICB0b2dvLmlucHV0UGF0aCA9IGZsdWlkLm1vZGVsLmNvbXBvc2VQYXRocyh0cmFuc2Zvcm1lci5vdXRwdXRQcmVmaXgsIHRyYW5zZm9ybVNwZWMub3V0cHV0UGF0aCk7XG4gICAgICAgIHRvZ28ub3V0cHV0UGF0aCA9IGZsdWlkLm1vZGVsLmNvbXBvc2VQYXRocyh0cmFuc2Zvcm1lci5pbnB1dFByZWZpeCwgdHJhbnNmb3JtU3BlYy5pbnB1dFBhdGgpO1xuICAgICAgICAvLyBpbnZlcnQgdHJhbnNmb3JtcyBmcm9tIGlubmVyVmFsdWUgYXMgd2VsbDpcbiAgICAgICAgLy8gVE9ETzogVGhlIE1vZGVsIFRyYW5zZm9ybWF0aW9ucyBmcmFtZXdvcmsgc2hvdWxkIGJlIGNhcGFibGUgb2YgdGhpcywgYnV0IHJpZ2h0IG5vdyB0aGVcbiAgICAgICAgLy8gaXNzdWUgaXMgdGhhdCB3ZSB1c2UgYSBcInByaXZhdGUgY29udHJhY3RcIiB0byBvcGVyYXRlIHRoZSBcImlubmVyVmFsdWVcIiBzbG90LiBXZSBuZWVkIHRvXG4gICAgICAgIC8vIHNwZW5kIHRpbWUgdGhpbmtpbmcgb2YgaG93IHRoaXMgc2hvdWxkIGJlIGZvcm1hbGlzZWRcbiAgICAgICAgaWYgKHRvZ28uaW5uZXJWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIGlubmVyVmFsdWUgPSB0b2dvLmlubmVyVmFsdWU7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlubmVyVmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpbm5lclZhbHVlW2ldID0gZmx1aWQubW9kZWwudHJhbnNmb3JtLmludmVydENvbmZpZ3VyYXRpb24oaW5uZXJWYWx1ZVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvZ287XG4gICAgfTtcblxuXG4gICAgZmx1aWQuZGVmYXVsdHMoXCJmbHVpZC50cmFuc2Zvcm1zLm9iamVjdFRvQXJyYXlcIiwge1xuICAgICAgICBncmFkZU5hbWVzOiBcImZsdWlkLnN0YW5kYXJkVHJhbnNmb3JtRnVuY3Rpb25cIlxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBhbiBvYmplY3QgaW50byBhcnJheSBvZiBvYmplY3RzLlxuICAgICAqIFRoaXMgcGVyZm9ybXMgdGhlIGludmVyc2UgdHJhbnNmb3JtIG9mIGZsdWlkLnRyYW5zZm9ybXMuYXJyYXlUb09iamVjdC5cbiAgICAgKi9cbiAgICBmbHVpZC50cmFuc2Zvcm1zLm9iamVjdFRvQXJyYXkgPSBmdW5jdGlvbiAoaGFzaCwgdHJhbnNmb3JtU3BlYywgdHJhbnNmb3JtZXIpIHtcbiAgICAgICAgaWYgKHRyYW5zZm9ybVNwZWMua2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZsdWlkLmZhaWwoXCJvYmplY3RUb0FycmF5IHJlcXVpcmVzIGEgJ2tleScgb3B0aW9uLlwiLCB0cmFuc2Zvcm1TcGVjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXdBcnJheSA9IFtdO1xuICAgICAgICB2YXIgcGl2b3QgPSB0cmFuc2Zvcm1TcGVjLmtleTtcblxuICAgICAgICBmbHVpZC5lYWNoKGhhc2gsIGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHt9O1xuICAgICAgICAgICAgY29udGVudFtwaXZvdF0gPSBrO1xuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybVNwZWMuaW5uZXJWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHYgPSBmbHVpZC5tb2RlbC50cmFuc2Zvcm0uZXhwYW5kSW5uZXJWYWx1ZXMoW3RyYW5zZm9ybVNwZWMuaW5wdXRQYXRoLCBrXSwgW3RyYW5zZm9ybVNwZWMub3V0cHV0UGF0aCwgbmV3QXJyYXkubGVuZ3RoLnRvU3RyaW5nKCldLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lciwgdHJhbnNmb3JtU3BlYy5pbm5lclZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICQuZXh0ZW5kKHRydWUsIGNvbnRlbnQsIHYpO1xuICAgICAgICAgICAgbmV3QXJyYXkucHVzaChjb250ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXdBcnJheTtcbiAgICB9O1xuXG4gICAgZmx1aWQuZGVmYXVsdHMoXCJmbHVpZC50cmFuc2Zvcm1zLmxpbWl0UmFuZ2VcIiwge1xuICAgICAgICBncmFkZU5hbWVzOiBcImZsdWlkLnN0YW5kYXJkVHJhbnNmb3JtRnVuY3Rpb25cIlxuICAgIH0pO1xuXG4gICAgZmx1aWQudHJhbnNmb3Jtcy5saW1pdFJhbmdlID0gZnVuY3Rpb24gKHZhbHVlLCB0cmFuc2Zvcm1TcGVjKSB7XG4gICAgICAgIHZhciBtaW4gPSB0cmFuc2Zvcm1TcGVjLm1pbjtcbiAgICAgICAgaWYgKG1pbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgZXhjbHVkZU1pbiA9IHRyYW5zZm9ybVNwZWMuZXhjbHVkZU1pbiB8fCAwO1xuICAgICAgICAgICAgbWluICs9IGV4Y2x1ZGVNaW47XG4gICAgICAgICAgICBpZiAodmFsdWUgPCBtaW4pIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG1pbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF4ID0gdHJhbnNmb3JtU3BlYy5tYXg7XG4gICAgICAgIGlmIChtYXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGV4Y2x1ZGVNYXggPSB0cmFuc2Zvcm1TcGVjLmV4Y2x1ZGVNYXggfHwgMDtcbiAgICAgICAgICAgIG1heCAtPSBleGNsdWRlTWF4O1xuICAgICAgICAgICAgaWYgKHZhbHVlID4gbWF4KSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBtYXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG5cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsdWlkLnRyYW5zZm9ybXMuZnJlZVwiLCB7XG4gICAgICAgIGdyYWRlTmFtZXM6IFwiZmx1aWQudHJhbnNmb3JtRnVuY3Rpb25cIlxuICAgIH0pO1xuXG4gICAgZmx1aWQudHJhbnNmb3Jtcy5mcmVlID0gZnVuY3Rpb24gKHRyYW5zZm9ybVNwZWMpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBmbHVpZC5tYWtlQXJyYXkodHJhbnNmb3JtU3BlYy5hcmdzKTtcbiAgICAgICAgcmV0dXJuIGZsdWlkLmludm9rZUdsb2JhbEZ1bmN0aW9uKHRyYW5zZm9ybVNwZWMuZnVuYywgYXJncyk7XG4gICAgfTtcblxufSkoalF1ZXJ5LCBmbHVpZF8yXzApO1xuOy8qXG5Db3B5cmlnaHQgMjAxMC0yMDExIEx1Y2VuZG8gRGV2ZWxvcG1lbnQgTHRkLlxuQ29weXJpZ2h0IDIwMTAtMjAxMSBPQ0FEIFVuaXZlcnNpdHlcblxuTGljZW5zZWQgdW5kZXIgdGhlIEVkdWNhdGlvbmFsIENvbW11bml0eSBMaWNlbnNlIChFQ0wpLCBWZXJzaW9uIDIuMCBvciB0aGUgTmV3XG5CU0QgbGljZW5zZS4gWW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIG9uZSB0aGVzZVxuTGljZW5zZXMuXG5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgRUNMIDIuMCBMaWNlbnNlIGFuZCBCU0QgTGljZW5zZSBhdFxuaHR0cHM6Ly9naXRodWIuY29tL2ZsdWlkLXByb2plY3QvaW5mdXNpb24vcmF3L21hc3Rlci9JbmZ1c2lvbi1MSUNFTlNFLnR4dFxuKi9cblxuLyoqIFRoaXMgZmlsZSBjb250YWlucyBmdW5jdGlvbnMgd2hpY2ggZGVwZW5kIG9uIHRoZSBwcmVzZW5jZSBvZiBhIERPTSBkb2N1bWVudFxuICogIGFuZCB3aGljaCBkZXBlbmQgb24gdGhlIGNvbnRlbnRzIG9mIEZsdWlkLmpzICoqL1xuXG52YXIgZmx1aWRfMl8wID0gZmx1aWRfMl8wIHx8IHt9O1xuXG4oZnVuY3Rpb24gKCQsIGZsdWlkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLyBUaGUgYmFzZSBncmFkZSBmb3IgZmx1aWQudmlld0NvbXBvbmVudCBhbmQgZmx1aWQudmlld1JlbGF5Q29tcG9uZW50IC0gd2lsbCBiZSByZW1vdmVkIGFnYWluIG9uY2UgdGhlIG9sZCBDaGFuZ2VBcHBsaWVyIGlzIGVsaW1pbmF0ZWRcbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsdWlkLmNvbW1vblZpZXdDb21wb25lbnRcIiwge1xuICAgICAgICBncmFkZU5hbWVzOiBbXCJmbHVpZC5saXR0bGVDb21wb25lbnRcIiwgXCJhdXRvSW5pdFwiXSxcbiAgICAgICAgaW5pdEZ1bmN0aW9uOiBcImZsdWlkLmluaXRWaWV3XCIsXG4gICAgICAgIGFyZ3VtZW50TWFwOiB7XG4gICAgICAgICAgICBjb250YWluZXI6IDAsXG4gICAgICAgICAgICBvcHRpb25zOiAxXG4gICAgICAgIH0sXG4gICAgICAgIG1lbWJlcnM6IHsgLy8gVXNlZCB0byBhbGxvdyBlYXJseSBhY2Nlc3MgdG8gRE9NIGJpbmRlciB2aWEgSW9DLCBidXQgdG8gYWxzbyBhdm9pZCB0cmlnZ2VyaW5nIGV2YWx1YXRpb24gb2Ygc2VsZWN0b3JzXG4gICAgICAgICAgICBkb206IFwiQGV4cGFuZDpmbHVpZC5pbml0RG9tQmluZGVyKHt0aGF0fSwge3RoYXR9Lm9wdGlvbnMuc2VsZWN0b3JzKVwiXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmx1aWQudmlld0NvbXBvbmVudFwiLCB7XG4gICAgICAgIGdyYWRlTmFtZXM6IFtcImZsdWlkLmNvbW1vblZpZXdDb21wb25lbnRcIiwgXCJmbHVpZC5zdGFuZGFyZENvbXBvbmVudFwiLCBcImF1dG9Jbml0XCJdXG4gICAgfSk7XG5cbiAgICAvLyBhIHZlcnNpb24gb2YgdGhlIHN0YW5kYXJkIGdyYWRlIGZsdWlkLnZpZXdDb21wb25lbnQgdGhhdCB1c2VzIHRoZSBuZXcgRkxVSUQtNTAyNCBDaGFuZ2VBcHBsaWVyIGFuZCBtb2RlbCByZWxheSBzeXN0ZW0gLSB0aGlzIHdpbGwgYmUgdGhlIGRlZmF1bHRcbiAgICAvLyBpbiBGbHVpZCAyLjAgYW5kIGJlIHJlbmFtZWQgYmFjayB0byBmbHVpZC52aWV3Q29tcG9uZW50XG4gICAgZmx1aWQuZGVmYXVsdHMoXCJmbHVpZC52aWV3UmVsYXlDb21wb25lbnRcIiwge1xuICAgICAgICBncmFkZU5hbWVzOiBbXCJmbHVpZC5jb21tb25WaWV3Q29tcG9uZW50XCIsIFwiZmx1aWQuc3RhbmRhcmRSZWxheUNvbXBvbmVudFwiLCBcImF1dG9Jbml0XCJdXG4gICAgfSk7XG5cbiAgICAvLyB1bnN1cHBvcnRlZCwgTk9OLUFQSSBmdW5jdGlvblxuICAgIGZsdWlkLmR1bXBTZWxlY3RvciA9IGZ1bmN0aW9uIChzZWxlY3RhYmxlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgKHNlbGVjdGFibGUpID09PSBcInN0cmluZ1wiID8gc2VsZWN0YWJsZSA6XG4gICAgICAgICAgICBzZWxlY3RhYmxlLnNlbGVjdG9yID8gc2VsZWN0YWJsZS5zZWxlY3RvciA6IFwiXCI7XG4gICAgfTtcblxuICAgIC8vIHVuc3VwcG9ydGVkLCBOT04tQVBJIGZ1bmN0aW9uXG4gICAgLy8gTk9URTogdGhpcyBmdW5jdGlvbiByZXByZXNlbnRzIGEgdGVtcG9yYXJ5IHN0cmF0ZWd5IHVudGlsIHdlIGhhdmUgbW9yZSBpbnRlZ3JhdGVkIElvQyBkZWJ1Z2dpbmcuXG4gICAgLy8gSXQgcHJlc2VydmVzIHRoZSBjdXJyZW50IGZyYW1ld29yayBiZWhhdmlvdXIgZm9yIHRoZSAxLjQgcmVsZWFzZSwgYnV0IHByb3ZpZGVzIGEgbW9yZSBpbmZvcm1hdGl2ZVxuICAgIC8vIGRpYWdub3N0aWMgLSBpbiBmYWN0LCBpdCBpcyBwZXJmZWN0bHkgYWNjZXB0YWJsZSBmb3IgYSBjb21wb25lbnQncyBjcmVhdG9yIHRvIHJldHVybiBubyB2YWx1ZSBhbmRcbiAgICAvLyB0aGUgZmFpbHVyZSBpcyByZWFsbHkgaW4gYXNzdW1wdGlvbnMgaW4gZmx1aWQuaW5pdENvbXBvbmVudC4gUmV2aXNpdCB0aGlzIGlzc3VlIGZvciAxLjVcbiAgICBmbHVpZC5kaWFnbm9zZUZhaWxlZFZpZXcgPSBmdW5jdGlvbiAoY29tcG9uZW50TmFtZSwgdGhhdCwgb3B0aW9ucywgYXJncykge1xuICAgICAgICBpZiAoIXRoYXQgJiYgKGZsdWlkLmhhc0dyYWRlKG9wdGlvbnMsIFwiZmx1aWQudmlld0NvbXBvbmVudFwiKSB8fCBmbHVpZC5oYXNHcmFkZShvcHRpb25zLCBcImZsdWlkLnZpZXdSZWxheUNvbXBvbmVudFwiKSkpIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBmbHVpZC53cmFwKGFyZ3NbMV0pO1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UxID0gXCJJbnN0YW50aWF0aW9uIG9mIGF1dG9Jbml0IGNvbXBvbmVudCB3aXRoIHR5cGUgXCIgKyBjb21wb25lbnROYW1lICsgXCIgZmFpbGVkLCBzaW5jZSBcIjtcbiAgICAgICAgICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgZmx1aWQuZmFpbChtZXNzYWdlMSArIFwiIGNvbnRhaW5lciBhcmd1bWVudCBpcyBlbXB0eVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbnRhaW5lci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBmbHVpZC5mYWlsKG1lc3NhZ2UxICsgXCJzZWxlY3RvciBcXFwiXCIsIGZsdWlkLmR1bXBTZWxlY3RvcihhcmdzWzFdKSwgXCJcXFwiIGRpZCBub3QgbWF0Y2ggYW55IG1hcmt1cCBpbiB0aGUgZG9jdW1lbnRcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZsdWlkLmZhaWwobWVzc2FnZTEgKyBcIiBjb21wb25lbnQgY3JlYXRvciBmdW5jdGlvbiBkaWQgbm90IHJldHVybiBhIHZhbHVlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZsdWlkLmNoZWNrVHJ5Q2F0Y2hQYXJhbWV0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbiB8fCB7IHNlYXJjaDogXCJcIiwgcHJvdG9jb2w6IFwiZmlsZTpcIiB9O1xuICAgICAgICB2YXIgR0VUcGFyYW1zID0gbG9jYXRpb24uc2VhcmNoLnNsaWNlKDEpLnNwbGl0KFwiJlwiKTtcbiAgICAgICAgcmV0dXJuIGZsdWlkLmZpbmQoR0VUcGFyYW1zLCBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgICAgIGlmIChwYXJhbS5pbmRleE9mKFwibm90cnljYXRjaFwiKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSA9PT0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgZmx1aWQubm90cnljYXRjaCA9IGZsdWlkLmNoZWNrVHJ5Q2F0Y2hQYXJhbWV0ZXIoKTtcblxuXG4gICAgLyoqXG4gICAgICogV3JhcHMgYW4gb2JqZWN0IGluIGEgalF1ZXJ5IGlmIGl0IGlzbid0IGFscmVhZHkgb25lLiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWZ1bCBzaW5jZVxuICAgICAqIGl0IGVuc3VyZXMgdG8gd3JhcCBhIG51bGwgb3Igb3RoZXJ3aXNlIGZhbHN5IGFyZ3VtZW50IHRvIGl0c2VsZiwgcmF0aGVyIHRoYW4gdGhlXG4gICAgICogb2Z0ZW4gdW5oZWxwZnVsIGpRdWVyeSBkZWZhdWx0IG9mIHJldHVybmluZyB0aGUgb3ZlcmFsbCBkb2N1bWVudCBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiB0aGUgb2JqZWN0IHRvIHdyYXAgaW4gYSBqUXVlcnlcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gdXNlckpRdWVyeSB0aGUgalF1ZXJ5IG9iamVjdCB0byB1c2UgZm9yIHRoZSB3cmFwcGluZywgb3B0aW9uYWwgLSB1c2UgdGhlIGN1cnJlbnQgalF1ZXJ5IGlmIGFic2VudFxuICAgICAqL1xuICAgIGZsdWlkLndyYXAgPSBmdW5jdGlvbiAob2JqLCB1c2VySlF1ZXJ5KSB7XG4gICAgICAgIHVzZXJKUXVlcnkgPSB1c2VySlF1ZXJ5IHx8ICQ7XG4gICAgICAgIHJldHVybiAoKCFvYmogfHwgb2JqLmpxdWVyeSkgPyBvYmogOiB1c2VySlF1ZXJ5KG9iaikpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJZiBvYmogaXMgYSBqUXVlcnksIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIGZpcnN0IERPTSBlbGVtZW50IHdpdGhpbiBpdC4gT3RoZXJ3aXNlLCB0aGUgb2JqZWN0IHdpbGwgYmUgcmV0dXJuZWQgdW5jaGFuZ2VkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtqUXVlcnl9IG9iaiB0aGUgalF1ZXJ5IGluc3RhbmNlIHRvIHVud3JhcCBpbnRvIGEgcHVyZSBET00gZWxlbWVudFxuICAgICAqL1xuICAgIGZsdWlkLnVud3JhcCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiAmJiBvYmouanF1ZXJ5ICYmIG9iai5sZW5ndGggPT09IDEgPyBvYmpbMF0gOiBvYmo7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgYSBzaW5nbGUgY29udGFpbmVyIGVsZW1lbnQgYW5kIHJldHVybnMgaXQgYXMgYSBqUXVlcnkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3x8alF1ZXJ5fHxlbGVtZW50fSBjb250YWluZXJTcGVjIGFuIGlkIHN0cmluZywgYSBzaW5nbGUtZWxlbWVudCBqUXVlcnksIG9yIGEgRE9NIGVsZW1lbnQgc3BlY2lmeWluZyBhIHVuaXF1ZSBjb250YWluZXJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZhbGxpYmxlIDxjb2RlPnRydWU8L2NvZGU+IGlmIGFuIGVtcHR5IGNvbnRhaW5lciBpcyB0byBiZSByZXBvcnRlZCBhcyBhIHZhbGlkIGNvbmRpdGlvblxuICAgICAqIEByZXR1cm4gYSBzaW5nbGUtZWxlbWVudCBqUXVlcnkgb2YgY29udGFpbmVyXG4gICAgICovXG4gICAgZmx1aWQuY29udGFpbmVyID0gZnVuY3Rpb24gKGNvbnRhaW5lclNwZWMsIGZhbGxpYmxlLCB1c2VySlF1ZXJ5KSB7XG4gICAgICAgIGlmICh1c2VySlF1ZXJ5KSB7XG4gICAgICAgICAgICBjb250YWluZXJTcGVjID0gZmx1aWQudW53cmFwKGNvbnRhaW5lclNwZWMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb250YWluZXIgPSBmbHVpZC53cmFwKGNvbnRhaW5lclNwZWMsIHVzZXJKUXVlcnkpO1xuICAgICAgICBpZiAoZmFsbGlibGUgJiYgKCFjb250YWluZXIgfHwgY29udGFpbmVyLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjb250YWluZXIgfHwgIWNvbnRhaW5lci5qcXVlcnkgfHwgY29udGFpbmVyLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAoY29udGFpbmVyU3BlYykgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXJTcGVjID0gY29udGFpbmVyLnNlbGVjdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNvdW50ID0gY29udGFpbmVyLmxlbmd0aCAhPT0gdW5kZWZpbmVkID8gY29udGFpbmVyLmxlbmd0aCA6IDA7XG4gICAgICAgICAgICBmbHVpZC5mYWlsKChjb3VudCA+IDEgPyBcIk1vcmUgdGhhbiBvbmUgKFwiICsgY291bnQgKyBcIikgY29udGFpbmVyIGVsZW1lbnRzIHdlcmVcIlxuICAgICAgICAgICAgICAgICAgICA6IFwiTm8gY29udGFpbmVyIGVsZW1lbnQgd2FzXCIpICsgXCIgZm91bmQgZm9yIHNlbGVjdG9yIFwiICsgY29udGFpbmVyU3BlYyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmbHVpZC5pc0RPTU5vZGUoY29udGFpbmVyWzBdKSkge1xuICAgICAgICAgICAgZmx1aWQuZmFpbChcImZsdWlkLmNvbnRhaW5lciB3YXMgc3VwcGxpZWQgYSBub24talF1ZXJ5YWJsZSBlbGVtZW50XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBET00gQmluZGVyIGluc3RhbmNlLCB1c2VkIHRvIGxvY2F0ZSBlbGVtZW50cyBpbiB0aGUgRE9NIGJ5IG5hbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29udGFpbmVyIHRoZSByb290IGVsZW1lbnQgaW4gd2hpY2ggdG8gbG9jYXRlIG5hbWVkIGVsZW1lbnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNlbGVjdG9ycyBhIGNvbGxlY3Rpb24gb2YgbmFtZWQgalF1ZXJ5IHNlbGVjdG9yc1xuICAgICAqL1xuICAgIGZsdWlkLmNyZWF0ZURvbUJpbmRlciA9IGZ1bmN0aW9uIChjb250YWluZXIsIHNlbGVjdG9ycykge1xuICAgICAgICAvLyBkb24ndCBwdXQgb24gYSB0eXBlbmFtZSB0byBhdm9pZCBjb25mdXNpbmcgcHJpbWl0aXZlIHZpc2l0Q29tcG9uZW50Q2hpbGRyZW5cbiAgICAgICAgdmFyIGNhY2hlID0ge30sIHRoYXQgPSB7aWQ6IGZsdWlkLmFsbG9jYXRlR3VpZCgpfTtcbiAgICAgICAgdmFyIHVzZXJKUXVlcnkgPSBjb250YWluZXIuY29uc3RydWN0b3I7XG5cbiAgICAgICAgZnVuY3Rpb24gY2FjaGVLZXkobmFtZSwgdGhpc0NvbnRhaW5lcikge1xuICAgICAgICAgICAgcmV0dXJuIGZsdWlkLmFsbG9jYXRlU2ltcGxlSWQodGhpc0NvbnRhaW5lcikgKyBcIi1cIiArIG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZWNvcmQobmFtZSwgdGhpc0NvbnRhaW5lciwgcmVzdWx0KSB7XG4gICAgICAgICAgICBjYWNoZVtjYWNoZUtleShuYW1lLCB0aGlzQ29udGFpbmVyKV0gPSByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGF0LmxvY2F0ZSA9IGZ1bmN0aW9uIChuYW1lLCBsb2NhbENvbnRhaW5lcikge1xuICAgICAgICAgICAgdmFyIHNlbGVjdG9yLCB0aGlzQ29udGFpbmVyLCB0b2dvO1xuXG4gICAgICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yc1tuYW1lXTtcbiAgICAgICAgICAgIHRoaXNDb250YWluZXIgPSBsb2NhbENvbnRhaW5lciA/IGxvY2FsQ29udGFpbmVyIDogY29udGFpbmVyO1xuICAgICAgICAgICAgaWYgKCF0aGlzQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgZmx1aWQuZmFpbChcIkRPTSBiaW5kZXIgaW52b2tlZCBmb3Igc2VsZWN0b3IgXCIgKyBuYW1lICsgXCIgd2l0aG91dCBjb250YWluZXJcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc0NvbnRhaW5lcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiAoc2VsZWN0b3IpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB0b2dvID0gdXNlckpRdWVyeShzZWxlY3Rvci5jYWxsKG51bGwsIGZsdWlkLnVud3JhcCh0aGlzQ29udGFpbmVyKSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b2dvID0gdXNlckpRdWVyeShzZWxlY3RvciwgdGhpc0NvbnRhaW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9nby5nZXQoMCkgPT09IGRvY3VtZW50KSB7XG4gICAgICAgICAgICAgICAgdG9nbyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0b2dvLnNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgdG9nby5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICAgICAgICAgIHRvZ28uY29udGV4dCA9IHRoaXNDb250YWluZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b2dvLnNlbGVjdG9yTmFtZSA9IG5hbWU7XG4gICAgICAgICAgICByZWNvcmQobmFtZSwgdGhpc0NvbnRhaW5lciwgdG9nbyk7XG4gICAgICAgICAgICByZXR1cm4gdG9nbztcbiAgICAgICAgfTtcbiAgICAgICAgdGhhdC5mYXN0TG9jYXRlID0gZnVuY3Rpb24gKG5hbWUsIGxvY2FsQ29udGFpbmVyKSB7XG4gICAgICAgICAgICB2YXIgdGhpc0NvbnRhaW5lciA9IGxvY2FsQ29udGFpbmVyID8gbG9jYWxDb250YWluZXIgOiBjb250YWluZXI7XG4gICAgICAgICAgICB2YXIga2V5ID0gY2FjaGVLZXkobmFtZSwgdGhpc0NvbnRhaW5lcik7XG4gICAgICAgICAgICB2YXIgdG9nbyA9IGNhY2hlW2tleV07XG4gICAgICAgICAgICByZXR1cm4gdG9nbyA/IHRvZ28gOiB0aGF0LmxvY2F0ZShuYW1lLCBsb2NhbENvbnRhaW5lcik7XG4gICAgICAgIH07XG4gICAgICAgIHRoYXQuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjYWNoZSA9IHt9O1xuICAgICAgICB9O1xuICAgICAgICB0aGF0LnJlZnJlc2ggPSBmdW5jdGlvbiAobmFtZXMsIGxvY2FsQ29udGFpbmVyKSB7XG4gICAgICAgICAgICB2YXIgdGhpc0NvbnRhaW5lciA9IGxvY2FsQ29udGFpbmVyID8gbG9jYWxDb250YWluZXIgOiBjb250YWluZXI7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5hbWVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgbmFtZXMgPSBbbmFtZXNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXNDb250YWluZXIubGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzQ29udGFpbmVyID0gW3RoaXNDb250YWluZXJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpc0NvbnRhaW5lci5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICB0aGF0LmxvY2F0ZShuYW1lc1tpXSwgdGhpc0NvbnRhaW5lcltqXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGF0LnJlc29sdmVQYXRoU2VnbWVudCA9IHRoYXQubG9jYXRlO1xuXG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgIH07XG5cbiAgICAvKiogRXhwZWN0IHRoYXQgalF1ZXJ5IHNlbGVjdG9yIHF1ZXJ5IGhhcyByZXN1bHRlZCBpbiBhIG5vbi1lbXB0eSBzZXQgb2ZcbiAgICAgKiByZXN1bHRzLiBJZiBub25lIGFyZSBmb3VuZCwgdGhpcyBmdW5jdGlvbiB3aWxsIGZhaWwgd2l0aCBhIGRpYWdub3N0aWMgbWVzc2FnZSxcbiAgICAgKiB3aXRoIHRoZSBzdXBwbGllZCBtZXNzYWdlIHByZXBlbmRlZC5cbiAgICAgKi9cbiAgICBmbHVpZC5leHBlY3RGaWxsZWRTZWxlY3RvciA9IGZ1bmN0aW9uIChyZXN1bHQsIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQubGVuZ3RoID09PSAwICYmIHJlc3VsdC5qcXVlcnkpIHtcbiAgICAgICAgICAgIGZsdWlkLmZhaWwobWVzc2FnZSArIFwiOiBzZWxlY3RvciBcXFwiXCIgKyByZXN1bHQuc2VsZWN0b3IgKyBcIlxcXCIgd2l0aCBuYW1lIFwiICsgcmVzdWx0LnNlbGVjdG9yTmFtZSArXG4gICAgICAgICAgICAgICAgICAgICAgIFwiIHJldHVybmVkIG5vIHJlc3VsdHMgaW4gY29udGV4dCBcIiArIGZsdWlkLmR1bXBFbChyZXN1bHQuY29udGV4dCkpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjZW50cmFsIGluaXRpYWxpYXRpb24gbWV0aG9kIGNhbGxlZCBhcyB0aGUgZmlyc3QgYWN0IG9mIGV2ZXJ5IEZsdWlkXG4gICAgICogY29tcG9uZW50LiBUaGlzIGZ1bmN0aW9uIGF1dG9tYXRpY2FsbHkgbWVyZ2VzIHVzZXIgb3B0aW9ucyB3aXRoIGRlZmF1bHRzLFxuICAgICAqIGF0dGFjaGVzIGEgRE9NIEJpbmRlciB0byB0aGUgaW5zdGFuY2UsIGFuZCBjb25maWd1cmVzIGV2ZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb21wb25lbnROYW1lIFRoZSB1bmlxdWUgXCJuYW1lXCIgb2YgdGhlIGNvbXBvbmVudCwgd2hpY2ggd2lsbCBiZSB1c2VkXG4gICAgICogdG8gZmV0Y2ggdGhlIGRlZmF1bHQgb3B0aW9ucyBmcm9tIHN0b3JlLiBCeSByZWNvbW1lbmRhdGlvbiwgdGhpcyBzaG91bGQgYmUgdGhlIGdsb2JhbFxuICAgICAqIG5hbWUgb2YgdGhlIGNvbXBvbmVudCdzIGNyZWF0b3IgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtqUXVlcnlhYmxlfSBjb250YWluZXIgQSBzcGVjaWZpZXIgZm9yIHRoZSBzaW5nbGUgcm9vdCBcImNvbnRhaW5lciBub2RlXCIgaW4gdGhlXG4gICAgICogRE9NIHdoaWNoIHdpbGwgaG91c2UgYWxsIHRoZSBtYXJrdXAgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1c2VyT3B0aW9ucyBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICAgLy8gNHRoIGFyZ3VtZW50IGlzIE5PVCBTVVBQT1JURUQsIHNlZSBjb21tZW50cyBmb3IgaW5pdExpdHRsZUNvbXBvbmVudFxuICAgIGZsdWlkLmluaXRWaWV3ID0gZnVuY3Rpb24gKGNvbXBvbmVudE5hbWUsIGNvbnRhaW5lclNwZWMsIHVzZXJPcHRpb25zLCBsb2NhbE9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGZsdWlkLmNvbnRhaW5lcihjb250YWluZXJTcGVjLCB0cnVlKTtcbiAgICAgICAgZmx1aWQuZXhwZWN0RmlsbGVkU2VsZWN0b3IoY29udGFpbmVyLCBcIkVycm9yIGluc3RhbnRpYXRpbmcgY29tcG9uZW50IHdpdGggbmFtZSBcXFwiXCIgKyBjb21wb25lbnROYW1lKTtcbiAgICAgICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5lZWQgdG8gZW5zdXJlIGNvbnRhaW5lciBpcyBzZXQgZWFybHksIHdpdGhvdXQgcmVseWluZyBvbiBhbiBJb0MgbWVjaGFuaXNtIC0gcmV0aGluayB0aGlzIHdpdGggYXN5bmNocm9ueVxuICAgICAgICB2YXIgcmVjZWl2ZXIgPSBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgICAgICAgdGhhdC5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIH07XG4gICAgICAgIHZhciB0aGF0ID0gZmx1aWQuaW5pdExpdHRsZUNvbXBvbmVudChjb21wb25lbnROYW1lLCB1c2VyT3B0aW9ucywgbG9jYWxPcHRpb25zIHx8IHtncmFkZU5hbWVzOiBbXCJmbHVpZC52aWV3Q29tcG9uZW50XCJdfSwgcmVjZWl2ZXIpO1xuXG4gICAgICAgIGlmICghdGhhdC5kb20pIHtcbiAgICAgICAgICAgIGZsdWlkLmluaXREb21CaW5kZXIodGhhdCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogY2Fubm90IGFmZm9yZCBhIG11dGFibGUgY29udGFpbmVyIC0gcHV0IHRoaXMgaW50byBwcm9wZXIgd29ya2Zsb3dcbiAgICAgICAgdmFyIHVzZXJKUXVlcnkgPSB0aGF0Lm9wdGlvbnMualF1ZXJ5OyAvLyBEbyBpdCBhIHNlY29uZCB0aW1lIHRvIGNvcnJlY3QgZm9yIGpRdWVyeSBpbmplY3Rpb25cbiAgICAgICAgLy8gaWYgKHVzZXJKUXVlcnkpIHtcbiAgICAgICAgLy8gICAgY29udGFpbmVyID0gZmx1aWQuY29udGFpbmVyKGNvbnRhaW5lclNwZWMsIHRydWUsIHVzZXJKUXVlcnkpO1xuICAgICAgICAvLyB9XG4gICAgICAgIGZsdWlkLmxvZyhcIkNvbnN0cnVjdGluZyB2aWV3IGNvbXBvbmVudCBcIiArIGNvbXBvbmVudE5hbWUgKyBcIiB3aXRoIGNvbnRhaW5lciBcIiArIGNvbnRhaW5lci5jb25zdHJ1Y3Rvci5leHBhbmRvICtcbiAgICAgICAgICAgICh1c2VySlF1ZXJ5ID8gXCIgdXNlciBqUXVlcnkgXCIgKyB1c2VySlF1ZXJ5LmV4cGFuZG8gOiBcIlwiKSArIFwiIGVudjogXCIgKyAkLmV4cGFuZG8pO1xuXG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IERPTSBCaW5kZXIgaW5zdGFuY2UgZm9yIHRoZSBzcGVjaWZpZWQgY29tcG9uZW50IGFuZCBtaXhlcyBpdCBpbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0aGF0IHRoZSBjb21wb25lbnQgaW5zdGFuY2UgdG8gYXR0YWNoIHRoZSBuZXcgRE9NIEJpbmRlciB0b1xuICAgICAqL1xuICAgIGZsdWlkLmluaXREb21CaW5kZXIgPSBmdW5jdGlvbiAodGhhdCwgc2VsZWN0b3JzKSB7XG4gICAgICAgIHRoYXQuZG9tID0gZmx1aWQuY3JlYXRlRG9tQmluZGVyKHRoYXQuY29udGFpbmVyLCBzZWxlY3RvcnMgfHwgdGhhdC5vcHRpb25zLnNlbGVjdG9ycyB8fCB7fSk7XG4gICAgICAgIHRoYXQubG9jYXRlID0gdGhhdC5kb20ubG9jYXRlO1xuICAgICAgICByZXR1cm4gdGhhdC5kb207XG4gICAgfTtcblxuICAgIC8vIERPTSBVdGlsaXRpZXMuXG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgbmVhcmVzdCBhbmNlc3RvciBvZiB0aGUgZWxlbWVudCB0aGF0IHBhc3NlcyB0aGUgdGVzdFxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBET00gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHRlc3QgQSBmdW5jdGlvbiB3aGljaCB0YWtlcyBhbiBlbGVtZW50IGFzIGEgcGFyYW1ldGVyIGFuZCByZXR1cm4gdHJ1ZSBvciBmYWxzZSBmb3Igc29tZSB0ZXN0XG4gICAgICovXG4gICAgZmx1aWQuZmluZEFuY2VzdG9yID0gZnVuY3Rpb24gKGVsZW1lbnQsIHRlc3QpIHtcbiAgICAgICAgZWxlbWVudCA9IGZsdWlkLnVud3JhcChlbGVtZW50KTtcbiAgICAgICAgd2hpbGUgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmICh0ZXN0KGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZsdWlkLmZpbmRGb3JtID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGZsdWlkLmZpbmRBbmNlc3Rvcihub2RlLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJmb3JtXCI7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKiogQSB1dGlsaXR5IHdpdGggdGhlIHNhbWUgc2lnbmF0dXJlIGFzIGpRdWVyeS50ZXh0IGFuZCBqUXVlcnkuaHRtbCwgYnV0IHdpdGhvdXQgdGhlIEFQSSBpcnJlZ3VsYXJpdHlcbiAgICAgKiB0aGF0IHRyZWF0cyBhIHNpbmdsZSBhcmd1bWVudCBvZiB1bmRlZmluZWQgYXMgZGlmZmVyZW50IHRvIG5vIGFyZ3VtZW50cyAqL1xuICAgIC8vIGluIGpRdWVyeSAxLjcuMSwgalF1ZXJ5IHB1bGxlZCB0aGUgc2FtZSBkdW1iIHRyaWNrIHdpdGggJC50ZXh0KCkgdGhhdCB0aGV5IGRpZCB3aXRoICQudmFsKCkgcHJldmlvdXNseSxcbiAgICAvLyBzZWUgY29tbWVudCBpbiBmbHVpZC52YWx1ZSBiZWxvd1xuICAgIGZsdWlkLmVhY2goW1widGV4dFwiLCBcImh0bWxcIl0sIGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgZmx1aWRbbWV0aG9kXSA9IGZ1bmN0aW9uIChub2RlLCBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgbm9kZSA9ICQobm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3VmFsdWUgPT09IHVuZGVmaW5lZCA/IG5vZGVbbWV0aG9kXSgpIDogbm9kZVttZXRob2RdKG5ld1ZhbHVlKTtcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8qKiBBIGdlbmVyYWxpc2F0aW9uIG9mIGpRdWVyeS52YWwgdG8gY29ycmVjdGx5IGhhbmRsZSB0aGUgY2FzZSBvZiBhY3F1aXJpbmcgYW5kXG4gICAgICogc2V0dGluZyB0aGUgdmFsdWUgb2YgY2x1c3RlcmVkIHJhZGlvIGJ1dHRvbi9jaGVja2JveCBzZXRzLCBwb3RlbnRpYWxseSwgZ2l2ZW5cbiAgICAgKiBhIG5vZGUgY29ycmVzcG9uZGluZyB0byBqdXN0IG9uZSBlbGVtZW50LlxuICAgICAqL1xuICAgIGZsdWlkLnZhbHVlID0gZnVuY3Rpb24gKG5vZGVJbiwgbmV3VmFsdWUpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBmbHVpZC51bndyYXAobm9kZUluKTtcbiAgICAgICAgdmFyIG11bHRpcGxlID0gZmFsc2U7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSB1bmRlZmluZWQgJiYgbm9kZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZVswXTtcbiAgICAgICAgICAgIG11bHRpcGxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJpbnB1dFwiICE9PSBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgfHwgIS9yYWRpb3xjaGVja2JveC8udGVzdChub2RlLnR5cGUpKSB7XG4gICAgICAgICAgICAvLyByZXNpc3QgY2hhbmdlcyB0byBjb250cmFjdCBvZiBqUXVlcnkudmFsKCkgaW4galF1ZXJ5IDEuNS4xIChzZWUgRkxVSUQtNDExMylcbiAgICAgICAgICAgIHJldHVybiBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkID8gJChub2RlKS52YWwoKSA6ICQobm9kZSkudmFsKG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZSA9IG5vZGUubmFtZTtcbiAgICAgICAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZmx1aWQuZmFpbChcIkNhbm5vdCBhY3F1aXJlIHZhbHVlIGZyb20gbm9kZSBcIiArIGZsdWlkLmR1bXBFbChub2RlKSArIFwiIHdoaWNoIGRvZXMgbm90IGhhdmUgbmFtZSBhdHRyaWJ1dGUgc2V0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbGVtZW50cztcbiAgICAgICAgaWYgKG11bHRpcGxlKSB7XG4gICAgICAgICAgICBlbGVtZW50cyA9IG5vZGVJbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZW1lbnRzID0gbm9kZS5vd25lckRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKG5hbWUpO1xuICAgICAgICAgICAgdmFyIHNjb3BlID0gZmx1aWQuZmluZEZvcm0obm9kZSk7XG4gICAgICAgICAgICBlbGVtZW50cyA9ICQuZ3JlcChlbGVtZW50cywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5uYW1lICE9PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICFzY29wZSB8fCBmbHVpZC5kb20uaXNDb250YWluZXIoc2NvcGUsIGVsZW1lbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld1ZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YobmV3VmFsdWUpID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gKG5ld1ZhbHVlID8gXCJ0cnVlXCIgOiBcImZhbHNlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIC8vIGpRdWVyeSBnZXRzIHRoaXMgcGFydGlhbGx5IHJpZ2h0LCBidXQgd2hlbiBkZWFsaW5nIHdpdGggcmFkaW8gYnV0dG9uIGFycmF5IHdpbGxcbiAgICAgICAgICAvLyBzZXQgYWxsIG9mIHRoZWlyIHZhbHVlcyB0byBcIm5ld1ZhbHVlXCIgcmF0aGVyIHRoYW4gc2V0dGluZyB0aGUgY2hlY2tlZCBwcm9wZXJ0eVxuICAgICAgICAgIC8vIG9mIHRoZSBjb3JyZXNwb25kaW5nIGNvbnRyb2wuXG4gICAgICAgICAgICAkLmVhY2goZWxlbWVudHMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrZWQgPSAobmV3VmFsdWUgaW5zdGFuY2VvZiBBcnJheSA/XG4gICAgICAgICAgICAgICAgICAgICQuaW5BcnJheSh0aGlzLnZhbHVlLCBuZXdWYWx1ZSkgIT09IC0xIDogbmV3VmFsdWUgPT09IHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7IC8vIHRoaXMgcGFydCBqUXVlcnkgd2lsbCBub3QgZG8gLSBleHRyYWN0aW5nIHZhbHVlIGZyb20gPGlucHV0PiBhcnJheVxuICAgICAgICAgICAgdmFyIGNoZWNrZWQgPSAkLm1hcChlbGVtZW50cywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudC5jaGVja2VkID8gZWxlbWVudC52YWx1ZSA6IG51bGw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwicmFkaW9cIiA/IGNoZWNrZWRbMF0gOiBjaGVja2VkO1xuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgZmx1aWQuQklORElOR19ST09UX0tFWSA9IFwiZmx1aWQtYmluZGluZy1yb290XCI7XG5cbiAgICAvKiogUmVjdXJzaXZlbHkgZmluZCBhbnkgZGF0YSBzdG9yZWQgdW5kZXIgYSBnaXZlbiBuYW1lIGZyb20gYSBub2RlIHVwd2FyZHNcbiAgICAgKiBpbiBpdHMgRE9NIGhpZXJhcmNoeSAqKi9cblxuICAgIGZsdWlkLmZpbmREYXRhID0gZnVuY3Rpb24gKGVsZW0sIG5hbWUpIHtcbiAgICAgICAgd2hpbGUgKGVsZW0pIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gJC5kYXRhKGVsZW0sIG5hbWUpO1xuICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsZW0gPSBlbGVtLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZmx1aWQuYmluZEZvc3NpbHMgPSBmdW5jdGlvbiAobm9kZSwgZGF0YSwgZm9zc2lscykge1xuICAgICAgICAkLmRhdGEobm9kZSwgZmx1aWQuQklORElOR19ST09UX0tFWSwge2RhdGE6IGRhdGEsIGZvc3NpbHM6IGZvc3NpbHN9KTtcbiAgICB9O1xuXG4gICAgZmx1aWQuYm91bmRQYXRoRm9yTm9kZSA9IGZ1bmN0aW9uIChub2RlLCBmb3NzaWxzKSB7XG4gICAgICAgIG5vZGUgPSBmbHVpZC51bndyYXAobm9kZSk7XG4gICAgICAgIHZhciBrZXkgPSBub2RlLm5hbWUgfHwgbm9kZS5pZDtcbiAgICAgICAgdmFyIHJlY29yZCA9IGZvc3NpbHNba2V5XTtcbiAgICAgICAgcmV0dXJuIHJlY29yZCA/IHJlY29yZC5FTCA6IG51bGw7XG4gICAgfTtcblxuICAgLyoqIFwiQXV0b21hdGljYWxseVwiIGFwcGx5IHRvIHdoYXRldmVyIHBhcnQgb2YgdGhlIGRhdGEgbW9kZWwgaXNcbiAgICAgKiByZWxldmFudCwgdGhlIGNoYW5nZWQgdmFsdWUgcmVjZWl2ZWQgYXQgdGhlIGdpdmVuIERPTSBub2RlKi9cbiAgICBmbHVpZC5hcHBseUJvdW5kQ2hhbmdlID0gZnVuY3Rpb24gKG5vZGUsIG5ld1ZhbHVlLCBhcHBsaWVyKSB7XG4gICAgICAgIG5vZGUgPSBmbHVpZC51bndyYXAobm9kZSk7XG4gICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGZsdWlkLnZhbHVlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSB1bmRlZmluZWQgJiYgbm9kZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZVswXTtcbiAgICAgICAgfSAvLyBhc3N1bWUgaGVyZSB0aGF0IHRoZXkgc2hhcmUgbmFtZSBhbmQgcGFyZW50XG4gICAgICAgIHZhciByb290ID0gZmx1aWQuZmluZERhdGEobm9kZSwgZmx1aWQuQklORElOR19ST09UX0tFWSk7XG4gICAgICAgIGlmICghcm9vdCkge1xuICAgICAgICAgICAgZmx1aWQuZmFpbChcIkJvdW5kIGRhdGEgY291bGQgbm90IGJlIGRpc2NvdmVyZWQgaW4gYW55IG5vZGUgYWJvdmUgXCIgKyBmbHVpZC5kdW1wRWwobm9kZSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuYW1lID0gbm9kZS5uYW1lO1xuICAgICAgICB2YXIgZm9zc2lsID0gcm9vdC5mb3NzaWxzW25hbWVdO1xuICAgICAgICBpZiAoIWZvc3NpbCkge1xuICAgICAgICAgICAgZmx1aWQuZmFpbChcIk5vIGZvc3NpbCBkaXNjb3ZlcmVkIGZvciBuYW1lIFwiICsgbmFtZSArIFwiIGluIGZvc3NpbCByZWNvcmQgYWJvdmUgXCIgKyBmbHVpZC5kdW1wRWwobm9kZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YoZm9zc2lsLm9sZHZhbHVlKSA9PT0gXCJib29sZWFuXCIpIHsgLy8gZGVhbCB3aXRoIHRoZSBjYXNlIG9mIGFuIFwiaXNvbGF0ZWQgY2hlY2tib3hcIlxuICAgICAgICAgICAgbmV3VmFsdWUgPSBuZXdWYWx1ZVswXSA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgRUwgPSByb290LmZvc3NpbHNbbmFtZV0uRUw7XG4gICAgICAgIGlmIChhcHBsaWVyKSB7XG4gICAgICAgICAgICBhcHBsaWVyLmZpcmVDaGFuZ2VSZXF1ZXN0KHtwYXRoOiBFTCwgdmFsdWU6IG5ld1ZhbHVlLCBzb3VyY2U6IFwiRE9NOlwiICsgbm9kZS5pZH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmx1aWQuc2V0KHJvb3QuZGF0YSwgRUwsIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBqUXVlcnkgb2JqZWN0IGdpdmVuIHRoZSBpZCBvZiBhIERPTSBub2RlLiBJbiB0aGUgY2FzZSB0aGUgZWxlbWVudFxuICAgICAqIGlzIG5vdCBmb3VuZCwgd2lsbCByZXR1cm4gYW4gZW1wdHkgbGlzdC5cbiAgICAgKi9cbiAgICBmbHVpZC5qQnlJZCA9IGZ1bmN0aW9uIChpZCwgZG9ra3VtZW50KSB7XG4gICAgICAgIGRva2t1bWVudCA9IGRva2t1bWVudCAmJiBkb2trdW1lbnQubm9kZVR5cGUgPT09IDkgPyBkb2trdW1lbnQgOiBkb2N1bWVudDtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBmbHVpZC5ieUlkKGlkLCBkb2trdW1lbnQpO1xuICAgICAgICB2YXIgdG9nbyA9IGVsZW1lbnQgPyAkKGVsZW1lbnQpIDogW107XG4gICAgICAgIHRvZ28uc2VsZWN0b3IgPSBcIiNcIiArIGlkO1xuICAgICAgICB0b2dvLmNvbnRleHQgPSBkb2trdW1lbnQ7XG4gICAgICAgIHJldHVybiB0b2dvO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIERPTSBlbGVtZW50IHF1aWNrbHksIGdpdmVuIGFuIGlkXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaWQgdGhlIGlkIG9mIHRoZSBET00gbm9kZSB0byBmaW5kXG4gICAgICogQHBhcmFtIHtEb2N1bWVudH0gZG9ra3VtZW50IHRoZSBkb2N1bWVudCBpbiB3aGljaCBpdCBpcyB0byBiZSBmb3VuZCAoaWYgbGVmdCBlbXB0eSwgdXNlIHRoZSBjdXJyZW50IGRvY3VtZW50KVxuICAgICAqIEByZXR1cm4gVGhlIERPTSBlbGVtZW50IHdpdGggdGhpcyBpZCwgb3IgbnVsbCwgaWYgbm9uZSBleGlzdHMgaW4gdGhlIGRvY3VtZW50LlxuICAgICAqL1xuICAgIGZsdWlkLmJ5SWQgPSBmdW5jdGlvbiAoaWQsIGRva2t1bWVudCkge1xuICAgICAgICBkb2trdW1lbnQgPSBkb2trdW1lbnQgJiYgZG9ra3VtZW50Lm5vZGVUeXBlID09PSA5ID8gZG9ra3VtZW50IDogZG9jdW1lbnQ7XG4gICAgICAgIHZhciBlbCA9IGRva2t1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgICAgIGlmIChlbCkge1xuICAgICAgICAvLyBVc2UgZWxlbWVudCBpZCBwcm9wZXJ0eSBoZXJlIHJhdGhlciB0aGFuIGF0dHJpYnV0ZSwgdG8gd29yayBhcm91bmQgRkxVSUQtMzk1M1xuICAgICAgICAgICAgaWYgKGVsLmlkICE9PSBpZCkge1xuICAgICAgICAgICAgICAgIGZsdWlkLmZhaWwoXCJQcm9ibGVtIGluIGRvY3VtZW50IHN0cnVjdHVyZSAtIHBpY2tlZCB1cCBlbGVtZW50IFwiICtcbiAgICAgICAgICAgICAgICAgICAgZmx1aWQuZHVtcEVsKGVsKSArIFwiIGZvciBpZCBcIiArIGlkICtcbiAgICAgICAgICAgICAgICAgICAgXCIgd2l0aG91dCB0aGlzIGlkIC0gbW9zdCBsaWtlbHkgdGhlIGVsZW1lbnQgaGFzIGEgbmFtZSB3aGljaCBjb25mbGljdHMgd2l0aCB0aGlzIGlkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaWQgYXR0cmlidXRlIGZyb20gYSBqUXVlcnkgb3IgcHVyZSBET00gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fHxFbGVtZW50fSBlbGVtZW50IHRoZSBlbGVtZW50IHRvIHJldHVybiB0aGUgaWQgYXR0cmlidXRlIGZvclxuICAgICAqL1xuICAgIGZsdWlkLmdldElkID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGZsdWlkLnVud3JhcChlbGVtZW50KS5pZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWxsb2NhdGUgYW4gaWQgdG8gdGhlIHN1cHBsaWVkIGVsZW1lbnQgaWYgaXQgaGFzIG5vbmUgYWxyZWFkeSwgYnkgYSBzaW1wbGVcbiAgICAgKiBzY2hlbWUgcmVzdWx0aW5nIGluIGlkcyBcImZsdWlkLWlkLW5ubm5cIiB3aGVyZSBubm5uIGlzIGFuIGluY3JlYXNpbmcgaW50ZWdlci5cbiAgICAgKi9cblxuICAgIGZsdWlkLmFsbG9jYXRlU2ltcGxlSWQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB2YXIgc2ltcGxlSWQgPSBcImZsdWlkLWlkLVwiICsgZmx1aWQuYWxsb2NhdGVHdWlkKCk7XG4gICAgICAgIGlmICghZWxlbWVudCB8fCBmbHVpZC5pc1ByaW1pdGl2ZShlbGVtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIHNpbXBsZUlkO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnQgPSBmbHVpZC51bndyYXAoZWxlbWVudCk7XG4gICAgICAgIGlmICghZWxlbWVudC5pZCkge1xuICAgICAgICAgICAgZWxlbWVudC5pZCA9IHNpbXBsZUlkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVtZW50LmlkO1xuICAgIH07XG5cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsdWlkLmFyaWFMYWJlbGxlclwiLCB7XG4gICAgICAgIGdyYWRlTmFtZXM6IFtcImZsdWlkLnZpZXdDb21wb25lbnRcIiwgXCJhdXRvSW5pdFwiXSxcbiAgICAgICAgbGFiZWxBdHRyaWJ1dGU6IFwiYXJpYS1sYWJlbFwiLFxuICAgICAgICBsaXZlUmVnaW9uTWFya3VwOiBcIjxkaXYgY2xhc3M9XFxcImxpdmVSZWdpb24gZmwtaGlkZGVuLWFjY2Vzc2libGVcXFwiIGFyaWEtbGl2ZT1cXFwicG9saXRlXFxcIj48L2Rpdj5cIixcbiAgICAgICAgbGl2ZVJlZ2lvbklkOiBcImZsdWlkLWFyaWFMYWJlbGxlci1saXZlUmVnaW9uXCIsXG4gICAgICAgIGludm9rZXJzOiB7XG4gICAgICAgICAgICBnZW5lcmF0ZUxpdmVFbGVtZW50OiB7XG4gICAgICAgICAgICAgICAgZnVuY05hbWU6IFwiZmx1aWQuYXJpYUxhYmVsbGVyLmdlbmVyYXRlTGl2ZUVsZW1lbnRcIixcbiAgICAgICAgICAgICAgICBhcmdzOiBcInt0aGF0fVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlOiB7XG4gICAgICAgICAgICAgICAgZnVuY05hbWU6IFwiZmx1aWQuYXJpYUxhYmVsbGVyLnVwZGF0ZVwiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtcInt0aGF0fVwiLCBcInthcmd1bWVudHN9LjBcIl1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbGlzdGVuZXJzOiB7XG4gICAgICAgICAgICBvbkNyZWF0ZToge1xuICAgICAgICAgICAgICAgIGZ1bmM6IFwie3RoYXR9LnVwZGF0ZVwiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtudWxsXVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgZmx1aWQuYXJpYUxhYmVsbGVyLnVwZGF0ZSA9IGZ1bmN0aW9uICh0aGF0LCBuZXdPcHRpb25zKSB7XG4gICAgICAgIG5ld09wdGlvbnMgPSBuZXdPcHRpb25zIHx8IHRoYXQub3B0aW9ucztcbiAgICAgICAgdGhhdC5jb250YWluZXIuYXR0cih0aGF0Lm9wdGlvbnMubGFiZWxBdHRyaWJ1dGUsIG5ld09wdGlvbnMudGV4dCk7XG4gICAgICAgIGlmIChuZXdPcHRpb25zLmR5bmFtaWNMYWJlbCkge1xuICAgICAgICAgICAgdmFyIGxpdmUgPSBmbHVpZC5qQnlJZCh0aGF0Lm9wdGlvbnMubGl2ZVJlZ2lvbklkKTtcbiAgICAgICAgICAgIGlmIChsaXZlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGxpdmUgPSB0aGF0LmdlbmVyYXRlTGl2ZUVsZW1lbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpdmUudGV4dChuZXdPcHRpb25zLnRleHQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZsdWlkLmFyaWFMYWJlbGxlci5nZW5lcmF0ZUxpdmVFbGVtZW50ID0gZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgICAgdmFyIGxpdmVFbCA9ICQodGhhdC5vcHRpb25zLmxpdmVSZWdpb25NYXJrdXApO1xuICAgICAgICBsaXZlRWwucHJvcChcImlkXCIsIHRoYXQub3B0aW9ucy5saXZlUmVnaW9uSWQpO1xuICAgICAgICAkKFwiYm9keVwiKS5hcHBlbmQobGl2ZUVsKTtcbiAgICAgICAgcmV0dXJuIGxpdmVFbDtcbiAgICB9O1xuXG4gICAgdmFyIExBQkVMX0tFWSA9IFwiYXJpYS1sYWJlbGxpbmdcIjtcblxuICAgIGZsdWlkLmdldEFyaWFMYWJlbGxlciA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQgPSAkKGVsZW1lbnQpO1xuICAgICAgICB2YXIgdGhhdCA9IGZsdWlkLmdldFNjb3BlZERhdGEoZWxlbWVudCwgTEFCRUxfS0VZKTtcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfTtcblxuICAgIC8qKiBNYW5hZ2VzIGFuIEFSSUEtbWVkaWF0ZWQgbGFiZWwgYXR0YWNoZWQgdG8gYSBnaXZlbiBET00gZWxlbWVudC4gQW5cbiAgICAgKiBhcmlhLWxhYmVsbGVkYnkgYXR0cmlidXRlIGFuZCB0YXJnZXQgbm9kZSBpcyBmYWJyaWNhdGVkIGluIHRoZSBkb2N1bWVudFxuICAgICAqIGlmIHRoZXkgZG8gbm90IGV4aXN0IGFscmVhZHksIGFuZCBhIFwibGl0dGxlIGNvbXBvbmVudFwiIGlzIHJldHVybmVkIGV4cG9zaW5nIGEgbWV0aG9kXG4gICAgICogXCJ1cGRhdGVcIiB0aGF0IGFsbG93cyB0aGUgdGV4dCB0byBiZSB1cGRhdGVkLiAqL1xuXG4gICAgZmx1aWQudXBkYXRlQXJpYUxhYmVsID0gZnVuY3Rpb24gKGVsZW1lbnQsIHRleHQsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBvcHRpb25zIHx8IHt9LCB7dGV4dDogdGV4dH0pO1xuICAgICAgICB2YXIgdGhhdCA9IGZsdWlkLmdldEFyaWFMYWJlbGxlcihlbGVtZW50KTtcbiAgICAgICAgaWYgKCF0aGF0KSB7XG4gICAgICAgICAgICB0aGF0ID0gZmx1aWQuYXJpYUxhYmVsbGVyKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgZmx1aWQuc2V0U2NvcGVkRGF0YShlbGVtZW50LCBMQUJFTF9LRVksIHRoYXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhhdC51cGRhdGUob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfTtcblxuICAgIC8qKiBcIkdsb2JhbCBEaXNtaXNzYWwgSGFuZGxlclwiIGZvciB0aGUgZW50aXJlIHBhZ2UuIEF0dGFjaGVzIGEgY2xpY2sgaGFuZGxlciB0byB0aGVcbiAgICAgKiBkb2N1bWVudCByb290IHRoYXQgd2lsbCBjYXVzZSBkaXNtaXNzYWwgb2YgYW55IGVsZW1lbnRzICh0eXBpY2FsbHkgZGlhbG9ncykgd2hpY2hcbiAgICAgKiBoYXZlIHJlZ2lzdGVyZWQgdGhlbXNlbHZlcy4gRGlzbWlzc2FsIHRocm91Z2ggdGhpcyByb3V0ZSB3aWxsIGF1dG9tYXRpY2FsbHkgY2xlYW4gdXBcbiAgICAgKiB0aGUgcmVjb3JkIC0gaG93ZXZlciwgdGhlIGRpc21pc3NlciB0aGVtc2VsdmVzIG11c3QgdGFrZSBjYXJlIHRvIGRlcmVnaXN0ZXIgaW4gdGhlIGNhc2VcbiAgICAgKiBkaXNtaXNzYWwgaXMgdHJpZ2dlcmVkIHRocm91Z2ggdGhlIGRpYWxvZyBpbnRlcmZhY2UgaXRzZWxmLiBUaGlzIGNvbXBvbmVudCBjYW4gYWxzbyBiZVxuICAgICAqIGF1dG9tYXRpY2FsbHkgY29uZmlndXJlZCBieSBmbHVpZC5kZWFkTWFuc0JsdXIgYnkgbWVhbnMgb2YgdGhlIFwiY2FuY2VsQnlEZWZhdWx0XCIgb3B0aW9uICovXG5cbiAgICB2YXIgZGlzbWlzc0xpc3QgPSB7fTtcblxuICAgICQoZG9jdW1lbnQpLmNsaWNrKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZmx1aWQucmVzb2x2ZUV2ZW50VGFyZ2V0KGV2ZW50KTtcbiAgICAgICAgd2hpbGUgKHRhcmdldCkge1xuICAgICAgICAgICAgaWYgKGRpc21pc3NMaXN0W3RhcmdldC5pZF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBmbHVpZC5lYWNoKGRpc21pc3NMaXN0LCBmdW5jdGlvbiAoZGlzbWlzc0Z1bmMsIGtleSkge1xuICAgICAgICAgICAgZGlzbWlzc0Z1bmMoZXZlbnQpO1xuICAgICAgICAgICAgZGVsZXRlIGRpc21pc3NMaXN0W2tleV07XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIC8vIFRPRE86IGV4dGVuZCBhIGNvbmZpZ3VyYWJsZSBlcXVpdmFsZW50IG9mIHRoZSBhYm92ZSBkZWFsaW5nIHdpdGggXCJmb2N1c2luXCIgZXZlbnRzXG5cbiAgICAvKiogQWNjZXB0cyBhIGZyZWUgaGFzaCBvZiBub2RlcyBhbmQgYW4gb3B0aW9uYWwgXCJkaXNtaXNzYWwgZnVuY3Rpb25cIi5cbiAgICAgKiBJZiBkaXNtaXNzRnVuYyBpcyBzZXQsIHRoaXMgXCJhcm1zXCIgdGhlIGRpc21pc3NhbCBzeXN0ZW0sIHN1Y2ggdGhhdCB3aGVuIGEgY2xpY2tcbiAgICAgKiBpcyByZWNlaXZlZCBPVVRTSURFIGFueSBvZiB0aGUgaGllcmFyY2h5IGNvdmVyZWQgYnkgXCJub2Rlc1wiLCB0aGUgZGlzbWlzc2FsIGZ1bmN0aW9uXG4gICAgICogd2lsbCBiZSBleGVjdXRlZC5cbiAgICAgKi9cbiAgICBmbHVpZC5nbG9iYWxEaXNtaXNzYWwgPSBmdW5jdGlvbiAobm9kZXMsIGRpc21pc3NGdW5jKSB7XG4gICAgICAgIGZsdWlkLmVhY2gobm9kZXMsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgLy8gRG9uJ3QgYm90aGVyIHRvIHVzZSB0aGUgcmVhbCBpZCBpZiBpdCBpcyBmcm9tIGEgZm9yZWlnbiBkb2N1bWVudCAtIHdlIHdpbGwgbmV2ZXIgcmVjZWl2ZSBldmVudHNcbiAgICAgICAgICAvLyBmcm9tIGl0IGRpcmVjdGx5IGluIGFueSBjYXNlIC0gYW5kIGZvcmVpZ24gZG9jdW1lbnRzIG1heSBiZSB1bmRlciB0aGUgY29udHJvbCBvZiBtYWxpZ24gZmllbmRzXG4gICAgICAgICAgLy8gc3VjaCBhcyB0aW55TUNFIHdobyBhbGxvY2F0ZSB0aGUgc2FtZSBpZCB0byBldmVyeXRoaW5nXG4gICAgICAgICAgICB2YXIgaWQgPSBmbHVpZC51bndyYXAobm9kZSkub3duZXJEb2N1bWVudCA9PT0gZG9jdW1lbnQ/IGZsdWlkLmFsbG9jYXRlU2ltcGxlSWQobm9kZSkgOiBmbHVpZC5hbGxvY2F0ZUd1aWQoKTtcbiAgICAgICAgICAgIGlmIChkaXNtaXNzRnVuYykge1xuICAgICAgICAgICAgICAgIGRpc21pc3NMaXN0W2lkXSA9IGRpc21pc3NGdW5jO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGRpc21pc3NMaXN0W2lkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKiBQcm92aWRlcyBhbiBhYnN0cmFjdGlvbiBmb3IgZGV0ZXJtaW5nIHRoZSBjdXJyZW50IHRpbWUuXG4gICAgICogVGhpcyBpcyB0byBwcm92aWRlIGEgZml4IGZvciBGTFVJRC00NzYyLCB3aGVyZSBJRTYgLSBJRThcbiAgICAgKiBkbyBub3Qgc3VwcG9ydCBEYXRlLm5vdygpLlxuICAgICAqL1xuICAgIGZsdWlkLm5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIERhdGUubm93ID8gRGF0ZS5ub3coKSA6IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgfTtcblxuXG4gICAgLyoqIFNldHMgYW4gaW50ZXJhdGlvbiBvbiBhIHRhcmdldCBjb250cm9sLCB3aGljaCBtb3JhbGx5IG1hbmFnZXMgYSBcImJsdXJcIiBmb3JcbiAgICAgKiBhIHBvc3NpYmx5IGNvbXBvc2l0ZSByZWdpb24uXG4gICAgICogQSB0aW1lZCBibHVyIGxpc3RlbmVyIGlzIHNldCBvbiB0aGUgY29udHJvbCwgd2hpY2ggd2FpdHMgZm9yIGEgc2hvcnQgcGVyaW9kIG9mXG4gICAgICogdGltZSAob3B0aW9ucy5kZWxheSwgZGVmYXVsdHMgdG8gMTUwbXMpIHRvIGRpc2NvdmVyIHdoZXRoZXIgdGhlIHJlYXNvbiBmb3IgdGhlXG4gICAgICogYmx1ciBpbnRlcmFjdGlvbiBpcyB0aGF0IGVpdGhlciBhIGZvY3VzIG9yIGNsaWNrIGlzIGJlaW5nIHNlcnZpY2VkIG9uIGEgbm9taW5hdGVkXG4gICAgICogc2V0IG9mIFwiZXhjbHVzaW9uc1wiIChvcHRpb25zLmV4Y2x1c2lvbnMsIGEgZnJlZSBoYXNoIG9mIGVsZW1lbnRzIG9yIGpRdWVyaWVzKS5cbiAgICAgKiBJZiBubyBzdWNoIGV2ZW50IGlzIHJlY2VpdmVkIHdpdGhpbiB0aGUgd2luZG93LCBvcHRpb25zLmhhbmRsZXIgd2lsbCBiZSBjYWxsZWRcbiAgICAgKiB3aXRoIHRoZSBhcmd1bWVudCBcImNvbnRyb2xcIiwgdG8gc2VydmljZSB3aGF0ZXZlciBpbnRlcmFjdGlvbiBpcyByZXF1aXJlZCBvZiB0aGVcbiAgICAgKiBibHVyLlxuICAgICAqL1xuXG4gICAgZmx1aWQuZGVhZE1hbnNCbHVyID0gZnVuY3Rpb24gKGNvbnRyb2wsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBzaG91bGQgYmUgcmV3cml0dGVuIGFzIGEgcHJvcGVyIGNvbXBvbmVudFxuICAgICAgICB2YXIgdGhhdCA9IHtvcHRpb25zOiAkLmV4dGVuZCh0cnVlLCB7fSwgZmx1aWQuZGVmYXVsdHMoXCJmbHVpZC5kZWFkTWFuc0JsdXJcIiksIG9wdGlvbnMpfTtcbiAgICAgICAgdGhhdC5ibHVyUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGF0Lmxhc3RDYW5jZWwgPSAwO1xuICAgICAgICB0aGF0LmNhbmNlbGxlciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgZmx1aWQubG9nKFwiQ2FuY2VsbGF0aW9uIHRocm91Z2ggXCIgKyBldmVudC50eXBlICsgXCIgb24gXCIgKyBmbHVpZC5kdW1wRWwoZXZlbnQudGFyZ2V0KSk7XG4gICAgICAgICAgICB0aGF0Lmxhc3RDYW5jZWwgPSBmbHVpZC5ub3coKTtcbiAgICAgICAgICAgIHRoYXQuYmx1clBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhhdC5ub3RlUHJvY2VlZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZmx1aWQuZ2xvYmFsRGlzbWlzc2FsKHRoYXQub3B0aW9ucy5leGNsdXNpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhhdC5yZUFybSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZsdWlkLmdsb2JhbERpc21pc3NhbCh0aGF0Lm9wdGlvbnMuZXhjbHVzaW9ucywgdGhhdC5wcm9jZWVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhhdC5hZGRFeGNsdXNpb24gPSBmdW5jdGlvbiAoZXhjbHVzaW9ucykge1xuICAgICAgICAgICAgZmx1aWQuZ2xvYmFsRGlzbWlzc2FsKGV4Y2x1c2lvbnMsIHRoYXQucHJvY2VlZCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoYXQucHJvY2VlZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgZmx1aWQubG9nKFwiRGlyZWN0IHByb2NlZWQgdGhyb3VnaCBcIiArIGV2ZW50LnR5cGUgKyBcIiBvbiBcIiArIGZsdWlkLmR1bXBFbChldmVudC50YXJnZXQpKTtcbiAgICAgICAgICAgIHRoYXQuYmx1clBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoYXQub3B0aW9ucy5oYW5kbGVyKGNvbnRyb2wpO1xuICAgICAgICB9O1xuICAgICAgICBmbHVpZC5lYWNoKHRoYXQub3B0aW9ucy5leGNsdXNpb25zLCBmdW5jdGlvbiAoZXhjbHVzaW9uKSB7XG4gICAgICAgICAgICBleGNsdXNpb24gPSAkKGV4Y2x1c2lvbik7XG4gICAgICAgICAgICBmbHVpZC5lYWNoKGV4Y2x1c2lvbiwgZnVuY3Rpb24gKGV4Y2x1ZGVFbCkge1xuICAgICAgICAgICAgICAgICQoZXhjbHVkZUVsKS5iaW5kKFwiZm9jdXNpblwiLCB0aGF0LmNhbmNlbGxlcikuXG4gICAgICAgICAgICAgICAgICAgIGJpbmQoXCJmbHVpZC1mb2N1c1wiLCB0aGF0LmNhbmNlbGxlcikuXG4gICAgICAgICAgICAgICAgICAgIGNsaWNrKHRoYXQuY2FuY2VsbGVyKS5tb3VzZWRvd24odGhhdC5jYW5jZWxsZXIpO1xuICAgIC8vIE1vdXNlZG93biBpcyBhZGRlZCBmb3IgRkxVSUQtNDIxMiwgYXMgYSByZXN1bHQgb2YgQ2hyb21lIGJ1ZyA2NzU5LCAxNDIwNFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXRoYXQub3B0aW9ucy5jYW5jZWxCeURlZmF1bHQpIHtcbiAgICAgICAgICAgICQoY29udHJvbCkuYmluZChcImZvY3Vzb3V0XCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIGZsdWlkLmxvZyhcIlN0YXJ0aW5nIGJsdXIgdGltZXIgZm9yIGVsZW1lbnQgXCIgKyBmbHVpZC5kdW1wRWwoZXZlbnQudGFyZ2V0KSk7XG4gICAgICAgICAgICAgICAgdmFyIG5vdyA9IGZsdWlkLm5vdygpO1xuICAgICAgICAgICAgICAgIGZsdWlkLmxvZyhcImJhY2sgZGVsYXk6IFwiICsgKG5vdyAtIHRoYXQubGFzdENhbmNlbCkpO1xuICAgICAgICAgICAgICAgIGlmIChub3cgLSB0aGF0Lmxhc3RDYW5jZWwgPiB0aGF0Lm9wdGlvbnMuYmFja0RlbGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuYmx1clBlbmRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQuYmx1clBlbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQub3B0aW9ucy5oYW5kbGVyKGNvbnRyb2wpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgdGhhdC5vcHRpb25zLmRlbGF5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhhdC5yZUFybSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgIH07XG5cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsdWlkLmRlYWRNYW5zQmx1clwiLCB7XG4gICAgICAgIGRlbGF5OiAxNTAsXG4gICAgICAgIGJhY2tEZWxheTogMTAwXG4gICAgfSk7XG5cbn0pKGpRdWVyeSwgZmx1aWRfMl8wKTtcbjsvKlxuQ29weXJpZ2h0IDIwMTAtMjAxMSBPQ0FEIFVuaXZlcnNpdHlcbkNvcHlyaWdodCAyMDEwLTIwMTEgTHVjZW5kbyBEZXZlbG9wbWVudCBMdGQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBFZHVjYXRpb25hbCBDb21tdW5pdHkgTGljZW5zZSAoRUNMKSwgVmVyc2lvbiAyLjAgb3IgdGhlIE5ld1xuQlNEIGxpY2Vuc2UuIFlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCBvbmUgdGhlc2VcbkxpY2Vuc2VzLlxuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIEVDTCAyLjAgTGljZW5zZSBhbmQgQlNEIExpY2Vuc2UgYXRcbmh0dHBzOi8vZ2l0aHViLmNvbS9mbHVpZC1wcm9qZWN0L2luZnVzaW9uL3Jhdy9tYXN0ZXIvSW5mdXNpb24tTElDRU5TRS50eHRcbiovXG5cbnZhciBmbHVpZF8yXzAgPSBmbHVpZF8yXzAgfHwge307XG5cbihmdW5jdGlvbiAoJCwgZmx1aWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8qKiBGcmFtZXdvcmstZ2xvYmFsIGNhY2hpbmcgc3RhdGUgZm9yIGZsdWlkLmZldGNoUmVzb3VyY2VzICoqL1xuXG4gICAgdmFyIHJlc291cmNlQ2FjaGUgPSB7fTtcblxuICAgIHZhciBwZW5kaW5nQ2xhc3MgPSB7fTtcblxuICAgIC8qKiBBY2NlcHRzIGEgaGFzaCBvZiBzdHJ1Y3R1cmVzIHdpdGggZnJlZSBrZXlzLCB3aGVyZSBlYWNoIGVudHJ5IGhhcyBlaXRoZXJcbiAgICAgKiBocmVmL3VybCBvciBub2RlSWQgc2V0IC0gb24gY29tcGxldGlvbiwgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgcG9wdWxhdGVkXG4gICAgICogc3RydWN0dXJlIHdpdGggZmV0Y2hlZCByZXNvdXJjZSB0ZXh0IGluIHRoZSBmaWVsZCBcInJlc291cmNlVGV4dFwiIGZvciBlYWNoXG4gICAgICogZW50cnkuIEVhY2ggc3RydWN0dXJlIG1heSBjb250YWluIFwib3B0aW9uc1wiIGhvbGRpbmcgcmF3IG9wdGlvbnMgdG8gYmUgZm9yd2FyZGVkXG4gICAgICogdG8galF1ZXJ5LmFqYXgoKS5cbiAgICAgKi9cblxuICAgIGZsdWlkLmZldGNoUmVzb3VyY2VzID0gZnVuY3Rpb24ocmVzb3VyY2VTcGVjcywgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHRoYXQgPSBmbHVpZC5pbml0TGl0dGxlQ29tcG9uZW50KFwiZmx1aWQuZmV0Y2hSZXNvdXJjZXNcIiwgb3B0aW9ucyk7XG4gICAgICAgIHRoYXQucmVzb3VyY2VTcGVjcyA9IHJlc291cmNlU3BlY3M7XG4gICAgICAgIHRoYXQuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgdGhhdC5vcGVyYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmbHVpZC5mZXRjaFJlc291cmNlcy5mZXRjaFJlc291cmNlc0ltcGwodGhhdCk7XG4gICAgICAgIH07XG4gICAgICAgIGZsdWlkLmVhY2gocmVzb3VyY2VTcGVjcywgZnVuY3Rpb24ocmVzb3VyY2VTcGVjLCBrZXkpIHtcbiAgICAgICAgICAgIHJlc291cmNlU3BlYy5yZWN1cnNlRmlyZXIgPSBmbHVpZC5tYWtlRXZlbnRGaXJlcih7bmFtZTogXCJJL08gY29tcGxldGlvbiBmb3IgcmVzb3VyY2UgXFxcIlwiICsga2V5ICsgXCJcXFwiXCJ9KTtcbiAgICAgICAgICAgIHJlc291cmNlU3BlYy5yZWN1cnNlRmlyZXIuYWRkTGlzdGVuZXIodGhhdC5vcGVyYXRlKTtcbiAgICAgICAgICAgIGlmIChyZXNvdXJjZVNwZWMudXJsICYmICFyZXNvdXJjZVNwZWMuaHJlZikge1xuICAgICAgICAgICAgICAgIHJlc291cmNlU3BlYy5ocmVmID0gcmVzb3VyY2VTcGVjLnVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGF0Lm9wdGlvbnMuYW1hbGdhbWF0ZUNsYXNzZXMpIHtcbiAgICAgICAgICAgIGZsdWlkLmZldGNoUmVzb3VyY2VzLmFtYWxnYW1hdGVDbGFzc2VzKHJlc291cmNlU3BlY3MsIHRoYXQub3B0aW9ucy5hbWFsZ2FtYXRlQ2xhc3NlcywgdGhhdC5vcGVyYXRlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGF0Lm9wZXJhdGUoKTtcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfTtcblxuICAgIC8qXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyB1bnN1cHBvcnRlZDogSXQgaXMgbm90IHJlYWxseSBpbnRlbmRlZCBmb3IgdXNlIGJ5IGltcGxlbWVudG9ycy5cbiAgICAgKi9cbiAgICAvLyBBZGQgXCJzeW50aGV0aWNcIiBlbGVtZW50cyBvZiAqdGhpcyogcmVzb3VyY2VTcGVjIGxpc3QgY29ycmVzcG9uZGluZyB0byBhbnlcbiAgICAvLyBzdGlsbCBwZW5kaW5nIGVsZW1lbnRzIG1hdGNoaW5nIHRoZSBQUk9MRVBUSUNLIENMQVNTIFNQRUNJRklDQVRJT04gc3VwcGxpZWRcbiAgICBmbHVpZC5mZXRjaFJlc291cmNlcy5hbWFsZ2FtYXRlQ2xhc3NlcyA9IGZ1bmN0aW9uKHNwZWNzLCBjbGFzc2VzLCBvcGVyYXRvcikge1xuICAgICAgICBmbHVpZC5lYWNoKGNsYXNzZXMsIGZ1bmN0aW9uKGNsYXp6KSB7XG4gICAgICAgICAgICB2YXIgcGVuZGluZyA9IHBlbmRpbmdDbGFzc1tjbGF6el07XG4gICAgICAgICAgICBmbHVpZC5lYWNoKHBlbmRpbmcsIGZ1bmN0aW9uKHBlbmRpbmdyZWMsIGNhbm9uKSB7XG4gICAgICAgICAgICAgICAgc3BlY3NbY2xhenorXCIhXCIrY2Fub25dID0gcGVuZGluZ3JlYztcbiAgICAgICAgICAgICAgICBwZW5kaW5ncmVjLnJlY3Vyc2VGaXJlci5hZGRMaXN0ZW5lcihvcGVyYXRvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyB1bnN1cHBvcnRlZDogSXQgaXMgbm90IHJlYWxseSBpbnRlbmRlZCBmb3IgdXNlIGJ5IGltcGxlbWVudG9ycy5cbiAgICAgKi9cbiAgICBmbHVpZC5mZXRjaFJlc291cmNlcy50aW1lU3VjY2Vzc0NhbGxiYWNrID0gZnVuY3Rpb24ocmVzb3VyY2VTcGVjKSB7XG4gICAgICAgIGlmIChyZXNvdXJjZVNwZWMudGltZVN1Y2Nlc3MgJiYgcmVzb3VyY2VTcGVjLm9wdGlvbnMgJiYgcmVzb3VyY2VTcGVjLm9wdGlvbnMuc3VjY2Vzcykge1xuICAgICAgICAgICAgdmFyIHN1Y2Nlc3MgPSByZXNvdXJjZVNwZWMub3B0aW9ucy5zdWNjZXNzO1xuICAgICAgICAgICAgcmVzb3VyY2VTcGVjLm9wdGlvbnMuc3VjY2VzcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgIHZhciByZXQgPSBzdWNjZXNzLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgZmx1aWQubG9nKFwiRXh0ZXJuYWwgY2FsbGJhY2sgZm9yIFVSTCBcIiArIHJlc291cmNlU3BlYy5ocmVmICsgXCIgY29tcGxldGVkIC0gY2FsbGJhY2sgdGltZTogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gc3RhcnRUaW1lLmdldFRpbWUoKSkgKyBcIm1zXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFRPRE86IEludGVncmF0ZSBwdW5jaC10aHJvdWdoIGZyb20gb2xkIEVuZ2FnZSBpbXBsZW1lbnRhdGlvblxuICAgIGZ1bmN0aW9uIGNhbm9uVXJsKHVybCkge1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cblxuICAgIGZsdWlkLmZldGNoUmVzb3VyY2VzLmNsZWFyUmVzb3VyY2VDYWNoZSA9IGZ1bmN0aW9uKHVybCkge1xuICAgICAgICBpZiAodXJsKSB7XG4gICAgICAgICAgICBkZWxldGUgcmVzb3VyY2VDYWNoZVtjYW5vblVybCh1cmwpXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZsdWlkLmNsZWFyKHJlc291cmNlQ2FjaGUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyB1bnN1cHBvcnRlZDogSXQgaXMgbm90IHJlYWxseSBpbnRlbmRlZCBmb3IgdXNlIGJ5IGltcGxlbWVudG9ycy5cbiAgICAgKi9cbiAgICBmbHVpZC5mZXRjaFJlc291cmNlcy5oYW5kbGVDYWNoZWRSZXF1ZXN0ID0gZnVuY3Rpb24ocmVzb3VyY2VTcGVjLCByZXNwb25zZSkge1xuICAgICAgICB2YXIgY2Fub24gPSBjYW5vblVybChyZXNvdXJjZVNwZWMuaHJlZik7XG4gICAgICAgIHZhciBjYWNoZWQgPSByZXNvdXJjZUNhY2hlW2Nhbm9uXTtcbiAgICAgICAgaWYgKGNhY2hlZC4kJGZpcmVyJCQpIHtcbiAgICAgICAgICAgIGZsdWlkLmxvZyhcIkhhbmRsaW5nIHJlcXVlc3QgZm9yIFwiICsgY2Fub24gKyBcIiBmcm9tIGNhY2hlXCIpO1xuICAgICAgICAgICAgdmFyIGZldGNoQ2xhc3MgPSByZXNvdXJjZVNwZWMuZmV0Y2hDbGFzcztcbiAgICAgICAgICAgIGlmIChmZXRjaENsYXNzICYmIHBlbmRpbmdDbGFzc1tmZXRjaENsYXNzXSkge1xuICAgICAgICAgICAgICAgIGZsdWlkLmxvZyhcIkNsZWFyaW5nIHBlbmRpbmdDbGFzcyBlbnRyeSBmb3IgY2xhc3MgXCIgKyBmZXRjaENsYXNzKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgcGVuZGluZ0NsYXNzW2ZldGNoQ2xhc3NdW2Nhbm9uXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc291cmNlQ2FjaGVbY2Fub25dID0gcmVzcG9uc2U7XG4gICAgICAgICAgICBjYWNoZWQuZmlyZShyZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLypcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHVuc3VwcG9ydGVkOiBJdCBpcyBub3QgcmVhbGx5IGludGVuZGVkIGZvciB1c2UgYnkgaW1wbGVtZW50b3JzLlxuICAgICAqL1xuICAgIGZsdWlkLmZldGNoUmVzb3VyY2VzLmNvbXBsZXRlUmVxdWVzdCA9IGZ1bmN0aW9uKHRoaXNTcGVjKSB7XG4gICAgICAgIHRoaXNTcGVjLnF1ZXVlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzU3BlYy5jb21wbGV0ZVRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBmbHVpZC5sb2coXCJSZXF1ZXN0IHRvIFVSTCBcIiArIHRoaXNTcGVjLmhyZWYgKyBcIiBjb21wbGV0ZWQgLSB0b3RhbCBlbGFwc2VkIHRpbWU6IFwiICtcbiAgICAgICAgICAgICh0aGlzU3BlYy5jb21wbGV0ZVRpbWUuZ2V0VGltZSgpIC0gdGhpc1NwZWMuaW5pdFRpbWUuZ2V0VGltZSgpKSArIFwibXNcIik7XG4gICAgICAgIHRoaXNTcGVjLnJlY3Vyc2VGaXJlci5maXJlKCk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyB1bnN1cHBvcnRlZDogSXQgaXMgbm90IHJlYWxseSBpbnRlbmRlZCBmb3IgdXNlIGJ5IGltcGxlbWVudG9ycy5cbiAgICAgKi9cbiAgICBmbHVpZC5mZXRjaFJlc291cmNlcy5tYWtlUmVzb3VyY2VDYWxsYmFjayA9IGZ1bmN0aW9uKHRoaXNTcGVjKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHRoaXNTcGVjLnJlc291cmNlVGV4dCA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIHRoaXNTcGVjLnJlc291cmNlS2V5ID0gdGhpc1NwZWMuaHJlZjtcbiAgICAgICAgICAgICAgICBpZiAodGhpc1NwZWMuZm9yY2VDYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICBmbHVpZC5mZXRjaFJlc291cmNlcy5oYW5kbGVDYWNoZWRSZXF1ZXN0KHRoaXNTcGVjLCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZsdWlkLmZldGNoUmVzb3VyY2VzLmNvbXBsZXRlUmVxdWVzdCh0aGlzU3BlYyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKHJlc3BvbnNlLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikge1xuICAgICAgICAgICAgICAgIHRoaXNTcGVjLmZldGNoRXJyb3IgPSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0U3RhdHVzOiByZXNwb25zZS50ZXh0U3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICBlcnJvclRocm93bjogZXJyb3JUaHJvd25cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGZsdWlkLmZldGNoUmVzb3VyY2VzLmNvbXBsZXRlUmVxdWVzdCh0aGlzU3BlYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfTtcbiAgICB9O1xuXG5cbiAgICAvKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgdW5zdXBwb3J0ZWQ6IEl0IGlzIG5vdCByZWFsbHkgaW50ZW5kZWQgZm9yIHVzZSBieSBpbXBsZW1lbnRvcnMuXG4gICAgICovXG4gICAgZmx1aWQuZmV0Y2hSZXNvdXJjZXMuaXNzdWVDYWNoZWRSZXF1ZXN0ID0gZnVuY3Rpb24ocmVzb3VyY2VTcGVjLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBjYW5vbiA9IGNhbm9uVXJsKHJlc291cmNlU3BlYy5ocmVmKTtcbiAgICAgICAgdmFyIGNhY2hlZCA9IHJlc291cmNlQ2FjaGVbY2Fub25dO1xuICAgICAgICBpZiAoIWNhY2hlZCkge1xuICAgICAgICAgICAgZmx1aWQubG9nKFwiRmlyc3QgcmVxdWVzdCBmb3IgY2FjaGVkIHJlc291cmNlIHdpdGggdXJsIFwiICsgY2Fub24pO1xuICAgICAgICAgICAgY2FjaGVkID0gZmx1aWQubWFrZUV2ZW50RmlyZXIoe25hbWU6IFwiY2FjaGUgbm90aWZpZXIgZm9yIHJlc291cmNlIFVSTCBcIiArIGNhbm9ufSk7XG4gICAgICAgICAgICBjYWNoZWQuJCRmaXJlciQkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc291cmNlQ2FjaGVbY2Fub25dID0gY2FjaGVkO1xuICAgICAgICAgICAgdmFyIGZldGNoQ2xhc3MgPSByZXNvdXJjZVNwZWMuZmV0Y2hDbGFzcztcbiAgICAgICAgICAgIGlmIChmZXRjaENsYXNzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwZW5kaW5nQ2xhc3NbZmV0Y2hDbGFzc10pIHtcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ0NsYXNzW2ZldGNoQ2xhc3NdID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBlbmRpbmdDbGFzc1tmZXRjaENsYXNzXVtjYW5vbl0gPSByZXNvdXJjZVNwZWM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpb25zLmNhY2hlID0gZmFsc2U7IC8vIFRPRE86IEdldHRpbmcgd2VpcmQgXCJub3QgbW9kaWZpZWRcIiBpc3N1ZXMgb24gRmlyZWZveFxuICAgICAgICAgICAgJC5hamF4KG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFjYWNoZWQuJCRmaXJlciQkKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zdWNjZXNzKGNhY2hlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmbHVpZC5sb2coXCJSZXF1ZXN0IGZvciBjYWNoZWQgcmVzb3VyY2Ugd2hpY2ggaXMgaW4gZmxpZ2h0OiB1cmwgXCIgKyBjYW5vbik7XG4gICAgICAgICAgICAgICAgY2FjaGVkLmFkZExpc3RlbmVyKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc3VjY2VzcyhyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLypcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHVuc3VwcG9ydGVkOiBJdCBpcyBub3QgcmVhbGx5IGludGVuZGVkIGZvciB1c2UgYnkgaW1wbGVtZW50b3JzLlxuICAgICAqL1xuICAgIC8vIENvbXBvc2UgY2FsbGJhY2tzIGluIHN1Y2ggYSB3YXkgdGhhdCB0aGUgMm5kLCBtYXJrZWQgXCJleHRlcm5hbFwiIHdpbGwgYmUgYXBwbGllZFxuICAgIC8vIGZpcnN0IGlmIGl0IGV4aXN0cywgYnV0IGluIGFsbCBjYXNlcywgdGhlIGZpcnN0LCBtYXJrZWQgaW50ZXJuYWwsIHdpbGwgYmVcbiAgICAvLyBDQUxMRUQgV0lUSE9VVCBGQUlMXG4gICAgZmx1aWQuZmV0Y2hSZXNvdXJjZXMuY29tcG9zZUNhbGxiYWNrcyA9IGZ1bmN0aW9uIChpbnRlcm5hbCwgZXh0ZXJuYWwpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVybmFsID8gKGludGVybmFsID9cbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBleHRlcm5hbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBmbHVpZC5sb2coXCJFeGNlcHRpb24gYXBwbHlpbmcgZXh0ZXJuYWwgZmV0Y2hSZXNvdXJjZXMgY2FsbGJhY2s6IFwiICsgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnRlcm5hbC5hcHBseShudWxsLCBhcmd1bWVudHMpOyAvLyBjYWxsIHRoZSBpbnRlcm5hbCBjYWxsYmFjayB3aXRob3V0IGZhaWxcbiAgICAgICAgfSA6IGV4dGVybmFsICkgOiBpbnRlcm5hbDtcbiAgICB9O1xuXG4gICAgLy8gdW5zdXBwb3J0ZWQsIE5PTi1BUEkgZnVuY3Rpb25cbiAgICBmbHVpZC5mZXRjaFJlc291cmNlcy5jb21wb3NlUG9saWN5ID0gZnVuY3Rpb24odGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIGZsdWlkLmZldGNoUmVzb3VyY2VzLmNvbXBvc2VDYWxsYmFja3ModGFyZ2V0LCBzb3VyY2UpO1xuICAgIH07XG5cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsdWlkLmZldGNoUmVzb3VyY2VzLmlzc3VlUmVxdWVzdFwiLCB7XG4gICAgICAgIG1lcmdlUG9saWN5OiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmbHVpZC5mZXRjaFJlc291cmNlcy5jb21wb3NlUG9saWN5LFxuICAgICAgICAgICAgZXJyb3I6IGZsdWlkLmZldGNoUmVzb3VyY2VzLmNvbXBvc2VQb2xpY3ksXG4gICAgICAgICAgICB1cmw6IFwicmV2ZXJzZVwiXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIHVuc3VwcG9ydGVkLCBOT04tQVBJIGZ1bmN0aW9uXG4gICAgZmx1aWQuZmV0Y2hSZXNvdXJjZXMuaXNzdWVSZXF1ZXN0ID0gZnVuY3Rpb24ocmVzb3VyY2VTcGVjLCBrZXkpIHtcbiAgICAgICAgdmFyIHRoaXNDYWxsYmFjayA9IGZsdWlkLmZldGNoUmVzb3VyY2VzLm1ha2VSZXNvdXJjZUNhbGxiYWNrKHJlc291cmNlU3BlYyk7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgdXJsOiAgICAgcmVzb3VyY2VTcGVjLmhyZWYsXG4gICAgICAgICAgICBzdWNjZXNzOiB0aGlzQ2FsbGJhY2suc3VjY2VzcyxcbiAgICAgICAgICAgIGVycm9yOiAgIHRoaXNDYWxsYmFjay5lcnJvcixcbiAgICAgICAgICAgIGRhdGFUeXBlOiByZXNvdXJjZVNwZWMuZGF0YVR5cGUgfHwgXCJ0ZXh0XCJcbiAgICAgICAgfTtcbiAgICAgICAgZmx1aWQuZmV0Y2hSZXNvdXJjZXMudGltZVN1Y2Nlc3NDYWxsYmFjayhyZXNvdXJjZVNwZWMpO1xuICAgICAgICBvcHRpb25zID0gZmx1aWQubWVyZ2UoZmx1aWQuZGVmYXVsdHMoXCJmbHVpZC5mZXRjaFJlc291cmNlcy5pc3N1ZVJlcXVlc3RcIikubWVyZ2VQb2xpY3ksXG4gICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucywgcmVzb3VyY2VTcGVjLm9wdGlvbnMpO1xuICAgICAgICByZXNvdXJjZVNwZWMucXVldWVkID0gdHJ1ZTtcbiAgICAgICAgcmVzb3VyY2VTcGVjLmluaXRUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgZmx1aWQubG9nKFwiUmVxdWVzdCB3aXRoIGtleSBcIiArIGtleSArIFwiIHF1ZXVlZCBmb3IgXCIgKyByZXNvdXJjZVNwZWMuaHJlZik7XG5cbiAgICAgICAgaWYgKHJlc291cmNlU3BlYy5mb3JjZUNhY2hlKSB7XG4gICAgICAgICAgICBmbHVpZC5mZXRjaFJlc291cmNlcy5pc3N1ZUNhY2hlZFJlcXVlc3QocmVzb3VyY2VTcGVjLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICQuYWpheChvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmbHVpZC5mZXRjaFJlc291cmNlcy5mZXRjaFJlc291cmNlc0ltcGwgPSBmdW5jdGlvbih0aGF0KSB7XG4gICAgICAgIHZhciBjb21wbGV0ZSA9IHRydWU7XG4gICAgICAgIHZhciBhbGxTeW5jID0gdHJ1ZTtcbiAgICAgICAgdmFyIHJlc291cmNlU3BlY3MgPSB0aGF0LnJlc291cmNlU3BlY3M7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiByZXNvdXJjZVNwZWNzKSB7XG4gICAgICAgICAgICB2YXIgcmVzb3VyY2VTcGVjID0gcmVzb3VyY2VTcGVjc1trZXldO1xuICAgICAgICAgICAgaWYgKCFyZXNvdXJjZVNwZWMub3B0aW9ucyB8fCByZXNvdXJjZVNwZWMub3B0aW9ucy5hc3luYykge1xuICAgICAgICAgICAgICAgIGFsbFN5bmMgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXNvdXJjZVNwZWMuaHJlZiAmJiAhcmVzb3VyY2VTcGVjLmNvbXBsZXRlVGltZSkge1xuICAgICAgICAgICAgICAgIGlmICghcmVzb3VyY2VTcGVjLnF1ZXVlZCkge1xuICAgICAgICAgICAgICAgICAgICBmbHVpZC5mZXRjaFJlc291cmNlcy5pc3N1ZVJlcXVlc3QocmVzb3VyY2VTcGVjLCBrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzb3VyY2VTcGVjLnF1ZXVlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlc291cmNlU3BlYy5ub2RlSWQgJiYgIXJlc291cmNlU3BlYy5yZXNvdXJjZVRleHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHJlc291cmNlU3BlYy5ub2RlSWQpO1xuICAgICAgICAgICAgICAgIC8vIHVwZ3JhZGUgdGhpcyB0byBzb21laG93IGRldGVjdCB3aGV0aGVyIG5vZGUgaXMgXCJhcm1vdXJlZFwiIHNvbWVob3dcbiAgICAgICAgICAgICAgICAvLyB3aXRoIGNvbW1lbnQgb3IgQ0RBVEEgd3JhcHBpbmdcbiAgICAgICAgICAgICAgICByZXNvdXJjZVNwZWMucmVzb3VyY2VUZXh0ID0gZmx1aWQuZG9tLmdldEVsZW1lbnRUZXh0KG5vZGUpO1xuICAgICAgICAgICAgICAgIHJlc291cmNlU3BlYy5yZXNvdXJjZUtleSA9IHJlc291cmNlU3BlYy5ub2RlSWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXBsZXRlICYmIHRoYXQuY2FsbGJhY2sgJiYgIXRoYXQuY2FsbGJhY2tDYWxsZWQpIHtcbiAgICAgICAgICAgIHRoYXQuY2FsbGJhY2tDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCQuYnJvd3Nlci5tb3ppbGxhICYmICFhbGxTeW5jKSB7XG4gICAgICAgICAgICAgICAgLy8gRGVmZXIgdGhpcyBjYWxsYmFjayB0byBhdm9pZCBkZWJ1Z2dpbmcgcHJvYmxlbXMgb24gRmlyZWZveFxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuY2FsbGJhY2socmVzb3VyY2VTcGVjcyk7XG4gICAgICAgICAgICAgICAgfSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGF0LmNhbGxiYWNrKHJlc291cmNlU3BlY3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFRPRE86IFRoaXMgZnJhbWV3b3JrIGZ1bmN0aW9uIGlzIGEgc3RvcC1nYXAgYmVmb3JlIHRoZSBcImdpbmdlciB3b3JsZFwiIGlzIGNhcGFibGUgb2ZcbiAgICAvLyBhc3luY2hyb25vdXMgaW5zdGFudGlhdGlvbi4gSXQgY3VycmVudGx5IHBlcmZvcm1zIHZlcnkgcG9vciBmaWRlbGl0eSBleHBhbnNpb24gb2YgYVxuICAgIC8vIGNvbXBvbmVudCdzIG9wdGlvbnMgdG8gZGlzY292ZXIgXCJyZXNvdXJjZXNcIiBvbmx5IGhlbGQgaW4gdGhlIHN0YXRpYyBlbnZpcm9ubWVudFxuICAgIGZsdWlkLmZldGNoUmVzb3VyY2VzLnByaW1lQ2FjaGVGcm9tUmVzb3VyY2VzID0gZnVuY3Rpb24oY29tcG9uZW50TmFtZSkge1xuICAgICAgICB2YXIgcmVzb3VyY2VzID0gZmx1aWQuZGVmYXVsdHMoY29tcG9uZW50TmFtZSkucmVzb3VyY2VzO1xuICAgICAgICB2YXIgZXhwYW5kZWQgPSAoZmx1aWQuZXhwYW5kT3B0aW9ucyA/IGZsdWlkLmV4cGFuZE9wdGlvbnMgOiBmbHVpZC5pZGVudGl0eSkoZmx1aWQuY29weShyZXNvdXJjZXMpKTtcbiAgICAgICAgZmx1aWQuZmV0Y2hSZXNvdXJjZXMoZXhwYW5kZWQpO1xuICAgIH07XG5cbiAgICAvKiogVXRpbGl0aWVzIGludm9raW5nIHJlcXVlc3RzIGZvciBleHBhbnNpb24gKiovXG4gICAgZmx1aWQucmVnaXN0ZXJOYW1lc3BhY2UoXCJmbHVpZC5leHBhbmRlclwiKTtcblxuICAgIC8qXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyB1bnN1cHBvcnRlZDogSXQgaXMgbm90IHJlYWxseSBpbnRlbmRlZCBmb3IgdXNlIGJ5IGltcGxlbWVudG9ycy5cbiAgICAgKi9cbiAgICBmbHVpZC5leHBhbmRlci5tYWtlRGVmYXVsdEZldGNoT3B0aW9ucyA9IGZ1bmN0aW9uIChzdWNjZXNzZGlzcG9zZXIsIGZhaWxpZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gJC5leHRlbmQodHJ1ZSwge2RhdGFUeXBlOiBcInRleHRcIn0sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKHJlc3BvbnNlLCBlbnZpcm9ubWVudGRpc3Bvc2VyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGpzb24gPSBKU09OLnBhcnNlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBlbnZpcm9ubWVudGRpc3Bvc2VyKHN1Y2Nlc3NkaXNwb3Nlcihqc29uKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKHJlc3BvbnNlLCB0ZXh0U3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgZmx1aWQubG9nKFwiRXJyb3IgZmV0Y2hpbmcgXCIgKyBmYWlsaWQgKyBcIjogXCIgKyB0ZXh0U3RhdHVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyB1bnN1cHBvcnRlZDogSXQgaXMgbm90IHJlYWxseSBpbnRlbmRlZCBmb3IgdXNlIGJ5IGltcGxlbWVudG9ycy5cbiAgICAgKi9cbiAgICBmbHVpZC5leHBhbmRlci5tYWtlRmV0Y2hFeHBhbmRlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB7IGV4cGFuZGVyOiB7XG4gICAgICAgICAgICB0eXBlOiBcImZsdWlkLmV4cGFuZGVyLmRlZmVycmVkRmV0Y2hlclwiLFxuICAgICAgICAgICAgaHJlZjogb3B0aW9ucy51cmwsXG4gICAgICAgICAgICBvcHRpb25zOiBmbHVpZC5leHBhbmRlci5tYWtlRGVmYXVsdEZldGNoT3B0aW9ucyhvcHRpb25zLmRpc3Bvc2VyLCBvcHRpb25zLnVybCwgb3B0aW9ucy5vcHRpb25zKSxcbiAgICAgICAgICAgIHJlc291cmNlU3BlY0NvbGxlY3RvcjogXCJ7cmVzb3VyY2VTcGVjQ29sbGVjdG9yfVwiLFxuICAgICAgICAgICAgZmV0Y2hLZXk6IG9wdGlvbnMuZmV0Y2hLZXlcbiAgICAgICAgfX07XG4gICAgfTtcblxuICAgIGZsdWlkLmV4cGFuZGVyLmRlZmVycmVkRmV0Y2hlciA9IGZ1bmN0aW9uKGRlbGl2ZXJlciwgc291cmNlLCBleHBhbmRPcHRpb25zKSB7XG4gICAgICAgIHZhciBleHBhbmRlciA9IHNvdXJjZS5leHBhbmRlcjtcbiAgICAgICAgdmFyIHNwZWMgPSBmbHVpZC5jb3B5KGV4cGFuZGVyKTtcbiAgICAgICAgLy8gZmV0Y2ggdGhlIFwiZ2xvYmFsXCIgY29sbGVjdG9yIHNwZWNpZmllZCBpbiB0aGUgZXh0ZXJuYWwgZW52aXJvbm1lbnQgdG8gcmVjZWl2ZVxuICAgICAgICAvLyB0aGlzIHJlc291cmNlU3BlY1xuICAgICAgICB2YXIgY29sbGVjdG9yID0gZmx1aWQuZXhwYW5kKGV4cGFuZGVyLnJlc291cmNlU3BlY0NvbGxlY3RvciwgZXhwYW5kT3B0aW9ucyk7XG4gICAgICAgIGRlbGV0ZSBzcGVjLnR5cGU7XG4gICAgICAgIGRlbGV0ZSBzcGVjLnJlc291cmNlU3BlY0NvbGxlY3RvcjtcbiAgICAgICAgZGVsZXRlIHNwZWMuZmV0Y2hLZXk7XG4gICAgICAgIHZhciBlbnZpcm9ubWVudGRpc3Bvc2VyID0gZnVuY3Rpb24oZGlzcG9zZWQpIHtcbiAgICAgICAgICAgIGRlbGl2ZXJlcihkaXNwb3NlZCk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIHJlcGxhY2UgdGhlIGNhbGxiYWNrIHdoaWNoIGlzIHRoZXJlICh0YWtpbmcgMiBhcmd1bWVudHMpIHdpdGggb25lIHdoaWNoXG4gICAgICAgIC8vIGRpcmVjdGx5IHJlc3BvbmRzIHRvIHRoZSByZXF1ZXN0LCBwYXNzaW5nIGluIHRoZSByZXN1bHQgYW5kIE9VUiBcImRpc3Bvc2VyXCIgLVxuICAgICAgICAvLyB3aGljaCBvbmNlIHRoZSB1c2VyIGhhcyBwcm9jZXNzZWQgdGhlIHJlc3BvbnNlIChzYXksIHBhcnNpbmcgSlNPTiBhbmQgcmVwYWNrYWdpbmcpXG4gICAgICAgIC8vIGZpbmFsbHkgZGVwb3NpdHMgaXQgaW4gdGhlIHBsYWNlIG9mIHRoZSBleHBhbmRlciBpbiB0aGUgdHJlZSB0byB3aGljaCB0aGlzIHJlZmVyZW5jZVxuICAgICAgICAvLyBoYXMgYmVlbiBzdG9yZWQgYXQgdGhlIHBvaW50IHRoaXMgZXhwYW5kZXIgd2FzIGV2YWx1YXRlZC5cbiAgICAgICAgc3BlYy5vcHRpb25zLnN1Y2Nlc3MgPSBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgZXhwYW5kZXIub3B0aW9ucy5zdWNjZXNzKHJlc3BvbnNlLCBlbnZpcm9ubWVudGRpc3Bvc2VyKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGtleSA9IGV4cGFuZGVyLmZldGNoS2V5IHx8IGZsdWlkLmFsbG9jYXRlR3VpZCgpO1xuICAgICAgICBjb2xsZWN0b3Jba2V5XSA9IHNwZWM7XG4gICAgICAgIHJldHVybiBmbHVpZC5OT19WQUxVRTtcbiAgICB9O1xuXG5cbn0pKGpRdWVyeSwgZmx1aWRfMl8wKTtcbjsvLyAtKi0gbW9kZTogamF2YXNjcmlwdDsgdGFiLXdpZHRoOiAyOyBpbmRlbnQtdGFicy1tb2RlOiBuaWw7IC0qLVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRFNQIEFQSSAtIEphdmFTY3JpcHQgc2hpbVxuLy9cbi8vIENvcHlyaWdodCAoQykgMjAxMiBNYXJjdXMgR2VlbG5hcmRcbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0b1xuLy8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGVcbi8vIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vclxuLy8gc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuLy8gRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HU1xuLy8gSU4gVEhFIFNPRlRXQVJFLlxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGludGVyZmFjZSBEU1Bcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbihmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgZyA9IHR5cGVvZiAod2luZG93KSAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHR5cGVvZiAoc2VsZikgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogZ2xvYmFsO1xuXG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChnLkRTUCkgcmV0dXJuO1xuXG4gICAgICB2YXIgRFNQID0ge307XG5cbiAgICAgIERTUC5hZGQgPSBmdW5jdGlvbiAoZHN0LCB4LCB5KSB7XG4gICAgICAgIHZhciBrO1xuICAgICAgICBpZiAoeSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSlcbiAgICAgICAgICBmb3IgKGsgPSBNYXRoLm1pbihkc3QubGVuZ3RoLCB4Lmxlbmd0aCwgeS5sZW5ndGgpIC0gMTsgayA+PSAwOyAtLWspXG4gICAgICAgICAgICBkc3Rba10gPSB4W2tdICsgeVtrXTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGZvciAoayA9IE1hdGgubWluKGRzdC5sZW5ndGgsIHgubGVuZ3RoKSAtIDE7IGsgPj0gMDsgLS1rKVxuICAgICAgICAgICAgZHN0W2tdID0geFtrXSArIHk7XG4gICAgICB9O1xuXG4gICAgICBEU1Auc3ViID0gZnVuY3Rpb24gKGRzdCwgeCwgeSkge1xuICAgICAgICB2YXIgaztcbiAgICAgICAgaWYgKHkgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpXG4gICAgICAgICAgZm9yIChrID0gTWF0aC5taW4oZHN0Lmxlbmd0aCwgeC5sZW5ndGgsIHkubGVuZ3RoKSAtIDE7IGsgPj0gMDsgLS1rKVxuICAgICAgICAgICAgZHN0W2tdID0geFtrXSAtIHlba107XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBmb3IgKGsgPSBNYXRoLm1pbihkc3QubGVuZ3RoLCB4Lmxlbmd0aCkgLSAxOyBrID49IDA7IC0taylcbiAgICAgICAgICAgIGRzdFtrXSA9IHhba10gLSB5O1xuICAgICAgfTtcblxuICAgICAgRFNQLm11bCA9IGZ1bmN0aW9uIChkc3QsIHgsIHkpIHtcbiAgICAgICAgdmFyIGs7XG4gICAgICAgIGlmICh5IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KVxuICAgICAgICAgIGZvciAoayA9IE1hdGgubWluKGRzdC5sZW5ndGgsIHgubGVuZ3RoLCB5Lmxlbmd0aCkgLSAxOyBrID49IDA7IC0taylcbiAgICAgICAgICAgIGRzdFtrXSA9IHhba10gKiB5W2tdO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZm9yIChrID0gTWF0aC5taW4oZHN0Lmxlbmd0aCwgeC5sZW5ndGgpIC0gMTsgayA+PSAwOyAtLWspXG4gICAgICAgICAgICBkc3Rba10gPSB4W2tdICogeTtcbiAgICAgIH07XG5cbiAgICAgIERTUC5tdWxDcGx4ID0gZnVuY3Rpb24gKGRzdFJlYWwsIGRzdEltYWcsIHhSZWFsLCB4SW1hZywgeVJlYWwsIHlJbWFnKSB7XG4gICAgICAgIHZhciBrLCB4ciwgeGksIHlyLCB5aTtcbiAgICAgICAgaWYgKHlSZWFsIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KVxuICAgICAgICAgIGZvciAoayA9IE1hdGgubWluKGRzdFJlYWwubGVuZ3RoLCBkc3RJbWFnLmxlbmd0aCwgeFJlYWwubGVuZ3RoLCB4SW1hZy5sZW5ndGgsIHlSZWFsLmxlbmd0aCwgeUltYWcubGVuZ3RoKSAtIDE7IGsgPj0gMDsgLS1rKSB7XG4gICAgICAgICAgICB4ciA9IHhSZWFsW2tdLCB4aSA9IHhJbWFnW2tdLCB5ciA9IHlSZWFsW2tdLCB5aSA9IHlJbWFnW2tdO1xuICAgICAgICAgICAgZHN0UmVhbFtrXSA9IHhyICogeXIgLSB4aSAqIHlpO1xuICAgICAgICAgICAgZHN0SW1hZ1trXSA9IHhyICogeWkgKyB4aSAqIHlyO1xuICAgICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIGZvciAoayA9IE1hdGgubWluKGRzdFJlYWwubGVuZ3RoLCBkc3RJbWFnLmxlbmd0aCwgeFJlYWwubGVuZ3RoLCB4SW1hZy5sZW5ndGgpIC0gMTsgayA+PSAwOyAtLWspIHtcbiAgICAgICAgICAgIHhyID0geFJlYWxba10sIHhpID0geEltYWdba107XG4gICAgICAgICAgICBkc3RSZWFsW2tdID0geHIgKiB5UmVhbCAtIHhpICogeUltYWc7XG4gICAgICAgICAgICBkc3RJbWFnW2tdID0geHIgKiB5SW1hZyArIHhpICogeVJlYWw7XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgRFNQLmRpdiA9IGZ1bmN0aW9uIChkc3QsIHgsIHkpIHtcbiAgICAgICAgdmFyIGs7XG4gICAgICAgIGlmICh5IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KVxuICAgICAgICAgIGZvciAoayA9IE1hdGgubWluKGRzdC5sZW5ndGgsIHgubGVuZ3RoLCB5Lmxlbmd0aCkgLSAxOyBrID49IDA7IC0taylcbiAgICAgICAgICAgIGRzdFtrXSA9IHhba10gLyB5W2tdO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZm9yIChrID0gTWF0aC5taW4oZHN0Lmxlbmd0aCwgeC5sZW5ndGgpIC0gMTsgayA+PSAwOyAtLWspXG4gICAgICAgICAgICBkc3Rba10gPSB4W2tdIC8geTtcbiAgICAgIH07XG5cbiAgICAgIERTUC5kaXZDcGx4ID0gZnVuY3Rpb24gKGRzdFJlYWwsIGRzdEltYWcsIHhSZWFsLCB4SW1hZywgeVJlYWwsIHlJbWFnKSB7XG4gICAgICAgIHZhciBrLCB4ciwgeGksIHlyLCB5aSwgZGVub207XG4gICAgICAgIGlmICh5UmVhbCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSlcbiAgICAgICAgICBmb3IgKGsgPSBNYXRoLm1pbihkc3RSZWFsLmxlbmd0aCwgZHN0SW1hZy5sZW5ndGgsIHhSZWFsLmxlbmd0aCwgeEltYWcubGVuZ3RoLCB5UmVhbC5sZW5ndGgsIHlJbWFnLmxlbmd0aCkgLSAxOyBrID49IDA7IC0taykge1xuICAgICAgICAgICAgeHIgPSB4UmVhbFtrXSwgeGkgPSB4SW1hZ1trXSwgeXIgPSB5UmVhbFtrXSwgeWkgPSB5SW1hZ1trXTtcbiAgICAgICAgICAgIGRlbm9tID0gMSAvICh5ciAqIHlyICsgeWkgKiB5aSk7XG4gICAgICAgICAgICBkc3RSZWFsW2tdID0gKHhyICogeXIgKyB4aSAqIHlpKSAqIGRlbm9tO1xuICAgICAgICAgICAgZHN0SW1hZ1trXSA9ICh4aSAqIHlyIC0geHIgKiB5aSkgKiBkZW5vbTtcbiAgICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbm9tID0gMSAvICh5UmVhbCAqIHlSZWFsICsgeUltYWcgKiB5SW1hZyk7XG4gICAgICAgICAgZm9yIChrID0gTWF0aC5taW4oZHN0UmVhbC5sZW5ndGgsIGRzdEltYWcubGVuZ3RoLCB4UmVhbC5sZW5ndGgsIHhJbWFnLmxlbmd0aCkgLSAxOyBrID49IDA7IC0taykge1xuICAgICAgICAgICAgeHIgPSB4UmVhbFtrXSwgeGkgPSB4SW1hZ1trXTtcbiAgICAgICAgICAgIGRzdFJlYWxba10gPSAoeHIgKiB5UmVhbCArIHhpICogeUltYWcpICogZGVub207XG4gICAgICAgICAgICBkc3RJbWFnW2tdID0gKHhpICogeVJlYWwgLSB4ciAqIHlJbWFnKSAqIGRlbm9tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgRFNQLm1hZGQgPSBmdW5jdGlvbiAoZHN0LCB4LCB5LCB6KSB7XG4gICAgICAgIHZhciBrO1xuICAgICAgICBpZiAoeiBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSlcbiAgICAgICAgICBmb3IgKGsgPSBNYXRoLm1pbihkc3QubGVuZ3RoLCB4Lmxlbmd0aCwgeS5sZW5ndGgsIHoubGVuZ3RoKSAtIDE7IGsgPj0gMDsgLS1rKVxuICAgICAgICAgICAgZHN0W2tdID0geFtrXSArIHlba10gKiB6W2tdO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZm9yIChrID0gTWF0aC5taW4oZHN0Lmxlbmd0aCwgeC5sZW5ndGgpIC0gMTsgayA+PSAwOyAtLWspXG4gICAgICAgICAgICBkc3Rba10gPSB4W2tdICsgeVtrXSAqIHo7XG4gICAgICB9O1xuXG4gICAgICBEU1AuYWJzID0gZnVuY3Rpb24gKGRzdCwgeCkge1xuICAgICAgICBmb3IgKHZhciBrID0gTWF0aC5taW4oZHN0Lmxlbmd0aCwgeC5sZW5ndGgpIC0gMTsgayA+PSAwOyAtLWspXG4gICAgICAgICAgZHN0W2tdID0gTWF0aC5hYnMoeFtrXSk7XG4gICAgICB9O1xuXG4gICAgICBEU1AuYWJzQ3BseCA9IGZ1bmN0aW9uIChkc3QsIHJlYWwsIGltYWcpIHtcbiAgICAgICAgZm9yICh2YXIgayA9IE1hdGgubWluKGRzdC5sZW5ndGgsIHJlYWwubGVuZ3RoLCBpbWFnLmxlbmd0aCkgLSAxOyBrID49IDA7IC0taylcbiAgICAgICAgICBkc3Rba10gPSBNYXRoLnNxcnQocmVhbFtrXSAqIHJlYWxba10gKyBpbWFnW2tdICogaW1hZ1trXSk7XG4gICAgICB9O1xuXG4gICAgICBEU1AuYWNvcyA9IGZ1bmN0aW9uIChkc3QsIHgpIHtcbiAgICAgICAgZm9yICh2YXIgayA9IE1hdGgubWluKGRzdC5sZW5ndGgsIHgubGVuZ3RoKSAtIDE7IGsgPj0gMDsgLS1rKVxuICAgICAgICAgIGRzdFtrXSA9IE1hdGguYWNvcyh4W2tdKTtcbiAgICAgIH07XG5cbiAgICAgIERTUC5hc2luID0gZnVuY3Rpb24gKGRzdCwgeCkge1xuICAgICAgICBmb3IgKHZhciBrID0gTWF0aC5taW4oZHN0Lmxlbmd0aCwgeC5sZW5ndGgpIC0gMTsgayA+PSAwOyAtLWspXG4gICAgICAgICAgZHN0W2tdID0gTWF0aC5hc2luKHhba10pO1xuICAgICAgfTtcblxuICAgICAgRFNQLmF0YW4gPSBmdW5jdGlvbiAoZHN0LCB4KSB7XG4gICAgICAgIGZvciAodmFyIGsgPSBNYXRoLm1pbihkc3QubGVuZ3RoLCB4Lmxlbmd0aCkgLSAxOyBrID49IDA7IC0taylcbiAgICAgICAgICBkc3Rba10gPSBNYXRoLmF0YW4oeFtrXSk7XG4gICAgICB9O1xuXG4gICAgICBEU1AuYXRhbjIgPSBmdW5jdGlvbiAoZHN0LCB5LCB4KSB7XG4gICAgICAgIGZvciAodmFyIGsgPSBNYXRoLm1pbihkc3QubGVuZ3RoLCB4Lmxlbmd0aCwgeS5sZW5ndGgpIC0gMTsgayA+PSAwOyAtLWspXG4gICAgICAgICAgZHN0W2tdID0gTWF0aC5hdGFuMih5W2tdLCB4W2tdKTtcbiAgICAgIH07XG5cbiAgICAgIERTUC5jZWlsID0gZnVuY3Rpb24gKGRzdCwgeCkge1xuICAgICAgICBmb3IgKHZhciBrID0gTWF0aC5taW4oZHN0Lmxlbmd0aCwgeC5sZW5ndGgpIC0gMTsgayA+PSAwOyAtLWspXG4gICAgICAgICAgZHN0W2tdID0gTWF0aC5jZWlsKHhba10pO1xuICAgICAgfTtcblxuICAgICAgRFNQLmNvcyA9IGZ1bmN0aW9uIChkc3QsIHgpIHtcbiAgICAgICAgZm9yICh2YXIgayA9IE1hdGgubWluKGRzdC5sZW5ndGgsIHgubGVuZ3RoKSAtIDE7IGsgPj0gMDsgLS1rKVxuICAgICAgICAgIGRzdFtrXSA9IE1hdGguY29zKHhba10pO1xuICAgICAgfTtcblxuICAgICAgRFNQLmV4cCA9IGZ1bmN0aW9uIChkc3QsIHgpIHtcbiAgICAgICAgZm9yICh2YXIgayA9IE1hdGgubWluKGRzdC5sZW5ndGgsIHgubGVuZ3RoKSAtIDE7IGsgPj0gMDsgLS1rKVxuICAgICAgICAgIGRzdFtrXSA9IE1hdGguZXhwKHhba10pO1xuICAgICAgfTtcblxuICAgICAgRFNQLmZsb29yID0gZnVuY3Rpb24gKGRzdCwgeCkge1xuICAgICAgICBmb3IgKHZhciBrID0gTWF0aC5taW4oZHN0Lmxlbmd0aCwgeC5sZW5ndGgpIC0gMTsgayA+PSAwOyAtLWspXG4gICAgICAgICAgZHN0W2tdID0gTWF0aC5mbG9vcih4W2tdKTtcbiAgICAgIH07XG5cbiAgICAgIERTUC5sb2cgPSBmdW5jdGlvbiAoZHN0LCB4KSB7XG4gICAgICAgIGZvciAodmFyIGsgPSBNYXRoLm1pbihkc3QubGVuZ3RoLCB4Lmxlbmd0aCkgLSAxOyBrID49IDA7IC0taylcbiAgICAgICAgICBkc3Rba10gPSBNYXRoLmxvZyh4W2tdKTtcbiAgICAgIH07XG5cbiAgICAgIERTUC5tYXggPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcmV0ID0gLUluZmluaXR5O1xuICAgICAgICBmb3IgKHZhciBrID0geC5sZW5ndGggLSAxOyBrID49IDA7IC0taykge1xuICAgICAgICAgIHZhciB2YWwgPSB4W2tdO1xuICAgICAgICAgIGlmICh2YWwgPiByZXQpXG4gICAgICAgICAgICByZXQgPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH07XG5cbiAgICAgIERTUC5taW4gPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcmV0ID0gSW5maW5pdHk7XG4gICAgICAgIGZvciAodmFyIGsgPSB4Lmxlbmd0aCAtIDE7IGsgPj0gMDsgLS1rKSB7XG4gICAgICAgICAgdmFyIHZhbCA9IHhba107XG4gICAgICAgICAgaWYgKHZhbCA8IHJldClcbiAgICAgICAgICAgIHJldCA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfTtcblxuICAgICAgRFNQLnBvdyA9IGZ1bmN0aW9uIChkc3QsIHgsIHkpIHtcbiAgICAgICAgdmFyIGs7XG4gICAgICAgIGlmICh5IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KVxuICAgICAgICAgIGZvciAoayA9IE1hdGgubWluKGRzdC5sZW5ndGgsIHgubGVuZ3RoLCB5Lmxlbmd0aCkgLSAxOyBrID49IDA7IC0taylcbiAgICAgICAgICAgIGRzdFtrXSA9IE1hdGgucG93KHhba10sIHlba10pO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvLyBPcHRpbWl6ZSBmb3Igc3BlY2lhbCBjYXNlc1xuICAgICAgICAgIGlmICh5ID09IDIpXG4gICAgICAgICAgICBmb3IgKGsgPSBNYXRoLm1pbihkc3QubGVuZ3RoLCB4Lmxlbmd0aCkgLSAxOyBrID49IDA7IC0taykge1xuICAgICAgICAgICAgICB2YXIgdmFsID0geFtrXTtcbiAgICAgICAgICAgICAgZHN0W2tdID0gdmFsICogdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHkgPT0gMylcbiAgICAgICAgICAgIGZvciAoayA9IE1hdGgubWluKGRzdC5sZW5ndGgsIHgubGVuZ3RoKSAtIDE7IGsgPj0gMDsgLS1rKSB7XG4gICAgICAgICAgICAgIHZhciB2YWwgPSB4W2tdO1xuICAgICAgICAgICAgICBkc3Rba10gPSB2YWwgKiB2YWwgKiB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoeSA9PSA0KVxuICAgICAgICAgICAgZm9yIChrID0gTWF0aC5taW4oZHN0Lmxlbmd0aCwgeC5sZW5ndGgpIC0gMTsgayA+PSAwOyAtLWspIHtcbiAgICAgICAgICAgICAgdmFyIHZhbCA9IHhba107XG4gICAgICAgICAgICAgIHZhbCA9IHZhbCAqIHZhbDtcbiAgICAgICAgICAgICAgZHN0W2tdID0gdmFsICogdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHkgPT0gLTEpXG4gICAgICAgICAgICBmb3IgKGsgPSBNYXRoLm1pbihkc3QubGVuZ3RoLCB4Lmxlbmd0aCkgLSAxOyBrID49IDA7IC0taylcbiAgICAgICAgICAgICAgZHN0W2tdID0gMSAvIHhba11cbiAgICAgICAgICBlbHNlIGlmICh5ID09IC0yKVxuICAgICAgICAgICAgZm9yIChrID0gTWF0aC5taW4oZHN0Lmxlbmd0aCwgeC5sZW5ndGgpIC0gMTsgayA+PSAwOyAtLWspIHtcbiAgICAgICAgICAgICAgdmFyIHZhbCA9IDEgLyB4W2tdO1xuICAgICAgICAgICAgICBkc3Rba10gPSB2YWwgKiB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZm9yIChrID0gTWF0aC5taW4oZHN0Lmxlbmd0aCwgeC5sZW5ndGgpIC0gMTsgayA+PSAwOyAtLWspXG4gICAgICAgICAgICAgIGRzdFtrXSA9IE1hdGgucG93KHhba10sIHkpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBEU1AucmFuZG9tID0gZnVuY3Rpb24gKGRzdCwgbG93LCBoaWdoKSB7XG4gICAgICAgIGlmICghbG93KVxuICAgICAgICAgIGxvdyA9IDA7XG4gICAgICAgIGlmIChpc05hTihwYXJzZUZsb2F0KGhpZ2gpKSlcbiAgICAgICAgICBoaWdoID0gMTtcbiAgICAgICAgdmFyIHNjYWxlID0gaGlnaCAtIGxvdztcbiAgICAgICAgZm9yICh2YXIgayA9IGRzdC5sZW5ndGggLSAxOyBrID49IDA7IC0taylcbiAgICAgICAgICBkc3Rba10gPSBNYXRoLnJhbmRvbSgpICogc2NhbGUgKyBsb3c7XG4gICAgICB9O1xuXG4gICAgICBEU1Aucm91bmQgPSBmdW5jdGlvbiAoZHN0LCB4KSB7XG4gICAgICAgIGZvciAodmFyIGsgPSBNYXRoLm1pbihkc3QubGVuZ3RoLCB4Lmxlbmd0aCkgLSAxOyBrID49IDA7IC0taylcbiAgICAgICAgICBkc3Rba10gPSBNYXRoLnJvdW5kKHhba10pO1xuICAgICAgfTtcblxuICAgICAgRFNQLnNpbiA9IGZ1bmN0aW9uIChkc3QsIHgpIHtcbiAgICAgICAgZm9yICh2YXIgayA9IE1hdGgubWluKGRzdC5sZW5ndGgsIHgubGVuZ3RoKSAtIDE7IGsgPj0gMDsgLS1rKVxuICAgICAgICAgIGRzdFtrXSA9IE1hdGguc2luKHhba10pO1xuICAgICAgfTtcblxuICAgICAgRFNQLnNxcnQgPSBmdW5jdGlvbiAoZHN0LCB4KSB7XG4gICAgICAgIGZvciAodmFyIGsgPSBNYXRoLm1pbihkc3QubGVuZ3RoLCB4Lmxlbmd0aCkgLSAxOyBrID49IDA7IC0taylcbiAgICAgICAgICBkc3Rba10gPSBNYXRoLnNxcnQoeFtrXSk7XG4gICAgICB9O1xuXG4gICAgICBEU1AudGFuID0gZnVuY3Rpb24gKGRzdCwgeCkge1xuICAgICAgICBmb3IgKHZhciBrID0gTWF0aC5taW4oZHN0Lmxlbmd0aCwgeC5sZW5ndGgpIC0gMTsgayA+PSAwOyAtLWspXG4gICAgICAgICAgZHN0W2tdID0gTWF0aC50YW4oeFtrXSk7XG4gICAgICB9O1xuXG4gICAgICBEU1AuY2xhbXAgPSBmdW5jdGlvbiAoZHN0LCB4LCB4TWluLCB4TWF4KSB7XG4gICAgICAgIGZvciAodmFyIGsgPSBNYXRoLm1pbihkc3QubGVuZ3RoLCB4Lmxlbmd0aCkgLSAxOyBrID49IDA7IC0taykge1xuICAgICAgICAgIHZhciB2YWwgPSB4W2tdO1xuICAgICAgICAgIGRzdFtrXSA9IHZhbCA8IHhNaW4gPyB4TWluIDogdmFsID4geE1heCA/IHhNYXggOiB2YWw7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIERTUC5mcmFjdCA9IGZ1bmN0aW9uIChkc3QsIHgpIHtcbiAgICAgICAgZm9yICh2YXIgayA9IE1hdGgubWluKGRzdC5sZW5ndGgsIHgubGVuZ3RoKSAtIDE7IGsgPj0gMDsgLS1rKSB7XG4gICAgICAgICAgdmFyIHZhbCA9IHhba107XG4gICAgICAgICAgZHN0W2tdID0gdmFsIC0gTWF0aC5mbG9vcih2YWwpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBEU1AucmFtcCA9IGZ1bmN0aW9uIChkc3QsIGZpcnN0LCBsYXN0KSB7XG4gICAgICAgIHZhciBtYXhJZHggPSBkc3QubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKG1heElkeCA+PSAwKVxuICAgICAgICAgIGRzdFswXSA9IGZpcnN0O1xuICAgICAgICBpZiAobWF4SWR4ID4gMCkge1xuICAgICAgICAgIHZhciBzdGVwID0gKGxhc3QgLSBmaXJzdCkgLyBtYXhJZHg7XG4gICAgICAgICAgZm9yICh2YXIgayA9IDE7IGsgPD0gbWF4SWR4OyArK2spXG4gICAgICAgICAgICBkc3Rba10gPSBmaXJzdCArIHN0ZXAgKiBrO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBEU1Auc2lnbiA9IGZ1bmN0aW9uIChkc3QsIHgpIHtcbiAgICAgICAgZm9yICh2YXIgayA9IE1hdGgubWluKGRzdC5sZW5ndGgsIHgubGVuZ3RoKSAtIDE7IGsgPj0gMDsgLS1rKVxuICAgICAgICAgIGRzdFtrXSA9IHhba10gPCAwID8gLTEgOiAxO1xuICAgICAgfTtcblxuICAgICAgRFNQLnN1bSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciByZXQgPSAwO1xuICAgICAgICBmb3IgKHZhciBrID0geC5sZW5ndGggLSAxOyBrID49IDA7IC0taylcbiAgICAgICAgICByZXQgKz0geFtrXTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH07XG5cbiAgICAgIERTUC5zYW1wbGVMaW5lYXIgPSBmdW5jdGlvbiAoZHN0LCB4LCB0LCByZXBlYXQpIHtcbiAgICAgICAgdmFyIHhMZW4gPSB4Lmxlbmd0aCwgbWF4SWR4ID0geExlbiAtIDE7XG4gICAgICAgIGlmIChyZXBlYXQpXG4gICAgICAgICAgZm9yICh2YXIgayA9IE1hdGgubWluKGRzdC5sZW5ndGgsIHQubGVuZ3RoKSAtIDE7IGsgPj0gMDsgLS1rKSB7XG4gICAgICAgICAgICB2YXIgdDIgPSB0W2tdO1xuICAgICAgICAgICAgdDIgPSB0MiAtIE1hdGguZmxvb3IodDIveExlbikgKiB4TGVuO1xuICAgICAgICAgICAgdmFyIGlkeCA9IE1hdGguZmxvb3IodDIpO1xuICAgICAgICAgICAgdmFyIHcgPSB0MiAtIGlkeDtcbiAgICAgICAgICAgIHZhciBwMSA9IHhbaWR4XTtcbiAgICAgICAgICAgIHZhciBwMiA9IHhbaWR4IDwgbWF4SWR4ID8gaWR4ICsgMSA6IDBdO1xuICAgICAgICAgICAgZHN0W2tdID0gcDEgKyB3ICogKHAyIC0gcDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIGZvciAodmFyIGsgPSBNYXRoLm1pbihkc3QubGVuZ3RoLCB0Lmxlbmd0aCkgLSAxOyBrID49IDA7IC0taykge1xuICAgICAgICAgICAgdmFyIHQyID0gdFtrXTtcbiAgICAgICAgICAgIHQyID0gdDIgPCAwID8gMCA6IHQyID4gbWF4SWR4ID8gbWF4SWR4IDogdDI7XG4gICAgICAgICAgICB2YXIgaWR4ID0gTWF0aC5mbG9vcih0Mik7XG4gICAgICAgICAgICB2YXIgdyA9IHQyIC0gaWR4O1xuICAgICAgICAgICAgdmFyIHAxID0geFtpZHhdO1xuICAgICAgICAgICAgdmFyIHAyID0geFtpZHggPCBtYXhJZHggPyBpZHggKyAxIDogbWF4SWR4XTtcbiAgICAgICAgICAgIGRzdFtrXSA9IHAxICsgdyAqIChwMiAtIHAxKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBEU1Auc2FtcGxlQ3ViaWMgPSBmdW5jdGlvbiAoZHN0LCB4LCB0LCByZXBlYXQpIHtcbiAgICAgICAgdmFyIHhMZW4gPSB4Lmxlbmd0aCwgbWF4SWR4ID0geExlbiAtIDE7XG4gICAgICAgIGlmIChyZXBlYXQpXG4gICAgICAgICAgZm9yICh2YXIgayA9IE1hdGgubWluKGRzdC5sZW5ndGgsIHQubGVuZ3RoKSAtIDE7IGsgPj0gMDsgLS1rKSB7XG4gICAgICAgICAgICB2YXIgdDIgPSB0W2tdO1xuICAgICAgICAgICAgdDIgPSB0MiAtIE1hdGguZmxvb3IodDIveExlbikgKiB4TGVuO1xuICAgICAgICAgICAgdmFyIGlkeCA9IE1hdGguZmxvb3IodDIpO1xuICAgICAgICAgICAgdmFyIHcgPSB0MiAtIGlkeDtcbiAgICAgICAgICAgIHZhciB3MiA9IHcgKiB3O1xuICAgICAgICAgICAgdmFyIHczID0gdzIgKiB3O1xuICAgICAgICAgICAgdmFyIGgyID0gLTIqdzMgKyAzKncyO1xuICAgICAgICAgICAgdmFyIGgxID0gMSAtIGgyO1xuICAgICAgICAgICAgdmFyIGg0ID0gdzMgLSB3MjtcbiAgICAgICAgICAgIHZhciBoMyA9IGg0IC0gdzIgKyB3O1xuICAgICAgICAgICAgdmFyIHAxID0geFtpZHggPiAwID8gaWR4IC0gMSA6IG1heElkeF07XG4gICAgICAgICAgICB2YXIgcDIgPSB4W2lkeF07XG4gICAgICAgICAgICB2YXIgcDMgPSB4W2lkeCA8IG1heElkeCA/IGlkeCArIDEgOiAwXTtcbiAgICAgICAgICAgIHZhciBwNCA9IHhbaWR4IDwgbWF4SWR4IC0gMSA/IGlkeCArIDIgOiAoaWR4ICsgMiAtIE1hdGguZmxvb3IoKGlkeCArIDIpL3hMZW4pICogeExlbildO1xuICAgICAgICAgICAgZHN0W2tdID0gaDEgKiBwMiArIGgyICogcDMgKyAwLjUgKiAoaDMgKiAocDMgLSBwMSkgKyBoNCAqIChwNCAtIHAyKSk7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgZm9yICh2YXIgayA9IE1hdGgubWluKGRzdC5sZW5ndGgsIHQubGVuZ3RoKSAtIDE7IGsgPj0gMDsgLS1rKSB7XG4gICAgICAgICAgICB2YXIgdDIgPSB0W2tdO1xuICAgICAgICAgICAgdDIgPSB0MiA8IDAgPyAwIDogdDIgPiBtYXhJZHggPyBtYXhJZHggOiB0MjtcbiAgICAgICAgICAgIHZhciBpZHggPSBNYXRoLmZsb29yKHQyKTtcbiAgICAgICAgICAgIHZhciB3ID0gdDIgLSBpZHg7XG4gICAgICAgICAgICB2YXIgdzIgPSB3ICogdztcbiAgICAgICAgICAgIHZhciB3MyA9IHcyICogdztcbiAgICAgICAgICAgIHZhciBoMiA9IC0yKnczICsgMyp3MjtcbiAgICAgICAgICAgIHZhciBoMSA9IDEgLSBoMjtcbiAgICAgICAgICAgIHZhciBoNCA9IHczIC0gdzI7XG4gICAgICAgICAgICB2YXIgaDMgPSBoNCAtIHcyICsgdztcbiAgICAgICAgICAgIHZhciBwMSA9IHhbaWR4ID4gMCA/IGlkeCAtIDEgOiAgMF07XG4gICAgICAgICAgICB2YXIgcDIgPSB4W2lkeF07XG4gICAgICAgICAgICB2YXIgcDMgPSB4W2lkeCA8IG1heElkeCA/IGlkeCArIDEgOiBtYXhJZHhdO1xuICAgICAgICAgICAgdmFyIHA0ID0geFtpZHggPCBtYXhJZHggLSAxID8gaWR4ICsgMiA6IG1heElkeF07XG4gICAgICAgICAgICBkc3Rba10gPSBoMSAqIHAyICsgaDIgKiBwMyArIDAuNSAqIChoMyAqIChwMyAtIHAxKSArIGg0ICogKHA0IC0gcDIpKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBEU1AucGFjayA9IGZ1bmN0aW9uIChkc3QsIG9mZnNldCwgc3RyaWRlLCBzcmMxLCBzcmMyLCBzcmMzLCBzcmM0KSB7XG4gICAgICAgIHZhciBkc3RDb3VudCA9IE1hdGguZmxvb3IoKGRzdC5sZW5ndGggLSBvZmZzZXQpIC8gc3RyaWRlKTtcbiAgICAgICAgdmFyIGNvdW50ID0gTWF0aC5taW4oZHN0Q291bnQsIHNyYzEubGVuZ3RoKTtcbiAgICAgICAgaWYgKHNyYzIpXG4gICAgICAgICAgaWYgKHNyYzMpXG4gICAgICAgICAgICBpZiAoc3JjNClcbiAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBjb3VudDsgKytrKSB7XG4gICAgICAgICAgICAgICAgZHN0W29mZnNldF0gPSBzcmMxW2tdO1xuICAgICAgICAgICAgICAgIGRzdFtvZmZzZXQgKyAxXSA9IHNyYzJba107XG4gICAgICAgICAgICAgICAgZHN0W29mZnNldCArIDJdID0gc3JjM1trXTtcbiAgICAgICAgICAgICAgICBkc3Rbb2Zmc2V0ICsgM10gPSBzcmM0W2tdO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSBzdHJpZGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBjb3VudDsgKytrKSB7XG4gICAgICAgICAgICAgICAgZHN0W29mZnNldF0gPSBzcmMxW2tdO1xuICAgICAgICAgICAgICAgIGRzdFtvZmZzZXQgKyAxXSA9IHNyYzJba107XG4gICAgICAgICAgICAgICAgZHN0W29mZnNldCArIDJdID0gc3JjM1trXTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gc3RyaWRlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBjb3VudDsgKytrKSB7XG4gICAgICAgICAgICAgIGRzdFtvZmZzZXRdID0gc3JjMVtrXTtcbiAgICAgICAgICAgICAgZHN0W29mZnNldCArIDFdID0gc3JjMltrXTtcbiAgICAgICAgICAgICAgb2Zmc2V0ICs9IHN0cmlkZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgY291bnQ7ICsraykge1xuICAgICAgICAgICAgZHN0W29mZnNldF0gPSBzcmMxW2tdO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHN0cmlkZTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBEU1AudW5wYWNrID0gZnVuY3Rpb24gKHNyYywgb2Zmc2V0LCBzdHJpZGUsIGRzdDEsIGRzdDIsIGRzdDMsIGRzdDQpIHtcbiAgICAgICAgdmFyIHNyY0NvdW50ID0gTWF0aC5mbG9vcigoc3JjLmxlbmd0aCAtIG9mZnNldCkgLyBzdHJpZGUpO1xuICAgICAgICB2YXIgY291bnQgPSBNYXRoLm1pbihzcmNDb3VudCwgZHN0MS5sZW5ndGgpO1xuICAgICAgICBpZiAoZHN0MilcbiAgICAgICAgICBpZiAoZHN0MylcbiAgICAgICAgICAgIGlmIChkc3Q0KVxuICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGNvdW50OyArK2spIHtcbiAgICAgICAgICAgICAgICBkc3QxW2tdID0gc3JjW29mZnNldF07XG4gICAgICAgICAgICAgICAgZHN0MltrXSA9IHNyY1tvZmZzZXQgKyAxXTtcbiAgICAgICAgICAgICAgICBkc3QzW2tdID0gc3JjW29mZnNldCArIDJdO1xuICAgICAgICAgICAgICAgIGRzdDRba10gPSBzcmNbb2Zmc2V0ICsgM107XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IHN0cmlkZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGNvdW50OyArK2spIHtcbiAgICAgICAgICAgICAgICBkc3QxW2tdID0gc3JjW29mZnNldF07XG4gICAgICAgICAgICAgICAgZHN0MltrXSA9IHNyY1tvZmZzZXQgKyAxXTtcbiAgICAgICAgICAgICAgICBkc3QzW2tdID0gc3JjW29mZnNldCArIDJdO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSBzdHJpZGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGNvdW50OyArK2spIHtcbiAgICAgICAgICAgICAgZHN0MVtrXSA9IHNyY1tvZmZzZXRdO1xuICAgICAgICAgICAgICBkc3QyW2tdID0gc3JjW29mZnNldCArIDFdO1xuICAgICAgICAgICAgICBvZmZzZXQgKz0gc3RyaWRlO1xuICAgICAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBjb3VudDsgKytrKSB7XG4gICAgICAgICAgICBkc3QxW2tdID0gc3JjW29mZnNldF07XG4gICAgICAgICAgICBvZmZzZXQgKz0gc3RyaWRlO1xuICAgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGcuRFNQID0gRFNQO1xuICAgIH0pKCk7XG5cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gaW50ZXJmYWNlIEZpbHRlclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGcuRmlsdGVyKSByZXR1cm47XG5cbiAgICAgIHZhciBGaWx0ZXIgPSBmdW5jdGlvbiAoYlNpemUsIGFTaXplKSB7XG4gICAgICAgIGlmIChpc05hTihwYXJzZUZsb2F0KGJTaXplKSkgfHwgIWlzRmluaXRlKGJTaXplKSlcbiAgICAgICAgICBiU2l6ZSA9IDE7XG4gICAgICAgIGlmICghYVNpemUpXG4gICAgICAgICAgYVNpemUgPSAwO1xuICAgICAgICB0aGlzLmIgPSBuZXcgRmxvYXQzMkFycmF5KGJTaXplKTtcbiAgICAgICAgdGhpcy5iWzBdID0gMTtcbiAgICAgICAgdGhpcy5hID0gbmV3IEZsb2F0MzJBcnJheShhU2l6ZSk7XG4gICAgICAgIHRoaXMuX2JIaXN0ID0gbmV3IEZsb2F0MzJBcnJheShiU2l6ZSk7XG4gICAgICAgIHRoaXMuX2FIaXN0ID0gbmV3IEZsb2F0MzJBcnJheShhU2l6ZSk7XG4gICAgICB9O1xuXG4gICAgICBGaWx0ZXIucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIChkc3QsIHgpIHtcbiAgICAgICAgLy8gUHV0IGNvbW1vbmx5IGFjY2Vzc2VkIG9iamVjdHMgYW5kIHByb3BlcnRpZXMgaW4gbG9jYWwgdmFyaWFibGVzXG4gICAgICAgIHZhciBhID0gdGhpcy5hLCBhTGVuID0gYS5sZW5ndGgsXG4gICAgICAgICAgICBiID0gdGhpcy5iLCBiTGVuID0gYi5sZW5ndGgsXG4gICAgICAgICAgICBhSGlzdCA9IHRoaXMuX2FIaXN0LCBiSGlzdCA9IHRoaXMuX2JIaXN0LFxuICAgICAgICAgICAgeExlbiA9IHgubGVuZ3RoLCBkc3RMZW4gPSBkc3QubGVuZ3RoO1xuXG4gICAgICAgIC8vIEZJWE1FOiBPcHRpbWl6ZSBmb3IgbG9uZyBGSVIgZmlsdGVyc1xuXG4gICAgICAgIC8vIFBlcmZvcm0gcnVuLWluIHBhcnQgdXNpbmcgdGhlIGhpc3RvcnkgKHNsb3cpXG4gICAgICAgIHZhciBiSGlzdFJ1bkluID0gYkxlbiAtIDE7XG4gICAgICAgIHZhciBhSGlzdFJ1bkluID0gYUxlbjtcbiAgICAgICAgdmFyIGs7XG4gICAgICAgIGZvciAoayA9IDA7IChiSGlzdFJ1bkluIHx8IGFIaXN0UnVuSW4pICYmIGsgPCB4TGVuOyArK2spIHtcbiAgICAgICAgICB2YXIgbSwgbm9IaXN0TGVuO1xuXG4gICAgICAgICAgLy8gRklSIHBhcnRcbiAgICAgICAgICBub0hpc3RMZW4gPSBiTGVuIC0gYkhpc3RSdW5JbjtcbiAgICAgICAgICBiSGlzdFJ1bkluICYmIGJIaXN0UnVuSW4tLTtcbiAgICAgICAgICB2YXIgcmVzID0gYlswXSAqIHhba107XG4gICAgICAgICAgZm9yIChtID0gMTsgbSA8IG5vSGlzdExlbjsgKyttKVxuICAgICAgICAgICAgcmVzICs9IGJbbV0gKiB4W2sgLSBtXTtcbiAgICAgICAgICBmb3IgKDsgbSA8IGJMZW47ICsrbSlcbiAgICAgICAgICAgIHJlcyArPSBiW21dICogYkhpc3RbbSAtIG5vSGlzdExlbl07XG5cbiAgICAgICAgICAvLyBSZWN1cnNpdmUgcGFydFxuICAgICAgICAgIG5vSGlzdExlbiA9IGFMZW4gLSBhSGlzdFJ1bkluO1xuICAgICAgICAgIGFIaXN0UnVuSW4gJiYgYUhpc3RSdW5Jbi0tO1xuICAgICAgICAgIGZvciAobSA9IDA7IG0gPCBub0hpc3RMZW47ICsrbSlcbiAgICAgICAgICAgIHJlcyAtPSBhW21dICogZHN0W2sgLSAxIC0gbV07XG4gICAgICAgICAgZm9yICg7IG0gPCBhTGVuOyArK20pXG4gICAgICAgICAgICByZXMgLT0gYVttXSAqIGFIaXN0W20gLSBub0hpc3RMZW5dO1xuXG4gICAgICAgICAgZHN0W2tdID0gcmVzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUGVyZm9ybSBoaXN0b3J5LWZyZWUgcGFydCAoZmFzdClcbiAgICAgICAgaWYgKGJMZW4gPT0gMyAmJiBhTGVuID09IDIpIHtcbiAgICAgICAgICAvLyBPcHRpbWl6ZWQgc3BlY2lhbCBjYXNlOiBiaXF1YWQgZmlsdGVyXG4gICAgICAgICAgdmFyIGIwID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGExID0gYVswXSwgYTIgPSBhWzFdO1xuICAgICAgICAgIHZhciB4MCA9IHhbay0xXSwgeDEgPSB4W2stMl0sIHgyO1xuICAgICAgICAgIHZhciB5MCA9IGRzdFtrLTFdLCB5MSA9IGRzdFtrLTJdLCB5MjtcbiAgICAgICAgICBmb3IgKDsgayA8IHhMZW47ICsraykge1xuICAgICAgICAgICAgeDIgPSB4MTtcbiAgICAgICAgICAgIHgxID0geDA7XG4gICAgICAgICAgICB4MCA9IHhba107XG4gICAgICAgICAgICB5MiA9IHkxO1xuICAgICAgICAgICAgeTEgPSB5MDtcbiAgICAgICAgICAgIHkwID0gYjAgKiB4MCArIGIxICogeDEgKyBiMiAqIHgyIC0gYTEgKiB5MSAtIGEyICogeTI7XG4gICAgICAgICAgICBkc3Rba10gPSB5MDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgLy8gR2VuZXJpYyBjYXNlXG4gICAgICAgICAgZm9yICg7IGsgPCB4TGVuOyArK2spIHtcbiAgICAgICAgICAgIHZhciBtO1xuXG4gICAgICAgICAgICAvLyBGSVIgcGFydFxuICAgICAgICAgICAgdmFyIHJlcyA9IGJbMF0gKiB4W2tdO1xuICAgICAgICAgICAgZm9yIChtID0gMTsgbSA8IGJMZW47ICsrbSlcbiAgICAgICAgICAgICAgcmVzICs9IGJbbV0gKiB4W2sgLSBtXTtcblxuICAgICAgICAgICAgLy8gUmVjdXJzaXZlIHBhcnRcbiAgICAgICAgICAgIGZvciAobSA9IDA7IG0gPCBhTGVuOyArK20pXG4gICAgICAgICAgICAgIHJlcyAtPSBhW21dICogZHN0W2sgLSAxIC0gbV07XG5cbiAgICAgICAgICAgIGRzdFtrXSA9IHJlcztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgaGlzdG9yeSBzdGF0ZVxuICAgICAgICB2YXIgaGlzdENvcHkgPSBNYXRoLm1pbihiTGVuIC0gMSwgeExlbik7XG4gICAgICAgIGZvciAoayA9IGJMZW4gLSAyOyBrID49IGhpc3RDb3B5OyAtLWspXG4gICAgICAgICAgYkhpc3Rba10gPSBiSGlzdFtrIC0gaGlzdENvcHldO1xuICAgICAgICBmb3IgKGsgPSAwOyBrIDwgaGlzdENvcHk7ICsraylcbiAgICAgICAgICBiSGlzdFtrXSA9IHhbeExlbiAtIDEgLSBrXTtcbiAgICAgICAgaGlzdENvcHkgPSBNYXRoLm1pbihhTGVuLCBkc3RMZW4pO1xuICAgICAgICBmb3IgKGsgPSBhTGVuIC0gMTsgayA+PSBoaXN0Q29weTsgLS1rKVxuICAgICAgICAgIGFIaXN0W2tdID0gYUhpc3RbayAtIGhpc3RDb3B5XTtcbiAgICAgICAgZm9yIChrID0gMDsgayA8IGhpc3RDb3B5OyArK2spXG4gICAgICAgICAgYUhpc3Rba10gPSBkc3RbeExlbiAtIDEgLSBrXTtcbiAgICAgIH07XG5cbiAgICAgIEZpbHRlci5wcm90b3R5cGUuY2xlYXJIaXN0b3J5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBrID0gdGhpcy5fYkhpc3QubGVuZ3RoIC0gMTsgayA+PSAwOyAtLWspXG4gICAgICAgICAgdGhpcy5fYkhpc3Rba10gPSAwO1xuICAgICAgICBmb3IgKHZhciBrID0gdGhpcy5fYUhpc3QubGVuZ3RoIC0gMTsgayA+PSAwOyAtLWspXG4gICAgICAgICAgdGhpcy5fYUhpc3Rba10gPSAwO1xuICAgICAgfTtcblxuICAgICAgZy5GaWx0ZXIgPSBGaWx0ZXI7XG4gICAgfSkoKTtcblxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBpbnRlcmZhY2UgRkZUXG4gICAgLy9cbiAgICAvLyBOT1RFOiBUaGlzIGlzIGVzc2VudGlhbGx5IGEgaGFuZC10cmFuc2xhdGlvbiBvZiB0aGUgQyBsYW5ndWFnZSBLaXNzIEZGVFxuICAgIC8vIGxpYnJhcnksIGNvcHlyaWdodCBieSBNYXJrIEJvcmdlcmRpbmcsIHJlbGljZW5zZWQgd2l0aCBwZXJtaXNzaW9uIGZyb20gdGhlXG4gICAgLy8gYXV0aG9yLlxuICAgIC8vXG4gICAgLy8gVGhlIGFsZ29yaXRobSBpbXBsZW1lbnRzIG1peGVkIHJhZGl4IEZGVCBhbmQgc3VwcG9ydHMgdHJhbnNmb3JtcyBvZiBhbnkgc2l6ZVxuICAgIC8vIChub3QganVzdCBwb3dlcnMgb2YgMikuIEZvciBvcHRpbWFsIHBlcmZvcm1hbmNlLCB1c2Ugc2l6ZXMgdGhhdCBjYW4gYmVcbiAgICAvLyBmYWN0b3JpemVkIGludG8gZmFjdG9ycyAyLCAzLCA0IGFuZCA1LlxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGcuRkZUKSByZXR1cm47XG5cbiAgICAgIHZhciBidXR0ZXJmbHkyID0gZnVuY3Rpb24gKG91dFJlLCBvdXRJbSwgb3V0SWR4LCBzdHJpZGUsIHR3UmUsIHR3SW0sIG0pIHtcbiAgICAgICAgdmFyIHNjcmF0Y2gwUmUsIHNjcmF0Y2gwSW0sXG4gICAgICAgICAgICBvdXQwUmUsIG91dDBJbSwgb3V0MVJlLCBvdXQxSW0sXG4gICAgICAgICAgICB0UmUsIHRJbTtcblxuICAgICAgICB2YXIgdHcxID0gMCxcbiAgICAgICAgICAgIGlkeDAgPSBvdXRJZHgsXG4gICAgICAgICAgICBpZHgxID0gb3V0SWR4ICsgbTtcblxuICAgICAgICB2YXIgaWR4MEVuZCA9IGlkeDAgKyBtO1xuICAgICAgICB3aGlsZSAoaWR4MCA8IGlkeDBFbmQpIHtcbiAgICAgICAgICAvLyBvdXQwID0gb3V0W2lkeDBdIC8gMlxuICAgICAgICAgIG91dDBSZSA9IG91dFJlW2lkeDBdICogMC41O1xuICAgICAgICAgIG91dDBJbSA9IG91dEltW2lkeDBdICogMC41O1xuICAgICAgICAgIC8vIG91dDEgPSBvdXRbaWR4MV0gLyAyXG4gICAgICAgICAgb3V0MVJlID0gb3V0UmVbaWR4MV0gKiAwLjU7XG4gICAgICAgICAgb3V0MUltID0gb3V0SW1baWR4MV0gKiAwLjU7XG5cbiAgICAgICAgICAvLyBzY3JhdGNoMCA9IG91dDEgKiB0d1t0dzFdXG4gICAgICAgICAgdFJlID0gdHdSZVt0dzFdOyB0SW0gPSB0d0ltW3R3MV07XG4gICAgICAgICAgc2NyYXRjaDBSZSA9IG91dDFSZSAqIHRSZSAtIG91dDFJbSAqIHRJbTtcbiAgICAgICAgICBzY3JhdGNoMEltID0gb3V0MVJlICogdEltICsgb3V0MUltICogdFJlO1xuXG4gICAgICAgICAgLy8gb3V0W2lkeDFdID0gb3V0MCAtIHNjcmF0Y2gwXG4gICAgICAgICAgb3V0UmVbaWR4MV0gPSBvdXQwUmUgLSBzY3JhdGNoMFJlO1xuICAgICAgICAgIG91dEltW2lkeDFdID0gb3V0MEltIC0gc2NyYXRjaDBJbTtcblxuICAgICAgICAgIC8vIG91dFtpZHgwXSA9IG91dDAgKyBzY3JhdGNoMFxuICAgICAgICAgIG91dFJlW2lkeDBdID0gb3V0MFJlICsgc2NyYXRjaDBSZTtcbiAgICAgICAgICBvdXRJbVtpZHgwXSA9IG91dDBJbSArIHNjcmF0Y2gwSW07XG5cbiAgICAgICAgICB0dzEgKz0gc3RyaWRlO1xuICAgICAgICAgICsraWR4MDsgKytpZHgxO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgYnV0dGVyZmx5MyA9IGZ1bmN0aW9uIChvdXRSZSwgb3V0SW0sIG91dElkeCwgc3RyaWRlLCB0d1JlLCB0d0ltLCBtKSB7XG4gICAgICAgIHZhciBzY3JhdGNoMFJlLCBzY3JhdGNoMEltLCBzY3JhdGNoMVJlLCBzY3JhdGNoMUltLFxuICAgICAgICAgICAgc2NyYXRjaDJSZSwgc2NyYXRjaDJJbSwgc2NyYXRjaDNSZSwgc2NyYXRjaDNJbSxcbiAgICAgICAgICAgIG91dDBSZSwgb3V0MEltLCBvdXQxUmUsIG91dDFJbSwgb3V0MlJlLCBvdXQySW0sXG4gICAgICAgICAgICB0UmUsIHRJbTtcblxuICAgICAgICB2YXIgdHcxID0gMCxcbiAgICAgICAgICAgIHR3MiA9IDAsXG4gICAgICAgICAgICBzdHJpZGUyID0gMiAqIHN0cmlkZSxcbiAgICAgICAgICAgIGlkeDAgPSBvdXRJZHgsXG4gICAgICAgICAgICBpZHgxID0gb3V0SWR4ICsgbSxcbiAgICAgICAgICAgIGlkeDIgPSBvdXRJZHggKyAyICogbTtcblxuICAgICAgICB2YXIgZXBpM0ltID0gdHdJbVtzdHJpZGUqbV07XG5cbiAgICAgICAgdmFyIGRpdjMgPSAxIC8gMztcbiAgICAgICAgdmFyIGlkeDBFbmQgPSBpZHgwICsgbTtcbiAgICAgICAgd2hpbGUgKGlkeDAgPCBpZHgwRW5kKSB7XG4gICAgICAgICAgLy8gb3V0MCA9IG91dFtpZHgwXSAvIDNcbiAgICAgICAgICBvdXQwUmUgPSBvdXRSZVtpZHgwXSAqIGRpdjM7XG4gICAgICAgICAgb3V0MEltID0gb3V0SW1baWR4MF0gKiBkaXYzO1xuICAgICAgICAgIC8vIG91dDEgPSBvdXRbaWR4MV0gLyAzXG4gICAgICAgICAgb3V0MVJlID0gb3V0UmVbaWR4MV0gKiBkaXYzO1xuICAgICAgICAgIG91dDFJbSA9IG91dEltW2lkeDFdICogZGl2MztcbiAgICAgICAgICAvLyBvdXQyID0gb3V0W2lkeDJdIC8gM1xuICAgICAgICAgIG91dDJSZSA9IG91dFJlW2lkeDJdICogZGl2MztcbiAgICAgICAgICBvdXQySW0gPSBvdXRJbVtpZHgyXSAqIGRpdjM7XG5cbiAgICAgICAgICAvLyBzY3JhdGNoMSA9IG91dDEgKiB0d1t0dzFdXG4gICAgICAgICAgdFJlID0gdHdSZVt0dzFdOyB0SW0gPSB0d0ltW3R3MV07XG4gICAgICAgICAgc2NyYXRjaDFSZSA9IG91dDFSZSAqIHRSZSAtIG91dDFJbSAqIHRJbTtcbiAgICAgICAgICBzY3JhdGNoMUltID0gb3V0MVJlICogdEltICsgb3V0MUltICogdFJlO1xuXG4gICAgICAgICAgLy8gc2NyYXRjaDIgPSBvdXQyICogdHdbdHcyXVxuICAgICAgICAgIHRSZSA9IHR3UmVbdHcyXTsgdEltID0gdHdJbVt0dzJdO1xuICAgICAgICAgIHNjcmF0Y2gyUmUgPSBvdXQyUmUgKiB0UmUgLSBvdXQySW0gKiB0SW07XG4gICAgICAgICAgc2NyYXRjaDJJbSA9IG91dDJSZSAqIHRJbSArIG91dDJJbSAqIHRSZTtcblxuICAgICAgICAgIC8vIHNjcmF0Y2gzID0gc2NyYXRjaDEgKyBzY3JhdGNoMlxuICAgICAgICAgIHNjcmF0Y2gzUmUgPSBzY3JhdGNoMVJlICsgc2NyYXRjaDJSZTtcbiAgICAgICAgICBzY3JhdGNoM0ltID0gc2NyYXRjaDFJbSArIHNjcmF0Y2gySW07XG5cbiAgICAgICAgICAvLyBzY3JhdGNoMCA9IHNjcmF0Y2gxIC0gc2NyYXRjaDJcbiAgICAgICAgICBzY3JhdGNoMFJlID0gc2NyYXRjaDFSZSAtIHNjcmF0Y2gyUmU7XG4gICAgICAgICAgc2NyYXRjaDBJbSA9IHNjcmF0Y2gxSW0gLSBzY3JhdGNoMkltO1xuXG4gICAgICAgICAgLy8gb3V0MSA9IG91dDAgLSBzY3JhdGNoMyAvIDJcbiAgICAgICAgICBvdXQxUmUgPSBvdXQwUmUgLSBzY3JhdGNoM1JlICogMC41O1xuICAgICAgICAgIG91dDFJbSA9IG91dDBJbSAtIHNjcmF0Y2gzSW0gKiAwLjU7XG5cbiAgICAgICAgICAvLyBzY3JhdGNoMCAqPSBlcGkzLmlcbiAgICAgICAgICBzY3JhdGNoMFJlICo9IGVwaTNJbTtcbiAgICAgICAgICBzY3JhdGNoMEltICo9IGVwaTNJbTtcblxuICAgICAgICAgIC8vIG91dFtpZHgwXSA9IG91dDAgKyBzY3JhdGNoM1xuICAgICAgICAgIG91dFJlW2lkeDBdID0gb3V0MFJlICsgc2NyYXRjaDNSZTtcbiAgICAgICAgICBvdXRJbVtpZHgwXSA9IG91dDBJbSArIHNjcmF0Y2gzSW07XG5cbiAgICAgICAgICBvdXRSZVtpZHgyXSA9IG91dDFSZSArIHNjcmF0Y2gwSW07XG4gICAgICAgICAgb3V0SW1baWR4Ml0gPSBvdXQxSW0gLSBzY3JhdGNoMFJlO1xuXG4gICAgICAgICAgb3V0UmVbaWR4MV0gPSBvdXQxUmUgLSBzY3JhdGNoMEltO1xuICAgICAgICAgIG91dEltW2lkeDFdID0gb3V0MUltICsgc2NyYXRjaDBSZTtcblxuICAgICAgICAgIHR3MSArPSBzdHJpZGU7IHR3MiArPSBzdHJpZGUyO1xuICAgICAgICAgICsraWR4MDsgKytpZHgxOyArK2lkeDI7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBidXR0ZXJmbHk0ID0gZnVuY3Rpb24gKG91dFJlLCBvdXRJbSwgb3V0SWR4LCBzdHJpZGUsIHR3UmUsIHR3SW0sIG0sIGludmVyc2UpIHtcbiAgICAgICAgdmFyIHNjcmF0Y2gwUmUsIHNjcmF0Y2gwSW0sIHNjcmF0Y2gxUmUsIHNjcmF0Y2gxSW0sIHNjcmF0Y2gyUmUsIHNjcmF0Y2gySW0sXG4gICAgICAgICAgICBzY3JhdGNoM1JlLCBzY3JhdGNoM0ltLCBzY3JhdGNoNFJlLCBzY3JhdGNoNEltLCBzY3JhdGNoNVJlLCBzY3JhdGNoNUltLFxuICAgICAgICAgICAgb3V0MFJlLCBvdXQwSW0sIG91dDFSZSwgb3V0MUltLCBvdXQyUmUsIG91dDJJbSwgb3V0M1JlLCBvdXQzSW0sXG4gICAgICAgICAgICB0UmUsIHRJbTtcblxuICAgICAgICB2YXIgdHcxID0gMCxcbiAgICAgICAgICAgIHR3MiA9IDAsXG4gICAgICAgICAgICB0dzMgPSAwLFxuICAgICAgICAgICAgc3RyaWRlMiA9IDIgKiBzdHJpZGUsXG4gICAgICAgICAgICBzdHJpZGUzID0gMyAqIHN0cmlkZSxcbiAgICAgICAgICAgIGlkeDAgPSBvdXRJZHgsXG4gICAgICAgICAgICBpZHgxID0gb3V0SWR4ICsgbSxcbiAgICAgICAgICAgIGlkeDIgPSBvdXRJZHggKyAyICogbSxcbiAgICAgICAgICAgIGlkeDMgPSBvdXRJZHggKyAzICogbTtcblxuICAgICAgICB2YXIgZGl2NCA9IDEgLyA0O1xuICAgICAgICB2YXIgaWR4MEVuZCA9IGlkeDAgKyBtO1xuICAgICAgICB3aGlsZSAoaWR4MCA8IGlkeDBFbmQpIHtcbiAgICAgICAgICAvLyBvdXQwID0gb3V0W2lkeDBdIC8gNFxuICAgICAgICAgIG91dDBSZSA9IG91dFJlW2lkeDBdICogZGl2NDtcbiAgICAgICAgICBvdXQwSW0gPSBvdXRJbVtpZHgwXSAqIGRpdjQ7XG4gICAgICAgICAgLy8gb3V0MSA9IG91dFtpZHgxXSAvIDRcbiAgICAgICAgICBvdXQxUmUgPSBvdXRSZVtpZHgxXSAqIGRpdjQ7XG4gICAgICAgICAgb3V0MUltID0gb3V0SW1baWR4MV0gKiBkaXY0O1xuICAgICAgICAgIC8vIG91dDIgPSBvdXRbaWR4Ml0gLyA0XG4gICAgICAgICAgb3V0MlJlID0gb3V0UmVbaWR4Ml0gKiBkaXY0O1xuICAgICAgICAgIG91dDJJbSA9IG91dEltW2lkeDJdICogZGl2NDtcbiAgICAgICAgICAvLyBvdXQzID0gb3V0W2lkeDNdIC8gNFxuICAgICAgICAgIG91dDNSZSA9IG91dFJlW2lkeDNdICogZGl2NDtcbiAgICAgICAgICBvdXQzSW0gPSBvdXRJbVtpZHgzXSAqIGRpdjQ7XG5cbiAgICAgICAgICAvLyBzY3JhdGNoMCA9IG91dDEgKiB0d1t0dzFdXG4gICAgICAgICAgdFJlID0gdHdSZVt0dzFdOyB0SW0gPSB0d0ltW3R3MV07XG4gICAgICAgICAgc2NyYXRjaDBSZSA9IG91dDFSZSAqIHRSZSAtIG91dDFJbSAqIHRJbTtcbiAgICAgICAgICBzY3JhdGNoMEltID0gb3V0MVJlICogdEltICsgb3V0MUltICogdFJlO1xuXG4gICAgICAgICAgLy8gc2NyYXRjaDEgPSBvdXQyICogdHdbdHcyXVxuICAgICAgICAgIHRSZSA9IHR3UmVbdHcyXTsgdEltID0gdHdJbVt0dzJdO1xuICAgICAgICAgIHNjcmF0Y2gxUmUgPSBvdXQyUmUgKiB0UmUgLSBvdXQySW0gKiB0SW07XG4gICAgICAgICAgc2NyYXRjaDFJbSA9IG91dDJSZSAqIHRJbSArIG91dDJJbSAqIHRSZTtcblxuICAgICAgICAgIC8vIHNjcmF0Y2gyID0gb3V0MyAqIHR3W3R3M11cbiAgICAgICAgICB0UmUgPSB0d1JlW3R3M107IHRJbSA9IHR3SW1bdHczXTtcbiAgICAgICAgICBzY3JhdGNoMlJlID0gb3V0M1JlICogdFJlIC0gb3V0M0ltICogdEltO1xuICAgICAgICAgIHNjcmF0Y2gySW0gPSBvdXQzUmUgKiB0SW0gKyBvdXQzSW0gKiB0UmU7XG5cbiAgICAgICAgICAvLyBzY3JhdGNoNSA9IG91dDAgLSBzY3JhdGNoMVxuICAgICAgICAgIHNjcmF0Y2g1UmUgPSBvdXQwUmUgLSBzY3JhdGNoMVJlO1xuICAgICAgICAgIHNjcmF0Y2g1SW0gPSBvdXQwSW0gLSBzY3JhdGNoMUltO1xuXG4gICAgICAgICAgLy8gb3V0MCArPSBzY3JhdGNoMVxuICAgICAgICAgIG91dDBSZSArPSBzY3JhdGNoMVJlO1xuICAgICAgICAgIG91dDBJbSArPSBzY3JhdGNoMUltO1xuXG4gICAgICAgICAgLy8gc2NyYXRjaDMgPSBzY3JhdGNoMCArIHNjcmF0Y2gyXG4gICAgICAgICAgc2NyYXRjaDNSZSA9IHNjcmF0Y2gwUmUgKyBzY3JhdGNoMlJlO1xuICAgICAgICAgIHNjcmF0Y2gzSW0gPSBzY3JhdGNoMEltICsgc2NyYXRjaDJJbTtcblxuICAgICAgICAgIC8vIHNjcmF0Y2g0ID0gc2NyYXRjaDAgLSBzY3JhdGNoMlxuICAgICAgICAgIHNjcmF0Y2g0UmUgPSBzY3JhdGNoMFJlIC0gc2NyYXRjaDJSZTtcbiAgICAgICAgICBzY3JhdGNoNEltID0gc2NyYXRjaDBJbSAtIHNjcmF0Y2gySW07XG5cbiAgICAgICAgICAvLyBvdXRbaWR4Ml0gPSBvdXQwIC0gc2NyYXRjaDNcbiAgICAgICAgICBvdXRSZVtpZHgyXSA9IG91dDBSZSAtIHNjcmF0Y2gzUmU7XG4gICAgICAgICAgb3V0SW1baWR4Ml0gPSBvdXQwSW0gLSBzY3JhdGNoM0ltO1xuXG4gICAgICAgICAgLy8gb3V0W2lkeDBdID0gb3V0MCArIHNjcmF0Y2gzXG4gICAgICAgICAgb3V0UmVbaWR4MF0gPSBvdXQwUmUgKyBzY3JhdGNoM1JlO1xuICAgICAgICAgIG91dEltW2lkeDBdID0gb3V0MEltICsgc2NyYXRjaDNJbTtcblxuICAgICAgICAgIGlmIChpbnZlcnNlKSB7XG4gICAgICAgICAgICBvdXRSZVtpZHgxXSA9IHNjcmF0Y2g1UmUgLSBzY3JhdGNoNEltO1xuICAgICAgICAgICAgb3V0SW1baWR4MV0gPSBzY3JhdGNoNUltICsgc2NyYXRjaDRSZTtcbiAgICAgICAgICAgIG91dFJlW2lkeDNdID0gc2NyYXRjaDVSZSArIHNjcmF0Y2g0SW07XG4gICAgICAgICAgICBvdXRJbVtpZHgzXSA9IHNjcmF0Y2g1SW0gLSBzY3JhdGNoNFJlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG91dFJlW2lkeDFdID0gc2NyYXRjaDVSZSArIHNjcmF0Y2g0SW07XG4gICAgICAgICAgICBvdXRJbVtpZHgxXSA9IHNjcmF0Y2g1SW0gLSBzY3JhdGNoNFJlO1xuICAgICAgICAgICAgb3V0UmVbaWR4M10gPSBzY3JhdGNoNVJlIC0gc2NyYXRjaDRJbTtcbiAgICAgICAgICAgIG91dEltW2lkeDNdID0gc2NyYXRjaDVJbSArIHNjcmF0Y2g0UmU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdHcxICs9IHN0cmlkZTsgdHcyICs9IHN0cmlkZTI7IHR3MyArPSBzdHJpZGUzO1xuICAgICAgICAgICsraWR4MDsgKytpZHgxOyArK2lkeDI7ICsraWR4MztcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIGJ1dHRlcmZseTUgPSBmdW5jdGlvbiAob3V0UmUsIG91dEltLCBvdXRJZHgsIHN0cmlkZSwgdHdSZSwgdHdJbSwgbSkge1xuICAgICAgICB2YXIgc2NyYXRjaDBSZSwgc2NyYXRjaDBJbSwgc2NyYXRjaDFSZSwgc2NyYXRjaDFJbSwgc2NyYXRjaDJSZSwgc2NyYXRjaDJJbSxcbiAgICAgICAgICAgIHNjcmF0Y2gzUmUsIHNjcmF0Y2gzSW0sIHNjcmF0Y2g0UmUsIHNjcmF0Y2g0SW0sIHNjcmF0Y2g1UmUsIHNjcmF0Y2g1SW0sXG4gICAgICAgICAgICBzY3JhdGNoNlJlLCBzY3JhdGNoNkltLCBzY3JhdGNoN1JlLCBzY3JhdGNoN0ltLCBzY3JhdGNoOFJlLCBzY3JhdGNoOEltLFxuICAgICAgICAgICAgc2NyYXRjaDlSZSwgc2NyYXRjaDlJbSwgc2NyYXRjaDEwUmUsIHNjcmF0Y2gxMEltLCBzY3JhdGNoMTFSZSwgc2NyYXRjaDExSW0sXG4gICAgICAgICAgICBzY3JhdGNoMTJSZSwgc2NyYXRjaDEySW0sXG4gICAgICAgICAgICBvdXQwUmUsIG91dDBJbSwgb3V0MVJlLCBvdXQxSW0sIG91dDJSZSwgb3V0MkltLCBvdXQzUmUsIG91dDNJbSwgb3V0NFJlLCBvdXQ0SW0sXG4gICAgICAgICAgICB0UmUsIHRJbTtcblxuICAgICAgICB2YXIgdHcxID0gMCxcbiAgICAgICAgICAgIHR3MiA9IDAsXG4gICAgICAgICAgICB0dzMgPSAwLFxuICAgICAgICAgICAgdHc0ID0gMCxcbiAgICAgICAgICAgIHN0cmlkZTIgPSAyICogc3RyaWRlLFxuICAgICAgICAgICAgc3RyaWRlMyA9IDMgKiBzdHJpZGUsXG4gICAgICAgICAgICBzdHJpZGU0ID0gNCAqIHN0cmlkZTtcblxuICAgICAgICB2YXIgaWR4MCA9IG91dElkeCxcbiAgICAgICAgICAgIGlkeDEgPSBvdXRJZHggKyBtLFxuICAgICAgICAgICAgaWR4MiA9IG91dElkeCArIDIgKiBtLFxuICAgICAgICAgICAgaWR4MyA9IG91dElkeCArIDMgKiBtLFxuICAgICAgICAgICAgaWR4NCA9IG91dElkeCArIDQgKiBtO1xuXG4gICAgICAgIC8vIHlhID0gdHdbc3RyaWRlKm1dO1xuICAgICAgICB2YXIgeWFSZSA9IHR3UmVbc3RyaWRlICogbV0sXG4gICAgICAgICAgICB5YUltID0gdHdJbVtzdHJpZGUgKiBtXTtcbiAgICAgICAgLy8geWIgPSB0d1tzdHJpZGUqMiptXTtcbiAgICAgICAgdmFyIHliUmUgPSB0d1JlW3N0cmlkZSAqIDIgKiBtXSxcbiAgICAgICAgICAgIHliSW0gPSB0d0ltW3N0cmlkZSAqIDIgKiBtXTtcblxuICAgICAgICB2YXIgZGl2NSA9IDEgLyA1O1xuICAgICAgICB2YXIgaWR4MEVuZCA9IGlkeDAgKyBtO1xuICAgICAgICB3aGlsZSAoaWR4MCA8IGlkeDBFbmQpIHtcbiAgICAgICAgICAvLyBvdXQwID0gb3V0W2lkeDBdIC8gNVxuICAgICAgICAgIG91dDBSZSA9IG91dFJlW2lkeDBdICogZGl2NTtcbiAgICAgICAgICBvdXQwSW0gPSBvdXRJbVtpZHgwXSAqIGRpdjU7XG4gICAgICAgICAgLy8gb3V0MSA9IG91dFtpZHgxXSAvIDVcbiAgICAgICAgICBvdXQxUmUgPSBvdXRSZVtpZHgxXSAqIGRpdjU7XG4gICAgICAgICAgb3V0MUltID0gb3V0SW1baWR4MV0gKiBkaXY1O1xuICAgICAgICAgIC8vIG91dDIgPSBvdXRbaWR4Ml0gLyA1XG4gICAgICAgICAgb3V0MlJlID0gb3V0UmVbaWR4Ml0gKiBkaXY1O1xuICAgICAgICAgIG91dDJJbSA9IG91dEltW2lkeDJdICogZGl2NTtcbiAgICAgICAgICAvLyBvdXQzID0gb3V0W2lkeDNdIC8gNVxuICAgICAgICAgIG91dDNSZSA9IG91dFJlW2lkeDNdICogZGl2NTtcbiAgICAgICAgICBvdXQzSW0gPSBvdXRJbVtpZHgzXSAqIGRpdjU7XG4gICAgICAgICAgLy8gb3V0NCA9IG91dFtpZHg0XSAvIDVcbiAgICAgICAgICBvdXQ0UmUgPSBvdXRSZVtpZHg0XSAqIGRpdjU7XG4gICAgICAgICAgb3V0NEltID0gb3V0SW1baWR4NF0gKiBkaXY1O1xuXG4gICAgICAgICAgLy8gc2NyYXRjaDAgPSBvdXQwO1xuICAgICAgICAgIHNjcmF0Y2gwUmUgPSBvdXQwUmU7XG4gICAgICAgICAgc2NyYXRjaDBJbSA9IG91dDBJbTtcblxuICAgICAgICAgIC8vIHNjcmF0Y2gxID0gb3V0MSAqIHR3W3R3MV1cbiAgICAgICAgICB0UmUgPSB0d1JlW3R3MV07IHRJbSA9IHR3SW1bdHcxXTtcbiAgICAgICAgICBzY3JhdGNoMVJlID0gb3V0MVJlICogdFJlIC0gb3V0MUltICogdEltO1xuICAgICAgICAgIHNjcmF0Y2gxSW0gPSBvdXQxUmUgKiB0SW0gKyBvdXQxSW0gKiB0UmU7XG4gICAgICAgICAgLy8gc2NyYXRjaDIgPSBvdXQyICogdHdbdHcyXVxuICAgICAgICAgIHRSZSA9IHR3UmVbdHcyXTsgdEltID0gdHdJbVt0dzJdO1xuICAgICAgICAgIHNjcmF0Y2gyUmUgPSBvdXQyUmUgKiB0UmUgLSBvdXQySW0gKiB0SW07XG4gICAgICAgICAgc2NyYXRjaDJJbSA9IG91dDJSZSAqIHRJbSArIG91dDJJbSAqIHRSZTtcbiAgICAgICAgICAvLyBzY3JhdGNoMyA9IG91dDMgKiB0d1t0dzNdXG4gICAgICAgICAgdFJlID0gdHdSZVt0dzNdOyB0SW0gPSB0d0ltW3R3M107XG4gICAgICAgICAgc2NyYXRjaDNSZSA9IG91dDNSZSAqIHRSZSAtIG91dDNJbSAqIHRJbTtcbiAgICAgICAgICBzY3JhdGNoM0ltID0gb3V0M1JlICogdEltICsgb3V0M0ltICogdFJlO1xuICAgICAgICAgIC8vIHNjcmF0Y2g0ID0gb3V0NCAqIHR3W3R3NF1cbiAgICAgICAgICB0UmUgPSB0d1JlW3R3NF07IHRJbSA9IHR3SW1bdHc0XTtcbiAgICAgICAgICBzY3JhdGNoNFJlID0gb3V0NFJlICogdFJlIC0gb3V0NEltICogdEltO1xuICAgICAgICAgIHNjcmF0Y2g0SW0gPSBvdXQ0UmUgKiB0SW0gKyBvdXQ0SW0gKiB0UmU7XG5cbiAgICAgICAgICAvLyBzY3JhdGNoNyA9IHNjcmF0Y2gxICsgc2NyYXRjaDRcbiAgICAgICAgICBzY3JhdGNoN1JlID0gc2NyYXRjaDFSZSArIHNjcmF0Y2g0UmU7XG4gICAgICAgICAgc2NyYXRjaDdJbSA9IHNjcmF0Y2gxSW0gKyBzY3JhdGNoNEltO1xuICAgICAgICAgIC8vIHNjcmF0Y2gxMCA9IHNjcmF0Y2gxIC0gc2NyYXRjaDRcbiAgICAgICAgICBzY3JhdGNoMTBSZSA9IHNjcmF0Y2gxUmUgLSBzY3JhdGNoNFJlO1xuICAgICAgICAgIHNjcmF0Y2gxMEltID0gc2NyYXRjaDFJbSAtIHNjcmF0Y2g0SW07XG4gICAgICAgICAgLy8gc2NyYXRjaDggPSBzY3JhdGNoMiArIHNjcmF0Y2gyXG4gICAgICAgICAgc2NyYXRjaDhSZSA9IHNjcmF0Y2gyUmUgKyBzY3JhdGNoM1JlO1xuICAgICAgICAgIHNjcmF0Y2g4SW0gPSBzY3JhdGNoMkltICsgc2NyYXRjaDNJbTtcbiAgICAgICAgICAvLyBzY3JhdGNoOSA9IHNjcmF0Y2gyIC0gc2NyYXRjaDNcbiAgICAgICAgICBzY3JhdGNoOVJlID0gc2NyYXRjaDJSZSAtIHNjcmF0Y2gzUmU7XG4gICAgICAgICAgc2NyYXRjaDlJbSA9IHNjcmF0Y2gySW0gLSBzY3JhdGNoM0ltO1xuXG4gICAgICAgICAgLy8gb3V0W2lkeDBdID0gb3V0MCArIHNjcmF0Y2g3ICsgc2NyYXRjaDhcbiAgICAgICAgICBvdXRSZVtpZHgwXSA9IG91dDBSZSArIHNjcmF0Y2g3UmUgKyBzY3JhdGNoOFJlO1xuICAgICAgICAgIG91dEltW2lkeDBdID0gb3V0MEltICsgc2NyYXRjaDdJbSArIHNjcmF0Y2g4SW07XG5cbiAgICAgICAgICBzY3JhdGNoNVJlID0gc2NyYXRjaDBSZSArIHNjcmF0Y2g3UmUgKiB5YVJlICsgc2NyYXRjaDhSZSAqIHliUmU7XG4gICAgICAgICAgc2NyYXRjaDVJbSA9IHNjcmF0Y2gwSW0gKyBzY3JhdGNoN0ltICogeWFSZSArIHNjcmF0Y2g4SW0gKiB5YlJlO1xuXG4gICAgICAgICAgc2NyYXRjaDZSZSA9IHNjcmF0Y2gxMEltICogeWFJbSArIHNjcmF0Y2g5SW0gKiB5YkltO1xuICAgICAgICAgIHNjcmF0Y2g2SW0gPSAtc2NyYXRjaDEwUmUgKiB5YUltIC0gc2NyYXRjaDlSZSAqIHliSW07XG5cbiAgICAgICAgICAvLyBvdXRbaWR4MV0gPSBzY3JhdGNoNSAtIHNjcmF0Y2g2XG4gICAgICAgICAgb3V0UmVbaWR4MV0gPSBzY3JhdGNoNVJlIC0gc2NyYXRjaDZSZTtcbiAgICAgICAgICBvdXRJbVtpZHgxXSA9IHNjcmF0Y2g1SW0gLSBzY3JhdGNoNkltO1xuICAgICAgICAgIC8vIG91dFtpZHg0XSA9IHNjcmF0Y2g1ICsgc2NyYXRjaDZcbiAgICAgICAgICBvdXRSZVtpZHg0XSA9IHNjcmF0Y2g1UmUgKyBzY3JhdGNoNlJlO1xuICAgICAgICAgIG91dEltW2lkeDRdID0gc2NyYXRjaDVJbSArIHNjcmF0Y2g2SW07XG5cbiAgICAgICAgICBzY3JhdGNoMTFSZSA9IHNjcmF0Y2gwUmUgKyBzY3JhdGNoN1JlICogeWJSZSArIHNjcmF0Y2g4UmUgKiB5YVJlO1xuICAgICAgICAgIHNjcmF0Y2gxMUltID0gc2NyYXRjaDBJbSArIHNjcmF0Y2g3SW0gKiB5YlJlICsgc2NyYXRjaDhJbSAqIHlhUmU7XG5cbiAgICAgICAgICBzY3JhdGNoMTJSZSA9IC1zY3JhdGNoMTBJbSAqIHliSW0gKyBzY3JhdGNoOUltICogeWFJbTtcbiAgICAgICAgICBzY3JhdGNoMTJJbSA9IHNjcmF0Y2gxMFJlICogeWJJbSAtIHNjcmF0Y2g5UmUgKiB5YUltO1xuXG4gICAgICAgICAgLy8gb3V0W2lkeDJdID0gc2NyYXRjaDExICsgc2NyYXRjaDEyXG4gICAgICAgICAgb3V0UmVbaWR4Ml0gPSBzY3JhdGNoMTFSZSArIHNjcmF0Y2gxMlJlO1xuICAgICAgICAgIG91dEltW2lkeDJdID0gc2NyYXRjaDExSW0gKyBzY3JhdGNoMTJJbTtcbiAgICAgICAgICAvLyBvdXRbaWR4M10gPSBzY3JhdGNoMTEgLSBzY3JhdGNoMTJcbiAgICAgICAgICBvdXRSZVtpZHgzXSA9IHNjcmF0Y2gxMVJlIC0gc2NyYXRjaDEyUmU7XG4gICAgICAgICAgb3V0SW1baWR4M10gPSBzY3JhdGNoMTFJbSAtIHNjcmF0Y2gxMkltO1xuXG4gICAgICAgICAgdHcxICs9IHN0cmlkZTsgdHcyICs9IHN0cmlkZTI7IHR3MyArPSBzdHJpZGUzOyB0dzQgKz0gc3RyaWRlNDtcbiAgICAgICAgICArK2lkeDA7ICsraWR4MTsgKytpZHgyOyArK2lkeDM7ICsraWR4NDtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIGJ1dHRlcmZseU4gPSBmdW5jdGlvbiAob3V0UmUsIG91dEltLCBvdXRJZHgsIHN0cmlkZSwgdHdSZSwgdHdJbSwgbSwgcCwgc2l6ZSkge1xuICAgICAgICB2YXIgdSwgcTEsIHEsIGlkeDA7XG4gICAgICAgIHZhciBvdXQwUmUsIG91dDBJbSwgYVJlLCBhSW0sIHRSZSwgdEltO1xuXG4gICAgICAgIC8vIEZJWE1FOiBBbGxvY2F0ZSBzdGF0aWNhbGx5XG4gICAgICAgIHZhciBzY3JhdGNoUmUgPSBuZXcgRmxvYXQzMkFycmF5KHApO1xuICAgICAgICB2YXIgc2NyYXRjaEltID0gbmV3IEZsb2F0MzJBcnJheShwKTtcblxuICAgICAgICB2YXIgcEludiA9IDEgLyBwO1xuICAgICAgICBmb3IgKHUgPSAwOyB1IDwgbTsgKyt1KSB7XG4gICAgICAgICAgaWR4MCA9IG91dElkeCArIHU7XG4gICAgICAgICAgZm9yIChxMSA9IDA7IHExIDwgcDsgKytxMSkge1xuICAgICAgICAgICAgLy8gc2NyYXRjaFtxMV0gPSBvdXRbaWR4MF0gLyBwXG4gICAgICAgICAgICBzY3JhdGNoUmVbcTFdID0gb3V0UmVbaWR4MF0gKiBwSW52O1xuICAgICAgICAgICAgc2NyYXRjaEltW3ExXSA9IG91dEltW2lkeDBdICogcEludjtcbiAgICAgICAgICAgIGlkeDAgKz0gbTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZHgwID0gb3V0SWR4ICsgdTtcbiAgICAgICAgICB2YXIgdHcxSW5jciA9IHN0cmlkZSAqIHU7XG4gICAgICAgICAgZm9yIChxMSA9IDA7IHExIDwgcDsgKytxMSkge1xuICAgICAgICAgICAgLy8gb3V0MCA9IHNjcmF0Y2hbMF1cbiAgICAgICAgICAgIG91dDBSZSA9IHNjcmF0Y2hSZVswXTtcbiAgICAgICAgICAgIG91dDBJbSA9IHNjcmF0Y2hJbVswXTtcblxuICAgICAgICAgICAgdmFyIHR3MSA9IDA7XG4gICAgICAgICAgICBmb3IgKHEgPSAxOyBxIDwgcDsgKytxKSB7XG4gICAgICAgICAgICAgIHR3MSArPSB0dzFJbmNyO1xuICAgICAgICAgICAgICBpZiAodHcxID49IHNpemUpXG4gICAgICAgICAgICAgICAgdHcxIC09IHNpemU7XG5cbiAgICAgICAgICAgICAgLy8gb3V0MCArPSBzY3JhdGNoW3FdICogdHdbdHcxXVxuICAgICAgICAgICAgICBhUmUgPSBzY3JhdGNoUmVbcV0sIGFJbSA9IHNjcmF0Y2hJbVtxXTtcbiAgICAgICAgICAgICAgdFJlID0gdHdSZVt0dzFdLCB0SW0gPSB0d0ltW3R3MV07XG4gICAgICAgICAgICAgIG91dDBSZSArPSBhUmUgKiB0UmUgLSBhSW0gKiB0SW07XG4gICAgICAgICAgICAgIG91dDBJbSArPSBhUmUgKiB0SW0gKyBhSW0gKiB0UmU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG91dFtpZHgwXSA9IG91dDBcbiAgICAgICAgICAgIG91dFJlW2lkeDBdID0gb3V0MFJlO1xuICAgICAgICAgICAgb3V0SW1baWR4MF0gPSBvdXQwSW07XG5cbiAgICAgICAgICAgIGlkeDAgKz0gbTtcbiAgICAgICAgICAgIHR3MUluY3IgKz0gc3RyaWRlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIHdvcmsgPSBmdW5jdGlvbiAob3V0UmUsIG91dEltLCBvdXRJZHgsIGZSZSwgZkltLCBmSWR4LCBzdHJpZGUsIGluU3RyaWRlLCBmYWN0b3JzLCBmYWN0b3JzSWR4LCB0d1JlLCB0d0ltLCBzaXplLCBpbnZlcnNlKSB7XG4gICAgICAgIHZhciBwID0gZmFjdG9yc1tmYWN0b3JzSWR4KytdOyAgLy8gUmFkaXhcbiAgICAgICAgdmFyIG0gPSBmYWN0b3JzW2ZhY3RvcnNJZHgrK107ICAvLyBTdGFnZSdzIEZGVCBsZW5ndGggLyBwXG5cbiAgICAgICAgdmFyIG91dElkeEJlZyA9IG91dElkeDtcbiAgICAgICAgdmFyIG91dElkeEVuZCA9IG91dElkeCArIHAgKiBtO1xuXG4gICAgICAgIHZhciBmSWR4SW5jciA9IHN0cmlkZSAqIGluU3RyaWRlO1xuICAgICAgICBpZiAobSA9PSAxKSB7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgb3V0UmVbb3V0SWR4XSA9IGZSZVtmSWR4XTtcbiAgICAgICAgICAgIG91dEltW291dElkeF0gPSBmSW1bZklkeF07XG4gICAgICAgICAgICBmSWR4ICs9IGZJZHhJbmNyO1xuICAgICAgICAgICAgKytvdXRJZHg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlIChvdXRJZHggIT0gb3V0SWR4RW5kKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAvLyBERlQgb2Ygc2l6ZSBtKnAgcGVyZm9ybWVkIGJ5IGRvaW5nIHAgaW5zdGFuY2VzIG9mIHNtYWxsZXIgREZUcyBvZlxuICAgICAgICAgICAgLy8gc2l6ZSBtLCBlYWNoIG9uZSB0YWtlcyBhIGRlY2ltYXRlZCB2ZXJzaW9uIG9mIHRoZSBpbnB1dC5cbiAgICAgICAgICAgIHdvcmsob3V0UmUsIG91dEltLCBvdXRJZHgsIGZSZSwgZkltLCBmSWR4LCBzdHJpZGUgKiBwLCBpblN0cmlkZSwgZmFjdG9ycywgZmFjdG9yc0lkeCwgdHdSZSwgdHdJbSwgc2l6ZSwgaW52ZXJzZSk7XG4gICAgICAgICAgICBmSWR4ICs9IGZJZHhJbmNyO1xuICAgICAgICAgICAgb3V0SWR4ICs9IG07XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlIChvdXRJZHggIT0gb3V0SWR4RW5kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dElkeCA9IG91dElkeEJlZztcblxuICAgICAgICAvLyBSZWNvbWJpbmUgdGhlIHAgc21hbGxlciBERlRzXG4gICAgICAgIHN3aXRjaCAocCkge1xuICAgICAgICAgIGNhc2UgMjogIGJ1dHRlcmZseTIob3V0UmUsIG91dEltLCBvdXRJZHgsIHN0cmlkZSwgdHdSZSwgdHdJbSwgbSk7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzogIGJ1dHRlcmZseTMob3V0UmUsIG91dEltLCBvdXRJZHgsIHN0cmlkZSwgdHdSZSwgdHdJbSwgbSk7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDogIGJ1dHRlcmZseTQob3V0UmUsIG91dEltLCBvdXRJZHgsIHN0cmlkZSwgdHdSZSwgdHdJbSwgbSwgaW52ZXJzZSk7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgNTogIGJ1dHRlcmZseTUob3V0UmUsIG91dEltLCBvdXRJZHgsIHN0cmlkZSwgdHdSZSwgdHdJbSwgbSk7IGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6IGJ1dHRlcmZseU4ob3V0UmUsIG91dEltLCBvdXRJZHgsIHN0cmlkZSwgdHdSZSwgdHdJbSwgbSwgcCwgc2l6ZSk7IGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvKiAgZmFjQnVmIGlzIHBvcHVsYXRlZCBieSBwMSxtMSxwMixtMiwgLi4uXG4gICAgICAgICAgd2hlcmVcbiAgICAgICAgICBwW2ldICogbVtpXSA9IG1baS0xXVxuICAgICAgICAgIG0wID0gbiAgICAgICAgICAgICAgICAgICovXG4gICAgICB2YXIgZmFjdG9yID0gZnVuY3Rpb24gKG4sIGZhY0J1Zikge1xuICAgICAgICAvLyBGYWN0b3Igb3V0IHBvd2VycyBvZiA0LCBwb3dlcnMgb2YgMiwgdGhlbiBhbnkgcmVtYWluaW5nIHByaW1lc1xuICAgICAgICB2YXIgcCA9IDQ7XG4gICAgICAgIHZhciBmbG9vclNxcnQgPSBNYXRoLmZsb29yKE1hdGguc3FydChuKSk7XG4gICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgd2hpbGUgKG4gJSBwKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHApIHtcbiAgICAgICAgICAgICAgY2FzZSA0OiAgcCA9IDI7IGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDI6ICBwID0gMzsgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6IHAgKz0gMjsgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocCA+IGZsb29yU3FydClcbiAgICAgICAgICAgICAgcCA9IG47XG4gICAgICAgICAgfVxuICAgICAgICAgIG4gPSBNYXRoLmZsb29yKG4gLyBwKTtcbiAgICAgICAgICBmYWNCdWZbaWR4KytdID0gcDtcbiAgICAgICAgICBmYWNCdWZbaWR4KytdID0gbjtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAobiA+IDEpO1xuICAgICAgfTtcblxuICAgICAgdmFyIEZGVCA9IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgIGlmICghc2l6ZSlcbiAgICAgICAgICBzaXplID0gMjU2O1xuICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xuXG4gICAgICAgIC8vIEFsbG9jYXRlIGFycmF5cyBmb3IgdHdpZGRsZSBmYWN0b3JzXG4gICAgICAgIHRoaXMuX3R3aWRkbGVzRndkUmUgPSBuZXcgRmxvYXQzMkFycmF5KHNpemUpO1xuICAgICAgICB0aGlzLl90d2lkZGxlc0Z3ZEltID0gbmV3IEZsb2F0MzJBcnJheShzaXplKTtcbiAgICAgICAgdGhpcy5fdHdpZGRsZXNJbnZSZSA9IHRoaXMuX3R3aWRkbGVzRndkUmU7XG4gICAgICAgIHRoaXMuX3R3aWRkbGVzSW52SW0gPSBuZXcgRmxvYXQzMkFycmF5KHNpemUpO1xuXG4gICAgICAgIC8vIEluaXQgdHdpZGRsZSBmYWN0b3JzIChib3RoIGZvcndhcmQgJiByZXZlcnNlKVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgICAgICAgdmFyIHBoYXNlID0gLTIqTWF0aC5QSSppIC8gc2l6ZTtcbiAgICAgICAgICAgIHZhciBjb3NQaGFzZSA9IE1hdGguY29zKHBoYXNlKSwgc2luUGhhc2UgPSBNYXRoLnNpbihwaGFzZSk7XG4gICAgICAgICAgICB0aGlzLl90d2lkZGxlc0Z3ZFJlW2ldID0gY29zUGhhc2U7XG4gICAgICAgICAgICB0aGlzLl90d2lkZGxlc0Z3ZEltW2ldID0gc2luUGhhc2U7XG4gICAgICAgICAgICB0aGlzLl90d2lkZGxlc0ludkltW2ldID0gLXNpblBoYXNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWxsb2NhdGUgYXJyYXlzIGZvciByYWRpeCBwbGFuXG4gICAgICAgIHRoaXMuX2ZhY3RvcnMgPSBuZXcgSW50MzJBcnJheSgyICogMzIpOyAgLy8gTUFYRkFDVE9SUyA9IDMyXG5cbiAgICAgICAgLy8gSW5pdCByYWRpeCBmYWN0b3JzIChtaXhlZCByYWRpeCBicmVha2Rvd24pXG4gICAgICAgIGZhY3RvcihzaXplLCB0aGlzLl9mYWN0b3JzKTtcbiAgICAgIH07XG5cbiAgICAgIEZGVC5wcm90b3R5cGUuZm9yd2FyZENwbHggPSBmdW5jdGlvbiAoZHN0UmVhbCwgZHN0SW1hZywgeFJlYWwsIHhJbWFnKSB7XG4gICAgICAgIHZhciB0d1JlID0gdGhpcy5fdHdpZGRsZXNGd2RSZTtcbiAgICAgICAgdmFyIHR3SW0gPSB0aGlzLl90d2lkZGxlc0Z3ZEltO1xuICAgICAgICB3b3JrKGRzdFJlYWwsIGRzdEltYWcsIDAsIHhSZWFsLCB4SW1hZywgMCwgMSwgMSwgdGhpcy5fZmFjdG9ycywgMCwgdHdSZSwgdHdJbSwgdGhpcy5zaXplLCBmYWxzZSk7XG4gICAgICB9O1xuXG4gICAgICBGRlQucHJvdG90eXBlLmZvcndhcmQgPSBmdW5jdGlvbiAoZHN0UmVhbCwgZHN0SW1hZywgeCkge1xuICAgICAgICAvLyBGSVhNRTogT3B0aW1pemUgdGhpcyBjYXNlIChyZWFsIGlucHV0IHNpZ25hbClcbiAgICAgICAgdGhpcy5mb3J3YXJkQ3BseChkc3RSZWFsLCBkc3RJbWFnLCB4LCBuZXcgRmxvYXQzMkFycmF5KHRoaXMuc2l6ZSkpO1xuICAgICAgfTtcblxuICAgICAgRkZULnByb3RvdHlwZS5pbnZlcnNlQ3BseCA9IGZ1bmN0aW9uIChkc3RSZWFsLCBkc3RJbWFnLCB4UmVhbCwgeEltYWcpIHtcbiAgICAgICAgdmFyIHR3UmUgPSB0aGlzLl90d2lkZGxlc0ludlJlO1xuICAgICAgICB2YXIgdHdJbSA9IHRoaXMuX3R3aWRkbGVzSW52SW07XG4gICAgICAgIHdvcmsoZHN0UmVhbCwgZHN0SW1hZywgMCwgeFJlYWwsIHhJbWFnLCAwLCAxLCAxLCB0aGlzLl9mYWN0b3JzLCAwLCB0d1JlLCB0d0ltLCB0aGlzLnNpemUsIHRydWUpO1xuICAgICAgfTtcblxuICAgICAgRkZULnByb3RvdHlwZS5pbnZlcnNlID0gZnVuY3Rpb24gKGRzdCwgeFJlYWwsIHhJbWFnKSB7XG4gICAgICAgIC8vIEZJWE1FOiBPcHRpbWl6ZSB0aGlzIGNhc2UgKHJlYWwgb3V0cHV0IHNpZ25hbClcbiAgICAgICAgdGhpcy5pbnZlcnNlQ3BseChkc3QsIG5ldyBGbG9hdDMyQXJyYXkodGhpcy5zaXplKSwgeFJlYWwsIHhJbWFnKTtcbiAgICAgIH07XG5cbiAgICAgIGcuRkZUID0gRkZUO1xuICAgIH0pKCk7XG5cbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgICAgIERTUDogZy5EU1AsXG4gICAgICAgICAgICBGaWx0ZXI6IGcuRmlsdGVyLFxuICAgICAgICAgICAgRkZUOiBnLkZGVFxuICAgICAgICB9O1xuICAgIH1cbn0pKCk7XG47XG4vKiogUmFuZG9tLmpzIGxpYnJhcnkuXG4gKiBcbiAqIFRoZSBjb2RlIGlzIGxpY2Vuc2VkIGFzIExHUEwuXG4qL1xuXG4vKiBcbiAgIEEgQy1wcm9ncmFtIGZvciBNVDE5OTM3LCB3aXRoIGluaXRpYWxpemF0aW9uIGltcHJvdmVkIDIwMDIvMS8yNi5cbiAgIENvZGVkIGJ5IFRha3VqaSBOaXNoaW11cmEgYW5kIE1ha290byBNYXRzdW1vdG8uXG4gXG4gICBCZWZvcmUgdXNpbmcsIGluaXRpYWxpemUgdGhlIHN0YXRlIGJ5IHVzaW5nIGluaXRfZ2VucmFuZChzZWVkKSAgXG4gICBvciBpbml0X2J5X2FycmF5KGluaXRfa2V5LCBrZXlfbGVuZ3RoKS5cbiBcbiAgIENvcHlyaWdodCAoQykgMTk5NyAtIDIwMDIsIE1ha290byBNYXRzdW1vdG8gYW5kIFRha3VqaSBOaXNoaW11cmEsXG4gICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gXG4gICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICAgYXJlIG1ldDpcblxuICAgICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG5cbiAgICAgMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICAgICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gICAgIDMuIFRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heSBub3QgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgXG4gICAgICAgIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBcbiAgICAgICAgcGVybWlzc2lvbi5cblxuICAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICAgXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICAgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gICBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgT1dORVIgT1JcbiAgIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLFxuICAgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuICAgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gICBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXG4gICBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuICAgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG4gICBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cblxuXG4gICBBbnkgZmVlZGJhY2sgaXMgdmVyeSB3ZWxjb21lLlxuICAgaHR0cDovL3d3dy5tYXRoLnNjaS5oaXJvc2hpbWEtdS5hYy5qcC9+bS1tYXQvTVQvZW10Lmh0bWxcbiAgIGVtYWlsOiBtLW1hdCBAIG1hdGguc2NpLmhpcm9zaGltYS11LmFjLmpwIChyZW1vdmUgc3BhY2UpXG4gKi9cblxudmFyIFJhbmRvbSA9IGZ1bmN0aW9uKHNlZWQpIHtcblx0c2VlZCA9IChzZWVkID09PSB1bmRlZmluZWQpID8gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSA6IHNlZWQ7XG5cdGlmICh0eXBlb2Yoc2VlZCkgIT09ICdudW1iZXInICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBUkdfQ0hFQ0tcblx0XHR8fCBNYXRoLmNlaWwoc2VlZCkgIT0gTWF0aC5mbG9vcihzZWVkKSkgeyAgICAgICAgICAgICAvLyBBUkdfQ0hFQ0tcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKFwic2VlZCB2YWx1ZSBtdXN0IGJlIGFuIGludGVnZXJcIik7IC8vIEFSR19DSEVDS1xuXHR9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQVJHX0NIRUNLXG5cdFxuXHRcblx0LyogUGVyaW9kIHBhcmFtZXRlcnMgKi8gIFxuXHR0aGlzLk4gPSA2MjQ7XG5cdHRoaXMuTSA9IDM5Nztcblx0dGhpcy5NQVRSSVhfQSA9IDB4OTkwOGIwZGY7ICAgLyogY29uc3RhbnQgdmVjdG9yIGEgKi9cblx0dGhpcy5VUFBFUl9NQVNLID0gMHg4MDAwMDAwMDsgLyogbW9zdCBzaWduaWZpY2FudCB3LXIgYml0cyAqL1xuXHR0aGlzLkxPV0VSX01BU0sgPSAweDdmZmZmZmZmOyAvKiBsZWFzdCBzaWduaWZpY2FudCByIGJpdHMgKi9cblxuXHR0aGlzLm10ID0gbmV3IEFycmF5KHRoaXMuTik7IC8qIHRoZSBhcnJheSBmb3IgdGhlIHN0YXRlIHZlY3RvciAqL1xuXHR0aGlzLm10aT10aGlzLk4rMTsgLyogbXRpPT1OKzEgbWVhbnMgbXRbTl0gaXMgbm90IGluaXRpYWxpemVkICovXG5cblx0Ly90aGlzLmluaXRfZ2VucmFuZChzZWVkKTtcblx0dGhpcy5pbml0X2J5X2FycmF5KFtzZWVkXSwgMSk7XG59O1xuXG4vKiBpbml0aWFsaXplcyBtdFtOXSB3aXRoIGEgc2VlZCAqL1xuUmFuZG9tLnByb3RvdHlwZS5pbml0X2dlbnJhbmQgPSBmdW5jdGlvbihzKSB7XG5cdHRoaXMubXRbMF0gPSBzID4+PiAwO1xuXHRmb3IgKHRoaXMubXRpPTE7IHRoaXMubXRpPHRoaXMuTjsgdGhpcy5tdGkrKykge1xuXHRcdHZhciBzID0gdGhpcy5tdFt0aGlzLm10aS0xXSBeICh0aGlzLm10W3RoaXMubXRpLTFdID4+PiAzMCk7XG5cdFx0dGhpcy5tdFt0aGlzLm10aV0gPSAoKCgoKHMgJiAweGZmZmYwMDAwKSA+Pj4gMTYpICogMTgxMjQzMzI1MykgPDwgMTYpICsgKHMgJiAweDAwMDBmZmZmKSAqIDE4MTI0MzMyNTMpXG5cdFx0KyB0aGlzLm10aTtcblx0XHQvKiBTZWUgS251dGggVEFPQ1AgVm9sMi4gM3JkIEVkLiBQLjEwNiBmb3IgbXVsdGlwbGllci4gKi9cblx0XHQvKiBJbiB0aGUgcHJldmlvdXMgdmVyc2lvbnMsIE1TQnMgb2YgdGhlIHNlZWQgYWZmZWN0ICAgKi9cblx0XHQvKiBvbmx5IE1TQnMgb2YgdGhlIGFycmF5IG10W10uICAgICAgICAgICAgICAgICAgICAgICAgKi9cblx0XHQvKiAyMDAyLzAxLzA5IG1vZGlmaWVkIGJ5IE1ha290byBNYXRzdW1vdG8gICAgICAgICAgICAgKi9cblx0XHR0aGlzLm10W3RoaXMubXRpXSA+Pj49IDA7XG5cdFx0LyogZm9yID4zMiBiaXQgbWFjaGluZXMgKi9cblx0fVxufTtcblxuLyogaW5pdGlhbGl6ZSBieSBhbiBhcnJheSB3aXRoIGFycmF5LWxlbmd0aCAqL1xuLyogaW5pdF9rZXkgaXMgdGhlIGFycmF5IGZvciBpbml0aWFsaXppbmcga2V5cyAqL1xuLyoga2V5X2xlbmd0aCBpcyBpdHMgbGVuZ3RoICovXG4vKiBzbGlnaHQgY2hhbmdlIGZvciBDKyssIDIwMDQvMi8yNiAqL1xuUmFuZG9tLnByb3RvdHlwZS5pbml0X2J5X2FycmF5ID0gZnVuY3Rpb24oaW5pdF9rZXksIGtleV9sZW5ndGgpIHtcblx0dmFyIGksIGosIGs7XG5cdHRoaXMuaW5pdF9nZW5yYW5kKDE5NjUwMjE4KTtcblx0aT0xOyBqPTA7XG5cdGsgPSAodGhpcy5OPmtleV9sZW5ndGggPyB0aGlzLk4gOiBrZXlfbGVuZ3RoKTtcblx0Zm9yICg7IGs7IGstLSkge1xuXHRcdHZhciBzID0gdGhpcy5tdFtpLTFdIF4gKHRoaXMubXRbaS0xXSA+Pj4gMzApO1xuXHRcdHRoaXMubXRbaV0gPSAodGhpcy5tdFtpXSBeICgoKCgocyAmIDB4ZmZmZjAwMDApID4+PiAxNikgKiAxNjY0NTI1KSA8PCAxNikgKyAoKHMgJiAweDAwMDBmZmZmKSAqIDE2NjQ1MjUpKSlcblx0XHQrIGluaXRfa2V5W2pdICsgajsgLyogbm9uIGxpbmVhciAqL1xuXHRcdHRoaXMubXRbaV0gPj4+PSAwOyAvKiBmb3IgV09SRFNJWkUgPiAzMiBtYWNoaW5lcyAqL1xuXHRcdGkrKzsgaisrO1xuXHRcdGlmIChpPj10aGlzLk4pIHsgdGhpcy5tdFswXSA9IHRoaXMubXRbdGhpcy5OLTFdOyBpPTE7IH1cblx0XHRpZiAoaj49a2V5X2xlbmd0aCkgaj0wO1xuXHR9XG5cdGZvciAoaz10aGlzLk4tMTsgazsgay0tKSB7XG5cdFx0dmFyIHMgPSB0aGlzLm10W2ktMV0gXiAodGhpcy5tdFtpLTFdID4+PiAzMCk7XG5cdFx0dGhpcy5tdFtpXSA9ICh0aGlzLm10W2ldIF4gKCgoKChzICYgMHhmZmZmMDAwMCkgPj4+IDE2KSAqIDE1NjYwODM5NDEpIDw8IDE2KSArIChzICYgMHgwMDAwZmZmZikgKiAxNTY2MDgzOTQxKSlcblx0XHQtIGk7IC8qIG5vbiBsaW5lYXIgKi9cblx0XHR0aGlzLm10W2ldID4+Pj0gMDsgLyogZm9yIFdPUkRTSVpFID4gMzIgbWFjaGluZXMgKi9cblx0XHRpKys7XG5cdFx0aWYgKGk+PXRoaXMuTikgeyB0aGlzLm10WzBdID0gdGhpcy5tdFt0aGlzLk4tMV07IGk9MTsgfVxuXHR9XG5cblx0dGhpcy5tdFswXSA9IDB4ODAwMDAwMDA7IC8qIE1TQiBpcyAxOyBhc3N1cmluZyBub24temVybyBpbml0aWFsIGFycmF5ICovIFxufTtcbiBcbi8qIGdlbmVyYXRlcyBhIHJhbmRvbSBudW1iZXIgb24gWzAsMHhmZmZmZmZmZl0taW50ZXJ2YWwgKi9cblJhbmRvbS5wcm90b3R5cGUuZ2VucmFuZF9pbnQzMiA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgeTtcblx0dmFyIG1hZzAxID0gbmV3IEFycmF5KDB4MCwgdGhpcy5NQVRSSVhfQSk7XG5cdC8qIG1hZzAxW3hdID0geCAqIE1BVFJJWF9BICBmb3IgeD0wLDEgKi9cblxuXHRpZiAodGhpcy5tdGkgPj0gdGhpcy5OKSB7IC8qIGdlbmVyYXRlIE4gd29yZHMgYXQgb25lIHRpbWUgKi9cblx0XHR2YXIga2s7XG5cblx0XHRpZiAodGhpcy5tdGkgPT0gdGhpcy5OKzEpICAgLyogaWYgaW5pdF9nZW5yYW5kKCkgaGFzIG5vdCBiZWVuIGNhbGxlZCwgKi9cblx0XHRcdHRoaXMuaW5pdF9nZW5yYW5kKDU0ODkpOyAvKiBhIGRlZmF1bHQgaW5pdGlhbCBzZWVkIGlzIHVzZWQgKi9cblxuXHRcdGZvciAoa2s9MDtrazx0aGlzLk4tdGhpcy5NO2trKyspIHtcblx0XHRcdHkgPSAodGhpcy5tdFtra10mdGhpcy5VUFBFUl9NQVNLKXwodGhpcy5tdFtraysxXSZ0aGlzLkxPV0VSX01BU0spO1xuXHRcdFx0dGhpcy5tdFtra10gPSB0aGlzLm10W2trK3RoaXMuTV0gXiAoeSA+Pj4gMSkgXiBtYWcwMVt5ICYgMHgxXTtcblx0XHR9XG5cdFx0Zm9yICg7a2s8dGhpcy5OLTE7a2srKykge1xuXHRcdFx0eSA9ICh0aGlzLm10W2trXSZ0aGlzLlVQUEVSX01BU0spfCh0aGlzLm10W2trKzFdJnRoaXMuTE9XRVJfTUFTSyk7XG5cdFx0XHR0aGlzLm10W2trXSA9IHRoaXMubXRba2srKHRoaXMuTS10aGlzLk4pXSBeICh5ID4+PiAxKSBeIG1hZzAxW3kgJiAweDFdO1xuXHRcdH1cblx0XHR5ID0gKHRoaXMubXRbdGhpcy5OLTFdJnRoaXMuVVBQRVJfTUFTSyl8KHRoaXMubXRbMF0mdGhpcy5MT1dFUl9NQVNLKTtcblx0XHR0aGlzLm10W3RoaXMuTi0xXSA9IHRoaXMubXRbdGhpcy5NLTFdIF4gKHkgPj4+IDEpIF4gbWFnMDFbeSAmIDB4MV07XG5cblx0XHR0aGlzLm10aSA9IDA7XG5cdH1cblxuXHR5ID0gdGhpcy5tdFt0aGlzLm10aSsrXTtcblxuXHQvKiBUZW1wZXJpbmcgKi9cblx0eSBePSAoeSA+Pj4gMTEpO1xuXHR5IF49ICh5IDw8IDcpICYgMHg5ZDJjNTY4MDtcblx0eSBePSAoeSA8PCAxNSkgJiAweGVmYzYwMDAwO1xuXHR5IF49ICh5ID4+PiAxOCk7XG5cblx0cmV0dXJuIHkgPj4+IDA7XG59O1xuIFxuLyogZ2VuZXJhdGVzIGEgcmFuZG9tIG51bWJlciBvbiBbMCwweDdmZmZmZmZmXS1pbnRlcnZhbCAqL1xuUmFuZG9tLnByb3RvdHlwZS5nZW5yYW5kX2ludDMxID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiAodGhpcy5nZW5yYW5kX2ludDMyKCk+Pj4xKTtcbn07XG5cbi8qIGdlbmVyYXRlcyBhIHJhbmRvbSBudW1iZXIgb24gWzAsMV0tcmVhbC1pbnRlcnZhbCAqL1xuUmFuZG9tLnByb3RvdHlwZS5nZW5yYW5kX3JlYWwxID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLmdlbnJhbmRfaW50MzIoKSooMS4wLzQyOTQ5NjcyOTUuMCk7IFxuXHQvKiBkaXZpZGVkIGJ5IDJeMzItMSAqLyBcbn07XG5cbi8qIGdlbmVyYXRlcyBhIHJhbmRvbSBudW1iZXIgb24gWzAsMSktcmVhbC1pbnRlcnZhbCAqL1xuUmFuZG9tLnByb3RvdHlwZS5yYW5kb20gPSBmdW5jdGlvbigpIHtcblx0aWYgKHRoaXMucHl0aG9uQ29tcGF0aWJpbGl0eSkge1xuXHRcdGlmICh0aGlzLnNraXApIHtcblx0XHRcdHRoaXMuZ2VucmFuZF9pbnQzMigpO1xuXHRcdH1cblx0XHR0aGlzLnNraXAgPSB0cnVlO1xuXHR9XG5cdHJldHVybiB0aGlzLmdlbnJhbmRfaW50MzIoKSooMS4wLzQyOTQ5NjcyOTYuMCk7IFxuXHQvKiBkaXZpZGVkIGJ5IDJeMzIgKi9cbn07XG5cbi8qIGdlbmVyYXRlcyBhIHJhbmRvbSBudW1iZXIgb24gKDAsMSktcmVhbC1pbnRlcnZhbCAqL1xuUmFuZG9tLnByb3RvdHlwZS5nZW5yYW5kX3JlYWwzID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiAodGhpcy5nZW5yYW5kX2ludDMyKCkgKyAwLjUpKigxLjAvNDI5NDk2NzI5Ni4wKTsgXG5cdC8qIGRpdmlkZWQgYnkgMl4zMiAqL1xufTtcblxuLyogZ2VuZXJhdGVzIGEgcmFuZG9tIG51bWJlciBvbiBbMCwxKSB3aXRoIDUzLWJpdCByZXNvbHV0aW9uKi9cblJhbmRvbS5wcm90b3R5cGUuZ2VucmFuZF9yZXM1MyA9IGZ1bmN0aW9uKCkgeyBcblx0dmFyIGE9dGhpcy5nZW5yYW5kX2ludDMyKCk+Pj41LCBiPXRoaXMuZ2VucmFuZF9pbnQzMigpPj4+NjsgXG5cdHJldHVybihhKjY3MTA4ODY0LjArYikqKDEuMC85MDA3MTk5MjU0NzQwOTkyLjApOyBcbn07XG5cbi8qIFRoZXNlIHJlYWwgdmVyc2lvbnMgYXJlIGR1ZSB0byBJc2FrdSBXYWRhLCAyMDAyLzAxLzA5IGFkZGVkICovXG5cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuUmFuZG9tLnByb3RvdHlwZS5MT0c0ID0gTWF0aC5sb2coNC4wKTtcblJhbmRvbS5wcm90b3R5cGUuU0dfTUFHSUNDT05TVCA9IDEuMCArIE1hdGgubG9nKDQuNSk7XG5cblJhbmRvbS5wcm90b3R5cGUuZXhwb25lbnRpYWwgPSBmdW5jdGlvbiAobGFtYmRhKSB7XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDEpIHsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQVJHX0NIRUNLICAgICAgICAgICAgICAgICAgICAgXG5cdFx0dGhyb3cgbmV3IFN5bnRheEVycm9yKFwiZXhwb25lbnRpYWwoKSBtdXN0IFwiICAgICAvLyBBUkdfQ0hFQ0tcblx0XHRcdFx0KyBcIiBiZSBjYWxsZWQgd2l0aCAnbGFtYmRhJyBwYXJhbWV0ZXJcIik7IC8vIEFSR19DSEVDS1xuXHR9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQVJHX0NIRUNLXG5cdFxuXHR2YXIgciA9IHRoaXMucmFuZG9tKCk7XG5cdHJldHVybiAtTWF0aC5sb2cocikgLyBsYW1iZGE7XG59O1xuXG5SYW5kb20ucHJvdG90eXBlLmdhbW1hID0gZnVuY3Rpb24gKGFscGhhLCBiZXRhKSB7XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDIpIHsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQVJHX0NIRUNLICAgICAgICAgICAgICAgICAgICAgXG5cdFx0dGhyb3cgbmV3IFN5bnRheEVycm9yKFwiZ2FtbWEoKSBtdXN0IGJlIGNhbGxlZFwiICAvLyBBUkdfQ0hFQ0tcblx0XHRcdFx0KyBcIiB3aXRoIGFscGhhIGFuZCBiZXRhIHBhcmFtZXRlcnNcIik7IC8vIEFSR19DSEVDS1xuXHR9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQVJHX0NIRUNLXG5cdFxuXHQvKiBCYXNlZCBvbiBQeXRob24gMi42IHNvdXJjZSBjb2RlIG9mIHJhbmRvbS5weS5cblx0ICovXG5cdFxuXHRpZiAoYWxwaGEgPiAxLjApIHtcblx0XHR2YXIgYWludiA9IE1hdGguc3FydCgyLjAgKiBhbHBoYSAtIDEuMCk7XG5cdFx0dmFyIGJiYiA9IGFscGhhIC0gdGhpcy5MT0c0O1xuXHRcdHZhciBjY2MgPSBhbHBoYSArIGFpbnY7XG5cdFx0XG5cdFx0d2hpbGUgKHRydWUpIHtcblx0XHRcdHZhciB1MSA9IHRoaXMucmFuZG9tKCk7XG5cdFx0XHRpZiAoKHUxIDwgMWUtNykgfHwgKHUgPiAwLjk5OTk5OTkpKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHUyID0gMS4wIC0gdGhpcy5yYW5kb20oKTtcblx0XHRcdHZhciB2ID0gTWF0aC5sb2codTEgLyAoMS4wIC0gdTEpKSAvIGFpbnY7XG5cdFx0XHR2YXIgeCA9IGFscGhhICogTWF0aC5leHAodik7XG5cdFx0XHR2YXIgeiA9IHUxICogdTEgKiB1Mjtcblx0XHRcdHZhciByID0gYmJiICsgY2NjICogdiAtIHg7XG5cdFx0XHRpZiAoKHIgKyB0aGlzLlNHX01BR0lDQ09OU1QgLSA0LjUgKiB6ID49IDAuMCkgfHwgKHIgPj0gTWF0aC5sb2coeikpKSB7XG5cdFx0XHRcdHJldHVybiB4ICogYmV0YTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSBpZiAoYWxwaGEgPT0gMS4wKSB7XG5cdFx0dmFyIHUgPSB0aGlzLnJhbmRvbSgpO1xuXHRcdHdoaWxlICh1IDw9IDFlLTcpIHtcblx0XHRcdHUgPSB0aGlzLnJhbmRvbSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gLSBNYXRoLmxvZyh1KSAqIGJldGE7XG5cdH0gZWxzZSB7XG5cdFx0d2hpbGUgKHRydWUpIHtcblx0XHRcdHZhciB1ID0gdGhpcy5yYW5kb20oKTtcblx0XHRcdHZhciBiID0gKE1hdGguRSArIGFscGhhKSAvIE1hdGguRTtcblx0XHRcdHZhciBwID0gYiAqIHU7XG5cdFx0XHRpZiAocCA8PSAxLjApIHtcblx0XHRcdFx0dmFyIHggPSBNYXRoLnBvdyhwLCAxLjAgLyBhbHBoYSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgeCA9IC0gTWF0aC5sb2coKGIgLSBwKSAvIGFscGhhKTtcblx0XHRcdH1cblx0XHRcdHZhciB1MSA9IHRoaXMucmFuZG9tKCk7XG5cdFx0XHRpZiAocCA+IDEuMCkge1xuXHRcdFx0XHRpZiAodTEgPD0gTWF0aC5wb3coeCwgKGFscGhhIC0gMS4wKSkpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh1MSA8PSBNYXRoLmV4cCgteCkpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB4ICogYmV0YTtcblx0fVxuXHRcbn07XG5cblJhbmRvbS5wcm90b3R5cGUubm9ybWFsID0gZnVuY3Rpb24gKG11LCBzaWdtYSkge1xuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAyKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBUkdfQ0hFQ0sgICAgICAgICAgICAgICAgICAgICBcblx0XHR0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJub3JtYWwoKSBtdXN0IGJlIGNhbGxlZFwiICAvLyBBUkdfQ0hFQ0tcblx0XHRcdFx0KyBcIiB3aXRoIG11IGFuZCBzaWdtYSBwYXJhbWV0ZXJzXCIpOyAgICAgIC8vIEFSR19DSEVDS1xuXHR9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFSR19DSEVDS1xuXHRcblx0dmFyIHogPSB0aGlzLmxhc3ROb3JtYWw7XG5cdHRoaXMubGFzdE5vcm1hbCA9IE5hTjtcblx0aWYgKCF6KSB7XG5cdFx0dmFyIGEgPSB0aGlzLnJhbmRvbSgpICogMiAqIE1hdGguUEk7XG5cdFx0dmFyIGIgPSBNYXRoLnNxcnQoLTIuMCAqIE1hdGgubG9nKDEuMCAtIHRoaXMucmFuZG9tKCkpKTtcblx0XHR6ID0gTWF0aC5jb3MoYSkgKiBiO1xuXHRcdHRoaXMubGFzdE5vcm1hbCA9IE1hdGguc2luKGEpICogYjtcblx0fSBcblx0cmV0dXJuIG11ICsgeiAqIHNpZ21hO1xufTtcblxuUmFuZG9tLnByb3RvdHlwZS5wYXJldG8gPSBmdW5jdGlvbiAoYWxwaGEpIHtcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggIT0gMSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBUkdfQ0hFQ0sgICAgICAgICAgICAgICAgICAgICBcblx0XHR0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJwYXJldG8oKSBtdXN0IGJlIGNhbGxlZFwiIC8vIEFSR19DSEVDS1xuXHRcdFx0XHQrIFwiIHdpdGggYWxwaGEgcGFyYW1ldGVyXCIpOyAgICAgICAgICAgICAvLyBBUkdfQ0hFQ0tcblx0fSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFSR19DSEVDS1xuXHRcblx0dmFyIHUgPSB0aGlzLnJhbmRvbSgpO1xuXHRyZXR1cm4gMS4wIC8gTWF0aC5wb3coKDEgLSB1KSwgMS4wIC8gYWxwaGEpO1xufTtcblxuUmFuZG9tLnByb3RvdHlwZS50cmlhbmd1bGFyID0gZnVuY3Rpb24gKGxvd2VyLCB1cHBlciwgbW9kZSkge1xuXHQvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RyaWFuZ3VsYXJfZGlzdHJpYnV0aW9uXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDMpIHsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQVJHX0NIRUNLICAgICAgICAgICAgICAgICAgICAgXG5cdFx0dGhyb3cgbmV3IFN5bnRheEVycm9yKFwidHJpYW5ndWxhcigpIG11c3QgYmUgY2FsbGVkXCIgLy8gQVJHX0NIRUNLXG5cdFx0KyBcIiB3aXRoIGxvd2VyLCB1cHBlciBhbmQgbW9kZSBwYXJhbWV0ZXJzXCIpOyAgICAvLyBBUkdfQ0hFQ0tcblx0fSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFSR19DSEVDS1xuXHRcblx0dmFyIGMgPSAobW9kZSAtIGxvd2VyKSAvICh1cHBlciAtIGxvd2VyKTtcblx0dmFyIHUgPSB0aGlzLnJhbmRvbSgpO1xuXHRcblx0aWYgKHUgPD0gYykge1xuXHRcdHJldHVybiBsb3dlciArIE1hdGguc3FydCh1ICogKHVwcGVyIC0gbG93ZXIpICogKG1vZGUgLSBsb3dlcikpO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiB1cHBlciAtIE1hdGguc3FydCgoMSAtIHUpICogKHVwcGVyIC0gbG93ZXIpICogKHVwcGVyIC0gbW9kZSkpO1xuXHR9XG59O1xuXG5SYW5kb20ucHJvdG90eXBlLnVuaWZvcm0gPSBmdW5jdGlvbiAobG93ZXIsIHVwcGVyKSB7XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDIpIHsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQVJHX0NIRUNLICAgICAgICAgICAgICAgICAgICAgXG5cdFx0dGhyb3cgbmV3IFN5bnRheEVycm9yKFwidW5pZm9ybSgpIG11c3QgYmUgY2FsbGVkXCIgLy8gQVJHX0NIRUNLXG5cdFx0KyBcIiB3aXRoIGxvd2VyIGFuZCB1cHBlciBwYXJhbWV0ZXJzXCIpOyAgICAvLyBBUkdfQ0hFQ0tcblx0fSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFSR19DSEVDS1xuXHRyZXR1cm4gbG93ZXIgKyB0aGlzLnJhbmRvbSgpICogKHVwcGVyIC0gbG93ZXIpO1xufTtcblxuUmFuZG9tLnByb3RvdHlwZS53ZWlidWxsID0gZnVuY3Rpb24gKGFscGhhLCBiZXRhKSB7XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDIpIHsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQVJHX0NIRUNLICAgICAgICAgICAgICAgICAgICAgXG5cdFx0dGhyb3cgbmV3IFN5bnRheEVycm9yKFwid2VpYnVsbCgpIG11c3QgYmUgY2FsbGVkXCIgLy8gQVJHX0NIRUNLXG5cdFx0KyBcIiB3aXRoIGFscGhhIGFuZCBiZXRhIHBhcmFtZXRlcnNcIik7ICAgIC8vIEFSR19DSEVDS1xuXHR9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQVJHX0NIRUNLXG5cdHZhciB1ID0gMS4wIC0gdGhpcy5yYW5kb20oKTtcblx0cmV0dXJuIGFscGhhICogTWF0aC5wb3coLU1hdGgubG9nKHUpLCAxLjAgLyBiZXRhKTtcbn07XG47LyohIEZsb2NraW5nIDAuMSwgQ29weXJpZ2h0IDIwMTEtMjAxNCBDb2xpbiBDbGFyayB8IGZsb2NraW5nanMub3JnICovXG5cbi8qXG4qIEZsb2NraW5nIC0gQ3JlYXRpdmUgYXVkaW8gc3ludGhlc2lzIGZvciB0aGUgV2ViIVxuKiBodHRwOi8vZ2l0aHViLmNvbS9jb2xpbmJkY2xhcmsvZmxvY2tpbmdcbipcbiogQ29weXJpZ2h0IDIwMTEtMjAxNCwgQ29saW4gQ2xhcmtcbiogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGFuZCBHUEwgVmVyc2lvbiAyIGxpY2Vuc2VzLlxuKi9cblxuLypnbG9iYWwgcmVxdWlyZSwgRmxvYXQzMkFycmF5LCB3aW5kb3csIEF1ZGlvQ29udGV4dCwgd2Via2l0QXVkaW9Db250ZXh0Ki9cbi8qanNoaW50IHdoaXRlOiBmYWxzZSwgbmV3Y2FwOiB0cnVlLCByZWdleHA6IHRydWUsIGJyb3dzZXI6IHRydWUsXG4gICAgZm9yaW46IGZhbHNlLCBub21lbjogdHJ1ZSwgYml0d2lzZTogZmFsc2UsIG1heGVycjogMTAwLFxuICAgIGluZGVudDogNCwgcGx1c3BsdXM6IGZhbHNlLCBjdXJseTogdHJ1ZSwgZXFlcWVxOiB0cnVlLFxuICAgIGZyZWV6ZTogdHJ1ZSwgbGF0ZWRlZjogdHJ1ZSwgbm9hcmc6IHRydWUsIG5vbmV3OiB0cnVlLCBxdW90bWFyazogZG91YmxlLCB1bmRlZjogdHJ1ZSxcbiAgICB1bnVzZWQ6IHRydWUsIHN0cmljdDogdHJ1ZSwgYXNpOiBmYWxzZSwgYm9zczogZmFsc2UsIGV2aWw6IGZhbHNlLCBleHByOiBmYWxzZSxcbiAgICBmdW5jc2NvcGU6IGZhbHNlKi9cblxudmFyIGZsdWlkID0gZmx1aWQgfHwgcmVxdWlyZShcImluZnVzaW9uXCIpLFxuICAgIGZsb2NrID0gZmx1aWQucmVnaXN0ZXJOYW1lc3BhY2UoXCJmbG9ja1wiKTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciAkID0gZmx1aWQucmVnaXN0ZXJOYW1lc3BhY2UoXCJqUXVlcnlcIik7XG5cbiAgICBmbG9jay5mbHVpZCA9IGZsdWlkO1xuXG4gICAgZmxvY2suaW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBlbnZpcm9PcHRzID0gIW9wdGlvbnMgPyB1bmRlZmluZWQgOiB7XG4gICAgICAgICAgICBhdWRpb1NldHRpbmdzOiBvcHRpb25zXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGVudmlybyA9IGZsb2NrLmVudmlyby5zaGFyZWQgPSBmbG9jay5lbnZpcm8oZW52aXJvT3B0cyk7XG5cbiAgICAgICAgcmV0dXJuIGVudmlybztcbiAgICB9O1xuXG4gICAgZmxvY2suT1VUX1VHRU5fSUQgPSBcImZsb2NraW5nLW91dFwiO1xuICAgIGZsb2NrLk1BWF9DSEFOTkVMUyA9IDMyO1xuICAgIGZsb2NrLk1JTl9CVVNFUyA9IDI7XG4gICAgZmxvY2suTUFYX0lOUFVUX0JVU0VTID0gMzI7XG4gICAgZmxvY2suTUlOX0lOUFVUX0JVU0VTID0gMTsgLy8gVE9ETzogVGhpcyBjb25zdHJhaW50IHNob3VsZCBiZSByZW1vdmVkLlxuICAgIGZsb2NrLkFMTF9DSEFOTkVMUyA9IGZsb2NrLk1BWF9JTlBVVF9CVVNFUztcblxuICAgIGZsb2NrLlBJID0gTWF0aC5QSTtcbiAgICBmbG9jay5UV09QSSA9IDIuMCAqIE1hdGguUEk7XG4gICAgZmxvY2suSEFMRlBJID0gTWF0aC5QSSAvIDIuMDtcbiAgICBmbG9jay5MT0cwMSA9IE1hdGgubG9nKDAuMSk7XG4gICAgZmxvY2suTE9HMDAxID0gTWF0aC5sb2coMC4wMDEpO1xuICAgIGZsb2NrLlJPT1QyID0gTWF0aC5zcXJ0KDIpO1xuXG4gICAgZmxvY2sucmF0ZXMgPSB7XG4gICAgICAgIEFVRElPOiBcImF1ZGlvXCIsXG4gICAgICAgIENPTlRST0w6IFwiY29udHJvbFwiLFxuICAgICAgICBTQ0hFRFVMRUQ6IFwic2NoZWR1bGVkXCIsXG4gICAgICAgIERFTUFORDogXCJkZW1hbmRcIixcbiAgICAgICAgQ09OU1RBTlQ6IFwiY29uc3RhbnRcIlxuICAgIH07XG5cbiAgICBmbG9jay5zYW1wbGVGb3JtYXRzID0ge1xuICAgICAgICBGTE9BVDMyTkU6IFwiZmxvYXQzMk5FXCJcbiAgICB9O1xuXG4gICAgZmx1aWQucmVnaXN0ZXJOYW1lc3BhY2UoXCJmbG9jay5kZWJ1Z1wiKTtcbiAgICBmbG9jay5kZWJ1Zy5mYWlsSGFyZCA9IHRydWU7XG5cbiAgICBmbG9jay5icm93c2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhpcyBpcyBhIG1vZGlmaWVkIHZlcnNpb24gb2YgalF1ZXJ5J3MgYnJvd3NlciBkZXRlY3Rpb24gY29kZSxcbiAgICAgICAgLy8gd2hpY2ggdGhleSByZW1vdmVkIGZyb20galF1ZXJ5IDIuMC5cbiAgICAgICAgLy8gU29tZSBvZiB1cyBzdGlsbCBoYXZlIHRvIGxpdmUgaW4gdGhlIG1lc3N5IHJlYWxpdHkgb2YgdGhlIHdlYi5cbiAgICAgICAgdmFyIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgYnJvd3NlciA9IHt9LFxuICAgICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgICBtYXRjaGVkO1xuXG4gICAgICAgIG1hdGNoID0gLyhjaHJvbWUpWyBcXC9dKFtcXHcuXSspLy5leGVjKHVhKSB8fFxuICAgICAgICAgICAgLyh3ZWJraXQpWyBcXC9dKFtcXHcuXSspLy5leGVjKHVhKSB8fFxuICAgICAgICAgICAgLyhvcGVyYSkoPzouKnZlcnNpb258KVsgXFwvXShbXFx3Ll0rKS8uZXhlYyh1YSkgfHxcbiAgICAgICAgICAgIC8obXNpZSkgKFtcXHcuXSspLy5leGVjKHVhKSB8fFxuICAgICAgICAgICAgdWEuaW5kZXhPZihcImNvbXBhdGlibGVcIikgPCAwICYmIC8obW96aWxsYSkoPzouKj8gcnY6KFtcXHcuXSspfCkvLmV4ZWModWEpIHx8IFtdO1xuXG4gICAgICAgIG1hdGNoZWQgPSB7XG4gICAgICAgICAgICBicm93c2VyOiBtYXRjaFsxXSB8fCBcIlwiLFxuICAgICAgICAgICAgdmVyc2lvbjogbWF0Y2hbMl0gfHwgXCIwXCJcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAobWF0Y2hlZC5icm93c2VyKSB7XG4gICAgICAgICAgICBicm93c2VyW21hdGNoZWQuYnJvd3Nlcl0gPSB0cnVlO1xuICAgICAgICAgICAgYnJvd3Nlci52ZXJzaW9uID0gbWF0Y2hlZC52ZXJzaW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hyb21lIGlzIFdlYmtpdCwgYnV0IFdlYmtpdCBpcyBhbHNvIFNhZmFyaS5cbiAgICAgICAgaWYgKGJyb3dzZXIuY2hyb21lKSB7XG4gICAgICAgICAgICBicm93c2VyLndlYmtpdCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoYnJvd3Nlci53ZWJraXQpIHtcbiAgICAgICAgICAgIGJyb3dzZXIuc2FmYXJpID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBicm93c2VyO1xuICAgIH07XG5cbiAgICAvLyBUT0RPOiBNb3ZlIHRvIGNvbXBvbmVudHMgaW4gdGhlIHN0YXRpYyBlbnZpcm9ubWVudCBhbmQgaW50byB0aGUgYXBwcm9wcmlhdGUgcGxhdGZvcm0gZmlsZXMuXG4gICAgZmx1aWQucmVnaXN0ZXJOYW1lc3BhY2UoXCJmbG9jay5wbGF0Zm9ybVwiKTtcbiAgICBmbG9jay5wbGF0Zm9ybS5pc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xuICAgIGZsb2NrLnBsYXRmb3JtLmhhc1JlcXVpcmUgPSB0eXBlb2YgcmVxdWlyZSAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgICBmbG9jay5wbGF0Zm9ybS5vcyA9IGZsb2NrLnBsYXRmb3JtLmlzQnJvd3NlciA/IHdpbmRvdy5uYXZpZ2F0b3IucGxhdGZvcm0gOiBmbHVpZC5yZXF1aXJlKFwib3NcIikucGxhdGZvcm0oKTtcbiAgICBmbG9jay5wbGF0Zm9ybS5pc0xpbnV4ID0gZmxvY2sucGxhdGZvcm0ub3MuaW5kZXhPZihcIkxpbnV4XCIpID4gLTE7XG4gICAgZmxvY2sucGxhdGZvcm0uaXNBbmRyb2lkID0gZmxvY2sucGxhdGZvcm0uaXNMaW51eCAmJiBmbG9jay5wbGF0Zm9ybS5vcy5pbmRleE9mKFwiYXJtXCIpID4gLTE7XG4gICAgZmxvY2sucGxhdGZvcm0uaXNJT1MgPSBmbG9jay5wbGF0Zm9ybS5vcyA9PT0gXCJpUGhvbmVcIiB8fCBmbG9jay5wbGF0Zm9ybS5vcyA9PT0gXCJpUGFkXCIgfHwgZmxvY2sucGxhdGZvcm0ub3MgPT09IFwiaVBvZFwiO1xuICAgIGZsb2NrLnBsYXRmb3JtLmlzTW9iaWxlID0gZmxvY2sucGxhdGZvcm0uaXNBbmRyb2lkIHx8IGZsb2NrLnBsYXRmb3JtLmlzSU9TO1xuICAgIGZsb2NrLnBsYXRmb3JtLmJyb3dzZXIgPSBmbG9jay5icm93c2VyKCk7XG4gICAgZmxvY2sucGxhdGZvcm0uaXNXZWJBdWRpbyA9IHR5cGVvZiBBdWRpb0NvbnRleHQgIT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIHdlYmtpdEF1ZGlvQ29udGV4dCAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgICBmbG9jay5wbGF0Zm9ybS5hdWRpb0VuZ2luZSA9IGZsb2NrLnBsYXRmb3JtLmlzQnJvd3NlciA/IChmbG9jay5wbGF0Zm9ybS5pc1dlYkF1ZGlvID8gXCJ3ZWJBdWRpb1wiIDogXCJtb3pcIikgOiBcIm5vZGVqc1wiO1xuICAgIGZsdWlkLnN0YXRpY0Vudmlyb25tZW50LmF1ZGlvRW5naW5lID0gZmx1aWQudHlwZVRhZyhcImZsb2NrLnBsYXRmb3JtLlwiICsgZmxvY2sucGxhdGZvcm0uYXVkaW9FbmdpbmUpO1xuXG4gICAgZmxvY2suZGVmYXVsdEJ1ZmZlclNpemVGb3JQbGF0Zm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGZsb2NrLnBsYXRmb3JtLmlzTW9iaWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gODE5MjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAxMDI0O1xuICAgIH07XG5cbiAgICBmbG9jay5zaGltID0ge1xuICAgICAgICBVUkw6IGZsb2NrLnBsYXRmb3JtLmlzQnJvd3NlciA/ICh3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkwgfHwgd2luZG93Lm1zVVJMKSA6IHVuZGVmaW5lZFxuICAgIH07XG5cbiAgICBmbG9jay5yZXF1aXJlTW9kdWxlID0gZnVuY3Rpb24gKG1vZHVsZU5hbWUsIGdsb2JhbE5hbWUpIHtcbiAgICAgICAgaWYgKGZsb2NrLnBsYXRmb3JtLmlzQnJvd3Nlcikge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvd1tnbG9iYWxOYW1lIHx8IG1vZHVsZU5hbWVdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFmbG9jay5wbGF0Zm9ybS5oYXNSZXF1aXJlKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc29sdmVkTmFtZSA9IGZsb2NrLnJlcXVpcmVNb2R1bGUucGF0aHNbbW9kdWxlTmFtZV0gfHwgbW9kdWxlTmFtZTtcbiAgICAgICAgdmFyIHRvZ28gPSByZXF1aXJlKHJlc29sdmVkTmFtZSk7XG5cbiAgICAgICAgcmV0dXJuIGdsb2JhbE5hbWUgPyB0b2dvW2dsb2JhbE5hbWVdIDogdG9nbztcbiAgICB9O1xuXG4gICAgZmxvY2sucmVxdWlyZU1vZHVsZS5wYXRocyA9IHtcbiAgICAgICAgZHNwYXBpOiBcIi4uL3RoaXJkLXBhcnR5L2RzcGFwaS9qcy9kc3BhcGkuanNcIixcbiAgICAgICAgUmFuZG9tOiBcIi4uL3RoaXJkLXBhcnR5L3NpbWpzL2pzL3JhbmRvbS0wLjI2LmpzXCJcbiAgICB9O1xuXG4gICAgLyoqKioqKioqKioqKipcbiAgICAgKiBVdGlsaXRpZXMgKlxuICAgICAqKioqKioqKioqKioqL1xuXG4gICAgZmxvY2subm9PcCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgZmxvY2suaXNJdGVyYWJsZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHZhciB0eXBlID0gdHlwZW9mIG87XG4gICAgICAgIHJldHVybiBvICYmIG8ubGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgdHlwZSAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlICE9PSBcImZ1bmN0aW9uXCI7XG4gICAgfTtcblxuICAgIGZsb2NrLmhhc1RhZyA9IGZ1bmN0aW9uIChvYmosIHRhZykge1xuICAgICAgICBpZiAoIW9iaiB8fCAhdGFnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iai50YWdzICYmIG9iai50YWdzLmluZGV4T2YodGFnKSA+IC0xO1xuICAgIH07XG5cbiAgICAvLyBUT0RPOiBDaHJvbWUgcHJvZmlsZXIgbWFya3MgdGhpcyBmdW5jdGlvbiBhcyB1bm9wdGltaXplZC5cbiAgICAvLyBUaGlzIHNob3VsZCBwcm9iYWJseSBiZSBmYWN0b3JlZCBpbnRvIHNlcGFyYXRlIGZ1bmN0aW9ucyBmb3JcbiAgICAvLyBuZXcgYW5kIGV4aXN0aW5nIGFycmF5cy4gKGUuZy4gXCJnZW5lcmF0ZVwiIHZzLiBcImZpbGxcIilcbiAgICBmbG9jay5nZW5lcmF0ZSA9IGZ1bmN0aW9uIChidWZPclNpemUsIGdlbmVyYXRvcikge1xuICAgICAgICB2YXIgYnVmID0gdHlwZW9mIGJ1Zk9yU2l6ZSA9PT0gXCJudW1iZXJcIiA/IG5ldyBGbG9hdDMyQXJyYXkoYnVmT3JTaXplKSA6IGJ1Zk9yU2l6ZSxcbiAgICAgICAgICAgIGlzRnVuYyA9IHR5cGVvZiBnZW5lcmF0b3IgPT09IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYnVmW2ldID0gaXNGdW5jID8gZ2VuZXJhdG9yKGksIGJ1ZikgOiBnZW5lcmF0b3I7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYnVmO1xuICAgIH07XG5cbiAgICBmbG9jay5nZW5lcmF0ZS5zaWxlbmNlID0gZnVuY3Rpb24gKGJ1Zk9yU2l6ZSkge1xuICAgICAgICBpZiAodHlwZW9mIGJ1Zk9yU2l6ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoYnVmT3JTaXplKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBidWYgPSBidWZPclNpemUsXG4gICAgICAgICAgICBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBidWZbaV0gPSAwLjA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYW4gaW4tcGxhY2UgcmV2ZXJzYWwgb2YgYWxsIGl0ZW1zIGluIHRoZSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBhcmcge0l0ZXJhYmxlfSBiIGEgYnVmZmVyIG9yIGFycmF5IHRvIHJldmVyc2VcbiAgICAgKiBAcmV0dXJuIHtJdGVyYWJsZX0gdGhlIGJ1ZmZlciwgcmV2ZXJzZWRcbiAgICAgKi9cbiAgICBmbG9jay5yZXZlcnNlID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgaWYgKCFiIHx8ICFmbG9jay5pc0l0ZXJhYmxlKGIpIHx8IGIubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBvZiByZXZlcnNlKCkgZXhpc3RzIGZvciByZWd1bGFyIEpTIGFycmF5c1xuICAgICAgICAvLyBhbmQgaXMgcGFydGlhbGx5IGltcGxlbWVudGVkIGZvciBUeXBlZEFycmF5cy4gVXNlIGl0IGlmIHBvc3NpYmxlLlxuICAgICAgICBpZiAodHlwZW9mIGIucmV2ZXJzZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi5yZXZlcnNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdDtcbiAgICAgICAgZm9yICh2YXIgbCA9IDAsIHIgPSBiLmxlbmd0aCAtIDE7IGwgPCByOyBsKyssIHItLSkge1xuICAgICAgICAgICAgdCA9IGJbbF07XG4gICAgICAgICAgICBiW2xdID0gYltyXTtcbiAgICAgICAgICAgIGJbcl0gPSB0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJhbmRvbWx5IHNlbGVjdHMgYW4gaW5kZXggZnJvbSB0aGUgc3BlY2lmaWVkIGFycmF5LlxuICAgICAqL1xuICAgIGZsb2NrLnJhbmRvbUluZGV4ID0gZnVuY3Rpb24gKGFycikge1xuICAgICAgICB2YXIgbWF4ID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiBtYXgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSYW5kb21seSBzZWxlY3RzIGFuIGl0ZW0gZnJvbSBhbiBhcnJheS1saWtlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXktbGlrZSBvYmplY3R9IGFyciB0aGUgYXJyYXkgdG8gY2hvb3NlIGZyb21cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhIHNlbGVjdGlvbiBzdHJhdGVneTsgZGVmYXVsdHMgdG8gZmxvY2sucmFuZG9tSW5kZXhcbiAgICAgKiBAcmV0dXJuIGEgcmFuZG9tbHkgc2VsZWN0ZWQgbGlzdCBpdGVtXG4gICAgICovXG4gICAgZmxvY2suYXJyYXlDaG9vc2UgPSBmdW5jdGlvbiAoYXJyLCBzdHJhdGVneSkge1xuICAgICAgICBzdHJhdGVneSA9IHN0cmF0ZWd5IHx8IGZsb2NrLnJhbmRvbUluZGV4O1xuICAgICAgICBhcnIgPSBmbHVpZC5tYWtlQXJyYXkoYXJyKTtcbiAgICAgICAgdmFyIGlkeCA9IHN0cmF0ZWd5KGFycik7XG4gICAgICAgIHJldHVybiBhcnJbaWR4XTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmFuZG9tbHkgc2VsZWN0cyBhbiBpdGVtIGZyb20gYW4gYXJyYXkgb3Igb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS1saWtlIG9iamVjdHxPYmplY3R9IGNvbGxlY3Rpb24gdGhlIG9iamVjdCB0byBjaG9vc2UgZnJvbVxuICAgICAqIEByZXR1cm4gYSByYW5kb21seSBzZWxlY3RlZCBpdGVtIGZyb20gY29sbGVjdGlvblxuICAgICAqL1xuICAgIGZsb2NrLmNob29zZSA9IGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBzdHJhdGVneSkge1xuICAgICAgICB2YXIga2V5LCB2YWw7XG5cbiAgICAgICAgaWYgKGZsb2NrLmlzSXRlcmFibGUoY29sbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHZhbCA9IGZsb2NrLmFycmF5Q2hvb3NlKGNvbGxlY3Rpb24sIHN0cmF0ZWd5KTtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cblxuICAgICAgICBrZXkgPSBmbG9jay5hcnJheUNob29zZShjb2xsZWN0aW9uLmtleXMsIHN0cmF0ZWd5KTtcbiAgICAgICAgdmFsID0gY29sbGVjdGlvbltrZXldO1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemVzIHRoZSBzcGVjaWZpZWQgYnVmZmVyIGluIHBsYWNlIHRvIHRoZSBzcGVjaWZpZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5YWJsZX0gYnVmZmVyIHRoZSBidWZmZXIgdG8gbm9ybWFsaXplXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG5vcm1hbCB0aGUgdmFsdWUgdG8gbm9ybWFsaXplIHRoZSBidWZmZXIgdG9cbiAgICAgKiBAcGFyYW0ge0FycmF5YWJsZX0gYSBidWZmZXIgdG8gb3V0cHV0IHZhbHVlcyBpbnRvOyBpZiBvbWl0dGVkLCBidWZmZXIgd2lsbCBiZSBtb2RpZmllZCBpbiBwbGFjZVxuICAgICAqIEByZXR1cm4gdGhlIGJ1ZmZlciwgbm9ybWFsaXplZCBpbiBwbGFjZVxuICAgICAqL1xuICAgIGZsb2NrLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChidWZmZXIsIG5vcm1hbCwgb3V0cHV0KSB7XG4gICAgICAgIG91dHB1dCA9IG91dHB1dCB8fCBidWZmZXI7XG5cbiAgICAgICAgdmFyIG1heFZhbCA9IDAuMCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgdmFsO1xuXG4gICAgICAgIG5vcm1hbCA9IG5vcm1hbCA9PT0gdW5kZWZpbmVkID8gMS4wIDogbm9ybWFsO1xuICAgICAgICAvLyBGaW5kIHRoZSBtYXhpbXVtIHZhbHVlIGluIHRoZSBidWZmZXIuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBNYXRoLmFicyhidWZmZXJbaV0pO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQgPiBtYXhWYWwpIHtcbiAgICAgICAgICAgICAgICBtYXhWYWwgPSBjdXJyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQW5kIHRoZW4gbm9ybWFsaXplIHRoZSBidWZmZXIgaW4gcGxhY2UuXG4gICAgICAgIGlmIChtYXhWYWwgPiAwLjApIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBidWZmZXJbaV07XG4gICAgICAgICAgICAgICAgb3V0cHV0W2ldID0gKHZhbCAvIG1heFZhbCkgKiBub3JtYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG5cbiAgICBmbG9jay5nZW5lcmF0ZUZvdXJpZXJUYWJsZSA9IGZ1bmN0aW9uIChzaXplLCBzY2FsZSwgbnVtSGFybXMsIHBoYXNlLCBhbXBzKSB7XG4gICAgICAgIHBoYXNlICo9IGZsb2NrLlRXT1BJO1xuXG4gICAgICAgIHJldHVybiBmbG9jay5nZW5lcmF0ZShzaXplLCBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgdmFyIGhhcm0sXG4gICAgICAgICAgICAgICAgYW1wLFxuICAgICAgICAgICAgICAgIHcsXG4gICAgICAgICAgICAgICAgdmFsID0gMC4wO1xuXG4gICAgICAgICAgICBmb3IgKGhhcm0gPSAwOyBoYXJtIDwgbnVtSGFybXM7IGhhcm0rKykge1xuICAgICAgICAgICAgICAgIGFtcCA9IGFtcHMgPyBhbXBzW2hhcm1dIDogMS4wO1xuICAgICAgICAgICAgICAgIHcgPSAoaGFybSArIDEpICogKGkgKiBzY2FsZSk7XG4gICAgICAgICAgICAgICAgdmFsICs9IGFtcCAqIE1hdGguY29zKHcgKyBwaGFzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmbG9jay5nZW5lcmF0ZU5vcm1hbGl6ZWRGb3VyaWVyVGFibGUgPSBmdW5jdGlvbiAoc2l6ZSwgc2NhbGUsIG51bUhhcm1zLCBwaGFzZSwgYW1wR2VuRm4pIHtcbiAgICAgICAgdmFyIGFtcHMgPSBmbG9jay5nZW5lcmF0ZShudW1IYXJtcywgZnVuY3Rpb24gKGhhcm0pIHtcbiAgICAgICAgICAgIHJldHVybiBhbXBHZW5GbihoYXJtICsgMSk7IC8vICBIYXJtb25pY3MgYXJlIGluZGV4ZWQgZnJvbSAxIGluc3RlYWQgb2YgMC5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHRhYmxlID0gZmxvY2suZ2VuZXJhdGVGb3VyaWVyVGFibGUoc2l6ZSwgc2NhbGUsIG51bUhhcm1zLCBwaGFzZSwgYW1wcyk7XG4gICAgICAgIHJldHVybiBmbG9jay5ub3JtYWxpemUodGFibGUpO1xuICAgIH07XG5cbiAgICBmbG9jay5maWxsVGFibGUgPSBmdW5jdGlvbiAoc2l6ZU9yVGFibGUsIGZpbGxGbikge1xuICAgICAgICB2YXIgbGVuID0gdHlwZW9mIChzaXplT3JUYWJsZSkgPT09IFwibnVtYmVyXCIgPyBzaXplT3JUYWJsZSA6IHNpemVPclRhYmxlLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGZpbGxGbihzaXplT3JUYWJsZSwgZmxvY2suVFdPUEkgLyBsZW4pO1xuICAgIH07XG5cbiAgICBmbG9jay50YWJsZUdlbmVyYXRvcnMgPSB7XG4gICAgICAgIHNpbjogZnVuY3Rpb24gKHNpemUsIHNjYWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmxvY2suZ2VuZXJhdGUoc2l6ZSwgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5zaW4oaSAqIHNjYWxlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRyaTogZnVuY3Rpb24gKHNpemUsIHNjYWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmxvY2suZ2VuZXJhdGVOb3JtYWxpemVkRm91cmllclRhYmxlKHNpemUsIHNjYWxlLCAxMDAwLCAxLjAsIGZ1bmN0aW9uIChoYXJtKSB7XG4gICAgICAgICAgICAgICAgLy8gT25seSBvZGQgaGFybW9uaWNzLFxuICAgICAgICAgICAgICAgIC8vIGFtcGxpdHVkZXMgZGVjcmVhc2luZyBieSB0aGUgaW52ZXJzZSBzcXVhcmUgb2YgdGhlIGhhcm1vbmljIG51bWJlclxuICAgICAgICAgICAgICAgIHJldHVybiBoYXJtICUgMiA9PT0gMCA/IDAuMCA6IDEuMCAvIChoYXJtICogaGFybSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBzYXc6IGZ1bmN0aW9uIChzaXplLCBzY2FsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZsb2NrLmdlbmVyYXRlTm9ybWFsaXplZEZvdXJpZXJUYWJsZShzaXplLCBzY2FsZSwgMTAsIC0wLjI1LCBmdW5jdGlvbiAoaGFybSkge1xuICAgICAgICAgICAgICAgIC8vIEFsbCBoYXJtb25pY3MsXG4gICAgICAgICAgICAgICAgLy8gYW1wbGl0dWRlcyBkZWNyZWFzaW5nIGJ5IHRoZSBpbnZlcnNlIG9mIHRoZSBoYXJtb25pYyBudW1iZXJcbiAgICAgICAgICAgICAgICByZXR1cm4gMS4wIC8gaGFybTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNxdWFyZTogZnVuY3Rpb24gKHNpemUsIHNjYWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmxvY2suZ2VuZXJhdGVOb3JtYWxpemVkRm91cmllclRhYmxlKHNpemUsIHNjYWxlLCAxMCwgLTAuMjUsIGZ1bmN0aW9uIChoYXJtKSB7XG4gICAgICAgICAgICAgICAgLy8gT25seSBvZGQgaGFybW9uaWNzLFxuICAgICAgICAgICAgICAgIC8vIGFtcGxpdHVkZXMgZGVjcmVhc2luZyBieSB0aGUgaW52ZXJzZSBvZiB0aGUgaGFybW9uaWMgbnVtYmVyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhcm0gJSAyID09PSAwID8gMC4wIDogMS4wIC8gaGFybTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbm46IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgICAgICAvLyBIYW5uaW5nIGVudmVsb3BlOiBzaW5eMihpKSBmb3IgaSBmcm9tIDAgdG8gcGlcbiAgICAgICAgICAgIHJldHVybiBmbG9jay5nZW5lcmF0ZShzaXplLCBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIHZhciB5ID0gTWF0aC5zaW4oTWF0aC5QSSAqIGkgLyBzaXplKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geSAqIHk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBzaW5XaW5kb3c6IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gZmxvY2suZ2VuZXJhdGUoc2l6ZSwgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5zaW4oTWF0aC5QSSAqIGkgLyBzaXplKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZsb2NrLnJhbmdlID0gZnVuY3Rpb24gKGJ1Zikge1xuICAgICAgICB2YXIgcmFuZ2UgPSB7XG4gICAgICAgICAgICBtYXg6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSxcbiAgICAgICAgICAgIG1pbjogSW5maW5pdHlcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGksIHZhbDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YWwgPSBidWZbaV07XG4gICAgICAgICAgICBpZiAodmFsID4gcmFuZ2UubWF4KSB7XG4gICAgICAgICAgICAgICAgcmFuZ2UubWF4ID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbCA8IHJhbmdlLm1pbikge1xuICAgICAgICAgICAgICAgIHJhbmdlLm1pbiA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByYW5nZTtcbiAgICB9O1xuXG4gICAgZmxvY2suc2NhbGUgPSBmdW5jdGlvbiAoYnVmKSB7XG4gICAgICAgIGlmICghYnVmKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmFuZ2UgPSBmbG9jay5yYW5nZShidWYpLFxuICAgICAgICAgICAgbXVsID0gKHJhbmdlLm1heCAtIHJhbmdlLm1pbikgLyAyLFxuICAgICAgICAgICAgc3ViID0gKHJhbmdlLm1heCArIHJhbmdlLm1pbikgLyAyLFxuICAgICAgICAgICAgaTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBidWZbaV0gPSAoYnVmW2ldIC0gc3ViKSAvIG11bDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBidWY7XG4gICAgfTtcblxuICAgIGZsb2NrLmNvcHlCdWZmZXIgPSBmdW5jdGlvbiAoYnVmZmVyLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZW5kID0gYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZW4gPSBlbmQgLSBzdGFydCxcbiAgICAgICAgICAgIHRhcmdldCA9IG5ldyBGbG9hdDMyQXJyYXkobGVuKSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBqO1xuXG4gICAgICAgIGZvciAoaSA9IHN0YXJ0LCBqID0gMDsgaSA8IGVuZDsgaSsrLCBqKyspIHtcbiAgICAgICAgICAgIHRhcmdldFtqXSA9IGJ1ZmZlcltpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfTtcblxuICAgIGZsb2NrLnBhcnNlTWlkaVN0cmluZyA9IGZ1bmN0aW9uIChtaWRpU3RyKSB7XG4gICAgICAgIGlmICghbWlkaVN0ciB8fCBtaWRpU3RyLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICBtaWRpU3RyID0gbWlkaVN0ci50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIHZhciBzZWNvbmRDaGFyID0gbWlkaVN0ci5jaGFyQXQoMSksXG4gICAgICAgICAgICBzcGxpdElkeCA9IHNlY29uZENoYXIgPT09IFwiI1wiIHx8IHNlY29uZENoYXIgPT09IFwiYlwiID8gMiA6IDEsXG4gICAgICAgICAgICBub3RlID0gbWlkaVN0ci5zdWJzdHJpbmcoMCwgc3BsaXRJZHgpLFxuICAgICAgICAgICAgb2N0YXZlID0gTnVtYmVyKG1pZGlTdHIuc3Vic3RyaW5nKHNwbGl0SWR4KSksXG4gICAgICAgICAgICBwaXRjaENsYXNzID0gZmxvY2subWlkaUZyZXEubm90ZU5hbWVzW25vdGVdLFxuICAgICAgICAgICAgbWlkaU51bSA9IG9jdGF2ZSAqIDEyICsgcGl0Y2hDbGFzcztcblxuICAgICAgICByZXR1cm4gbWlkaU51bTtcbiAgICB9O1xuXG4gICAgZmxvY2subWlkaUZyZXEgPSBmdW5jdGlvbiAobWlkaSwgYTRGcmVxLCBhNE5vdGVOdW0sIG5vdGVzUGVyT2N0YXZlKSB7XG4gICAgICAgIGE0RnJlcSA9IGE0RnJlcSA9PT0gdW5kZWZpbmVkID8gNDQwIDogYTRGcmVxO1xuICAgICAgICBhNE5vdGVOdW0gPSBhNE5vdGVOdW0gPT09IHVuZGVmaW5lZCA/IDY5IDogYTROb3RlTnVtO1xuICAgICAgICBub3Rlc1Blck9jdGF2ZSA9IG5vdGVzUGVyT2N0YXZlIHx8IDEyO1xuXG4gICAgICAgIGlmICh0eXBlb2YgbWlkaSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbWlkaSA9IGZsb2NrLnBhcnNlTWlkaVN0cmluZyhtaWRpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhNEZyZXEgKiBNYXRoLnBvdygyLCAobWlkaSAtIGE0Tm90ZU51bSkgKiAxIC8gbm90ZXNQZXJPY3RhdmUpO1xuICAgIH07XG5cbiAgICBmbG9jay5taWRpRnJlcS5ub3RlTmFtZXMgPSB7XG4gICAgICAgIFwiYiNcIjogMCxcbiAgICAgICAgXCJjXCI6IDAsXG4gICAgICAgIFwiYyNcIjogMSxcbiAgICAgICAgXCJkYlwiOiAxLFxuICAgICAgICBcImRcIjogMixcbiAgICAgICAgXCJkI1wiOiAzLFxuICAgICAgICBcImViXCI6IDMsXG4gICAgICAgIFwiZVwiOiA0LFxuICAgICAgICBcImUjXCI6IDUsXG4gICAgICAgIFwiZlwiOiA1LFxuICAgICAgICBcImYjXCI6IDYsXG4gICAgICAgIFwiZ2JcIjogNixcbiAgICAgICAgXCJnXCI6IDcsXG4gICAgICAgIFwiZyNcIjogOCxcbiAgICAgICAgXCJhYlwiOiA4LFxuICAgICAgICBcImFcIjogOSxcbiAgICAgICAgXCJhI1wiOiAxMCxcbiAgICAgICAgXCJiYlwiOiAxMCxcbiAgICAgICAgXCJiXCI6IDExLFxuICAgICAgICBcImNiXCI6IDExXG4gICAgfTtcblxuICAgIGZsb2NrLmludGVycG9sYXRlID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogUGVyZm9ybXMgc2ltcGxlIHRydW5jYXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICBub25lOiBmdW5jdGlvbiAoaWR4LCB0YWJsZSkge1xuICAgICAgICAgICAgaWR4ID0gaWR4ICUgdGFibGUubGVuZ3RoO1xuXG4gICAgICAgICAgICByZXR1cm4gdGFibGVbaWR4IHwgMF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBlcmZvcm1zIGxpbmVhciBpbnRlcnBvbGF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgbGluZWFyOiBmdW5jdGlvbiAoaWR4LCB0YWJsZSkge1xuICAgICAgICAgICAgdmFyIGxlbiA9IHRhYmxlLmxlbmd0aDtcbiAgICAgICAgICAgIGlkeCA9IGlkeCAlIGxlbjtcblxuICAgICAgICAgICAgdmFyIGkxID0gaWR4IHwgMCxcbiAgICAgICAgICAgICAgICBpMiA9IChpMSArIDEpICUgbGVuLFxuICAgICAgICAgICAgICAgIGZyYWMgPSBpZHggLSBpMSxcbiAgICAgICAgICAgICAgICB5MSA9IHRhYmxlW2kxXSxcbiAgICAgICAgICAgICAgICB5MiA9IHRhYmxlW2kyXTtcblxuICAgICAgICAgICAgcmV0dXJuIHkxICsgZnJhYyAqICh5MiAtIHkxKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUGVyZm9ybXMgSGVybWl0ZSBjdWJpYyBpbnRlcnBvbGF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBCYXNlZCBvbiBMYXVyZW50IERlIFNvcmFzJyBpbXBsZW1lbnRhdGlvbiBhdDpcbiAgICAgICAgICogaHR0cDovL3d3dy5tdXNpY2RzcC5vcmcvc2hvd0FyY2hpdmVDb21tZW50LnBocD9BcmNoaXZlSUQ9OTNcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGlkeCB7TnVtYmVyfSBhbiBpbmRleCBpbnRvIHRoZSB0YWJsZVxuICAgICAgICAgKiBAcGFyYW0gdGFibGUge0FycmF5YWJsZX0gdGhlIHRhYmxlIGZyb20gd2hpY2ggdmFsdWVzIGFyb3VuZCBpZHggc2hvdWxkIGJlIGRyYXduIGFuZCBpbnRlcnBvbGF0ZWRcbiAgICAgICAgICogQHJldHVybiB7TnVtYmVyfSBhbiBpbnRlcnBvbGF0ZWQgdmFsdWVcbiAgICAgICAgICovXG4gICAgICAgIGhlcm1pdGU6IGZ1bmN0aW9uIChpZHgsIHRhYmxlKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gdGFibGUubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGludFBvcnRpb24gPSBNYXRoLmZsb29yKGlkeCksXG4gICAgICAgICAgICAgICAgaTAgPSBpbnRQb3J0aW9uICUgbGVuLFxuICAgICAgICAgICAgICAgIGZyYWMgPSBpZHggLSBpbnRQb3J0aW9uLFxuICAgICAgICAgICAgICAgIGltMSA9IGkwID4gMCA/IGkwIC0gMSA6IGxlbiAtIDEsXG4gICAgICAgICAgICAgICAgaTEgPSAoaTAgKyAxKSAlIGxlbixcbiAgICAgICAgICAgICAgICBpMiA9IChpMCArIDIpICUgbGVuLFxuICAgICAgICAgICAgICAgIHhtMSA9IHRhYmxlW2ltMV0sXG4gICAgICAgICAgICAgICAgeDAgPSB0YWJsZVtpMF0sXG4gICAgICAgICAgICAgICAgeDEgPSB0YWJsZVtpMV0sXG4gICAgICAgICAgICAgICAgeDIgPSB0YWJsZVtpMl0sXG4gICAgICAgICAgICAgICAgYyA9ICh4MSAtIHhtMSkgKiAwLjUsXG4gICAgICAgICAgICAgICAgdiA9IHgwIC0geDEsXG4gICAgICAgICAgICAgICAgdyA9IGMgKyB2LFxuICAgICAgICAgICAgICAgIGEgPSB3ICsgdiArICh4MiAtIHgwKSAqIDAuNSxcbiAgICAgICAgICAgICAgICBiTmVnID0gdyArIGEsXG4gICAgICAgICAgICAgICAgdmFsID0gKCgoYSAqIGZyYWMpIC0gYk5lZykgKiBmcmFjICsgYykgKiBmcmFjICsgeDA7XG5cbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZmxvY2suaW50ZXJwb2xhdGUuY3ViaWMgPSBmbG9jay5pbnRlcnBvbGF0ZS5oZXJtaXRlO1xuXG4gICAgZmxvY2subG9nID0ge1xuICAgICAgICB3YXJuOiBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgICAgICBmbHVpZC5sb2coZmx1aWQubG9nTGV2ZWwuV0FSTiwgbXNnKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkZWJ1ZzogZnVuY3Rpb24gKG1zZykge1xuICAgICAgICAgICAgZmx1aWQubG9nKGZsdWlkLmxvZ0xldmVsLklORk8sIG1zZyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZmxvY2suZmFpbCA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgaWYgKGZsb2NrLmRlYnVnLmZhaWxIYXJkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZsdWlkLmxvZyhmbHVpZC5sb2dMZXZlbC5GQUlMLCBtc2cpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZsb2NrLnBhdGhQYXJzZUVycm9yID0gZnVuY3Rpb24gKHJvb3QsIHBhdGgsIHRva2VuKSB7XG4gICAgICAgIHZhciBtc2cgPSBcIkVycm9yIHBhcnNpbmcgcGF0aCAnXCIgKyBwYXRoICsgXCInLiBTZWdtZW50ICdcIiArIHRva2VuICtcbiAgICAgICAgICAgIFwiJyBjb3VsZCBub3QgYmUgcmVzb2x2ZWQuIFJvb3Qgb2JqZWN0IHdhczogXCIgKyBmbHVpZC5wcmV0dHlQcmludEpTT04ocm9vdCk7XG5cbiAgICAgICAgZmxvY2suZmFpbChtc2cpO1xuICAgIH07XG5cbiAgICBmbG9jay5nZXQgPSBmdW5jdGlvbiAocm9vdCwgcGF0aCkge1xuICAgICAgICBpZiAoIXJvb3QpIHtcbiAgICAgICAgICAgIHJldHVybiBmbHVpZC5nZXRHbG9iYWxWYWx1ZShwYXRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIHR5cGVvZiByb290ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gZmx1aWQuZ2V0R2xvYmFsVmFsdWUocm9vdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXBhdGggfHwgcGF0aCA9PT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRva2VuaXplZCA9IHBhdGggPT09IFwiXCIgPyBbXSA6IFN0cmluZyhwYXRoKS5zcGxpdChcIi5cIiksXG4gICAgICAgICAgICB2YWxGb3JTZWcgPSByb290W3Rva2VuaXplZFswXV0sXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCB0b2tlbml6ZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh2YWxGb3JTZWcgPT09IG51bGwgfHwgdmFsRm9yU2VnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmbG9jay5wYXRoUGFyc2VFcnJvcihyb290LCBwYXRoLCB0b2tlbml6ZWRbaSAtIDFdKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWxGb3JTZWcgPSB2YWxGb3JTZWdbdG9rZW5pemVkW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWxGb3JTZWc7XG4gICAgfTtcblxuICAgIGZsb2NrLnNldCA9IGZ1bmN0aW9uIChyb290LCBwYXRoLCB2YWx1ZSkge1xuICAgICAgICBpZiAoIXJvb3QgfHwgIXBhdGggfHwgcGF0aCA9PT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRva2VuaXplZCA9IFN0cmluZyhwYXRoKS5zcGxpdChcIi5cIiksXG4gICAgICAgICAgICBsID0gdG9rZW5pemVkLmxlbmd0aCxcbiAgICAgICAgICAgIHByb3AgPSB0b2tlbml6ZWRbMF0sXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgdHlwZTtcblxuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICByb290ID0gcm9vdFtwcm9wXTtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlb2Ygcm9vdDtcbiAgICAgICAgICAgIGlmICh0eXBlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgZmxvY2suZmFpbChcIkVycm9yIHdoaWxlIHNldHRpbmcgYSB2YWx1ZSBhdCBwYXRoICdcIiArIHBhdGggK1xuICAgICAgICAgICAgICAgICAgICBcIicuIEEgbm9uLWNvbnRhaW5lciBvYmplY3Qgd2FzIGZvdW5kIGF0IHNlZ21lbnQgJ1wiICsgcHJvcCArIFwiJy4gVmFsdWU6IFwiICsgcm9vdCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9wID0gdG9rZW5pemVkW2ldO1xuICAgICAgICAgICAgaWYgKHJvb3RbcHJvcF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJvb3RbcHJvcF0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByb290W3Byb3BdID0gdmFsdWU7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG5cbiAgICBmbG9jay5pbnZva2UgPSBmdW5jdGlvbiAocm9vdCwgcGF0aCwgYXJncykge1xuICAgICAgICB2YXIgZm4gPSB0eXBlb2Ygcm9vdCA9PT0gXCJmdW5jdGlvblwiID8gcm9vdCA6IGZsb2NrLmdldChyb290LCBwYXRoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBmbG9jay5mYWlsKFwiUGF0aCAnXCIgKyBwYXRoICsgXCInIGRvZXMgbm90IHJlc29sdmUgdG8gYSBmdW5jdGlvbi5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH07XG5cblxuICAgIGZsb2NrLmlucHV0ID0ge307XG5cbiAgICBmbG9jay5pbnB1dC5zaG91bGRFeHBhbmQgPSBmdW5jdGlvbiAoaW5wdXROYW1lKSB7XG4gICAgICAgIHJldHVybiBmbG9jay5wYXJzZS5zcGVjaWFsSW5wdXRzLmluZGV4T2YoaW5wdXROYW1lKSA8IDA7XG4gICAgfTtcblxuICAgIC8vIFRPRE86IFJlcGxhY2UgdGhpcyB3aXRoIGEgcmVndWxhciBleHByZXNzaW9uO1xuICAgIC8vIHRoaXMgcHJvZHVjZXMgdG9vIG11Y2ggZ2FyYmFnZSFcbiAgICBmbG9jay5pbnB1dC5wYXRoRXhwYW5kZXIgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICB2YXIgc2VncyA9IGZsdWlkLm1vZGVsLnBhcnNlRUwocGF0aCksXG4gICAgICAgICAgICBzZXBhcmF0b3IgPSBcImlucHV0c1wiLFxuICAgICAgICAgICAgbGVuID0gc2Vncy5sZW5ndGgsXG4gICAgICAgICAgICBwZW5JZHggPSBsZW4gLSAxLFxuICAgICAgICAgICAgdG9nbyA9IFtdLFxuICAgICAgICAgICAgaTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGVuSWR4OyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzZWcgPSBzZWdzW2ldO1xuICAgICAgICAgICAgdmFyIG5leHRTZWcgPSBzZWdzW2kgKyAxXTtcblxuICAgICAgICAgICAgdG9nby5wdXNoKHNlZyk7XG5cbiAgICAgICAgICAgIGlmIChuZXh0U2VnID09PSBcIm1vZGVsXCIgfHwgbmV4dFNlZyA9PT0gXCJvcHRpb25zXCIpIHtcbiAgICAgICAgICAgICAgICB0b2dvID0gdG9nby5jb25jYXQoc2Vncy5zbGljZShpICsgMSwgcGVuSWR4KSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaXNOYU4oTnVtYmVyKG5leHRTZWcpKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0b2dvLnB1c2goc2VwYXJhdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRvZ28ucHVzaChzZWdzW3BlbklkeF0pO1xuXG4gICAgICAgIHJldHVybiB0b2dvLmpvaW4oXCIuXCIpO1xuICAgIH07XG5cbiAgICBmbG9jay5pbnB1dC5leHBhbmRQYXRocyA9IGZ1bmN0aW9uIChwYXRocykge1xuICAgICAgICB2YXIgZXhwYW5kZWQgPSB7fSxcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBleHBhbmRlZFBhdGgsXG4gICAgICAgICAgICB2YWx1ZTtcblxuICAgICAgICBmb3IgKHBhdGggaW4gcGF0aHMpIHtcbiAgICAgICAgICAgIGV4cGFuZGVkUGF0aCA9IGZsb2NrLmlucHV0LnBhdGhFeHBhbmRlcihwYXRoKTtcbiAgICAgICAgICAgIHZhbHVlID0gcGF0aHNbcGF0aF07XG4gICAgICAgICAgICBleHBhbmRlZFtleHBhbmRlZFBhdGhdID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwYW5kZWQ7XG4gICAgfTtcblxuICAgIGZsb2NrLmlucHV0LmV4cGFuZFBhdGggPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICByZXR1cm4gKHR5cGVvZiBwYXRoID09PSBcInN0cmluZ1wiKSA/IGZsb2NrLmlucHV0LnBhdGhFeHBhbmRlcihwYXRoKSA6IGZsb2NrLmlucHV0LmV4cGFuZFBhdGhzKHBhdGgpO1xuICAgIH07XG5cbiAgICBmbG9jay5pbnB1dC5nZXRWYWx1ZUZvclBhdGggPSBmdW5jdGlvbiAocm9vdCwgcGF0aCkge1xuICAgICAgICBwYXRoID0gZmxvY2suaW5wdXQuZXhwYW5kUGF0aChwYXRoKTtcbiAgICAgICAgdmFyIGlucHV0ID0gZmxvY2suZ2V0KHJvb3QsIHBhdGgpO1xuXG4gICAgICAgIC8vIElmIHRoZSB1bml0IGdlbmVyYXRvciBpcyBhIHZhbHVlVHlwZSB1Z2VuLCByZXR1cm4gaXRzIHZhbHVlLCBvdGhlcndpc2UgcmV0dXJuIHRoZSB1Z2VuIGl0c2VsZi5cbiAgICAgICAgcmV0dXJuIGZsb2NrLmhhc1RhZyhpbnB1dCwgXCJmbG9jay51Z2VuLnZhbHVlVHlwZVwiKSA/IGlucHV0LmlucHV0cy52YWx1ZSA6IGlucHV0O1xuICAgIH07XG5cbiAgICBmbG9jay5pbnB1dC5nZXRWYWx1ZXNGb3JQYXRoQXJyYXkgPSBmdW5jdGlvbiAocm9vdCwgcGF0aHMpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHt9LFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIHBhdGg7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwYXRoID0gcGF0aHNbaV07XG4gICAgICAgICAgICB2YWx1ZXNbcGF0aF0gPSBmbG9jay5pbnB1dC5nZXQocm9vdCwgcGF0aCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH07XG5cbiAgICBmbG9jay5pbnB1dC5nZXRWYWx1ZXNGb3JQYXRoT2JqZWN0ID0gZnVuY3Rpb24gKHJvb3QsIHBhdGhPYmopIHtcbiAgICAgICAgdmFyIGtleTtcblxuICAgICAgICBmb3IgKGtleSBpbiBwYXRoT2JqKSB7XG4gICAgICAgICAgICBwYXRoT2JqW2tleV0gPSBmbG9jay5pbnB1dC5nZXQocm9vdCwga2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXRoT2JqO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB2YWx1ZSBvZiB0aGUgdWdlbiBhdCB0aGUgc3BlY2lmaWVkIHBhdGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aCB0aGUgdWdlbidzIHBhdGggd2l0aGluIHRoZSBzeW50aCBncmFwaFxuICAgICAqIEByZXR1cm4ge051bWJlcnxVR2VufSBhIHNjYWxhciB2YWx1ZSBpbiB0aGUgY2FzZSBvZiBhIHZhbHVlIHVnZW4sIG90aGVyd2lzZSB0aGUgdWdlbiBpdHNlbGZcbiAgICAgKi9cbiAgICBmbG9jay5pbnB1dC5nZXQgPSBmdW5jdGlvbiAocm9vdCwgcGF0aCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHBhdGggPT09IFwic3RyaW5nXCIgPyBmbG9jay5pbnB1dC5nZXRWYWx1ZUZvclBhdGgocm9vdCwgcGF0aCkgOlxuICAgICAgICAgICAgZmxvY2suaXNJdGVyYWJsZShwYXRoKSA/IGZsb2NrLmlucHV0LmdldFZhbHVlc0ZvclBhdGhBcnJheShyb290LCBwYXRoKSA6XG4gICAgICAgICAgICBmbG9jay5pbnB1dC5nZXRWYWx1ZXNGb3JQYXRoT2JqZWN0KHJvb3QsIHBhdGgpO1xuICAgIH07XG5cbiAgICBmbG9jay5pbnB1dC5yZXNvbHZlVmFsdWUgPSBmdW5jdGlvbiAocm9vdCwgcGF0aCwgdmFsLCB0YXJnZXQsIGlucHV0TmFtZSwgcHJldmlvdXNJbnB1dCwgdmFsdWVQYXJzZXIpIHtcbiAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHRoZSB2YWx1ZSBpcyBhY3R1YWxseSBhIFwiZ2V0IGV4cHJlc3Npb25cIlxuICAgICAgICAvLyAoaS5lLiBhbiBFTCBwYXRoIHdyYXBwZWQgaW4gJHt9KSBhbmQgcmVzb2x2ZSBpdCBpZiBuZWNlc3NhcnkuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB2YXIgZXh0cmFjdGVkID0gZmx1aWQuZXh0cmFjdEVMKHZhbCwgZmxvY2suaW5wdXQudmFsdWVFeHByZXNzaW9uU3BlYyk7XG4gICAgICAgICAgICBpZiAoZXh0cmFjdGVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc29sdmVkID0gZmxvY2suaW5wdXQuZ2V0VmFsdWVGb3JQYXRoKHJvb3QsIGV4dHJhY3RlZCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc29sdmVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmxvY2subG9nLmRlYnVnKFwiVGhlIHZhbHVlIGV4cHJlc3Npb24gJ1wiICsgdmFsICsgXCInIHJlc29sdmVkIHRvIHVuZGVmaW5lZC4gXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIklmIHRoaXMgaXNuJ3QgZXhwZWN0ZWQsIGNoZWNrIHRvIGVuc3VyZSB0aGF0IHlvdXIgcGF0aCBpcyB2YWxpZC5cIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZsb2NrLmlucHV0LnNob3VsZEV4cGFuZChpbnB1dE5hbWUpICYmIHZhbHVlUGFyc2VyID9cbiAgICAgICAgICAgIHZhbHVlUGFyc2VyKHZhbCwgcGF0aCwgdGFyZ2V0LCBwcmV2aW91c0lucHV0KSA6IHZhbDtcbiAgICB9O1xuXG4gICAgZmxvY2suaW5wdXQudmFsdWVFeHByZXNzaW9uU3BlYyA9IHtcbiAgICAgICAgRUxzdHlsZTogXCIke31cIlxuICAgIH07XG5cbiAgICBmbG9jay5pbnB1dC5zZXRWYWx1ZUZvclBhdGggPSBmdW5jdGlvbiAocm9vdCwgcGF0aCwgdmFsLCBiYXNlVGFyZ2V0LCB2YWx1ZVBhcnNlcikge1xuICAgICAgICBwYXRoID0gZmxvY2suaW5wdXQuZXhwYW5kUGF0aChwYXRoKTtcblxuICAgICAgICB2YXIgcHJldmlvdXNJbnB1dCA9IGZsb2NrLmdldChyb290LCBwYXRoKSxcbiAgICAgICAgICAgIGxhc3REb3RJZHggPSBwYXRoLmxhc3RJbmRleE9mKFwiLlwiKSxcbiAgICAgICAgICAgIGlucHV0TmFtZSA9IHBhdGguc2xpY2UobGFzdERvdElkeCArIDEpLFxuICAgICAgICAgICAgdGFyZ2V0ID0gbGFzdERvdElkeCA+IC0xID8gZmxvY2suZ2V0KHJvb3QsIHBhdGguc2xpY2UoMCwgcGF0aC5sYXN0SW5kZXhPZihcIi5pbnB1dHNcIikpKSA6XG4gICAgICAgICAgICAgICAgYmFzZVRhcmdldCxcbiAgICAgICAgICAgIHJlc29sdmVkVmFsID0gZmxvY2suaW5wdXQucmVzb2x2ZVZhbHVlKHJvb3QsIHBhdGgsIHZhbCwgdGFyZ2V0LCBpbnB1dE5hbWUsIHByZXZpb3VzSW5wdXQsIHZhbHVlUGFyc2VyKTtcblxuICAgICAgICBmbG9jay5zZXQocm9vdCwgcGF0aCwgcmVzb2x2ZWRWYWwpO1xuXG4gICAgICAgIGlmICh0YXJnZXQgJiYgdGFyZ2V0Lm9uSW5wdXRDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0YXJnZXQub25JbnB1dENoYW5nZWQoaW5wdXROYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNvbHZlZFZhbDtcbiAgICB9O1xuXG4gICAgZmxvY2suaW5wdXQuc2V0VmFsdWVzRm9yUGF0aHMgPSBmdW5jdGlvbiAocm9vdCwgdmFsdWVNYXAsIGJhc2VUYXJnZXQsIHZhbHVlUGFyc2VyKSB7XG4gICAgICAgIHZhciByZXN1bHRNYXAgPSB7fSxcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICByZXN1bHQ7XG5cbiAgICAgICAgZm9yIChwYXRoIGluIHZhbHVlTWFwKSB7XG4gICAgICAgICAgICB2YWwgPSB2YWx1ZU1hcFtwYXRoXTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZsb2NrLmlucHV0LnNldChyb290LCBwYXRoLCB2YWwsIGJhc2VUYXJnZXQsIHZhbHVlUGFyc2VyKTtcbiAgICAgICAgICAgIHJlc3VsdE1hcFtwYXRoXSA9IHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHRNYXA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSB1Z2VuIGF0IHRoZSBzcGVjaWZpZWQgcGF0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIHRoZSB1Z2VuJ3MgcGF0aCB3aXRoaW4gdGhlIHN5bnRoIGdyYXBoXG4gICAgICogQHBhcmFtIHtOdW1iZXIgfHwgVUdlbkRlZn0gdmFsIGEgc2NhbGFyIHZhbHVlIChmb3IgVmFsdWUgdWdlbnMpIG9yIGEgVUdlbkRlZiBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtVR2VufSB0aGUgbmV3bHkgY3JlYXRlZCBVR2VuIHRoYXQgd2FzIHNldCBhdCB0aGUgc3BlY2lmaWVkIHBhdGhcbiAgICAgKi9cbiAgICBmbG9jay5pbnB1dC5zZXQgPSBmdW5jdGlvbiAocm9vdCwgcGF0aCwgdmFsLCBiYXNlVGFyZ2V0LCB2YWx1ZVBhcnNlcikge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHBhdGggPT09IFwic3RyaW5nXCIgP1xuICAgICAgICAgICAgZmxvY2suaW5wdXQuc2V0VmFsdWVGb3JQYXRoKHJvb3QsIHBhdGgsIHZhbCwgYmFzZVRhcmdldCwgdmFsdWVQYXJzZXIpIDpcbiAgICAgICAgICAgIGZsb2NrLmlucHV0LnNldFZhbHVlc0ZvclBhdGhzKHJvb3QsIHBhdGgsIGJhc2VUYXJnZXQsIHZhbHVlUGFyc2VyKTtcbiAgICB9O1xuXG5cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsb2NrLm5vZGVMaXN0XCIsIHtcbiAgICAgICAgZ3JhZGVOYW1lczogW1wiZmx1aWQubGl0dGxlQ29tcG9uZW50XCIsIFwiYXV0b0luaXRcIl0sXG4gICAgICAgIG1lbWJlcnM6IHtcbiAgICAgICAgICAgIG5vZGVzOiBbXSxcbiAgICAgICAgICAgIG5hbWVkTm9kZXM6IHt9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZsb2NrLm5vZGVMaXN0LnByZUluaXQgPSBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgICB0aGF0LmhlYWQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgdGhhdC5ub2Rlcy51bnNoaWZ0KG5vZGUpO1xuICAgICAgICAgICAgaWYgKG5vZGUubmlja05hbWUpIHtcbiAgICAgICAgICAgICAgICB0aGF0Lm5hbWVkTm9kZXNbbm9kZS5uaWNrTmFtZV0gPSBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5iZWZvcmUgPSBmdW5jdGlvbiAocmVmTm9kZSwgbm9kZSkge1xuICAgICAgICAgICAgdmFyIHJlZklkeCA9IHRoYXQubm9kZXMuaW5kZXhPZihyZWZOb2RlKTtcbiAgICAgICAgICAgIHRoYXQuaW5zZXJ0KHJlZklkeCwgbm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVmSWR4O1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQuYWZ0ZXIgPSBmdW5jdGlvbiAocmVmTm9kZSwgbm9kZSkge1xuICAgICAgICAgICAgdmFyIHJlZklkeCA9IHRoYXQubm9kZXMuaW5kZXhPZihyZWZOb2RlKSxcbiAgICAgICAgICAgICAgICBhdElkeCA9IHJlZklkeCArIDE7XG4gICAgICAgICAgICB0aGF0Lmluc2VydChhdElkeCwgbm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gYXRJZHg7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5pbnNlcnQgPSBmdW5jdGlvbiAoaWR4LCBub2RlKSB7XG4gICAgICAgICAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGF0LmhlYWQobm9kZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoYXQubm9kZXMuc3BsaWNlKGlkeCwgMCwgbm9kZSk7XG4gICAgICAgICAgICBpZiAobm9kZS5uaWNrTmFtZSkge1xuICAgICAgICAgICAgICAgIHRoYXQubmFtZWROb2Rlc1tub2RlLm5pY2tOYW1lXSA9IG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaWR4O1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQudGFpbCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICB0aGF0Lm5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICBpZiAobm9kZS5uaWNrTmFtZSkge1xuICAgICAgICAgICAgICAgIHRoYXQubmFtZWROb2Rlc1tub2RlLm5pY2tOYW1lXSA9IG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhhdC5ub2Rlcy5sZW5ndGg7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5yZW1vdmUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgdmFyIGlkeCA9IHRoYXQubm9kZXMuaW5kZXhPZihub2RlKTtcbiAgICAgICAgICAgIGlmIChpZHggPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkeDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhhdC5ub2Rlcy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGF0Lm5hbWVkTm9kZXNbbm9kZS5uaWNrTmFtZV07XG4gICAgICAgICAgICByZXR1cm4gaWR4O1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQucmVwbGFjZSA9IGZ1bmN0aW9uIChuZXdOb2RlLCBvbGROb2RlKSB7XG4gICAgICAgICAgICB2YXIgaWR4ID0gdGhhdC5ub2Rlcy5pbmRleE9mKG9sZE5vZGUpO1xuICAgICAgICAgICAgaWYgKGlkeCA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC5oZWFkKG5ld05vZGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGF0Lm5vZGVzW2lkeF0gPSBuZXdOb2RlO1xuICAgICAgICAgICAgZGVsZXRlIHRoYXQubmFtZWROb2Rlc1tvbGROb2RlLm5pY2tOYW1lXTtcblxuICAgICAgICAgICAgaWYgKG5ld05vZGUubmlja05hbWUpIHtcbiAgICAgICAgICAgICAgICB0aGF0Lm5hbWVkTm9kZXNbbmV3Tm9kZS5uaWNrTmFtZV0gPSBuZXdOb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlkeDtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0LmNsZWFyQWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgd2hpbGUgKHRoYXQubm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoYXQubm9kZXMucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcblxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICogU3ludGhzIGFuZCBQbGF5YmFjayAqXG4gICAgICoqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgZmx1aWQuZGVmYXVsdHMoXCJmbG9jay5lbnZpcm9cIiwge1xuICAgICAgICBncmFkZU5hbWVzOiBbXCJmbHVpZC5zdGFuZGFyZFJlbGF5Q29tcG9uZW50XCIsIFwiZmxvY2subm9kZUxpc3RcIiwgXCJhdXRvSW5pdFwiXSxcblxuICAgICAgICBtZW1iZXJzOiB7XG4gICAgICAgICAgICBhdWRpb1NldHRpbmdzOiBcIkBleHBhbmQ6ZmxvY2suZW52aXJvLmNsYW1wQXVkaW9TZXR0aW5ncyh7dGhhdH0ub3B0aW9ucy5hdWRpb1NldHRpbmdzKVwiLFxuICAgICAgICAgICAgYnVzZXM6IHtcbiAgICAgICAgICAgICAgICBleHBhbmRlcjoge1xuICAgICAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJmbG9jay5lbnZpcm8uY3JlYXRlQXVkaW9CdWZmZXJzXCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtcInt0aGF0fS5hdWRpb1NldHRpbmdzLm51bUJ1c2VzXCIsIFwie3RoYXR9LmF1ZGlvU2V0dGluZ3MuYmxvY2tTaXplXCJdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJ1ZmZlcnM6IHt9LFxuICAgICAgICAgICAgYnVmZmVyU291cmNlczoge31cbiAgICAgICAgfSxcblxuICAgICAgICBtb2RlbDoge1xuICAgICAgICAgICAgaXNQbGF5aW5nOiBmYWxzZSxcblxuICAgICAgICAgICAgLy8gVE9ETzogQnVzZXMgc2hvdWxkIHByb2JhYmx5IGJlIG1hbmFnZWQgYnkgdGhlaXIgb3duIGNvbXBvbmVudC5cbiAgICAgICAgICAgIG5leHRBdmFpbGFibGVCdXM6IHtcbiAgICAgICAgICAgICAgICBpbnB1dDogMCxcbiAgICAgICAgICAgICAgICBpbnRlcmNvbm5lY3Q6IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhdWRpb1NldHRpbmdzOiB7XG4gICAgICAgICAgICByYXRlczoge1xuICAgICAgICAgICAgICAgIGF1ZGlvOiA0ODAwMCwgLy8gVGhpcyBpcyBvbmx5IGEgaGludC4gU29tZSBhdWRpbyBiYWNrZW5kcyAoc3VjaCBhcyB0aGUgV2ViIEF1ZGlvIEFQSSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1heSBkZWZpbmUgdGhlIHNhbXBsZSByYXRlIHRoZW1zZWx2ZXMuXG4gICAgICAgICAgICAgICAgY29udHJvbDogdW5kZWZpbmVkLCAvLyBDb250cm9sIHJhdGUgaXMgY2FsY3VsYXRlZCBkeW5hbWljYWxseSBiYXNlZCBvbiB0aGUgYXVkaW8gcmF0ZSBhbmQgdGhlIGJsb2NrIHNpemUuXG4gICAgICAgICAgICAgICAgc2NoZWR1bGVkOiB1bmRlZmluZWQsIC8vIFRoZSBzY2hlZHVsZWQgcmF0ZSBpcyBhIHVzZXItc3BlY2lmaWVkIHBhcmFtZXRlci5cbiAgICAgICAgICAgICAgICBkZW1hbmQ6IDAsXG4gICAgICAgICAgICAgICAgY29uc3RhbnQ6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBibG9ja1NpemU6IDY0LFxuICAgICAgICAgICAgY2hhbnM6IDIsXG4gICAgICAgICAgICBudW1JbnB1dEJ1c2VzOiAyLFxuICAgICAgICAgICAgbnVtQnVzZXM6IDgsXG4gICAgICAgICAgICAvLyBUaGlzIGJ1ZmZlciBzaXplIGRldGVybWluZXMgdGhlIG92ZXJhbGwgbGF0ZW5jeSBvZiBGbG9ja2luZydzIGF1ZGlvIG91dHB1dC5cbiAgICAgICAgICAgIC8vIFRPRE86IFJlcGxhY2UgdGhpcyB3aXRoIElvQyBhd2Vzb21lbmVzcy5cbiAgICAgICAgICAgIGJ1ZmZlclNpemU6IGZsb2NrLmRlZmF1bHRCdWZmZXJTaXplRm9yUGxhdGZvcm0oKSxcbiAgICAgICAgfSxcblxuICAgICAgICBjb21wb25lbnRzOiB7XG4gICAgICAgICAgICBhc3luY1NjaGVkdWxlcjoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZmxvY2suc2NoZWR1bGVyLmFzeW5jXCJcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGF1ZGlvU3RyYXRlZ3k6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZsb2NrLmF1ZGlvU3RyYXRlZ3kucGxhdGZvcm1cIixcbiAgICAgICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgIGF1ZGlvU2V0dGluZ3M6IFwie2Vudmlyb30uYXVkaW9TZXR0aW5nc1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGludm9rZXJzOiB7XG4gICAgICAgICAgICBhY3F1aXJlTmV4dEJ1czoge1xuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcImZsb2NrLmVudmlyby5hY3F1aXJlTmV4dEJ1c1wiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICAgICAgXCJ7YXJndW1lbnRzfS4wXCIsIC8vIFRoZSB0eXBlIG9mIGJ1cywgZWl0aGVyIFwiaW5wdXRcIiBvciBcImludGVyY29ubmVjdFwiLlxuICAgICAgICAgICAgICAgICAgICBcInt0aGF0fS5idXNlc1wiLFxuICAgICAgICAgICAgICAgICAgICBcInt0aGF0fS5hcHBsaWVyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwie3RoYXR9Lm1vZGVsXCIsXG4gICAgICAgICAgICAgICAgICAgIFwie3RoYXR9LmF1ZGlvU2V0dGluZ3NcIlxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBsaXN0ZW5lcnM6IHtcbiAgICAgICAgICAgIG9uQ3JlYXRlOiB7XG4gICAgICAgICAgICAgICAgZnVuY05hbWU6IFwiZmxvY2suZW52aXJvLmNhbGN1bGF0ZUNvbnRyb2xSYXRlXCIsXG4gICAgICAgICAgICAgICAgYXJnczogW1wie3RoYXR9LmF1ZGlvU2V0dGluZ3NcIl1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZmxvY2suZW52aXJvLmNsYW1wQXVkaW9TZXR0aW5ncyA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHMubnVtSW5wdXRCdXNlcyA9IE1hdGgubWluKHMubnVtSW5wdXRCdXNlcywgZmxvY2suTUFYX0lOUFVUX0JVU0VTKTtcbiAgICAgICAgcy5udW1JbnB1dEJ1c2VzID0gTWF0aC5tYXgocy5udW1JbnB1dEJ1c2VzLCBmbG9jay5NSU5fSU5QVVRfQlVTRVMpO1xuICAgICAgICBzLmNoYW5zID0gTWF0aC5taW4ocy5jaGFucywgZmxvY2suTUFYX0NIQU5ORUxTKTtcbiAgICAgICAgcy5udW1CdXNlcyA9IE1hdGgubWF4KHMubnVtQnVzZXMsIHMuY2hhbnMpO1xuICAgICAgICBzLm51bUJ1c2VzID0gTWF0aC5tYXgocy5udW1CdXNlcywgZmxvY2suTUlOX0JVU0VTKTtcblxuICAgICAgICByZXR1cm4gcztcbiAgICB9O1xuXG4gICAgLy8gVE9ETzogVGhpcyBzaG91bGQgYmUgbW9kZWxpemVkLlxuICAgIGZsb2NrLmVudmlyby5jYWxjdWxhdGVDb250cm9sUmF0ZSA9IGZ1bmN0aW9uIChhdWRpb1NldHRpbmdzKSB7XG4gICAgICAgIGF1ZGlvU2V0dGluZ3MucmF0ZXMuY29udHJvbCA9IGF1ZGlvU2V0dGluZ3MucmF0ZXMuYXVkaW8gLyBhdWRpb1NldHRpbmdzLmJsb2NrU2l6ZTtcbiAgICAgICAgcmV0dXJuIGF1ZGlvU2V0dGluZ3M7XG4gICAgfTtcblxuICAgIGZsb2NrLmVudmlyby5hY3F1aXJlTmV4dEJ1cyA9IGZ1bmN0aW9uICh0eXBlLCBidXNlcywgYXBwbGllciwgbSwgcykge1xuICAgICAgICB2YXIgYnVzTnVtID0gbS5uZXh0QXZhaWxhYmxlQnVzW3R5cGVdO1xuXG4gICAgICAgIGlmIChidXNOdW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZmxvY2suZmFpbChcIkFuIGludmFsaWQgYnVzIHR5cGUgd2FzIHNwZWNpZmllZCB3aGVuIGludm9raW5nIFwiICtcbiAgICAgICAgICAgICAgICBcImZsb2NrLmVudmlyby5hY3F1aXJlTmV4dEJ1cygpLiBUeXBlIHdhczogXCIgKyB0eXBlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElucHV0IGJ1c2VzIHN0YXJ0IGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBvdXRwdXQgYnVzZXMuXG4gICAgICAgIHZhciBvZmZzZXRCdXNOdW0gPSBidXNOdW0gKyBzLmNoYW5zLFxuICAgICAgICAgICAgb2Zmc2V0QnVzTWF4ID0gcy5jaGFucyArIHMubnVtSW5wdXRCdXNlcztcblxuICAgICAgICAvLyBJbnRlcmNvbm5lY3QgYnVzZXMgYXJlIGFmdGVyIHRoZSBpbnB1dCBidXNlcy5cbiAgICAgICAgaWYgKHR5cGUgPT09IFwiaW50ZXJjb25uZWN0XCIpIHtcbiAgICAgICAgICAgIG9mZnNldEJ1c051bSArPSBzLm51bUlucHV0QnVzZXM7XG4gICAgICAgICAgICBvZmZzZXRCdXNNYXggPSBidXNlcy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2Zmc2V0QnVzTnVtID49IG9mZnNldEJ1c01heCkge1xuICAgICAgICAgICAgZmxvY2suZmFpbChcIlVuYWJsZSB0byBhcXVpcmUgYSBidXMuIFRoZXJlIGFyZSBpbnN1ZmZpY2llbnQgYnVzZXMgYXZhaWxhYmxlLiBcIiArXG4gICAgICAgICAgICAgICAgXCJQbGVhc2UgdXNlIGFuIGV4aXN0aW5nIGJ1cyBvciBjb25maWd1cmUgYWRkaXRpb25hbCBidXNlcyB1c2luZyB0aGUgZW52aXJvbWVudCdzIFwiICtcbiAgICAgICAgICAgICAgICBcIm51bUJ1c2VzIGFuZCBudW1JbnB1dEJ1c2VzIHBhcmFtZXRlcnMuXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYXBwbGllci5jaGFuZ2UoXCJuZXh0QXZhaWxhYmxlQnVzLlwiICsgdHlwZSwgKytidXNOdW0pO1xuXG4gICAgICAgIHJldHVybiBvZmZzZXRCdXNOdW07XG4gICAgfTtcblxuICAgIGZsb2NrLmVudmlyby5wcmVJbml0ID0gZnVuY3Rpb24gKHRoYXQpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3RhcnRzIGdlbmVyYXRpbmcgc2FtcGxlcyBmcm9tIGFsbCBzeW50aHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGF0LnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoYXQubW9kZWwuaXNQbGF5aW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGF0LmF1ZGlvU3RyYXRlZ3kuc3RhcnQoKTtcbiAgICAgICAgICAgIHRoYXQubW9kZWwuaXNQbGF5aW5nID0gdHJ1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVwcmVjYXRlZC4gVXNlIHN0YXJ0KCkgaW5zdGVhZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoYXQucGxheSA9IHRoYXQuc3RhcnQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3BzIGdlbmVyYXRpbmcgc2FtcGxlcyBmcm9tIGFsbCBzeW50aHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGF0LnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoYXQubW9kZWwuaXNQbGF5aW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGF0LmF1ZGlvU3RyYXRlZ3kuc3RvcCgpO1xuICAgICAgICAgICAgdGhhdC5tb2RlbC5pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBUT0RPOiBUaGlzIHNob3VsZCBiZSBmYWN0b3JlZCBhcyBhbiBldmVudC5cbiAgICAgICAgdGhhdC5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQuc3RvcCgpO1xuICAgICAgICAgICAgdGhhdC5hc3luY1NjaGVkdWxlci5jbGVhckFsbCgpO1xuICAgICAgICAgICAgdGhhdC5hcHBsaWVyLmNoYW5nZShcIm5leHRBdmFpbGFibGVCdXMuaW5wdXRcIiwgMCk7XG4gICAgICAgICAgICB0aGF0LmFwcGxpZXIuY2hhbmdlKFwibmV4dEF2YWlsYWJsZUJ1cy5pbnRlcmNvbm5lY3RcIiwgMCk7XG4gICAgICAgICAgICB0aGF0LmF1ZGlvU3RyYXRlZ3kucmVzZXQoKTtcbiAgICAgICAgICAgIHRoYXQuY2xlYXJBbGwoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0LnJlZ2lzdGVyQnVmZmVyID0gZnVuY3Rpb24gKGJ1ZkRlc2MpIHtcbiAgICAgICAgICAgIGlmIChidWZEZXNjLmlkKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5idWZmZXJzW2J1ZkRlc2MuaWRdID0gYnVmRGVzYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0LnJlbGVhc2VCdWZmZXIgPSBmdW5jdGlvbiAoYnVmRGVzYykge1xuICAgICAgICAgICAgaWYgKCFidWZEZXNjKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaWQgPSB0eXBlb2YgYnVmRGVzYyA9PT0gXCJzdHJpbmdcIiA/IGJ1ZkRlc2MgOiBidWZEZXNjLmlkO1xuICAgICAgICAgICAgZGVsZXRlIHRoYXQuYnVmZmVyc1tpZF07XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIGZsb2NrLmVudmlyby5maW5hbEluaXQgPSBmdW5jdGlvbiAodGhhdCkge1xuXG4gICAgICAgIHRoYXQuZ2VuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGV2YWx1YXRvciA9IHRoYXQuYXVkaW9TdHJhdGVneS5ub2RlRXZhbHVhdG9yO1xuICAgICAgICAgICAgZXZhbHVhdG9yLmNsZWFyQnVzZXMoKTtcbiAgICAgICAgICAgIGV2YWx1YXRvci5nZW4oKTtcbiAgICAgICAgfTtcblxuICAgIH07XG5cbiAgICBmbG9jay5lbnZpcm8uY3JlYXRlQXVkaW9CdWZmZXJzID0gZnVuY3Rpb24gKG51bUJ1ZnMsIGJsb2NrU2l6ZSkge1xuICAgICAgICB2YXIgYnVmcyA9IFtdLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bUJ1ZnM7IGkrKykge1xuICAgICAgICAgICAgYnVmc1tpXSA9IG5ldyBGbG9hdDMyQXJyYXkoYmxvY2tTaXplKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmcztcbiAgICB9O1xuXG5cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsb2NrLmF1ZGlvU3RyYXRlZ3lcIiwge1xuICAgICAgICBncmFkZU5hbWVzOiBbXCJmbHVpZC5zdGFuZGFyZFJlbGF5Q29tcG9uZW50XCJdLFxuXG4gICAgICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgICAgIG5vZGVFdmFsdWF0b3I6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZsb2NrLmVudmlyby5ub2RlRXZhbHVhdG9yXCIsXG4gICAgICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICBudW1CdXNlczogXCJ7ZW52aXJvfS5vcHRpb25zLmF1ZGlvU2V0dGluZ3MubnVtQnVzZXNcIixcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tTaXplOiBcIntlbnZpcm99Lm9wdGlvbnMuYXVkaW9TZXR0aW5ncy5ibG9ja1NpemVcIixcbiAgICAgICAgICAgICAgICAgICAgbWVtYmVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVzZXM6IFwie2Vudmlyb30uYnVzZXNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzOiBcIntlbnZpcm99Lm5vZGVzXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqKioqKioqKioqKioqKioqXG4gICAgICogTm9kZSBFdmFsdXRvciAqXG4gICAgICoqKioqKioqKioqKioqKioqL1xuXG4gICAgZmx1aWQuZGVmYXVsdHMoXCJmbG9jay5lbnZpcm8ubm9kZUV2YWx1YXRvclwiLCB7XG4gICAgICAgIGdyYWRlTmFtZXM6IFtcImZsdWlkLmxpdHRsZUNvbXBvbmVudFwiLCBcImF1dG9Jbml0XCJdXG4gICAgfSk7XG5cbiAgICBmbG9jay5lbnZpcm8ubm9kZUV2YWx1YXRvci5maW5hbEluaXQgPSBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgICB0aGF0LmNsZWFyQnVzZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbnVtQnVzZXMgPSB0aGF0Lm9wdGlvbnMubnVtQnVzZXMsXG4gICAgICAgICAgICAgICAgYnVzTGVuID0gdGhhdC5vcHRpb25zLmJsb2NrU2l6ZSxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIGJ1cyxcbiAgICAgICAgICAgICAgICBqO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtQnVzZXM7IGkrKykge1xuICAgICAgICAgICAgICAgIGJ1cyA9IHRoYXQuYnVzZXNbaV07XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGJ1c0xlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1c1tqXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQuZ2VuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG5vZGVzID0gdGhhdC5ub2RlcyxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIG5vZGU7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgICAgICBub2RlLmdlbihub2RlLm1vZGVsLmJsb2NrU2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcblxuXG4gICAgZmx1aWQuZGVmYXVsdHMoXCJmbG9jay5hdXRvRW52aXJvXCIsIHtcbiAgICAgICAgZ3JhZGVOYW1lczogW1wiZmx1aWQubGl0dGxlQ29tcG9uZW50XCIsIFwiYXV0b0luaXRcIl1cbiAgICB9KTtcblxuICAgIGZsb2NrLmF1dG9FbnZpcm8ucHJlSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFmbG9jay5lbnZpcm8uc2hhcmVkKSB7XG4gICAgICAgICAgICBmbG9jay5pbml0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsb2NrLm5vZGVcIiwge1xuICAgICAgICBncmFkZU5hbWVzOiBbXCJmbG9jay5hdXRvRW52aXJvXCIsIFwiZmx1aWQubW9kZWxDb21wb25lbnRcIiwgXCJhdXRvSW5pdFwiXVxuICAgIH0pO1xuXG4gICAgZmx1aWQuZGVmYXVsdHMoXCJmbG9jay51Z2VuTm9kZUxpc3RcIiwge1xuICAgICAgICBncmFkZU5hbWVzOiBbXCJmbG9jay5ub2RlTGlzdFwiLCBcImF1dG9Jbml0XCJdXG4gICAgfSk7XG5cbiAgICBmbG9jay51Z2VuTm9kZUxpc3QuZmluYWxJbml0ID0gZnVuY3Rpb24gKHRoYXQpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5zZXJ0cyBhIHVuaXQgZ2VuZXJhdG9yIGFuZCBhbGwgaXRzIGlucHV0cyBpbnRvIHRoZSBub2RlIGxpc3QsIHN0YXJ0aW5nIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXG4gICAgICAgICAqIE5vdGUgdGhhdCB0aGUgbm9kZSBpdHNlbGYgd2lsbCBub3QgYmUgaW5zZXJ0IGludG8gdGhlIGxpc3QgYXQgdGhpcyBpbmRleC0taXRzIGlucHV0cyBtdXN0XG4gICAgICAgICAqIG11c3QgYmUgYWhlYWQgb2YgaXQgaW4gdGhlIGxpc3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpZHggdGhlIGluZGV4IHRvIHN0YXJ0IGFkZGluZyB0aGUgbmV3IG5vZGUgYW5kIGl0cyBpbnB1dHMgYXRcbiAgICAgICAgICogQHBhcmFtIHtVR2VufSBub2RlIHRoZSBub2RlIHRvIGFkZCwgYWxvbmcgd2l0aCBpdHMgaW5wdXRzXG4gICAgICAgICAqIEByZXR1cm4ge051bWJlcn0gdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBzcGVjaWZpZWQgbm9kZSB3YXMgaW5zZXJ0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoYXQuaW5zZXJ0VHJlZSA9IGZ1bmN0aW9uIChpZHgsIG5vZGUpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dHMgPSBub2RlLmlucHV0cyxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgaW5wdXQ7XG5cbiAgICAgICAgICAgIGZvciAoa2V5IGluIGlucHV0cykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gaW5wdXRzW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKGZsb2NrLmlzVUdlbihpbnB1dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWR4ID0gdGhhdC5pbnNlcnRUcmVlKGlkeCwgaW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICBpZHgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGF0Lmluc2VydChpZHgsIG5vZGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgdW5pdCBnZW5lcmF0b3IgYW5kIGFsbCBpdHMgaW5wdXRzIGZyb20gdGhlIG5vZGUgbGlzdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtVR2VufSBub2RlIHRoZSBub2RlIHRvIHJlbW92ZSBhbG9uZyB3aXRoIGl0cyBpbnB1dHNcbiAgICAgICAgICogQHJldHVybiB7TnVtYmVyfSB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIG5vZGUgd2FzIHJlbW92ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoYXQucmVtb3ZlVHJlZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRzID0gbm9kZS5pbnB1dHMsXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIGlucHV0O1xuXG4gICAgICAgICAgICBmb3IgKGtleSBpbiBpbnB1dHMpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IGlucHV0c1trZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5yZW1vdmVUcmVlKGlucHV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGF0LnJlbW92ZShub2RlKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVwbGFjZXMgb25lIG5vZGUgYW5kIGFsbCBpdHMgaW5wdXRzIHdpdGggYSBuZXcgbm9kZSBhbmQgaXRzIGlucHV0cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtVR2VufSBuZXdOb2RlIHRoZSBub2RlIHRvIGFkZCB0byB0aGUgbGlzdFxuICAgICAgICAgKiBAcGFyYW0ge1VHZW59IG9sZE5vZGUgdGhlIG5vZGUgdG8gcmVtb3ZlIGZyb20gdGhlIGxpc3RcbiAgICAgICAgICogQHJldHVybiB7TnVtYmVyfSBpZHggdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBuZXcgbm9kZSB3YXMgYWRkZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoYXQucmVwbGFjZVRyZWUgPSBmdW5jdGlvbiAobmV3Tm9kZSwgb2xkTm9kZSkge1xuICAgICAgICAgICAgaWYgKCFvbGROb2RlKSB7XG4gICAgICAgICAgICAgICAgIC8vIENhbid0IHVzZSAudGFpbCgpIGJlY2F1c2UgaXQgd29uJ3QgcmVjdXJzaXZlbHkgYWRkIGlucHV0cy5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC5pbnNlcnRUcmVlKHRoYXQubm9kZXMubGVuZ3RoLCBuZXdOb2RlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGlkeCA9IHRoYXQucmVtb3ZlVHJlZShvbGROb2RlKTtcbiAgICAgICAgICAgIHRoYXQuaW5zZXJ0VHJlZShpZHgsIG5ld05vZGUpO1xuXG4gICAgICAgICAgICByZXR1cm4gaWR4O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTd2FwcyBvbmUgbm9kZSBpbiB0aGUgbGlzdCBmb3IgYW5vdGhlciBpbiBwbGFjZSwgYXR0YWNoaW5nIHRoZSBwcmV2aW91cyB1bml0IGdlbmVyYXRvcidzXG4gICAgICAgICAqIGlucHV0cyB0byB0aGUgbmV3IG9uZS4gSWYgYSBsaXN0IG9mIGlucHV0c1RvUmVhdHRhY2ggaXMgc3BlY2lmaWVkLCBvbmx5IHRoZXNlIGlucHV0cyB3aWxsXG4gICAgICAgICAqIGJlIHN3YXBwZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIHdpbGwgZGlyZWN0bHkgbW9kaWZ5IHRoZSBub2RlcyBpbiBxdWVzdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtVR2VufSBuZXdOb2RlIHRoZSBub2RlIHRvIGFkZCB0byB0aGUgbGlzdCwgc3dhcHBpbmcgaXQgaW4gcGxhY2UgZm9yIHRoZSBvbGQgb25lXG4gICAgICAgICAqIEBwYXJhbSB7VUdlbn0gb2xkTm9kZSB0aGUgbm9kZSByZW1vdmUgZnJvbSB0aGUgbGlzdFxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBpbnB1dHNUb1JlYXR0YWNoIGEgbGlzdCBvZiBpbnB1dE5hbWVzIHRvIGF0dGFjaCB0byB0aGUgbmV3IG5vZGUgZnJvbSB0aGUgb2xkIG9uZVxuICAgICAgICAgKiBAcmV0dXJuIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgbmV3IG5vZGUgd2FzIGluc2VydGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGF0LnN3YXBUcmVlID0gZnVuY3Rpb24gKG5ld05vZGUsIG9sZE5vZGUsIGlucHV0c1RvUmVhdHRhY2gpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dE5hbWU7XG5cbiAgICAgICAgICAgIGlmICghaW5wdXRzVG9SZWF0dGFjaCkge1xuICAgICAgICAgICAgICAgIG5ld05vZGUuaW5wdXRzID0gb2xkTm9kZS5pbnB1dHM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoaW5wdXROYW1lIGluIG9sZE5vZGUuaW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dHNUb1JlYXR0YWNoLmluZGV4T2YoaW5wdXROYW1lKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQucmVtb3ZlVHJlZShvbGROb2RlLmlucHV0c1tpbnB1dE5hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld05vZGUuaW5wdXRzW2lucHV0TmFtZV0gPSBvbGROb2RlLmlucHV0c1tpbnB1dE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChpbnB1dE5hbWUgaW4gbmV3Tm9kZS5pbnB1dHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0c1RvUmVhdHRhY2guaW5kZXhPZihpbnB1dE5hbWUpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5yZXBsYWNlVHJlZShuZXdOb2RlLmlucHV0c1tpbnB1dE5hbWVdLCBvbGROb2RlLmlucHV0c1tpbnB1dE5hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoYXQucmVwbGFjZShuZXdOb2RlLCBvbGROb2RlKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgZmx1aWQuZGVmYXVsdHMoXCJmbG9jay5zeW50aFwiLCB7XG4gICAgICAgIGdyYWRlTmFtZXM6IFtcbiAgICAgICAgICAgIFwiZmx1aWQuZXZlbnRlZENvbXBvbmVudFwiLFxuICAgICAgICAgICAgXCJmbHVpZC5tb2RlbENvbXBvbmVudFwiLFxuICAgICAgICAgICAgXCJmbG9jay5ub2RlXCIsXG4gICAgICAgICAgICBcImZsb2NrLnVnZW5Ob2RlTGlzdFwiLFxuICAgICAgICAgICAgXCJhdXRvSW5pdFwiXG4gICAgICAgIF0sXG5cbiAgICAgICAgcmF0ZTogZmxvY2sucmF0ZXMuQVVESU8sXG5cbiAgICAgICAgaW52b2tlcnM6IHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUGxheXMgdGhlIHN5bnRoLiBUaGlzIGlzIGEgY29udmVuaWVuY2UgbWV0aG9kIHRoYXQgd2lsbCBhZGQgdGhlIHN5bnRoIHRvIHRoZSB0YWlsIG9mIHRoZVxuICAgICAgICAgICAgICogZW52aXJvbm1lbnQncyBub2RlIGdyYXBoIGFuZCB0aGVuIHBsYXkgdGhlIGVudmlyb25tbmVudC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gZHVyIG9wdGlvbmFsIGR1cmF0aW9uIHRvIHBsYXkgdGhpcyBzeW50aCBpbiBzZWNvbmRzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHBsYXk6IHtcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJmbG9jay5zeW50aC5wbGF5XCIsXG4gICAgICAgICAgICAgICAgYXJnczogW1wie3RoYXR9XCIsIFwie3RoYXR9LmVudmlyb1wiXVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTdG9wcyB0aGUgc3ludGggaWYgaXQgaXMgY3VycmVudGx5IHBsYXlpbmcuXG4gICAgICAgICAgICAgKiBUaGlzIGlzIGEgY29udmVuaWVuY2UgbWV0aG9kIHRoYXQgd2lsbCByZW1vdmUgdGhlIHN5bnRoIGZyb20gdGhlIGVudmlyb25tZW50J3Mgbm9kZSBncmFwaC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcGF1c2U6IHtcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJmbG9jay5zeW50aC5wYXVzZVwiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtcInt0aGF0fVwiLCBcInt0aGF0fS5lbnZpcm9cIl1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBsaXN0ZW5lcnM6IHtcbiAgICAgICAgICAgIG9uRGVzdHJveToge1xuICAgICAgICAgICAgICAgIFwiZnVuY1wiOiBcInt0aGF0fS5wYXVzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZsb2NrLnN5bnRoLnBsYXkgPSBmdW5jdGlvbiAodGhhdCwgZW4pIHtcbiAgICAgICAgaWYgKGVuLm5vZGVzLmluZGV4T2YodGhhdCkgPT09IC0xKSB7XG4gICAgICAgICAgICBlbi5oZWFkKHRoYXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFlbi5tb2RlbC5pc1BsYXlpbmcpIHtcbiAgICAgICAgICAgIGVuLnBsYXkoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmbG9jay5zeW50aC5wYXVzZSA9IGZ1bmN0aW9uICh0aGF0LCBlbikge1xuICAgICAgICBlbi5yZW1vdmUodGhhdCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFN5bnRocyByZXByZXNlbnQgYSBjb2xsZWN0aW9uIG9mIHNpZ25hbC1nZW5lcmF0aW5nIHVuaXRzLCB3aXJlZCB0b2dldGhlciB0byBmb3JtIGFuIGluc3RydW1lbnQuXG4gICAgICogVGhleSBhcmUgY3JlYXRlZCB3aXRoIGEgc3ludGhEZWYgb2JqZWN0LCBhIGRlY2xhcmF0aXZlIHN0cnVjdHVyZSBkZXNjcmliaW5nIHRoZSBzeW50aCdzIHVuaXQgZ2VuZXJhdG9yIGdyYXBoLlxuICAgICAqL1xuICAgIGZsb2NrLnN5bnRoLmZpbmFsSW5pdCA9IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICAgIHRoYXQucmF0ZSA9IHRoYXQub3B0aW9ucy5yYXRlO1xuICAgICAgICB0aGF0LmVudmlybyA9IHRoYXQuZW52aXJvIHx8IGZsb2NrLmVudmlyby5zaGFyZWQ7XG4gICAgICAgIHRoYXQuYXVkaW9TZXR0aW5ncyA9ICQuZXh0ZW5kKHRydWUsIHt9LCB0aGF0LmVudmlyby5hdWRpb1NldHRpbmdzLCB0aGF0Lm9wdGlvbnMuYXVkaW9TZXR0aW5ncyk7XG4gICAgICAgIHRoYXQubW9kZWwuYmxvY2tTaXplID0gdGhhdC5yYXRlID09PSBmbG9jay5yYXRlcy5BVURJTyA/IHRoYXQuYXVkaW9TZXR0aW5ncy5ibG9ja1NpemUgOiAxO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZW5lcmF0ZXMgb25lIGJsb2NrIG9mIGF1ZGlvIHJhdGUgc2lnbmFsIGJ5IGV2YWx1YXRpbmcgdGhpcyBzeW50aCdzIHVuaXQgZ2VuZXJhdG9yIGdyYXBoLlxuICAgICAgICAgKi9cbiAgICAgICAgLy8gVE9ETzogVGhpcyBmdW5jdGlvbiBpcyBtYXJrZWQgYXMgdW5vcHRpbWl6ZWQgYnkgdGhlIENocm9tZSBwcm9maWxlci5cbiAgICAgICAgdGhhdC5nZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbSA9IHRoYXQubW9kZWwsXG4gICAgICAgICAgICAgICAgbm9kZXMgPSB0aGF0Lm5vZGVzLFxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgbm9kZTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmdlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuZ2VuKG5vZGUubW9kZWwuYmxvY2tTaXplKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtLnZhbHVlID0gbm9kZS5tb2RlbC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgdmFsdWUgb2YgdGhlIHVnZW4gYXQgdGhlIHNwZWNpZmllZCBwYXRoLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aCB0aGUgdWdlbidzIHBhdGggd2l0aGluIHRoZSBzeW50aCBncmFwaFxuICAgICAgICAgKiBAcmV0dXJuIHtOdW1iZXJ8VUdlbn0gYSBzY2FsYXIgdmFsdWUgaW4gdGhlIGNhc2Ugb2YgYSB2YWx1ZSB1Z2VuLCBvdGhlcndpc2UgdGhlIHVnZW4gaXRzZWxmXG4gICAgICAgICAqL1xuICAgICAgICB0aGF0LmdldCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmxvY2suaW5wdXQuZ2V0KHRoYXQubmFtZWROb2RlcywgcGF0aCk7XG4gICAgICAgIH07XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIHVnZW4gYXQgdGhlIHNwZWNpZmllZCBwYXRoLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aCB0aGUgdWdlbidzIHBhdGggd2l0aGluIHRoZSBzeW50aCBncmFwaFxuICAgICAgICAgKiBAcGFyYW0ge051bWJlciB8fCBVR2VuRGVmfSB2YWwgYSBzY2FsYXIgdmFsdWUgKGZvciBWYWx1ZSB1Z2Vucykgb3IgYSBVR2VuRGVmIG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJuIHtVR2VufSB0aGUgbmV3bHkgY3JlYXRlZCBVR2VuIHRoYXQgd2FzIHNldCBhdCB0aGUgc3BlY2lmaWVkIHBhdGhcbiAgICAgICAgICovXG4gICAgICAgIHRoYXQuc2V0ID0gZnVuY3Rpb24gKHBhdGgsIHZhbCwgc3dhcCkge1xuICAgICAgICAgICAgcmV0dXJuIGZsb2NrLmlucHV0LnNldCh0aGF0Lm5hbWVkTm9kZXMsIHBhdGgsIHZhbCwgdW5kZWZpbmVkLCBmdW5jdGlvbiAodWdlbkRlZiwgcGF0aCwgdGFyZ2V0LCBwcmV2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZsb2NrLnN5bnRoLnVnZW5WYWx1ZVBhcnNlcih0aGF0LCB1Z2VuRGVmLCBwcmV2LCBzd2FwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIHZhbHVlIG9mIGEgdWdlbiBhdCB0aGUgc3BlY2lmaWVkIHBhdGhcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGggdGhlIHVnZW4ncyBwYXRoIHdpdGhpbiB0aGUgc3ludGggZ3JhcGhcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXIgfHwgVUdlbkRlZiB8fCBBcnJheX0gdmFsIGFuIG9wdGlvbmFsIHZhbHVlIHRvIHRvIHNldC0tYSBzY2FsYXIgdmFsdWUsIGEgVUdlbkRlZiBvYmplY3QsIG9yIGFuIGFycmF5IG9mIFVHZW5EZWZzXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbiB8fCBPYmplY3R9IHN3YXAgc3BlY2lmaWVzIGlmIHRoZSBleGlzdGluZyBpbnB1dHMgc2hvdWxkIGJlIHN3YXBwZWQgb250byB0aGUgbmV3IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4ge051bWJlciB8fCBVR2VuRGVmIHx8IEFycmF5fSB0aGUgdmFsdWUgdGhhdCB3YXMgc2V0IG9yIHJldHJpZXZlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhhdC5pbnB1dCA9IGZ1bmN0aW9uIChwYXRoLCB2YWwsIHN3YXApIHtcbiAgICAgICAgICAgIHJldHVybiAhcGF0aCA/IHVuZGVmaW5lZCA6IHR5cGVvZiBwYXRoID09PSBcInN0cmluZ1wiID9cbiAgICAgICAgICAgICAgICBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IHRoYXQuZ2V0KHBhdGgpIDogdGhhdC5zZXQocGF0aCwgdmFsLCBzd2FwKSA6XG4gICAgICAgICAgICAgICAgZmxvY2suaXNJdGVyYWJsZShwYXRoKSA/IHRoYXQuZ2V0KHBhdGgpIDogdGhhdC5zZXQocGF0aCwgdmFsLCBzd2FwKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0LmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbyA9IHRoYXQub3B0aW9ucyxcbiAgICAgICAgICAgICAgICAvLyBBdCBkZW1hbmQgb3Igc2NoZWR1bGUgcmF0ZXMsIG92ZXJyaWRlIHRoZSByYXRlIG9mIGFsbCBub24tY29uc3RhbnQgdWdlbnMuXG4gICAgICAgICAgICAgICAgb3ZlcnJpZGVSYXRlID0gby5yYXRlID09PSBmbG9jay5yYXRlcy5TQ0hFRFVMRUQgfHwgby5yYXRlID09PSBmbG9jay5yYXRlcy5ERU1BTkQ7XG5cbiAgICAgICAgICAgIGlmICghby5zeW50aERlZikge1xuICAgICAgICAgICAgICAgIGZsdWlkLmxvZyhmbHVpZC5sb2dMZXZlbC5JTVBPUlRBTlQsXG4gICAgICAgICAgICAgICAgICAgIFwiV2FybmluZzogSW5zdGFudGlhdGluZyBhIGZsb2NrLnN5bnRoIGluc3RhbmNlIHdpdGggYW4gZW1wdHkgc3ludGggZGVmLlwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUGFyc2UgdGhlIHN5bnRoRGVmIGludG8gYSBncmFwaCBvZiB1bml0IGdlbmVyYXRvcnMuXG4gICAgICAgICAgICB0aGF0Lm91dCA9IGZsb2NrLnBhcnNlLnN5bnRoRGVmKG8uc3ludGhEZWYsIHtcbiAgICAgICAgICAgICAgICByYXRlOiBvLnJhdGUsXG4gICAgICAgICAgICAgICAgb3ZlcnJpZGVSYXRlOiBvdmVycmlkZVJhdGUsXG4gICAgICAgICAgICAgICAgdmlzaXRvcnM6IHRoYXQudGFpbCxcbiAgICAgICAgICAgICAgICBidWZmZXJzOiB0aGF0LmVudmlyby5idWZmZXJzLFxuICAgICAgICAgICAgICAgIGJ1c2VzOiB0aGF0LmVudmlyby5idXNlcyxcbiAgICAgICAgICAgICAgICBhdWRpb1NldHRpbmdzOiB0aGF0LmF1ZGlvU2V0dGluZ3NcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBBZGQgdGhpcyBzeW50aCB0byB0aGUgdGFpbCBvZiB0aGUgc3ludGhlc2lzIGVudmlyb25tZW50IGlmIGFwcHJvcHJpYXRlLlxuICAgICAgICAgICAgaWYgKG8uYWRkVG9FbnZpcm9ubWVudCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aGF0LmVudmlyby50YWlsKHRoYXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQuaW5pdCgpO1xuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICB9O1xuXG4gICAgZmxvY2suc3ludGgudWdlblZhbHVlUGFyc2VyID0gZnVuY3Rpb24gKHRoYXQsIHVnZW5EZWYsIHByZXYsIHN3YXApIHtcbiAgICAgICAgaWYgKHVnZW5EZWYgPT09IG51bGwgfHwgdWdlbkRlZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJzZWQgPSBmbG9jay5wYXJzZS51Z2VuRGVmKHVnZW5EZWYsIHtcbiAgICAgICAgICAgIGF1ZGlvU2V0dGluZ3M6IHRoYXQuYXVkaW9TZXR0aW5ncyxcbiAgICAgICAgICAgIGJ1c2VzOiB0aGF0LmVudmlyby5idXNlcyxcbiAgICAgICAgICAgIGJ1ZmZlcnM6IHRoYXQuZW52aXJvLmJ1ZmZlcnNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIG5ld1VHZW5zID0gZmxvY2suaXNJdGVyYWJsZShwYXJzZWQpID8gcGFyc2VkIDogKHBhcnNlZCAhPT0gdW5kZWZpbmVkID8gW3BhcnNlZF0gOiBbXSksXG4gICAgICAgICAgICBvbGRVR2VucyA9IGZsb2NrLmlzSXRlcmFibGUocHJldikgPyBwcmV2IDogKHByZXYgIT09IHVuZGVmaW5lZCA/IFtwcmV2XSA6IFtdKTtcblxuICAgICAgICB2YXIgcmVwbGFjZUxlbiA9IE1hdGgubWluKG5ld1VHZW5zLmxlbmd0aCwgb2xkVUdlbnMubGVuZ3RoKSxcbiAgICAgICAgICAgIHJlcGxhY2VGbiA9IHN3YXAgPyB0aGF0LnN3YXBUcmVlIDogdGhhdC5yZXBsYWNlVHJlZSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBhdElkeCxcbiAgICAgICAgICAgIGo7XG5cbiAgICAgICAgLy8gVE9ETzogSW1wcm92ZSBwZXJmb3JtYW5jZSBieSBoYW5kbGluZyBhcnJheXMgaW5saW5lIGluc3RlYWQgb2YgcmVwZWF0ZWQgZnVuY3Rpb24gY2FsbHMuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCByZXBsYWNlTGVuOyBpKyspIHtcbiAgICAgICAgICAgIGF0SWR4ID0gcmVwbGFjZUZuKG5ld1VHZW5zW2ldLCBvbGRVR2Vuc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGogPSBpOyBqIDwgbmV3VUdlbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGF0SWR4Kys7XG4gICAgICAgICAgICB0aGF0Lmluc2VydFRyZWUoYXRJZHgsIG5ld1VHZW5zW2pdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaiA9IGk7IGogPCBvbGRVR2Vucy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdGhhdC5yZW1vdmVUcmVlKG9sZFVHZW5zW2pdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE1ha2VzIGEgbmV3IHN5bnRoLlxuICAgICAqIERlcHJlY2F0ZWQuIFVzZSBmbG9jay5zeW50aCBpbnN0ZWFkLiBUaGlzIGlzIHByb3ZpZGVkIGZvciBzZW1pLWJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IHdpdGhcbiAgICAgKiBwcmV2aW91cyB2ZXJzaW9uIG9mIEZsb2NraW5nIHdoZXJlIGZsb2NrLnN5bnRoIGhhZCBhIG11bHRpLWFyZ3VtZW50IHNpZ25hdHVyZS5cbiAgICAgKi9cbiAgICBmbG9jay5zeW50aC5tYWtlID0gZnVuY3Rpb24gKGRlZiwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgb3B0aW9ucy5zeW50aERlZiA9IGRlZjtcbiAgICAgICAgcmV0dXJuIGZsb2NrLnN5bnRoKG9wdGlvbnMpO1xuICAgIH07XG5cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsb2NrLnN5bnRoLnZhbHVlXCIsIHtcbiAgICAgICAgZ3JhZGVOYW1lczogW1wiZmxvY2suc3ludGhcIiwgXCJhdXRvSW5pdFwiXSxcblxuICAgICAgICByYXRlOiBcImRlbWFuZFwiLFxuXG4gICAgICAgIGFkZFRvRW52aXJvbm1lbnQ6IGZhbHNlXG4gICAgfSk7XG5cbiAgICBmbG9jay5zeW50aC52YWx1ZS5maW5hbEluaXQgPSBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgICB0aGF0LnZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5nZW4oMSk7XG4gICAgICAgICAgICByZXR1cm4gdGhhdC5tb2RlbC52YWx1ZTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG5cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsb2NrLnN5bnRoLmZyYW1lUmF0ZVwiLCB7XG4gICAgICAgIGdyYWRlTmFtZXM6IFtcImZsb2NrLnN5bnRoLnZhbHVlXCIsIFwiYXV0b0luaXRcIl0sXG5cbiAgICAgICAgcmF0ZTogXCJzY2hlZHVsZWRcIixcblxuICAgICAgICBmcHM6IDYwLFxuXG4gICAgICAgIGF1ZGlvU2V0dGluZ3M6IHtcbiAgICAgICAgICAgIHJhdGVzOiB7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVkOiBcInt0aGF0fS5vcHRpb25zLmZwc1wiXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG4gICAgZmx1aWQuZGVmYXVsdHMoXCJmbG9jay5zeW50aC5ncm91cFwiLCB7XG4gICAgICAgIGdyYWRlTmFtZXM6IFtcImZsdWlkLmV2ZW50ZWRDb21wb25lbnRcIiwgXCJmbG9jay5ub2RlXCIsIFwiZmxvY2subm9kZUxpc3RcIiwgXCJhdXRvSW5pdFwiXSxcbiAgICAgICAgcmF0ZTogZmxvY2sucmF0ZXMuQVVESU9cbiAgICB9KTtcblxuICAgIGZsb2NrLnN5bnRoLmdyb3VwLmZpbmFsSW5pdCA9IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICAgIHRoYXQucmF0ZSA9IHRoYXQub3B0aW9ucy5yYXRlO1xuICAgICAgICB0aGF0LmVudmlybyA9IHRoYXQuZW52aXJvIHx8IGZsb2NrLmVudmlyby5zaGFyZWQ7XG5cbiAgICAgICAgZmxvY2suc3ludGguZ3JvdXAubWFrZURpc3BhdGNoZWRNZXRob2RzKHRoYXQsIFtcbiAgICAgICAgICAgIFwiaW5wdXRcIiwgXCJnZXRcIiwgXCJzZXRcIiwgXCJnZW5cIiwgXCJwbGF5XCIsIFwicGF1c2VcIlxuICAgICAgICBdKTtcblxuICAgICAgICB0aGF0LmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhhdC5vcHRpb25zLmFkZFRvRW52aXJvbm1lbnQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5lbnZpcm8udGFpbCh0aGF0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0LmluaXQoKTtcbiAgICB9O1xuXG4gICAgZmxvY2suc3ludGguZ3JvdXAubWFrZURpc3BhdGNoZXIgPSBmdW5jdGlvbiAobm9kZXMsIG1zZykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGksXG4gICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICB2YWw7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgICAgICAgdmFsID0gbm9kZVttc2ddLmFwcGx5KG5vZGUsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIGZsb2NrLnN5bnRoLmdyb3VwLm1ha2VEaXNwYXRjaGVkTWV0aG9kcyA9IGZ1bmN0aW9uICh0aGF0LCBtZXRob2ROYW1lcykge1xuICAgICAgICB2YXIgbmFtZSxcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG1ldGhvZE5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBuYW1lID0gbWV0aG9kTmFtZXNbaV07XG4gICAgICAgICAgICB0aGF0W25hbWVdID0gZmxvY2suc3ludGguZ3JvdXAubWFrZURpc3BhdGNoZXIodGhhdC5ub2RlcywgbmFtZSwgZmxvY2suc3ludGguZ3JvdXAuZGlzcGF0Y2gpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfTtcblxuXG4gICAgZmx1aWQuZGVmYXVsdHMoXCJmbG9jay5zeW50aC5wb2x5cGhvbmljXCIsIHtcbiAgICAgICAgZ3JhZGVOYW1lczogW1wiZmxvY2suc3ludGguZ3JvdXBcIiwgXCJhdXRvSW5pdFwiXSxcbiAgICAgICAgbm90ZVNwZWNzOiB7XG4gICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgIFwiZW52LmdhdGVcIjogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9mZjoge1xuICAgICAgICAgICAgICAgIFwiZW52LmdhdGVcIjogMFxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtYXhWb2ljZXM6IDE2LFxuICAgICAgICBpbml0Vm9pY2VzTGF6aWx5OiB0cnVlLFxuICAgICAgICBhbXBsaXR1ZGVLZXk6IFwiZW52LnN1c3RhaW5cIixcbiAgICAgICAgYW1wbGl0dWRlTm9ybWFsaXplcjogXCJzdGF0aWNcIiAvLyBcImR5bmFtaWNcIiwgXCJzdGF0aWNcIiwgRnVuY3Rpb24sIGZhbHNleVxuICAgIH0pO1xuXG4gICAgZmxvY2suc3ludGgucG9seXBob25pYy5maW5hbEluaXQgPSBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgICB0aGF0LmFjdGl2ZVZvaWNlcyA9IHt9O1xuICAgICAgICB0aGF0LmZyZWVWb2ljZXMgPSBbXTtcblxuICAgICAgICB0aGF0Lm5vdGVDaGFuZ2UgPSBmdW5jdGlvbiAodm9pY2UsIGV2ZW50TmFtZSwgY2hhbmdlU3BlYykge1xuICAgICAgICAgICAgdmFyIG5vdGVFdmVudFNwZWMgPSB0aGF0Lm9wdGlvbnMubm90ZVNwZWNzW2V2ZW50TmFtZV07XG4gICAgICAgICAgICBjaGFuZ2VTcGVjID0gJC5leHRlbmQoe30sIG5vdGVFdmVudFNwZWMsIGNoYW5nZVNwZWMpO1xuICAgICAgICAgICAgdm9pY2UuaW5wdXQoY2hhbmdlU3BlYyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5ub3RlT24gPSBmdW5jdGlvbiAobm90ZU5hbWUsIGNoYW5nZVNwZWMpIHtcbiAgICAgICAgICAgIHZhciB2b2ljZSA9IHRoYXQubmV4dEZyZWVWb2ljZSgpO1xuICAgICAgICAgICAgaWYgKHRoYXQuYWN0aXZlVm9pY2VzW25vdGVOYW1lXSkge1xuICAgICAgICAgICAgICAgIHRoYXQubm90ZU9mZihub3RlTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGF0LmFjdGl2ZVZvaWNlc1tub3RlTmFtZV0gPSB2b2ljZTtcbiAgICAgICAgICAgIHRoYXQubm90ZUNoYW5nZSh2b2ljZSwgXCJvblwiLCBjaGFuZ2VTcGVjKTtcblxuICAgICAgICAgICAgcmV0dXJuIHZvaWNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQubm90ZU9mZiA9IGZ1bmN0aW9uIChub3RlTmFtZSwgY2hhbmdlU3BlYykge1xuICAgICAgICAgICAgdmFyIHZvaWNlID0gdGhhdC5hY3RpdmVWb2ljZXNbbm90ZU5hbWVdO1xuICAgICAgICAgICAgaWYgKCF2b2ljZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhhdC5ub3RlQ2hhbmdlKHZvaWNlLCBcIm9mZlwiLCBjaGFuZ2VTcGVjKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGF0LmFjdGl2ZVZvaWNlc1tub3RlTmFtZV07XG4gICAgICAgICAgICB0aGF0LmZyZWVWb2ljZXMucHVzaCh2b2ljZSk7XG5cbiAgICAgICAgICAgIHJldHVybiB2b2ljZTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0LmNyZWF0ZVZvaWNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHZvaWNlID0gZmxvY2suc3ludGgoe1xuICAgICAgICAgICAgICAgIHN5bnRoRGVmOiB0aGF0Lm9wdGlvbnMuc3ludGhEZWYsXG4gICAgICAgICAgICAgICAgYWRkVG9FbnZpcm9ubWVudDogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgbm9ybWFsaXplciA9IHRoYXQub3B0aW9ucy5hbXBsaXR1ZGVOb3JtYWxpemVyLFxuICAgICAgICAgICAgICAgIGFtcEtleSA9IHRoYXQub3B0aW9ucy5hbXBsaXR1ZGVLZXksXG4gICAgICAgICAgICAgICAgbm9ybVZhbHVlO1xuXG4gICAgICAgICAgICBpZiAobm9ybWFsaXplcikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9ybWFsaXplciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZXIodm9pY2UsIGFtcEtleSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub3JtYWxpemVyID09PSBcInN0YXRpY1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1WYWx1ZSA9IDEuMCAvIHRoYXQub3B0aW9ucy5tYXhWb2ljZXM7XG4gICAgICAgICAgICAgICAgICAgIHZvaWNlLmlucHV0KGFtcEtleSwgbm9ybVZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IGR5bmFtaWMgdm9pY2Ugbm9ybWFsaXphdGlvbi5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoYXQubm9kZXMucHVzaCh2b2ljZSk7XG5cbiAgICAgICAgICAgIHJldHVybiB2b2ljZTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0LnBvb2xlZFZvaWNlQWxsb2NhdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoYXQuZnJlZVZvaWNlcy5wb3AoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0LmxhenlWb2ljZUFsbG9jYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGF0LmZyZWVWb2ljZXMubGVuZ3RoID4gMSA/XG4gICAgICAgICAgICAgICAgdGhhdC5mcmVlVm9pY2VzLnBvcCgpIDogT2JqZWN0LmtleXModGhhdC5hY3RpdmVWb2ljZXMpLmxlbmd0aCA+IHRoYXQub3B0aW9ucy5tYXhWb2ljZXMgP1xuICAgICAgICAgICAgICAgIG51bGwgOiB0aGF0LmNyZWF0ZVZvaWNlKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGF0Lm9wdGlvbnMuaW5pdFZvaWNlc0xhemlseSkge1xuICAgICAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGF0Lm9wdGlvbnMubWF4Vm9pY2VzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5mcmVlVm9pY2VzW2ldID0gdGhhdC5jcmVhdGVWb2ljZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGF0Lm5leHRGcmVlVm9pY2UgPSB0aGF0LnBvb2xlZFZvaWNlQWxsb2NhdG9yO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGF0Lm5leHRGcmVlVm9pY2UgPSB0aGF0LmxhenlWb2ljZUFsbG9jYXRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0LmluaXQoKTtcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGZsb2NrLmJhbmQgcHJvdmlkZXMgYW4gSW9DLWZyaWVuZGx5IGludGVyZmFjZSBmb3IgYSBjb2xsZWN0aW9uIG9mIG5hbWVkIHN5bnRocy5cbiAgICAgKi9cbiAgICAvLyBUT0RPOiBVbml0IHRlc3RzLlxuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmxvY2suYmFuZFwiLCB7XG4gICAgICAgIGdyYWRlTmFtZXM6IFtcImZsdWlkLmV2ZW50ZWRDb21wb25lbnRcIiwgXCJhdXRvSW5pdFwiXSxcblxuICAgICAgICBpbnZva2Vyczoge1xuICAgICAgICAgICAgcGxheToge1xuICAgICAgICAgICAgICAgIGZ1bmM6IFwie3RoYXR9LmV2ZW50cy5vblBsYXkuZmlyZVwiXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBwYXVzZToge1xuICAgICAgICAgICAgICAgIGZ1bmM6IFwie3RoYXR9LmV2ZW50cy5vblBhdXNlLmZpcmVcIlxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0OiB7XG4gICAgICAgICAgICAgICAgZnVuYzogXCJ7dGhhdH0uZXZlbnRzLm9uU2V0LmZpcmVcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGV2ZW50czoge1xuICAgICAgICAgICAgb25QbGF5OiBudWxsLFxuICAgICAgICAgICAgb25QYXVzZTogbnVsbCxcbiAgICAgICAgICAgIG9uU2V0OiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgZGlzdHJpYnV0ZU9wdGlvbnM6IHtcbiAgICAgICAgICAgIHNvdXJjZTogXCJ7dGhhdH0ub3B0aW9ucy5zeW50aExpc3RlbmVyc1wiLFxuICAgICAgICAgICAgcmVtb3ZlU291cmNlOiB0cnVlLFxuICAgICAgICAgICAgdGFyZ2V0OiBcInt0aGF0IGZsb2NrLnN5bnRofS5vcHRpb25zLmxpc3RlbmVyc1wiXG4gICAgICAgIH0sXG5cbiAgICAgICAgc3ludGhMaXN0ZW5lcnM6IHtcbiAgICAgICAgICAgIFwie2JhbmR9LmV2ZW50cy5vblBsYXlcIjoge1xuICAgICAgICAgICAgICAgIGZ1bmM6IFwie3RoYXR9LnBsYXlcIlxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgXCJ7YmFuZH0uZXZlbnRzLm9uUGF1c2VcIjoge1xuICAgICAgICAgICAgICAgIGZ1bmM6IFwie3RoYXR9LnBhdXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgKiBFcnJvciBIYW5kbGluZyBDb252ZW5pZW5jZXMgKlxuICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgZmxvY2suYnVmZmVyRGVzYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZmxvY2suYnVmZmVyRGVzYyBpcyBub3QgZGVmaW5lZC4gRGlkIHlvdSBmb3JnZXQgdG8gaW5jbHVkZSB0aGUgZmxvY2tpbmctYnVmZmVycy5qcyBmaWxlP1wiKTtcbiAgICB9O1xufSgpKTtcbjsvKlxuKiBGbG9ja2luZyBBdWRpbyBCdWZmZXJzXG4qIGh0dHA6Ly9naXRodWIuY29tL2NvbGluYmRjbGFyay9mbG9ja2luZ1xuKlxuKiBDb3B5cmlnaHQgMjAxMy0xNCwgQ29saW4gQ2xhcmtcbiogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGFuZCBHUEwgVmVyc2lvbiAyIGxpY2Vuc2VzLlxuKi9cblxuLypnbG9iYWwgcmVxdWlyZSwgQXVkaW9CdWZmZXIqL1xuLypqc2hpbnQgd2hpdGU6IGZhbHNlLCBuZXdjYXA6IHRydWUsIHJlZ2V4cDogdHJ1ZSwgYnJvd3NlcjogdHJ1ZSxcbiAgICBmb3JpbjogZmFsc2UsIG5vbWVuOiB0cnVlLCBiaXR3aXNlOiBmYWxzZSwgbWF4ZXJyOiAxMDAsXG4gICAgaW5kZW50OiA0LCBwbHVzcGx1czogZmFsc2UsIGN1cmx5OiB0cnVlLCBlcWVxZXE6IHRydWUsXG4gICAgZnJlZXplOiB0cnVlLCBsYXRlZGVmOiB0cnVlLCBub2FyZzogdHJ1ZSwgbm9uZXc6IHRydWUsIHF1b3RtYXJrOiBkb3VibGUsIHVuZGVmOiB0cnVlLFxuICAgIHVudXNlZDogdHJ1ZSwgc3RyaWN0OiB0cnVlLCBhc2k6IGZhbHNlLCBib3NzOiBmYWxzZSwgZXZpbDogZmFsc2UsIGV4cHI6IGZhbHNlLFxuICAgIGZ1bmNzY29wZTogZmFsc2UqL1xuXG52YXIgZmx1aWQgPSBmbHVpZCB8fCByZXF1aXJlKFwiaW5mdXNpb25cIiksXG4gICAgZmxvY2sgPSBmbHVpZC5yZWdpc3Rlck5hbWVzcGFjZShcImZsb2NrXCIpO1xuXG4oZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy8gQmFzZWQgb24gQnJpYW4gQ2F2YWxpZXIgYW5kIEpvaG4gSGFubidzIFRpbnkgUHJvbWlzZXMgbGlicmFyeS5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdW5zY3JpcHRhYmxlL3Byb21pc2VzL2Jsb2IvbWFzdGVyL3NyYy9UaW55Mi5qc1xuICAgIGZ1bmN0aW9uIFByb21pc2UoKSB7XG4gICAgICAgIHZhciByZXNvbHZlID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgY29tcGxldGUoXCJyZXNvbHZlXCIsIHJlc3VsdCk7XG4gICAgICAgICAgICBwcm9taXNlLnN0YXRlID0gXCJmdWxmaWxsZWRcIjtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcmVqZWN0ID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgY29tcGxldGUoXCJyZWplY3RcIiwgZXJyKTtcbiAgICAgICAgICAgIHByb21pc2Uuc3RhdGUgPSBcInJlamVjdGVkXCI7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHRoZW4gPSBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlOiByZXNvbHZlLFxuICAgICAgICAgICAgICAgICAgICByZWplY3Q6IHJlamVjdFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZm4gPSBwcm9taXNlLnN0YXRlID09PSBcImZ1bGZpbGxlZFwiID8gcmVzb2x2ZSA6IHJlamVjdDtcbiAgICAgICAgICAgICAgICBmbihwcm9taXNlLnZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGNhbGxiYWNrcyA9IFtdLFxuICAgICAgICAgICAgcHJvbWlzZSA9IHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogXCJwZW5kaW5nXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICByZXNvbHZlOiByZXNvbHZlLFxuICAgICAgICAgICAgICAgIHJlamVjdDogcmVqZWN0LFxuICAgICAgICAgICAgICAgIHRoZW46IHRoZW4sXG4gICAgICAgICAgICAgICAgc2FmZToge1xuICAgICAgICAgICAgICAgICAgICB0aGVuOiBmdW5jdGlvbiBzYWZlVGhlbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG5cbiAgICAgICAgZnVuY3Rpb24gY29tcGxldGUodHlwZSwgcmVzdWx0KSB7XG4gICAgICAgICAgICB2YXIgcmVqZWN0b3IgPSBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgcmVzb2x2ZXIgPSBmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHByb21pc2UudmFsdWUgPSByZXN1bHQ7XG4gICAgICAgICAgICBwcm9taXNlLnRoZW4gPSB0eXBlID09PSBcInJlamVjdFwiID8gcmVqZWN0b3IgOiByZXNvbHZlcjtcbiAgICAgICAgICAgIHByb21pc2UucmVzb2x2ZSA9IHByb21pc2UucmVqZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb21pc2UgYWxyZWFkeSBjb21wbGV0ZWRcIik7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpbnZva2VDYWxsYmFja3ModHlwZSwgcmVzdWx0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGludm9rZUNhbGxiYWNrcyAodHlwZSwgcmVzdWx0KSB7XG4gICAgICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgICAgICBjYjtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNiID0gY2FsbGJhY2tzW2ldO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNiW3R5cGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiW3R5cGVdKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYWxsYmFja3MgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuXG4gICAgZmx1aWQuZGVmYXVsdHMoXCJmbG9jay5wcm9taXNlXCIsIHtcbiAgICAgICAgZ3JhZGVOYW1lczogW1wiZmx1aWQuZXZlbnRlZENvbXBvbmVudFwiLCBcImF1dG9Jbml0XCJdLFxuXG4gICAgICAgIG1lbWJlcnM6IHtcbiAgICAgICAgICAgIHByb21pc2U6IHtcbiAgICAgICAgICAgICAgICBleHBhbmRlcjoge1xuICAgICAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJmbG9jay5wcm9taXNlLm1ha2VcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZmxvY2sucHJvbWlzZS5tYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKTtcbiAgICB9O1xuXG4gICAgLy8gVE9ETzogVGhpcyBpcyBhY3R1YWxseSBwYXJ0IG9mIHRoZSBpbnRlcnByZXRlcidzIGV4cGFuc2lvbiBwcm9jZXNzXG4gICAgLy8gYW5kIHNob3VsZCBiZSBjbGVhcmx5IG5hbWVkIGFzIHN1Y2guXG4gICAgZmxvY2suYnVmZmVyRGVzYyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBmbiA9IGZsb2NrLnBsYXRmb3JtLmlzV2ViQXVkaW8gJiYgZGF0YSBpbnN0YW5jZW9mIEF1ZGlvQnVmZmVyID9cbiAgICAgICAgICAgIGZsb2NrLmJ1ZmZlckRlc2MuZnJvbUF1ZGlvQnVmZmVyIDogZmxvY2suaXNJdGVyYWJsZShkYXRhKSA/XG4gICAgICAgICAgICBmbG9jay5idWZmZXJEZXNjLmZyb21DaGFubmVsQXJyYXkgOiBmbG9jay5idWZmZXJEZXNjLmV4cGFuZDtcblxuICAgICAgICByZXR1cm4gZm4oZGF0YSk7XG4gICAgfTtcblxuICAgIGZsb2NrLmJ1ZmZlckRlc2MuaW5mZXJGb3JtYXQgPSBmdW5jdGlvbiAoYnVmRGVzYykge1xuICAgICAgICB2YXIgZm9ybWF0ID0gYnVmRGVzYy5mb3JtYXQsXG4gICAgICAgICAgICBkYXRhID0gYnVmRGVzYy5kYXRhO1xuXG4gICAgICAgIGZvcm1hdC5zYW1wbGVSYXRlID0gZm9ybWF0LnNhbXBsZVJhdGUgfHwgNDQxMDA7XG4gICAgICAgIGZvcm1hdC5udW1TYW1wbGVGcmFtZXMgPSBmb3JtYXQubnVtU2FtcGxlRnJhbWVzIHx8IGRhdGEuY2hhbm5lbHNbMF0ubGVuZ3RoO1xuICAgICAgICBmb3JtYXQuZHVyYXRpb24gPSBmb3JtYXQubnVtU2FtcGxlRnJhbWVzIC8gZm9ybWF0LnNhbXBsZVJhdGU7XG5cbiAgICAgICAgcmV0dXJuIGJ1ZkRlc2M7XG4gICAgfTtcblxuICAgIGZsb2NrLmJ1ZmZlckRlc2MuZnJvbUNoYW5uZWxBcnJheSA9IGZ1bmN0aW9uIChhcnIsIHNhbXBsZVJhdGUpIHtcbiAgICAgICAgdmFyIGJ1ZkRlc2MgPSB7XG4gICAgICAgICAgICBjb250YWluZXI6IHt9LFxuXG4gICAgICAgICAgICBmb3JtYXQ6IHtcbiAgICAgICAgICAgICAgICBudW1DaGFubmVsczogMSxcbiAgICAgICAgICAgICAgICBzYW1wbGVSYXRlOiBzYW1wbGVSYXRlXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbHM6IFthcnJdXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGZsb2NrLmJ1ZmZlckRlc2MuaW5mZXJGb3JtYXQoYnVmRGVzYyk7XG4gICAgfTtcblxuICAgIGZsb2NrLmJ1ZmZlckRlc2MuZXhwYW5kID0gZnVuY3Rpb24gKGJ1ZkRlc2MpIHtcbiAgICAgICAgYnVmRGVzYy5jb250YWluZXIgPSBidWZEZXNjLmNvbnRhaW5lciB8fCB7fTtcbiAgICAgICAgYnVmRGVzYy5mb3JtYXQgPSBidWZEZXNjLmZvcm1hdCB8fCB7fTtcblxuICAgICAgICBidWZEZXNjLmZvcm1hdC5udW1DaGFubmVscyA9IGJ1ZkRlc2MuZm9ybWF0Lm51bUNoYW5uZWxzIHx8IGJ1ZkRlc2MuZGF0YS5jaGFubmVscy5sZW5ndGg7XG5cbiAgICAgICAgaWYgKGJ1ZkRlc2MuZGF0YSAmJiBidWZEZXNjLmRhdGEuY2hhbm5lbHMpIHtcbiAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYW4gdW53cmFwcGVkIHNpbmdsZS1jaGFubmVsIGFycmF5LlxuICAgICAgICAgICAgaWYgKGJ1ZkRlc2MuZm9ybWF0Lm51bUNoYW5uZWxzID09PSAxICYmIGJ1ZkRlc2MuZGF0YS5jaGFubmVscy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgICAgICBidWZEZXNjLmRhdGEuY2hhbm5lbHMgPSBbYnVmRGVzYy5kYXRhLmNoYW5uZWxzXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGJ1ZkRlc2MuZm9ybWF0Lm51bUNoYW5uZWxzICE9PSBidWZEZXNjLmRhdGEuY2hhbm5lbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHNwZWNpZmllZCBudW1iZXIgb2YgY2hhbm5lbHMgZG9lcyBub3QgbWF0Y2ggXCIgK1xuICAgICAgICAgICAgICAgICAgICBcInRoZSBhY3R1YWwgY2hhbm5lbCBkYXRhLiBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwibnVtQ2hhbm5lbHMgd2FzOiBcIiArIGJ1ZkRlc2MuZm9ybWF0Lm51bUNoYW5uZWxzICtcbiAgICAgICAgICAgICAgICAgICAgXCIgYnV0IHRoZSBzYW1wbGUgZGF0YSBjb250YWlucyBcIiArIGJ1ZkRlc2MuZGF0YS5jaGFubmVscy5sZW5ndGggKyBcIiBjaGFubmVscy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmxvY2suYnVmZmVyRGVzYy5pbmZlckZvcm1hdChidWZEZXNjKTtcbiAgICB9O1xuXG4gICAgZmxvY2suYnVmZmVyRGVzYy5mcm9tQXVkaW9CdWZmZXIgPSBmdW5jdGlvbiAoYXVkaW9CdWZmZXIpIHtcbiAgICAgICAgdmFyIGRlc2MgPSB7XG4gICAgICAgICAgICBjb250YWluZXI6IHt9LFxuICAgICAgICAgICAgZm9ybWF0OiB7XG4gICAgICAgICAgICAgICAgc2FtcGxlUmF0ZTogYXVkaW9CdWZmZXIuc2FtcGxlUmF0ZSxcbiAgICAgICAgICAgICAgICBudW1DaGFubmVsczogYXVkaW9CdWZmZXIubnVtYmVyT2ZDaGFubmVscyxcbiAgICAgICAgICAgICAgICBudW1TYW1wbGVGcmFtZXM6IGF1ZGlvQnVmZmVyLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogYXVkaW9CdWZmZXIuZHVyYXRpb25cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbHM6IFtdXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGF1ZGlvQnVmZmVyLm51bWJlck9mQ2hhbm5lbHM7IGkrKykge1xuICAgICAgICAgICAgZGVzYy5kYXRhLmNoYW5uZWxzLnB1c2goYXVkaW9CdWZmZXIuZ2V0Q2hhbm5lbERhdGEoaSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlc2M7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIHNvdXJjZSBmb3IgZmV0Y2hpbmcgYnVmZmVycy5cbiAgICAgKi9cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsb2NrLmJ1ZmZlclNvdXJjZVwiLCB7XG4gICAgICAgIGdyYWRlTmFtZXM6IFtcImZsdWlkLmV2ZW50ZWRDb21wb25lbnRcIiwgXCJmbHVpZC5tb2RlbENvbXBvbmVudFwiLCBcImF1dG9Jbml0XCJdLFxuXG4gICAgICAgIG1vZGVsOiB7XG4gICAgICAgICAgICBzdGF0ZTogXCJzdGFydFwiLFxuICAgICAgICAgICAgc3JjOiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgY29tcG9uZW50czoge1xuICAgICAgICAgICAgYnVmZmVyUHJvbWlzZToge1xuICAgICAgICAgICAgICAgIGNyZWF0ZU9uRXZlbnQ6IFwib25SZWZyZXNoUHJvbWlzZVwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiZmxvY2sucHJvbWlzZVwiLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNyZWF0ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidGhpc1wiOiBcInt0aGF0fS5wcm9taXNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcInRoZW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXCJ7YnVmZmVyU291cmNlfS5ldmVudHMuYWZ0ZXJGZXRjaC5maXJlXCIsIFwie2J1ZmZlclNvdXJjZX0uZXZlbnRzLm9uRXJyb3IuZmlyZVwiXVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGludm9rZXJzOiB7XG4gICAgICAgICAgICBnZXQ6IHtcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJmbG9jay5idWZmZXJTb3VyY2UuZ2V0XCIsXG4gICAgICAgICAgICAgICAgYXJnczogW1wie3RoYXR9XCIsIFwie2FyZ3VtZW50c30uMFwiXVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0OiB7XG4gICAgICAgICAgICAgICAgZnVuY05hbWU6IFwiZmxvY2suYnVmZmVyU291cmNlLnNldFwiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtcInt0aGF0fVwiLCBcInthcmd1bWVudHN9LjBcIl1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICAgICAgZnVuY05hbWU6IFwiZmxvY2suYnVmZmVyU291cmNlLmVycm9yXCIsXG4gICAgICAgICAgICAgICAgYXJnczogW1wie3RoYXR9XCIsIFwie2FyZ3VtZW50c30uMFwiXVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGxpc3RlbmVyczoge1xuICAgICAgICAgICAgb25DcmVhdGU6IHtcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJ7dGhhdH0uZXZlbnRzLm9uUmVmcmVzaFByb21pc2UuZmlyZVwiXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBvblJlZnJlc2hQcm9taXNlOiB7XG4gICAgICAgICAgICAgICAgZnVuY05hbWU6IFwie3RoYXR9LmFwcGxpZXIucmVxdWVzdENoYW5nZVwiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtcInN0YXRlXCIsIFwic3RhcnRcIl1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG9uRmV0Y2g6IHtcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJ7dGhhdH0uYXBwbGllci5yZXF1ZXN0Q2hhbmdlXCIsXG4gICAgICAgICAgICAgICAgYXJnczogW1wic3RhdGVcIiwgXCJpbi1wcm9ncmVzc1wiXVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgYWZ0ZXJGZXRjaDogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY05hbWU6IFwie3RoYXR9LmFwcGxpZXIucmVxdWVzdENoYW5nZVwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXCJzdGF0ZVwiLCBcImZldGNoZWRcIl1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY05hbWU6IFwie3RoYXR9LmV2ZW50cy5vbkJ1ZmZlclVwZGF0ZWQuZmlyZVwiLCAvLyBUT0RPOiBSZXBsYWNlIHdpdGggYm9pbGluZz9cbiAgICAgICAgICAgICAgICAgICAgYXJnczogW1wie2FyZ3VtZW50c30uMFwiXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG5cbiAgICAgICAgICAgIG9uQnVmZmVyVXBkYXRlZDoge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IEhhcmRjb2RlZCByZWZlcmVuY2UgdG8gc2hhcmVkIGVudmlyb25tZW50LlxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcImZsb2NrLmVudmlyby5zaGFyZWQucmVnaXN0ZXJCdWZmZXJcIixcbiAgICAgICAgICAgICAgICBhcmdzOiBbXCJ7YXJndW1lbnRzfS4wXCJdXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBvbkVycm9yOiB7XG4gICAgICAgICAgICAgICAgZnVuY05hbWU6IFwie3RoYXR9LmFwcGxpZXIucmVxdWVzdENoYW5nZVwiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtcInN0YXRlXCIsIFwiZXJyb3JcIl1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBldmVudHM6IHtcbiAgICAgICAgICAgIG9uUmVmcmVzaFByb21pc2U6IG51bGwsXG4gICAgICAgICAgICBvbkVycm9yOiBudWxsLFxuICAgICAgICAgICAgb25GZXRjaDogbnVsbCxcbiAgICAgICAgICAgIGFmdGVyRmV0Y2g6IG51bGwsXG4gICAgICAgICAgICBvbkJ1ZmZlclVwZGF0ZWQ6IG51bGxcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZmxvY2suYnVmZmVyU291cmNlLmdldCA9IGZ1bmN0aW9uICh0aGF0LCBidWZEZWYpIHtcbiAgICAgICAgaWYgKHRoYXQubW9kZWwuc3RhdGUgPT09IFwiaW4tcHJvZ3Jlc3NcIiB8fCAoYnVmRGVmLnNyYyA9PT0gdGhhdC5tb2RlbC5zcmMgJiYgIWJ1ZkRlZi5yZXBsYWNlKSkge1xuICAgICAgICAgICAgLy8gV2UndmUgYWxyZWFkeSBmZXRjaGVkIHRoZSBidWZmZXIgb3IgYXJlIGluIHRoZSBwcm9jZXNzIG9mIGRvaW5nIHNvLlxuICAgICAgICAgICAgcmV0dXJuIHRoYXQuYnVmZmVyUHJvbWlzZS5wcm9taXNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJ1ZkRlZi5zcmMpIHtcbiAgICAgICAgICAgIGlmICgodGhhdC5tb2RlbC5zdGF0ZSA9PT0gXCJmZXRjaGVkXCIgfHwgdGhhdC5tb2RlbC5zdGF0ZSA9PT0gXCJlcnJvcmVkXCIpICYmXG4gICAgICAgICAgICAgICAgKHRoYXQubW9kZWwuc3JjICE9PSBidWZEZWYuc3JjIHx8IGJ1ZkRlZi5yZXBsYWNlKSkge1xuICAgICAgICAgICAgICAgIHRoYXQuZXZlbnRzLm9uUmVmcmVzaFByb21pc2UuZmlyZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhhdC5tb2RlbC5zdGF0ZSA9PT0gXCJzdGFydFwiKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5tb2RlbC5zcmMgPSBidWZEZWYuc3JjO1xuICAgICAgICAgICAgICAgIHRoYXQuZXZlbnRzLm9uRmV0Y2guZmlyZShidWZEZWYpO1xuICAgICAgICAgICAgICAgIGZsb2NrLmF1ZGlvLmRlY29kZSh7XG4gICAgICAgICAgICAgICAgICAgIHNyYzogYnVmRGVmLnNyYyxcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKGJ1ZkRlc2MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChidWZEZWYuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZEZXNjLmlkID0gYnVmRGVmLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnNldChidWZEZXNjKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IHRoYXQuZXJyb3JcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGF0LmJ1ZmZlclByb21pc2UucHJvbWlzZTtcbiAgICB9O1xuXG4gICAgZmxvY2suYnVmZmVyU291cmNlLnNldCA9IGZ1bmN0aW9uICh0aGF0LCBidWZEZXNjKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoYXQubW9kZWwuc3RhdGU7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gXCJzdGFydFwiIHx8IHN0YXRlID09PSBcImluLXByb2dyZXNzXCIpIHtcbiAgICAgICAgICAgIHRoYXQuYnVmZmVyUHJvbWlzZS5wcm9taXNlLnJlc29sdmUoYnVmRGVzYyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhhdC5idWZmZXJQcm9taXNlLnByb21pc2U7XG4gICAgfTtcblxuICAgIGZsb2NrLmJ1ZmZlclNvdXJjZS5lcnJvciA9IGZ1bmN0aW9uICh0aGF0LCBtc2cpIHtcbiAgICAgICAgdGhhdC5idWZmZXJQcm9taXNlLnByb21pc2UucmVqZWN0KG1zZyk7XG5cbiAgICAgICAgcmV0dXJuIHRoYXQuYnVmZmVyUHJvbWlzZS5wcm9taXNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBIEJ1ZmZlciBMb2FkZXIgaXMgcmVzcG9uc2libGUgZm9yIGxvYWRpbmcgYSBjb2xsZWN0aW9uXG4gICAgICogb2YgYnVmZmVycyBhc3luY2hyb25vdXNseSwgYW5kIHdpbGwgZmlyZSBhbiBldmVudCB3aGVuIHRoZXlcbiAgICAgKiBhcmUgYWxsIHJlYWR5LlxuICAgICAqL1xuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmxvY2suYnVmZmVyTG9hZGVyXCIsIHtcbiAgICAgICAgZ3JhZGVOYW1lczogW1wiZmx1aWQuZXZlbnRlZENvbXBvbmVudFwiLCBcImF1dG9Jbml0XCJdLFxuXG4gICAgICAgIG1lbWJlcnM6IHtcbiAgICAgICAgICAgIGJ1ZmZlcnM6IFtdXG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gQSBsaXN0IG9mIEJ1ZmZlckRlZiBvYmplY3RzIHRvIHJlc29sdmUuXG4gICAgICAgIGJ1ZmZlckRlZnM6IFtdLFxuXG4gICAgICAgIGV2ZW50czoge1xuICAgICAgICAgICAgYWZ0ZXJCdWZmZXJzTG9hZGVkOiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgbGlzdGVuZXJzOiB7XG4gICAgICAgICAgICBvbkNyZWF0ZToge1xuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcImZsb2NrLmJ1ZmZlckxvYWRlci5sb2FkQnVmZmVyc1wiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtcInt0aGF0fS5vcHRpb25zLmJ1ZmZlckRlZnNcIiwgXCJ7dGhhdH0uYnVmZmVyc1wiLCBcInt0aGF0fS5ldmVudHMuYWZ0ZXJCdWZmZXJzTG9hZGVkLmZpcmVcIl1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZmxvY2suYnVmZmVyTG9hZGVyLmlkRnJvbVVSTCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgdmFyIGxhc3RTbGFzaCA9IHVybC5sYXN0SW5kZXhPZihcIi9cIiksXG4gICAgICAgICAgICBpZFN0YXJ0ID0gbGFzdFNsYXNoID4gLTEgPyBsYXN0U2xhc2ggKyAxIDogMCxcbiAgICAgICAgICAgIGV4dCA9IHVybC5sYXN0SW5kZXhPZihcIi5cIiksXG4gICAgICAgICAgICBpZEVuZCA9IGV4dCA+IC0xID8gZXh0IDogdXJsLmxlbmd0aDtcblxuICAgICAgICByZXR1cm4gdXJsLnN1YnN0cmluZyhpZFN0YXJ0LCBpZEVuZCk7XG4gICAgfTtcblxuICAgIGZsb2NrLmJ1ZmZlckxvYWRlci5pZHNGcm9tVVJMcyA9IGZ1bmN0aW9uICh1cmxzKSB7XG4gICAgICAgIHJldHVybiBmbHVpZC50cmFuc2Zvcm0odXJscywgZmxvY2suYnVmZmVyTG9hZGVyLmlkRnJvbVVSTCk7XG4gICAgfTtcblxuICAgIGZsb2NrLmJ1ZmZlckxvYWRlci5leHBhbmRGaWxlU2VxdWVuY2UgPSBmdW5jdGlvbiAoZmlsZVVSTHMpIHtcbiAgICAgICAgZmlsZVVSTHMgPSBmaWxlVVJMcyB8fCBbXTtcblxuICAgICAgICB2YXIgYnVmRGVmcyA9IFtdLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgIGlkO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBmaWxlVVJMcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdXJsID0gZmlsZVVSTHNbaV07XG4gICAgICAgICAgICBpZCA9IGZsb2NrLmJ1ZmZlckxvYWRlci5pZEZyb21VUkwodXJsKTtcbiAgICAgICAgICAgIGJ1ZkRlZnMucHVzaCh7XG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIHVybDogdXJsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBidWZEZWZzO1xuICAgIH07XG5cbiAgICBmbG9jay5idWZmZXJMb2FkZXIubG9hZEJ1ZmZlcnMgPSBmdW5jdGlvbiAoYnVmZmVyRGVmcywgZGVjb2RlZEJ1ZmZlcnMsIGFmdGVyQnVmZmVyc0xvYWRlZCkge1xuICAgICAgICBidWZmZXJEZWZzID0gZmx1aWQubWFrZUFycmF5KGJ1ZmZlckRlZnMpO1xuXG4gICAgICAgIC8vIFRPRE86IFRoaXMgaXMgYSBzaWduIHRoYXQgZmxvY2sucGFyc2UuYnVmZmVyRm9yRGVmIGlzIHN0aWxsIHRlcnJpYmx5IGJyb2tlbi5cbiAgICAgICAgdmFyIGJ1ZmZlclRhcmdldCA9IHtcbiAgICAgICAgICAgIHNldEJ1ZmZlcjogZnVuY3Rpb24gKGRlY29kZWQpIHtcbiAgICAgICAgICAgICAgICBkZWNvZGVkQnVmZmVycy5wdXNoKGRlY29kZWQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRlY29kZWRCdWZmZXJzLmxlbmd0aCA9PT0gYnVmZmVyRGVmcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXJCdWZmZXJzTG9hZGVkKGRlY29kZWRCdWZmZXJzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXJEZWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYnVmRGVmID0gYnVmZmVyRGVmc1tpXTtcbiAgICAgICAgICAgIGlmIChidWZEZWYuaWQgPT09IHVuZGVmaW5lZCAmJiBidWZEZWYudXJsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBidWZEZWYuaWQgPSBmbG9jay5idWZmZXJMb2FkZXIuaWRGcm9tVVJMKGJ1ZkRlZi51cmwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUT0RPOiBIYXJkY29kZWQgcmVmZXJlbmNlIHRvIHRoZSBzaGFyZWQgZW52aXJvbm1lbnQuXG4gICAgICAgICAgICBmbG9jay5wYXJzZS5idWZmZXJGb3JEZWYoYnVmZmVyRGVmc1tpXSwgYnVmZmVyVGFyZ2V0LCBmbG9jay5lbnZpcm8uc2hhcmVkKTtcbiAgICAgICAgfVxuICAgIH07XG5cbn0oKSk7XG47LypcbiogRmxvY2tpbmcgUGFyc2VyXG4qIGh0dHA6Ly9naXRodWIuY29tL2NvbGluYmRjbGFyay9mbG9ja2luZ1xuKlxuKiBDb3B5cmlnaHQgMjAxMS0yMDE0LCBDb2xpbiBDbGFya1xuKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgYW5kIEdQTCBWZXJzaW9uIDIgbGljZW5zZXMuXG4qL1xuXG4vKmdsb2JhbCByZXF1aXJlLCBGbG9hdDMyQXJyYXkqL1xuLypqc2hpbnQgd2hpdGU6IGZhbHNlLCBuZXdjYXA6IHRydWUsIHJlZ2V4cDogdHJ1ZSwgYnJvd3NlcjogdHJ1ZSxcbiAgICBmb3JpbjogZmFsc2UsIG5vbWVuOiB0cnVlLCBiaXR3aXNlOiBmYWxzZSwgbWF4ZXJyOiAxMDAsXG4gICAgaW5kZW50OiA0LCBwbHVzcGx1czogZmFsc2UsIGN1cmx5OiB0cnVlLCBlcWVxZXE6IHRydWUsXG4gICAgZnJlZXplOiB0cnVlLCBsYXRlZGVmOiB0cnVlLCBub2FyZzogdHJ1ZSwgbm9uZXc6IHRydWUsIHF1b3RtYXJrOiBkb3VibGUsIHVuZGVmOiB0cnVlLFxuICAgIHVudXNlZDogdHJ1ZSwgc3RyaWN0OiB0cnVlLCBhc2k6IGZhbHNlLCBib3NzOiBmYWxzZSwgZXZpbDogZmFsc2UsIGV4cHI6IGZhbHNlLFxuICAgIGZ1bmNzY29wZTogZmFsc2UqL1xuXG52YXIgZmx1aWQgPSBmbHVpZCB8fCByZXF1aXJlKFwiaW5mdXNpb25cIiksXG4gICAgZmxvY2sgPSBmbHVpZC5yZWdpc3Rlck5hbWVzcGFjZShcImZsb2NrXCIpO1xuXG4oZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyICQgPSBmbHVpZC5yZWdpc3Rlck5hbWVzcGFjZShcImpRdWVyeVwiKTtcbiAgICBmbHVpZC5yZWdpc3Rlck5hbWVzcGFjZShcImZsb2NrLnBhcnNlXCIpO1xuXG4gICAgZmxvY2sucGFyc2Uuc3ludGhEZWYgPSBmdW5jdGlvbiAodWdlbkRlZiwgb3B0aW9ucykge1xuICAgICAgICBpZiAoIXVnZW5EZWYpIHtcbiAgICAgICAgICAgIHVnZW5EZWYgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZmxvY2sucGFyc2Uuc3ludGhEZWYuaGFzT3V0VUdlbih1Z2VuRGVmKSkge1xuICAgICAgICAgICAgLy8gV2UgZGlkbid0IGdldCBhbiBvdXQgdWdlbiBzcGVjaWZpZWQsIHNvIHdlIG5lZWQgdG8gbWFrZSBvbmUuXG4gICAgICAgICAgICB1Z2VuRGVmID0ge1xuICAgICAgICAgICAgICAgIGlkOiBmbG9jay5PVVRfVUdFTl9JRCxcbiAgICAgICAgICAgICAgICB1Z2VuOiBcImZsb2NrLnVnZW4udmFsdWVPdXRcIixcbiAgICAgICAgICAgICAgICBpbnB1dHM6IHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlczogdWdlbkRlZlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnJhdGUgPT09IGZsb2NrLnJhdGVzLkFVRElPKSB7XG4gICAgICAgICAgICAgICAgdWdlbkRlZi51Z2VuID0gXCJmbG9jay51Z2VuLm91dFwiO1xuICAgICAgICAgICAgICAgIHVnZW5EZWYuaW5wdXRzLmJ1cyA9IDA7XG4gICAgICAgICAgICAgICAgdWdlbkRlZi5pbnB1dHMuZXhwYW5kID0gb3B0aW9ucy5hdWRpb1NldHRpbmdzLmNoYW5zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZsb2NrLnBhcnNlLnVnZW5Gb3JEZWYodWdlbkRlZiwgb3B0aW9ucyk7XG4gICAgfTtcblxuICAgIGZsb2NrLnBhcnNlLnN5bnRoRGVmLmhhc091dFVHZW4gPSBmdW5jdGlvbiAoc3ludGhEZWYpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBpcyBob3N0aWxlIHRvIHRoaXJkLXBhcnR5IGV4dGVuc2lvbi5cbiAgICAgICAgcmV0dXJuICFmbG9jay5pc0l0ZXJhYmxlKHN5bnRoRGVmKSAmJiAoXG4gICAgICAgICAgICBzeW50aERlZi5pZCA9PT0gZmxvY2suT1VUX1VHRU5fSUQgfHxcbiAgICAgICAgICAgIHN5bnRoRGVmLnVnZW4gPT09IFwiZmxvY2sudWdlbi5vdXRcIiB8fFxuICAgICAgICAgICAgc3ludGhEZWYudWdlbiA9PT0gXCJmbG9jay51Z2VuLnZhbHVlT3V0XCJcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgZmxvY2sucGFyc2UubWFrZVVHZW4gPSBmdW5jdGlvbiAodWdlbkRlZiwgcGFyc2VkSW5wdXRzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciByYXRlcyA9IG9wdGlvbnMuYXVkaW9TZXR0aW5ncy5yYXRlcyxcbiAgICAgICAgICAgIGJsb2NrU2l6ZSA9IG9wdGlvbnMuYXVkaW9TZXR0aW5ncy5ibG9ja1NpemU7XG5cbiAgICAgICAgLy8gQXNzdW1lIGF1ZGlvIHJhdGUgaWYgbm8gcmF0ZSB3YXMgc3BlY2lmaWVkIGJ5IHRoZSB1c2VyLlxuICAgICAgICBpZiAoIXVnZW5EZWYucmF0ZSkge1xuICAgICAgICAgICAgdWdlbkRlZi5yYXRlID0gZmxvY2sucmF0ZXMuQVVESU87XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2FtcGxlUmF0ZTtcbiAgICAgICAgLy8gU2V0IHRoZSB1Z2VuJ3Mgc2FtcGxlIHJhdGUgdmFsdWUgYWNjb3JkaW5nIHRvIHRoZSByYXRlIHRoZSB1c2VyIHNwZWNpZmllZC5cbiAgICAgICAgaWYgKHVnZW5EZWYub3B0aW9ucyAmJiB1Z2VuRGVmLm9wdGlvbnMuc2FtcGxlUmF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzYW1wbGVSYXRlID0gdWdlbkRlZi5vcHRpb25zLnNhbXBsZVJhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzYW1wbGVSYXRlID0gcmF0ZXNbdWdlbkRlZi5yYXRlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IEluZnVzaW9uIG9wdGlvbnMgbWVyZ2luZyFcbiAgICAgICAgdWdlbkRlZi5vcHRpb25zID0gJC5leHRlbmQodHJ1ZSwge30sIHVnZW5EZWYub3B0aW9ucywge1xuICAgICAgICAgICAgc2FtcGxlUmF0ZTogc2FtcGxlUmF0ZSxcbiAgICAgICAgICAgIHJhdGU6IHVnZW5EZWYucmF0ZSxcbiAgICAgICAgICAgIGF1ZGlvU2V0dGluZ3M6IHtcbiAgICAgICAgICAgICAgICByYXRlczogcmF0ZXMsXG4gICAgICAgICAgICAgICAgYmxvY2tTaXplOiBibG9ja1NpemVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRPRE86IFdoZW4gd2Ugc3dpdGNoIHRvIEluZnVzaW9uIG9wdGlvbnMgbWVyZ2luZywgdGhlc2Ugc2hvdWxkIGhhdmUgYSBtZXJnZVBvbGljeSBvZiBwcmVzZXJ2ZS5cbiAgICAgICAgdWdlbkRlZi5vcHRpb25zLmF1ZGlvU2V0dGluZ3MuYnVmZmVycyA9IG9wdGlvbnMuYnVmZmVycztcbiAgICAgICAgdWdlbkRlZi5vcHRpb25zLmF1ZGlvU2V0dGluZ3MuYnVzZXMgPSBvcHRpb25zLmJ1c2VzO1xuXG4gICAgICAgIHZhciBvdXRwdXRCdWZmZXJTaXplID0gdWdlbkRlZi5yYXRlID09PSBmbG9jay5yYXRlcy5BVURJTyA/IGJsb2NrU2l6ZSA6IDEsXG4gICAgICAgICAgICBvdXRwdXRCdWZmZXJzO1xuXG4gICAgICAgIGlmIChmbG9jay5oYXNUYWcodWdlbkRlZi5vcHRpb25zLCBcImZsb2NrLnVnZW4ubXVsdGlDaGFubmVsT3V0cHV0XCIpKSB7XG4gICAgICAgICAgICB2YXIgbnVtT3V0cHV0cyA9IHVnZW5EZWYub3B0aW9ucy5udW1PdXRwdXRzIHx8IDE7XG4gICAgICAgICAgICBvdXRwdXRCdWZmZXJzID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtT3V0cHV0czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0QnVmZmVycy5wdXNoKG5ldyBGbG9hdDMyQXJyYXkob3V0cHV0QnVmZmVyU2l6ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0QnVmZmVycyA9IG5ldyBGbG9hdDMyQXJyYXkob3V0cHV0QnVmZmVyU2l6ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmxvY2suaW52b2tlKHVuZGVmaW5lZCwgdWdlbkRlZi51Z2VuLCBbXG4gICAgICAgICAgICBwYXJzZWRJbnB1dHMsXG4gICAgICAgICAgICBvdXRwdXRCdWZmZXJzLFxuICAgICAgICAgICAgdWdlbkRlZi5vcHRpb25zXG4gICAgICAgIF0pO1xuICAgIH07XG5cblxuICAgIGZsb2NrLnBhcnNlLnJlc2VydmVkV29yZHMgPSBbXCJpZFwiLCBcInVnZW5cIiwgXCJyYXRlXCIsIFwiaW5wdXRzXCIsIFwib3B0aW9uc1wiXTtcbiAgICBmbG9jay5wYXJzZS5zcGVjaWFsSW5wdXRzID0gW1widmFsdWVcIiwgXCJidWZmZXJcIiwgXCJsaXN0XCIsIFwidGFibGVcIiwgXCJlbnZlbG9wZVwiXTtcblxuICAgIGZsb2NrLnBhcnNlLmV4cGFuZFVHZW5EZWYgPSBmdW5jdGlvbiAodWdlbkRlZikge1xuICAgICAgICB2YXIgaW5wdXRzID0ge30sXG4gICAgICAgICAgICBwcm9wO1xuXG4gICAgICAgIC8vIENvcHkgYW55IG5vbi1yZXNlcnZlZCBwcm9wZXJ0aWVzIGZyb20gdGhlIHRvcC1sZXZlbCB1Z2VuRGVmIG9iamVjdCBpbnRvIHRoZSBpbnB1dHMgcHJvcGVydHkuXG4gICAgICAgIGZvciAocHJvcCBpbiB1Z2VuRGVmKSB7XG4gICAgICAgICAgICBpZiAoZmxvY2sucGFyc2UucmVzZXJ2ZWRXb3Jkcy5pbmRleE9mKHByb3ApID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGlucHV0c1twcm9wXSA9IHVnZW5EZWZbcHJvcF07XG4gICAgICAgICAgICAgICAgZGVsZXRlIHVnZW5EZWZbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdWdlbkRlZi5pbnB1dHMgPSBpbnB1dHM7XG5cbiAgICAgICAgcmV0dXJuIHVnZW5EZWY7XG4gICAgfTtcblxuICAgIGZsb2NrLnBhcnNlLnVnZW5EZWZGb3JDb25zdGFudFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1Z2VuOiBcImZsb2NrLnVnZW4udmFsdWVcIixcbiAgICAgICAgICAgIHJhdGU6IGZsb2NrLnJhdGVzLkNPTlNUQU5ULFxuICAgICAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIGZsb2NrLnBhcnNlLmV4cGFuZFZhbHVlRGVmID0gZnVuY3Rpb24gKHVnZW5EZWYpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgKHVnZW5EZWYpO1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuIGZsb2NrLnBhcnNlLnVnZW5EZWZGb3JDb25zdGFudFZhbHVlKHVnZW5EZWYpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHJldHVybiB1Z2VuRGVmO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB2YWx1ZSB0eXBlIGZvdW5kIGluIHVnZW4gZGVmaW5pdGlvbi4gVUdlbkRlZiB3YXM6IFwiICtcbiAgICAgICAgICAgIGZsdWlkLnByZXR0eVByaW50SlNPTih1Z2VuRGVmKSk7XG4gICAgfTtcblxuICAgIGZsb2NrLnBhcnNlLnJhdGVNYXAgPSB7XG4gICAgICAgIFwiYXJcIjogZmxvY2sucmF0ZXMuQVVESU8sXG4gICAgICAgIFwia3JcIjogZmxvY2sucmF0ZXMuQ09OVFJPTCxcbiAgICAgICAgXCJzclwiOiBmbG9jay5yYXRlcy5TQ0hFRFVMRUQsXG4gICAgICAgIFwiZHJcIjogZmxvY2sucmF0ZXMuREVNQU5ELFxuICAgICAgICBcImNyXCI6IGZsb2NrLnJhdGVzLkNPTlNUQU5UXG4gICAgfTtcblxuICAgIGZsb2NrLnBhcnNlLmV4cGFuZFJhdGUgPSBmdW5jdGlvbiAodWdlbkRlZiwgb3B0aW9ucykge1xuICAgICAgICB1Z2VuRGVmLnJhdGUgPSBmbG9jay5wYXJzZS5yYXRlTWFwW3VnZW5EZWYucmF0ZV0gfHwgdWdlbkRlZi5yYXRlO1xuICAgICAgICBpZiAob3B0aW9ucy5vdmVycmlkZVJhdGUgJiYgdWdlbkRlZi5yYXRlICE9PSBmbG9jay5yYXRlcy5DT05TVEFOVCkge1xuICAgICAgICAgICAgdWdlbkRlZi5yYXRlID0gb3B0aW9ucy5yYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVnZW5EZWY7XG4gICAgfTtcblxuICAgIGZsb2NrLnBhcnNlLnVnZW5EZWYgPSBmdW5jdGlvbiAodWdlbkRlZnMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHBhcnNlRm4gPSBmbG9jay5pc0l0ZXJhYmxlKHVnZW5EZWZzKSA/IGZsb2NrLnBhcnNlLnVnZW5zRm9yRGVmcyA6IGZsb2NrLnBhcnNlLnVnZW5Gb3JEZWY7XG4gICAgICAgIHZhciBwYXJzZWQgPSBwYXJzZUZuKHVnZW5EZWZzLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9O1xuXG4gICAgZmxvY2sucGFyc2UudWdlbkRlZi5tZXJnZU9wdGlvbnMgPSBmdW5jdGlvbiAodWdlbkRlZikge1xuICAgICAgICAvLyBUT0RPOiBJbmZ1c2lvbiBvcHRpb25zIG1lcmdpbmcuXG4gICAgICAgIHZhciBkZWZhdWx0cyA9IGZsdWlkLmRlZmF1bHRzKHVnZW5EZWYudWdlbikgfHwge307XG5cbiAgICAgICAgLy8gVE9ETzogSW5zYW5lIVxuICAgICAgICBkZWZhdWx0cyA9IGZsdWlkLmNvcHkoZGVmYXVsdHMpO1xuICAgICAgICBkZWZhdWx0cy5vcHRpb25zID0gZGVmYXVsdHMudWdlbk9wdGlvbnM7XG4gICAgICAgIGRlbGV0ZSBkZWZhdWx0cy51Z2VuT3B0aW9ucztcbiAgICAgICAgLy9cblxuICAgICAgICByZXR1cm4gJC5leHRlbmQodHJ1ZSwge30sIGRlZmF1bHRzLCB1Z2VuRGVmKTtcbiAgICB9O1xuXG4gICAgZmxvY2sucGFyc2UudWdlbnNGb3JEZWZzID0gZnVuY3Rpb24gKHVnZW5EZWZzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBwYXJzZWQgPSBbXSxcbiAgICAgICAgICAgIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB1Z2VuRGVmcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcGFyc2VkW2ldID0gZmxvY2sucGFyc2UudWdlbkZvckRlZih1Z2VuRGVmc1tpXSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHVuaXQgZ2VuZXJhdG9yIGZvciB0aGUgc3BlY2lmaWVkIHVuaXQgZ2VuZXJhdG9yIGRlZmluaXRpb24gc3BlYy5cbiAgICAgKlxuICAgICAqIHVnZW5EZWZzIGFyZSBwbGFpbiBvbGQgSlNPTiBvYmplY3RzIGRlc2NyaWJpbmcgdGhlIGNoYXJhY3RlcmlzdGljcyBvZiB0aGUgZGVzaXJlZCB1bml0IGdlbmVyYXRvciwgaW5jbHVkaW5nOlxuICAgICAqICAgICAgLSB1Z2VuOiB0aGUgdHlwZSBvZiB1bml0IGdlbmVyYXRvciwgYXMgc3RyaW5nIChlLmcuIFwiZmxvY2sudWdlbi5zaW5Pc2NcIilcbiAgICAgKiAgICAgIC0gcmF0ZTogdGhlIHJhdGUgYXQgd2hpY2ggdGhlIHVnZW4gc2hvdWxkIGJlIHJ1biwgZWl0aGVyIFwiYXVkaW9cIiwgXCJjb250cm9sXCIsIG9yIFwiY29uc3RhbnRcIlxuICAgICAqICAgICAgLSBpZDogYW4gb3B0aW9uYWwgdW5pcXVlIG5hbWUgZm9yIHRoZSB1bml0IGdlbmVyYXRvciwgd2hpY2ggd2lsbCBtYWtlIGl0IGF2YWlsYWJsZSBhcyBhIHN5bnRoIGlucHV0XG4gICAgICogICAgICAtIGlucHV0czogYSBKU09OIG9iamVjdCBjb250YWluaW5nIG5hbWVkIGtleS92YWx1ZSBwYWlycyBmb3IgaW5wdXRzIHRvIHRoZSB1bml0IGdlbmVyYXRvclxuICAgICAqICAgICAgICAgICBPUlxuICAgICAqICAgICAgLSBpbnB1dHMga2V5ZWQgYnkgbmFtZSBhdCB0aGUgdG9wIGxldmVsIG9mIHRoZSB1Z2VuRGVmXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1VHZW5EZWZ9IHVnZW5EZWYgdGhlIHVuaXQgZ2VuZXJhdG9yIGRlZmluaXRpb24gdG8gcGFyc2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBhbiBvcHRpb25zIG9iamVjdCBjb250YWluaW5nOlxuICAgICAqICAgICAgICAgICB7T2JqZWN0fSBhdWRpb1NldHRpbmdzIHRoZSBlbnZpcm9ubWVudCdzIGF1ZGlvIHNldHRpbmdzXG4gICAgICogICAgICAgICAgIHtBcnJheX0gYnVzZXMgdGhlIGVudmlyb25tZW50J3MgZ2xvYmFsIGJ1c2VzXG4gICAgICogICAgICAgICAgIHtBcnJheX0gYnVmZmVycyB0aGUgZW52aXJvbm1lbnQncyBnbG9iYWwgYnVmZmVyc1xuICAgICAqICAgICAgICAgICB7QXJyYXkgb2YgRnVuY3Rpb25zfSB2aXNpdG9ycyBhbiBvcHRpb25hbCBsaXN0IG9mIHZpc2l0b3IgZnVuY3Rpb25zIHRvIGludm9rZSB3aGVuIHRoZSB1Z2VuIGhhcyBiZWVuIGNyZWF0ZWRcbiAgICAgKiBAcmV0dXJuIHRoZSBwYXJzZWQgdW5pdCBnZW5lcmF0b3Igb2JqZWN0XG4gICAgICovXG4gICAgZmxvY2sucGFyc2UudWdlbkZvckRlZiA9IGZ1bmN0aW9uICh1Z2VuRGVmLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSAkLmV4dGVuZCh0cnVlLCB7XG4gICAgICAgICAgICBhdWRpb1NldHRpbmdzOiBmbG9jay5lbnZpcm8uc2hhcmVkLm9wdGlvbnMuYXVkaW9TZXR0aW5ncyxcbiAgICAgICAgICAgIGJ1c2VzOiBmbG9jay5lbnZpcm8uc2hhcmVkLmJ1c2VzLFxuICAgICAgICAgICAgYnVmZmVyczogZmxvY2suZW52aXJvLnNoYXJlZC5idWZmZXJzXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgICAgIHZhciBvID0gb3B0aW9ucyxcbiAgICAgICAgICAgIHZpc2l0b3JzID0gby52aXNpdG9ycyxcbiAgICAgICAgICAgIHJhdGVzID0gby5hdWRpb1NldHRpbmdzLnJhdGVzO1xuXG4gICAgICAgIC8vIElmIHdlIHJlY2VpdmUgYSBwbGFpbiBzY2FsYXIgdmFsdWUsIGV4cGFuZCBpdCBpbnRvIGEgdmFsdWUgdWdlbkRlZi5cbiAgICAgICAgdWdlbkRlZiA9IGZsb2NrLnBhcnNlLmV4cGFuZFZhbHVlRGVmKHVnZW5EZWYpO1xuXG4gICAgICAgIC8vIFdlIHJlY2VpdmVkIGFuIGFycmF5IG9mIHVnZW4gZGVmcy5cbiAgICAgICAgaWYgKGZsb2NrLmlzSXRlcmFibGUodWdlbkRlZikpIHtcbiAgICAgICAgICAgIHJldHVybiBmbG9jay5wYXJzZS51Z2Vuc0ZvckRlZnModWdlbkRlZiwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXVnZW5EZWYuaW5wdXRzKSB7XG4gICAgICAgICAgICB1Z2VuRGVmID0gZmxvY2sucGFyc2UuZXhwYW5kVUdlbkRlZih1Z2VuRGVmKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZsb2NrLnBhcnNlLmV4cGFuZFJhdGUodWdlbkRlZiwgb3B0aW9ucyk7XG4gICAgICAgIHVnZW5EZWYgPSBmbG9jay5wYXJzZS51Z2VuRGVmLm1lcmdlT3B0aW9ucyh1Z2VuRGVmLCBvcHRpb25zKTtcblxuICAgICAgICB2YXIgaW5wdXREZWZzID0gdWdlbkRlZi5pbnB1dHMsXG4gICAgICAgICAgICBpbnB1dHMgPSB7fSxcbiAgICAgICAgICAgIGlucHV0RGVmO1xuXG4gICAgICAgIC8vIFRPRE86IFRoaXMgbm90aW9uIG9mIFwic3BlY2lhbCBpbnB1dHNcIiBzaG91bGQgYmUgcmVmYWN0b3JlZCBhcyBhIHBsdWdnYWJsZSBzeXN0ZW0gb2ZcbiAgICAgICAgLy8gXCJpbnB1dCBleHBhbmRlcnNcIiB0aGF0IGFyZSByZXNwb25zaWJsZSBmb3IgcHJvY2Vzc2luZyBpbnB1dCBkZWZpbml0aW9ucyBvZiB2YXJpb3VzIHNvcnRzLlxuICAgICAgICAvLyBJbiBwYXJ0aWN1bGFyLCBidWZmZXIgbWFuYWdlbWVudCBzaG91bGQgYmUgaGVyZSBzbyB0aGF0IHdlIGNhbiBpbml0aWFsaXplIGJ1ZmZlckRlZnMgbW9yZVxuICAgICAgICAvLyBwcm9hY3RpdmVseSBhbmQgcmVtb3ZlIHRoaXMgYmVoYXZpb3VyIGZyb20gZmxvY2sudWdlbi5idWZmZXIuXG4gICAgICAgIGZvciAoaW5wdXREZWYgaW4gaW5wdXREZWZzKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXREZWZWYWwgPSBpbnB1dERlZnNbaW5wdXREZWZdO1xuXG4gICAgICAgICAgICBpZiAoaW5wdXREZWZWYWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gU2tpcCBudWxsIGlucHV0cy5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ3JlYXRlIHVnZW5zIGZvciBhbGwgaW5wdXRzIGV4Y2VwdCBzcGVjaWFsIGlucHV0cy5cbiAgICAgICAgICAgIGlucHV0c1tpbnB1dERlZl0gPSBmbG9jay5pbnB1dC5zaG91bGRFeHBhbmQoaW5wdXREZWYsIHVnZW5EZWYpID9cbiAgICAgICAgICAgICAgICBmbG9jay5wYXJzZS51Z2VuRm9yRGVmKGlucHV0RGVmVmFsLCBvcHRpb25zKSA6IC8vIFBhcnNlIHRoZSB1Z2VuZGVmIGFuZCBjcmVhdGUgYSB1Z2VuIGluc3RhbmNlLlxuICAgICAgICAgICAgICAgIGlucHV0RGVmVmFsOyAvLyBEb24ndCBpbnN0YW50aWF0ZSBhIHVnZW4sIGp1c3QgcGFzcyB0aGUgZGVmIG9uIGFzLWlzLlxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF1Z2VuRGVmLnVnZW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuaXQgZ2VuZXJhdG9yIGRlZmluaXRpb24gbGFja3MgYSAndWdlbicgcHJvcGVydHk7IFwiICtcbiAgICAgICAgICAgICAgICBcImNhbid0IGluaXRpYWxpemUgdGhlIHN5bnRoIGdyYXBoLiBWYWx1ZTogXCIgKyBmbHVpZC5wcmV0dHlQcmludEpTT04odWdlbkRlZikpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHVnZW4gPSBmbG9jay5wYXJzZS5tYWtlVUdlbih1Z2VuRGVmLCBpbnB1dHMsIG9wdGlvbnMpO1xuICAgICAgICBpZiAodWdlbkRlZi5pZCkge1xuICAgICAgICAgICAgdWdlbi5pZCA9IHVnZW5EZWYuaWQ7XG4gICAgICAgICAgICB1Z2VuLm5pY2tOYW1lID0gdWdlbkRlZi5pZDsgLy8gVE9ETzogTm9ybWFsaXplIG5pY2tuYW1lcyBhbmQgaWRzLlxuICAgICAgICB9XG5cbiAgICAgICAgdWdlbi5vcHRpb25zLnVnZW5EZWYgPSB1Z2VuRGVmO1xuXG4gICAgICAgIGlmICh2aXNpdG9ycykge1xuICAgICAgICAgICAgdmlzaXRvcnMgPSBmbHVpZC5tYWtlQXJyYXkodmlzaXRvcnMpO1xuICAgICAgICAgICAgZmx1aWQuZWFjaCh2aXNpdG9ycywgZnVuY3Rpb24gKHZpc2l0b3IpIHtcbiAgICAgICAgICAgICAgICB2aXNpdG9yKHVnZW4sIHVnZW5EZWYsIHJhdGVzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVnZW47XG4gICAgfTtcblxuICAgIGZsb2NrLnBhcnNlLmV4cGFuZEJ1ZmZlckRlZiA9IGZ1bmN0aW9uIChidWZEZWYpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBidWZEZWYgPT09IFwic3RyaW5nXCIgPyB7aWQ6IGJ1ZkRlZn0gOlxuICAgICAgICAgICAgKGZsb2NrLmlzSXRlcmFibGUoYnVmRGVmKSB8fCBidWZEZWYuZGF0YSB8fCBidWZEZWYuZm9ybWF0KSA/XG4gICAgICAgICAgICBmbG9jay5idWZmZXJEZXNjKGJ1ZkRlZikgOiBidWZEZWY7XG4gICAgfTtcblxuICAgIGZsb2NrLnBhcnNlLmJ1ZmZlckZvckRlZiA9IGZ1bmN0aW9uIChidWZEZWYsIHVnZW4sIGVudmlybykge1xuICAgICAgICBidWZEZWYgPSBmbG9jay5wYXJzZS5leHBhbmRCdWZmZXJEZWYoYnVmRGVmKTtcblxuICAgICAgICBpZiAoYnVmRGVmLmRhdGEgJiYgYnVmRGVmLmRhdGEuY2hhbm5lbHMpIHtcbiAgICAgICAgICAgIGJ1ZkRlZiA9IGZsb2NrLmJ1ZmZlckRlc2MoYnVmRGVmKTtcbiAgICAgICAgICAgIGZsb2NrLnBhcnNlLmJ1ZmZlckZvckRlZi5yZXNvbHZlQnVmZmVyKGJ1ZkRlZiwgdWdlbiwgZW52aXJvKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZsb2NrLnBhcnNlLmJ1ZmZlckZvckRlZi5yZXNvbHZlRGVmKGJ1ZkRlZiwgdWdlbiwgZW52aXJvKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmbG9jay5wYXJzZS5idWZmZXJGb3JEZWYuZmluZFNvdXJjZSA9IGZ1bmN0aW9uIChkZWZPckRlc2MsIGVudmlybykge1xuICAgICAgICB2YXIgc291cmNlO1xuXG4gICAgICAgIGlmIChlbnZpcm8gJiYgZGVmT3JEZXNjLmlkKSB7XG4gICAgICAgICAgICBzb3VyY2UgPSBlbnZpcm8uYnVmZmVyU291cmNlc1tkZWZPckRlc2MuaWRdO1xuICAgICAgICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSBlbnZpcm8uYnVmZmVyU291cmNlc1tkZWZPckRlc2MuaWRdID0gZmxvY2suYnVmZmVyU291cmNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzb3VyY2UgPSBmbG9jay5idWZmZXJTb3VyY2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfTtcblxuICAgIGZsb2NrLnBhcnNlLmJ1ZmZlckZvckRlZi5iaW5kVG9Qcm9taXNlID0gZnVuY3Rpb24gKHAsIHNvdXJjZSwgdWdlbikge1xuICAgICAgICAvLyBUT0RPOiByZWZhY3RvciB0aGlzLlxuICAgICAgICB2YXIgc3VjY2VzcyA9IGZ1bmN0aW9uIChidWZEZXNjKSB7XG4gICAgICAgICAgICBzb3VyY2UuZXZlbnRzLm9uQnVmZmVyVXBkYXRlZC5hZGRMaXN0ZW5lcihzdWNjZXNzKTtcbiAgICAgICAgICAgIGlmICh1Z2VuKSB7XG4gICAgICAgICAgICAgICAgdWdlbi5zZXRCdWZmZXIoYnVmRGVzYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGVycm9yID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICAgICAgaWYgKCFtc2cgJiYgc291cmNlLm1vZGVsLnNyYyAmJiBzb3VyY2UubW9kZWwuc3JjLmluZGV4T2YoXCIuYWlmXCIpKSB7XG4gICAgICAgICAgICAgICAgbXNnID0gXCJpZiB0aGlzIGlzIGFuIEFJRkYgZmlsZSwgeW91IG1pZ2h0IG5lZWQgdG8gaW5jbHVkZVwiICtcbiAgICAgICAgICAgICAgICBcIiBmbG9ja2luZy1hdWRpb2ZpbGUtY29tcGF0aWJpbGl0eS5qcyBpbiBzb21lIGJyb3dzZXJzLlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3Igd2hpbGUgcmVzb2x2aW5nIGJ1ZmZlciBcIiArIHNvdXJjZS5tb2RlbC5zcmMgKyBcIjogXCIgKyBtc2cpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHAudGhlbihzdWNjZXNzLCBlcnJvcik7XG4gICAgfTtcblxuICAgIGZsb2NrLnBhcnNlLmJ1ZmZlckZvckRlZi5yZXNvbHZlRGVmID0gZnVuY3Rpb24gKGJ1ZkRlZiwgdWdlbiwgZW52aXJvKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBmbG9jay5wYXJzZS5idWZmZXJGb3JEZWYuZmluZFNvdXJjZShidWZEZWYsIGVudmlybyksXG4gICAgICAgICAgICBwO1xuXG4gICAgICAgIGJ1ZkRlZi5zcmMgPSBidWZEZWYudXJsIHx8IGJ1ZkRlZi5zcmM7XG4gICAgICAgIGlmIChidWZEZWYuc2VsZWN0b3IgJiYgdHlwZW9mKGRvY3VtZW50KSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgYnVmRGVmLnNyYyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYnVmRGVmLnNlbGVjdG9yKS5maWxlc1swXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHAgPSBzb3VyY2UuZ2V0KGJ1ZkRlZik7XG4gICAgICAgIGZsb2NrLnBhcnNlLmJ1ZmZlckZvckRlZi5iaW5kVG9Qcm9taXNlKHAsIHNvdXJjZSwgdWdlbik7XG4gICAgfTtcblxuXG4gICAgZmxvY2sucGFyc2UuYnVmZmVyRm9yRGVmLnJlc29sdmVCdWZmZXIgPSBmdW5jdGlvbiAoYnVmRGVzYywgdWdlbiwgZW52aXJvKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBmbG9jay5wYXJzZS5idWZmZXJGb3JEZWYuZmluZFNvdXJjZShidWZEZXNjLCBlbnZpcm8pLFxuICAgICAgICAgICAgcCA9IHNvdXJjZS5zZXQoYnVmRGVzYyk7XG5cbiAgICAgICAgZmxvY2sucGFyc2UuYnVmZmVyRm9yRGVmLmJpbmRUb1Byb21pc2UocCwgc291cmNlLCB1Z2VuKTtcbiAgICB9O1xuXG59KCkpO1xuOy8qXG4gKiBGbG9ja2luZyBBdWRpbyBGaWxlIFV0aWxpdGllc1xuICogaHR0cDovL2dpdGh1Yi5jb20vY29saW5iZGNsYXJrL2Zsb2NraW5nXG4gKlxuICogQ29weXJpZ2h0IDIwMTEtMjAxNCwgQ29saW4gQ2xhcmtcbiAqIER1YWwgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBhbmQgR1BMIFZlcnNpb24gMiBsaWNlbnNlcy5cbiAqL1xuXG4vKmdsb2JhbCByZXF1aXJlLCBBcnJheUJ1ZmZlciwgVWludDhBcnJheSwgRmlsZSwgRmlsZVJlYWRlciAqL1xuLypqc2hpbnQgd2hpdGU6IGZhbHNlLCBuZXdjYXA6IHRydWUsIHJlZ2V4cDogdHJ1ZSwgYnJvd3NlcjogdHJ1ZSxcbmZvcmluOiBmYWxzZSwgbm9tZW46IHRydWUsIGJpdHdpc2U6IGZhbHNlLCBtYXhlcnI6IDEwMCxcbmluZGVudDogNCwgcGx1c3BsdXM6IGZhbHNlLCBjdXJseTogdHJ1ZSwgZXFlcWVxOiB0cnVlLFxuZnJlZXplOiB0cnVlLCBsYXRlZGVmOiB0cnVlLCBub2FyZzogdHJ1ZSwgbm9uZXc6IHRydWUsIHF1b3RtYXJrOiBkb3VibGUsIHVuZGVmOiB0cnVlLFxudW51c2VkOiB0cnVlLCBzdHJpY3Q6IHRydWUsIGFzaTogZmFsc2UsIGJvc3M6IGZhbHNlLCBldmlsOiBmYWxzZSwgZXhwcjogZmFsc2UsXG5mdW5jc2NvcGU6IGZhbHNlKi9cblxudmFyIGZsdWlkID0gZmx1aWQgfHwgcmVxdWlyZShcImluZnVzaW9uXCIpLFxuICAgIGZsb2NrID0gZmx1aWQucmVnaXN0ZXJOYW1lc3BhY2UoXCJmbG9ja1wiKTtcblxuKGZ1bmN0aW9uICgpIHtcblxuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9uIGluIHRoZSBuZXh0IHJvdW5kIG9mIHRoZSBldmVudCBsb29wLlxuICAgICAqL1xuICAgIC8vIFRPRE86IFJlcGxhY2UgdGhpcyBhbmQgdGhlIGNvZGUgdGhhdCBkZXBlbmRzIG9uIGl0IHdpdGggYSBnb29kIFByb21pc2UgaW1wbGVtZW50YXRpb24uXG4gICAgZmxvY2suYXBwbHlEZWZlcnJlZCA9IGZ1bmN0aW9uIChmbiwgYXJncywgZGVsYXkpIHtcbiAgICAgICAgaWYgKCFmbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVsYXkgPSB0eXBlb2YgKGRlbGF5KSA9PT0gXCJ1bmRlZmluZWRcIiA/IDAgOiBkZWxheTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfSwgZGVsYXkpO1xuICAgIH07XG5cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKipcbiAgICAgKiBOZXR3b3JrIHV0aWxpdGllcyAqXG4gICAgICoqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIGZsdWlkLnJlZ2lzdGVyTmFtZXNwYWNlKFwiZmxvY2submV0XCIpO1xuXG4gICAgLyoqXG4gICAgICogTG9hZHMgYW4gQXJyYXlCdWZmZXIgaW50byBtZW1vcnkgdXNpbmcgWE1MSHR0cFJlcXVlc3QuXG4gICAgICovXG4gICAgZmxvY2submV0LnJlYWRCdWZmZXJGcm9tVXJsID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHNyYyA9IG9wdGlvbnMuc3JjLFxuICAgICAgICAgICAgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgICAgIGlmICh4aHIuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zdWNjZXNzKHhoci5yZXNwb25zZSwgZmxvY2suZmlsZS5wYXJzZUZpbGVFeHRlbnNpb24oc3JjKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoeGhyLnN0YXR1c1RleHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5lcnJvcih4aHIuc3RhdHVzVGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHhoci5vcGVuKG9wdGlvbnMubWV0aG9kIHx8IFwiR0VUXCIsIHNyYywgdHJ1ZSk7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSBvcHRpb25zLnJlc3BvbnNlVHlwZSB8fCBcImFycmF5YnVmZmVyXCI7XG4gICAgICAgIHhoci5zZW5kKG9wdGlvbnMuZGF0YSk7XG4gICAgfTtcblxuXG4gICAgLyoqKioqKioqKioqKioqKioqXG4gICAgICogRmlsZSBVdGlsdGllcyAqXG4gICAgICoqKioqKioqKioqKioqKioqL1xuXG4gICAgZmx1aWQucmVnaXN0ZXJOYW1lc3BhY2UoXCJmbG9jay5maWxlXCIpO1xuXG4gICAgZmxvY2suZmlsZS5taW1lVHlwZXMgPSB7XG4gICAgICAgIFwiYXVkaW8vd2F2XCI6IFwid2F2XCIsXG4gICAgICAgIFwiYXVkaW8veC13YXZcIjogXCJ3YXZcIixcbiAgICAgICAgXCJhdWRpby93YXZlXCI6IFwid2F2XCIsXG4gICAgICAgIFwiYXVkaW8veC1haWZmXCI6IFwiYWlmZlwiLFxuICAgICAgICBcImF1ZGlvL2FpZmZcIjogXCJhaWZmXCIsXG4gICAgICAgIFwic291bmQvYWlmZlwiOiBcImFpZmZcIlxuICAgIH07XG5cbiAgICBmbG9jay5maWxlLnR5cGVBbGlhc2VzID0ge1xuICAgICAgICBcImFpZlwiOiBcImFpZmZcIixcbiAgICAgICAgXCJ3YXZlXCI6IFwid2F2XCJcbiAgICB9O1xuXG4gICAgZmxvY2suZmlsZS5wYXJzZUZpbGVFeHRlbnNpb24gPSBmdW5jdGlvbiAoZmlsZU5hbWUpIHtcbiAgICAgICAgdmFyIGxhc3REb3QgPSBmaWxlTmFtZS5sYXN0SW5kZXhPZihcIi5cIiksXG4gICAgICAgICAgICBleHQsXG4gICAgICAgICAgICBhbGlhcztcblxuICAgICAgICAvLyBUT0RPOiBCZXR0ZXIgZXJyb3IgaGFuZGxpbmcgaW4gY2FzZXMgd2hlcmUgd2UndmUgZ290IHVucmVjb2duaXplZCBmaWxlIGV4dGVuc2lvbnMuXG4gICAgICAgIC8vICAgICAgIGkuZS4gd2Ugc2hvdWxkIHRyeSB0byByZWFkIHRoZSBoZWFkZXIgaW5zdGVhZCBvZiByZWx5aW5nIG9uIGV4dGVuc2lvbnMuXG4gICAgICAgIGlmIChsYXN0RG90IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGV4dCA9IGZpbGVOYW1lLnN1YnN0cmluZyhsYXN0RG90ICsgMSk7XG4gICAgICAgIGV4dCA9IGV4dC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBhbGlhcyA9ICBmbG9jay5maWxlLnR5cGVBbGlhc2VzW2V4dF07XG5cbiAgICAgICAgcmV0dXJuIGFsaWFzIHx8IGV4dDtcbiAgICB9O1xuXG4gICAgZmxvY2suZmlsZS5wYXJzZU1JTUVUeXBlID0gZnVuY3Rpb24gKG1pbWVUeXBlKSB7XG4gICAgICAgIHJldHVybiBmbG9jay5maWxlLm1pbWVUeXBlc1ttaW1lVHlwZV07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgYmluYXJ5IHN0cmluZyB0byBhbiBBcnJheUJ1ZmZlciwgc3VpdGFibGUgZm9yIHVzZSB3aXRoIGEgRGF0YVZpZXcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcyB0aGUgcmF3IHN0cmluZyB0byBjb252ZXJ0IHRvIGFuIEFycmF5QnVmZmVyXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtVaW50OEFycmF5fSB0aGUgY29udmVydGVkIGJ1ZmZlclxuICAgICAqL1xuICAgIGZsb2NrLmZpbGUuc3RyaW5nVG9CdWZmZXIgPSBmdW5jdGlvbiAocykge1xuICAgICAgICB2YXIgbGVuID0gcy5sZW5ndGgsXG4gICAgICAgICAgICBiID0gbmV3IEFycmF5QnVmZmVyKGxlbiksXG4gICAgICAgICAgICB2ID0gbmV3IFVpbnQ4QXJyYXkoYiksXG4gICAgICAgICAgICBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZbaV0gPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHYuYnVmZmVyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBc3luY2hyb25vdXNseSBwYXJzZXMgdGhlIHNwZWNpZmllZCBkYXRhIFVSTCBpbnRvIGFuIEFycmF5QnVmZmVyLlxuICAgICAqL1xuICAgIGZsb2NrLmZpbGUucmVhZEJ1ZmZlckZyb21EYXRhVXJsID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHVybCA9IG9wdGlvbnMuc3JjLFxuICAgICAgICAgICAgZGVsaW0gPSB1cmwuaW5kZXhPZihcIixcIiksXG4gICAgICAgICAgICBoZWFkZXIgPSB1cmwuc3Vic3RyaW5nKDAsIGRlbGltKSxcbiAgICAgICAgICAgIGRhdGEgPSB1cmwuc3Vic3RyaW5nKGRlbGltICsgMSksXG4gICAgICAgICAgICBiYXNlNjRJZHggPSBoZWFkZXIuaW5kZXhPZihcIjtiYXNlNjRcIiksXG4gICAgICAgICAgICBpc0Jhc2U2NCA9ICBiYXNlNjRJZHggPiAtMSxcbiAgICAgICAgICAgIG1pbWVUeXBlU3RhcnRJZHggPSB1cmwuaW5kZXhPZihcImRhdGE6XCIpICsgNSxcbiAgICAgICAgICAgIG1pbWVUeXBlRW5kSWR4ID0gaXNCYXNlNjQgPyBiYXNlNjRJZHggOiBkZWxpbSxcbiAgICAgICAgICAgIG1pbWVUeXBlID0gdXJsLnN1YnN0cmluZyhtaW1lVHlwZVN0YXJ0SWR4LCBtaW1lVHlwZUVuZElkeCk7XG5cbiAgICAgICAgaWYgKGlzQmFzZTY0KSB7XG4gICAgICAgICAgICBkYXRhID0gYXRvYihkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZsb2NrLmFwcGx5RGVmZXJyZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IGZsb2NrLmZpbGUuc3RyaW5nVG9CdWZmZXIoZGF0YSk7XG4gICAgICAgICAgICBvcHRpb25zLnN1Y2Nlc3MoYnVmZmVyLCBmbG9jay5maWxlLnBhcnNlTUlNRVR5cGUobWltZVR5cGUpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFzeW5jaHJvbm91c2x5IHJlYWRzIHRoZSBzcGVjaWZpZWQgRmlsZSBpbnRvIGFuIEFycmF5QnVmZmVyLlxuICAgICAqL1xuICAgIGZsb2NrLmZpbGUucmVhZEJ1ZmZlckZyb21GaWxlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlYWRlciAgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuc3VjY2VzcyhlLnRhcmdldC5yZXN1bHQsIGZsb2NrLmZpbGUucGFyc2VGaWxlRXh0ZW5zaW9uKG9wdGlvbnMuc3JjLm5hbWUpKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKG9wdGlvbnMuc3JjKTtcblxuICAgICAgICByZXR1cm4gcmVhZGVyO1xuICAgIH07XG5cblxuICAgIGZsdWlkLnJlZ2lzdGVyTmFtZXNwYWNlKFwiZmxvY2suYXVkaW9cIik7XG5cbiAgICAvKipcbiAgICAgKiBBc3ljaHJvbm91c2x5IGxvYWRzIGFuIEFycmF5QnVmZmVyIGludG8gbWVtb3J5LlxuICAgICAqXG4gICAgICogT3B0aW9uczpcbiAgICAgKiAgLSBzcmM6IHRoZSBVUkwgdG8gbG9hZCB0aGUgYXJyYXkgYnVmZmVyIGZyb21cbiAgICAgKiAgLSBtZXRob2Q6IHRoZSBIVFRQIG1ldGhvZCB0byB1c2UgKGlmIGFwcGxpY2FibGUpXG4gICAgICogIC0gZGF0YTogdGhlIGRhdGEgdG8gYmUgc2VudCBhcyBwYXJ0IG9mIHRoZSByZXF1ZXN0IChpdCdzIHlvdXIgam9iIHRvIHF1ZXJ5IHN0cmluZy1pemUgdGhpcyBpZiBpdCdzIGFuIEhUVFAgcmVxdWVzdClcbiAgICAgKiAgLSBzdWNjZXNzOiB0aGUgc3VjY2VzcyBjYWxsYmFjaywgd2hpY2ggdGFrZXMgdGhlIEFycmF5QnVmZmVyIHJlc3BvbnNlIGFzIGl0cyBvbmx5IGFyZ3VtZW50XG4gICAgICogIC0gZXJyb3I6IGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGludm9rZWQgaWYgYW4gZXJyb3Igb2NjdXJzLCB3aGljaCB0YWtlcyB0aGUgZXJyb3IgbWVzc2FnZSBhcyBpdHMgb25seSBhcmd1bWVudFxuICAgICAqL1xuICAgIGZsb2NrLmF1ZGlvLmxvYWRCdWZmZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgc3JjID0gb3B0aW9ucy5zcmMgfHwgb3B0aW9ucy51cmw7XG4gICAgICAgIGlmICghc3JjKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3JjIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgIGZsb2NrLmFwcGx5RGVmZXJyZWQob3B0aW9ucy5zdWNjZXNzLCBbc3JjLCBvcHRpb25zLnR5cGVdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWFkZXIgPSBmbG9jay5hdWRpby5sb2FkQnVmZmVyLnJlYWRlckZvclNvdXJjZShzcmMpO1xuXG4gICAgICAgIHJlYWRlcihvcHRpb25zKTtcbiAgICB9O1xuXG4gICAgZmxvY2suYXVkaW8ubG9hZEJ1ZmZlci5yZWFkZXJGb3JTb3VyY2UgPSBmdW5jdGlvbiAoc3JjKSB7XG4gICAgICAgIHJldHVybiAodHlwZW9mIChGaWxlKSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzcmMgaW5zdGFuY2VvZiBGaWxlKSA/IGZsb2NrLmZpbGUucmVhZEJ1ZmZlckZyb21GaWxlIDpcbiAgICAgICAgICAgIHNyYy5pbmRleE9mKFwiZGF0YTpcIikgPT09IDAgPyBmbG9jay5maWxlLnJlYWRCdWZmZXJGcm9tRGF0YVVybCA6IGZsb2NrLm5ldC5yZWFkQnVmZmVyRnJvbVVybDtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhbmQgZGVjb2RlcyBhbiBhdWRpbyBmaWxlLiBCeSBkZWZhdWx0LCB0aGlzIGlzIGRvbmUgYXN5bmNocm9ub3VzbHkgaW4gYSBXZWIgV29ya2VyLlxuICAgICAqIFRoaXMgZGVjb2RlciBjdXJyZW50bHkgc3VwcG9ydHMgV0FWRSBhbmQgQUlGRiBmaWxlIGZvcm1hdHMuXG4gICAgICovXG4gICAgZmxvY2suYXVkaW8uZGVjb2RlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3M7XG5cbiAgICAgICAgdmFyIHdyYXBwZWRTdWNjZXNzID0gZnVuY3Rpb24gKHJhd0RhdGEsIHR5cGUpIHtcbiAgICAgICAgICAgIHZhciBzdHJhdGVnaWVzID0gZmxvY2suYXVkaW8uZGVjb2RlclN0cmF0ZWdpZXMsXG4gICAgICAgICAgICAgICAgc3RyYXRlZ3kgPSBzdHJhdGVnaWVzW3R5cGVdIHx8IHN0cmF0ZWdpZXNbXCJkZWZhdWx0XCJdO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kZWNvZGVyKSB7XG4gICAgICAgICAgICAgICAgc3RyYXRlZ3kgPSB0eXBlb2YgKG9wdGlvbnMuZGVjb2RlcikgPT09IFwic3RyaW5nXCIgP1xuICAgICAgICAgICAgICAgICAgICAgZmx1aWQuZ2V0R2xvYmFsVmFsdWUob3B0aW9ucy5kZWNvZGVyKSA6IG9wdGlvbnMuZGVjb2RlcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RyYXRlZ3koe1xuICAgICAgICAgICAgICAgIHJhd0RhdGE6IHJhd0RhdGEsXG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBzdWNjZXNzLFxuICAgICAgICAgICAgICAgIGVycm9yOiBvcHRpb25zLmVycm9yLFxuICAgICAgICAgICAgICAgIHNhbXBsZVJhdGU6IG9wdGlvbnMuc2FtcGxlUmF0ZSB8fFxuICAgICAgICAgICAgICAgICAgICAoZmxvY2suZW52aXJvLnNoYXJlZCA/IGZsb2NrLmVudmlyby5zaGFyZWQuYXVkaW9TZXR0aW5ncy5yYXRlcy5hdWRpbyA6IHVuZGVmaW5lZClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIG9wdGlvbnMuc3VjY2VzcyA9IHdyYXBwZWRTdWNjZXNzO1xuICAgICAgICBmbG9jay5hdWRpby5sb2FkQnVmZmVyKG9wdGlvbnMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBc3luY2hyb25vdXNseSBkZWNvZGVzIHRoZSBzcGVjaWZpZWQgQXJyYXlCdWZmZXIgcmF3RGF0YSB1c2luZ1xuICAgICAqIHRoZSBicm93c2VyJ3MgV2ViIEF1ZGlvIENvbnRleHQuXG4gICAgICovXG4gICAgZmxvY2suYXVkaW8uZGVjb2RlLndlYkF1ZGlvID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgdmFyIGN0eCA9IGZsb2NrLmVudmlyby5zaGFyZWQuYXVkaW9TdHJhdGVneS5jb250ZXh0LFxuICAgICAgICAgICAgc3VjY2VzcyA9IGZ1bmN0aW9uIChhdWRpb0J1ZmZlcikge1xuICAgICAgICAgICAgICAgIHZhciBidWZEZXNjID0gZmxvY2suYnVmZmVyRGVzYy5mcm9tQXVkaW9CdWZmZXIoYXVkaW9CdWZmZXIpO1xuICAgICAgICAgICAgICAgIG8uc3VjY2VzcyhidWZEZXNjKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgY3R4LmRlY29kZUF1ZGlvRGF0YShvLnJhd0RhdGEsIHN1Y2Nlc3MsIG8uZXJyb3IpO1xuICAgIH07XG5cbiAgICBmbG9jay5hdWRpby5kZWNvZGVyU3RyYXRlZ2llcyA9IHtcbiAgICAgICAgXCJkZWZhdWx0XCI6IGZsb2NrLmF1ZGlvLmRlY29kZS53ZWJBdWRpb1xuICAgIH07XG5cbiAgICBmbG9jay5hdWRpby5yZWdpc3RlckRlY29kZXJTdHJhdGVneSA9IGZ1bmN0aW9uICh0eXBlLCBzdHJhdGVneSkge1xuICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHR5cGUpIHtcbiAgICAgICAgICAgICAgICBmbG9jay5hdWRpby5kZWNvZGVyU3RyYXRlZ2llc1trZXldID0gdHlwZVtrZXldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHN0cmF0ZWd5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBzdHJhdGVneSA9IGZsdWlkLmdldEdsb2JhbFZhbHVlKHN0cmF0ZWd5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZsb2NrLmF1ZGlvLmRlY29kZXJTdHJhdGVnaWVzW3R5cGVdID0gc3RyYXRlZ3k7XG4gICAgfTtcblxufSgpKTtcbjsvKlxuKiBGbG9ja2luZyBTY2hlZHVsZXJcbiogaHR0cDovL2dpdGh1Yi5jb20vY29saW5iZGNsYXJrL2Zsb2NraW5nXG4qXG4qIENvcHlyaWdodCAyMDEzLTIwMTQsIENvbGluIENsYXJrXG4qIER1YWwgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBhbmQgR1BMIFZlcnNpb24gMiBsaWNlbnNlcy5cbiovXG5cbi8qZ2xvYmFsIHJlcXVpcmUsIHNlbGYqL1xuLypqc2hpbnQgd2hpdGU6IGZhbHNlLCBuZXdjYXA6IHRydWUsIHJlZ2V4cDogdHJ1ZSwgYnJvd3NlcjogdHJ1ZSxcbiAgICBmb3JpbjogZmFsc2UsIG5vbWVuOiB0cnVlLCBiaXR3aXNlOiBmYWxzZSwgbWF4ZXJyOiAxMDAsXG4gICAgaW5kZW50OiA0LCBwbHVzcGx1czogZmFsc2UsIGN1cmx5OiB0cnVlLCBlcWVxZXE6IHRydWUsXG4gICAgZnJlZXplOiB0cnVlLCBsYXRlZGVmOiB0cnVlLCBub2FyZzogdHJ1ZSwgbm9uZXc6IHRydWUsIHF1b3RtYXJrOiBkb3VibGUsIHVuZGVmOiB0cnVlLFxuICAgIHVudXNlZDogdHJ1ZSwgc3RyaWN0OiB0cnVlLCBhc2k6IGZhbHNlLCBib3NzOiBmYWxzZSwgZXZpbDogZmFsc2UsIGV4cHI6IGZhbHNlLFxuICAgIGZ1bmNzY29wZTogZmFsc2UqL1xuXG52YXIgZmx1aWQgPSBmbHVpZCB8fCByZXF1aXJlKFwiaW5mdXNpb25cIiksXG4gICAgZmxvY2sgPSBmbHVpZC5yZWdpc3Rlck5hbWVzcGFjZShcImZsb2NrXCIpO1xuXG4oZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy8gVE9ETzogVGhpcyBkdXBsaWNhdGVzIGNvZGUgaW4gZmxvY2tpbmctY29yZSBhbmQgc2hvdWxkIGJlIGZhY3RvcmVkIGRpZmZlcmVudGx5LlxuICAgIGZsb2NrLnNoaW0gPSB7XG4gICAgICAgIFVSTDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTCB8fCB3aW5kb3cubXNVUkwgOiB1bmRlZmluZWRcbiAgICB9O1xuXG4gICAgZmxvY2sud29ya2VyID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgY29kZSxcbiAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgIGJsb2I7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29kZSA9IFwiKFwiICsgY29kZS50b1N0cmluZygpICsgXCIpKCk7XCI7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSBmbG9jay53b3JrZXIgbXVzdCBiZSBpbml0aWFsaXplZCB3aXRoIGEgU3RyaW5nIG9yIGEgRnVuY3Rpb24uXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHdpbmRvdy5CbG9iKSB7XG4gICAgICAgICAgICBibG9iID0gbmV3IEJsb2IoW2NvZGVdLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0L2phdmFzY3JpcHRcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB1cmwgPSBmbG9jay5zaGltLlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1cmwgPSBcImRhdGE6dGV4dC9qYXZhc2NyaXB0O2Jhc2U2NCxcIiArIHdpbmRvdy5idG9hKGNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgV29ya2VyKHVybCk7XG4gICAgfTtcblxuXG4gICAgZmx1aWQucmVnaXN0ZXJOYW1lc3BhY2UoXCJmbG9jay5zY2hlZHVsZXJcIik7XG5cblxuICAgIC8qKioqKioqKioqXG4gICAgICogQ2xvY2tzICpcbiAgICAgKioqKioqKioqKi9cblxuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmxvY2suc2NoZWR1bGVyLmludGVydmFsQ2xvY2tcIiwge1xuICAgICAgICBncmFkZU5hbWVzOiBbXCJmbHVpZC5ldmVudGVkQ29tcG9uZW50XCIsIFwiYXV0b0luaXRcIl0sXG4gICAgICAgIGV2ZW50czoge1xuICAgICAgICAgICAgdGljazogbnVsbFxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBmbG9jay5zY2hlZHVsZXIuaW50ZXJ2YWxDbG9jay5maW5hbEluaXQgPSBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgICB0aGF0LnNjaGVkdWxlZCA9IHt9O1xuXG4gICAgICAgIHRoYXQuc2NoZWR1bGUgPSBmdW5jdGlvbiAoaW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIHZhciBpZCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGF0LmV2ZW50cy50aWNrLmZpcmUoaW50ZXJ2YWwpO1xuICAgICAgICAgICAgfSwgaW50ZXJ2YWwpO1xuICAgICAgICAgICAgdGhhdC5zY2hlZHVsZWRbaW50ZXJ2YWxdID0gaWQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5jbGVhciA9IGZ1bmN0aW9uIChpbnRlcnZhbCkge1xuICAgICAgICAgICAgdmFyIGlkID0gdGhhdC5zY2hlZHVsZWRbaW50ZXJ2YWxdO1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpZCk7XG4gICAgICAgICAgICBkZWxldGUgdGhhdC5zY2hlZHVsZWRbaW50ZXJ2YWxdO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQuY2xlYXJBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpbnRlcnZhbCBpbiB0aGF0LnNjaGVkdWxlZCkge1xuICAgICAgICAgICAgICAgIHRoYXQuY2xlYXIoaW50ZXJ2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQuZW5kID0gdGhhdC5jbGVhckFsbDtcbiAgICB9O1xuXG5cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsb2NrLnNjaGVkdWxlci5zY2hlZHVsZUNsb2NrXCIsIHtcbiAgICAgICAgZ3JhZGVOYW1lczogW1wiZmx1aWQuZXZlbnRlZENvbXBvbmVudFwiLCBcImF1dG9Jbml0XCJdLFxuICAgICAgICBldmVudHM6IHtcbiAgICAgICAgICAgIHRpY2s6IG51bGxcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZmxvY2suc2NoZWR1bGVyLnNjaGVkdWxlQ2xvY2suZmluYWxJbml0ID0gZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgICAgdGhhdC5zY2hlZHVsZWQgPSBbXTtcblxuICAgICAgICB0aGF0LnNjaGVkdWxlID0gZnVuY3Rpb24gKHRpbWVGcm9tTm93KSB7XG4gICAgICAgICAgICB2YXIgaWQ7XG4gICAgICAgICAgICBpZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoYXQuY2xlYXIoaWQpO1xuICAgICAgICAgICAgICAgIHRoYXQuZXZlbnRzLnRpY2suZmlyZSh0aW1lRnJvbU5vdyk7XG4gICAgICAgICAgICB9LCB0aW1lRnJvbU5vdyk7XG4gICAgICAgICAgICB0aGF0LnNjaGVkdWxlZC5wdXNoKGlkKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0LmNsZWFyID0gZnVuY3Rpb24gKGlkLCBpZHgpIHtcbiAgICAgICAgICAgIGlkeCA9IGlkeCA9PT0gdW5kZWZpbmVkID8gdGhhdC5zY2hlZHVsZWQuaW5kZXhPZihpZCkgOiBpZHg7XG4gICAgICAgICAgICBpZiAoaWR4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGF0LnNjaGVkdWxlZC5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5jbGVhckFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhhdC5zY2hlZHVsZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSB0aGF0LnNjaGVkdWxlZFtpXTtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhhdC5zY2hlZHVsZWQubGVuZ3RoID0gMDtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0LmVuZCA9IHRoYXQuY2xlYXJBbGw7XG4gICAgfTtcblxuXG4gICAgZmx1aWQuZGVmYXVsdHMoXCJmbG9jay5zY2hlZHVsZXIud2ViV29ya2VyQ2xvY2tcIiwge1xuICAgICAgICBncmFkZU5hbWVzOiBbXCJmbHVpZC5tb2RlbENvbXBvbmVudFwiLCBcImZsdWlkLmV2ZW50ZWRDb21wb25lbnRcIiwgXCJhdXRvSW5pdFwiXSxcbiAgICAgICAgbW9kZWw6IHtcbiAgICAgICAgICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgbXNnOiBcInNjaGVkdWxlXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNsZWFyOiB7XG4gICAgICAgICAgICAgICAgICAgIG1zZzogXCJjbGVhclwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjbGVhckFsbDoge1xuICAgICAgICAgICAgICAgICAgICBtc2c6IFwiY2xlYXJBbGxcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICAgICAgICAgIG1zZzogXCJlbmRcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZXZlbnRzOiB7XG4gICAgICAgICAgICB0aWNrOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIGNsb2NrVHlwZTogXCJpbnRlcnZhbENsb2NrXCJcbiAgICB9KTtcblxuICAgIGZsb2NrLnNjaGVkdWxlci53ZWJXb3JrZXJDbG9jay5maW5hbEluaXQgPSBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgICB0aGF0LndvcmtlciA9IG5ldyBmbG9jay53b3JrZXIoZmxvY2suc2NoZWR1bGVyLndlYldvcmtlckNsb2NrLndvcmtlckltcGwpO1xuXG4gICAgICAgIC8vIFN0YXJ0IHRoZSB3b3JrZXItc2lkZSBjbG9jay5cbiAgICAgICAgdGhhdC53b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgbXNnOiBcInN0YXJ0XCIsXG4gICAgICAgICAgICB2YWx1ZTogdGhhdC5vcHRpb25zLmNsb2NrVHlwZVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBMaXN0ZW4gZm9yIHRpY2sgbWVzc2FnZXMgZnJvbSB0aGUgd29ya2VyIGFuZCBmaXJlIGFjY29yZGluZ2x5LlxuICAgICAgICB0aGF0Lndvcmtlci5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdGhhdC5ldmVudHMudGljay5maXJlKGUuZGF0YS52YWx1ZSk7XG4gICAgICAgIH0sIGZhbHNlKTtcblxuICAgICAgICB0aGF0LnBvc3RUb1dvcmtlciA9IGZ1bmN0aW9uIChtc2dOYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIG1zZyA9IHRoYXQubW9kZWwubWVzc2FnZXNbbXNnTmFtZV07XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG1zZy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhhdC53b3JrZXIucG9zdE1lc3NhZ2UobXNnKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0LnNjaGVkdWxlID0gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgICAgIHRoYXQucG9zdFRvV29ya2VyKFwic2NoZWR1bGVcIiwgdGltZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5jbGVhciA9IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgICAgICB0aGF0LnBvc3RUb1dvcmtlcihcImNsZWFyXCIsIHRpbWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQuY2xlYXJBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0LnBvc3RUb1dvcmtlcihcImNsZWFyQWxsXCIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQuZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5wb3N0VG9Xb3JrZXIoXCJlbmRcIik7XG4gICAgICAgIH07XG4gICAgfTtcblxuXG4gICAgLy8gVGhpcyBjb2RlIGlzIG9ubHkgaW50ZW5kZWQgdG8gcnVuIGZyb20gd2l0aGluIGEgV29ya2VyLCB2aWEgZmxvY2sud29ya2VyLlxuICAgIGZsb2NrLnNjaGVkdWxlci53ZWJXb3JrZXJDbG9jay53b3JrZXJJbXBsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cbiAgICAgICAgdmFyIGZsb2NrID0gZmxvY2sgfHwge307XG4gICAgICAgIGZsb2NrLndvcmtlciA9IGZsb2NrLndvcmtlciB8fCB7fTtcblxuICAgICAgICBmbG9jay53b3JrZXIuY2xvY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHt9O1xuXG4gICAgICAgICAgICB0aGF0LnRpY2sgPSBmdW5jdGlvbiAoaW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgbXNnOiBcInRpY2tcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGludGVydmFsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gdGhhdDtcbiAgICAgICAgfTtcblxuICAgICAgICBmbG9jay53b3JrZXIuaW50ZXJ2YWxDbG9jayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gZmxvY2sud29ya2VyLmNsb2NrKCk7XG4gICAgICAgICAgICB0aGF0LnNjaGVkdWxlZCA9IHt9O1xuXG4gICAgICAgICAgICAvLyBUT0RPOiBDb3B5LXBhc3RlZCBmcm9tIGZsb2NrLnNjaGVkdWxlci5pbnRlcnZhbENsb2NrLlxuICAgICAgICAgICAgdGhhdC5zY2hlZHVsZSA9IGZ1bmN0aW9uIChpbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgIHZhciBpZCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC50aWNrKGludGVydmFsKTtcbiAgICAgICAgICAgICAgICB9LCBpbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgdGhhdC5zY2hlZHVsZWRbaW50ZXJ2YWxdID0gaWQ7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBUT0RPOiBDb3B5LXBhc3RlZCBmcm9tIGZsb2NrLnNjaGVkdWxlci5pbnRlcnZhbENsb2NrLlxuICAgICAgICAgICAgdGhhdC5jbGVhciA9IGZ1bmN0aW9uIChpbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgIHZhciBpZCA9IHRoYXQuc2NoZWR1bGVkW2ludGVydmFsXTtcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGlkKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhhdC5zY2hlZHVsZWRbaW50ZXJ2YWxdO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gVE9ETzogQ29weS1wYXN0ZWQgZnJvbSBmbG9jay5zY2hlZHVsZXIuaW50ZXJ2YWxDbG9jay5cbiAgICAgICAgICAgIHRoYXQuY2xlYXJBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaW50ZXJ2YWwgaW4gdGhhdC5zY2hlZHVsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5jbGVhcihpbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgZmxvY2sud29ya2VyLnNjaGVkdWxlQ2xvY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IGZsb2NrLndvcmtlci5jbG9jaygpO1xuICAgICAgICAgICAgdGhhdC5zY2hlZHVsZWQgPSBbXTtcblxuICAgICAgICAgICAgLy8gVE9ETzogQ29weS1wYXN0ZWQgZnJvbSBmbG9jay5zY2hlZHVsZXIuc2NoZWR1bGVDbG9jay5cbiAgICAgICAgICAgIHRoYXQuc2NoZWR1bGUgPSBmdW5jdGlvbiAodGltZUZyb21Ob3cpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWQ7XG4gICAgICAgICAgICAgICAgaWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5jbGVhcihpZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQudGljayh0aW1lRnJvbU5vdyk7XG4gICAgICAgICAgICAgICAgfSwgdGltZUZyb21Ob3cpO1xuICAgICAgICAgICAgICAgIHRoYXQuc2NoZWR1bGVkLnB1c2goaWQpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gVE9ETzogQ29weS1wYXN0ZWQgZnJvbSBmbG9jay5zY2hlZHVsZXIuc2NoZWR1bGVDbG9jay5cbiAgICAgICAgICAgIHRoYXQuY2xlYXIgPSBmdW5jdGlvbiAoaWQsIGlkeCkge1xuICAgICAgICAgICAgICAgIGlkeCA9IGlkeCA9PT0gdW5kZWZpbmVkID8gdGhhdC5zY2hlZHVsZWQuaW5kZXhPZihpZCkgOiBpZHg7XG4gICAgICAgICAgICAgICAgaWYgKGlkeCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuc2NoZWR1bGVkLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoaWQpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gVE9ETzogQ29weS1wYXN0ZWQgZnJvbSBmbG9jay5zY2hlZHVsZXIuc2NoZWR1bGVDbG9jay5cbiAgICAgICAgICAgIHRoYXQuY2xlYXJBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGF0LnNjaGVkdWxlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaWQgPSB0aGF0LnNjaGVkdWxlZFtpXTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhhdC5zY2hlZHVsZWQubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiB0aGF0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmIChlLmRhdGEubXNnID09PSBcInN0YXJ0XCIpIHtcbiAgICAgICAgICAgICAgICBmbG9jay5jbG9jayA9IGZsb2NrLndvcmtlcltlLmRhdGEudmFsdWVdKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGUuZGF0YS5tc2cgPT09IFwiZW5kXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmxvY2suY2xvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgZmxvY2suY2xvY2suY2xlYXJBbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZmxvY2suY2xvY2spIHtcbiAgICAgICAgICAgICAgICBmbG9jay5jbG9ja1tlLmRhdGEubXNnXShlLmRhdGEudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBmYWxzZSk7XG4gICAgfTtcblxuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmxvY2suc2NoZWR1bGVyLndlYldvcmtlckludGVydmFsQ2xvY2tcIiwge1xuICAgICAgICBncmFkZU5hbWVzOiBbXCJmbG9jay5zY2hlZHVsZXIud2ViV29ya2VyQ2xvY2tcIiwgXCJhdXRvSW5pdFwiXSxcbiAgICAgICAgY2xvY2tUeXBlOiBcImludGVydmFsQ2xvY2tcIlxuICAgIH0pO1xuXG4gICAgZmx1aWQuZGVmYXVsdHMoXCJmbG9jay5zY2hlZHVsZXIud2ViV29ya2VyU2NoZWR1bGVDbG9ja1wiLCB7XG4gICAgICAgIGdyYWRlTmFtZXM6IFtcImZsb2NrLnNjaGVkdWxlci53ZWJXb3JrZXJDbG9ja1wiLCBcImF1dG9Jbml0XCJdLFxuICAgICAgICBjbG9ja1R5cGU6IFwic2NoZWR1bGVDbG9ja1wiXG4gICAgfSk7XG5cblxuICAgIC8qKioqKioqKioqKioqKlxuICAgICAqIFNjaGVkdWxlcnMgKlxuICAgICAqKioqKioqKioqKioqKi9cblxuICAgIGZsb2NrLnNjaGVkdWxlci5tYWtlT25lU2hvdFZhbHVlTGlzdGVuZXIgPSBmdW5jdGlvbiAodmFsdWUsIGZuLCByZW1vdmVGbikge1xuICAgICAgICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICAgICAgaWYgKHRpbWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZm4odGltZSk7XG4gICAgICAgICAgICAgICAgcmVtb3ZlRm4obGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBsaXN0ZW5lcjtcbiAgICB9O1xuXG4gICAgZmxvY2suc2NoZWR1bGVyLm1ha2VSZXBlYXRpbmdWYWx1ZUxpc3RlbmVyID0gZnVuY3Rpb24gKHZhbHVlLCBmbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgICAgIGlmICh0aW1lID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGZuKHRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG5cblxuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmxvY2suc2NoZWR1bGVyLmFzeW5jXCIsIHtcbiAgICAgICAgZ3JhZGVOYW1lczogW1wiZmx1aWQuZXZlbnRlZENvbXBvbmVudFwiLCBcImF1dG9Jbml0XCJdLFxuICAgICAgICBjb21wb25lbnRzOiB7XG4gICAgICAgICAgICB0aW1lQ29udmVydGVyOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJmbG9jay5jb252ZXJ0LnNlY29uZHNcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGludGVydmFsQ2xvY2s6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZsb2NrLnNjaGVkdWxlci53ZWJXb3JrZXJJbnRlcnZhbENsb2NrXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzY2hlZHVsZUNsb2NrOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJmbG9jay5zY2hlZHVsZXIud2ViV29ya2VyU2NoZWR1bGVDbG9ja1wiXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFRPRE86IER1cGxpY2F0aW9uIVxuICAgIGZsb2NrLnNjaGVkdWxlci5hc3luYy5maW5hbEluaXQgPSBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgICB0aGF0LmludGVydmFsTGlzdGVuZXJzID0ge307XG4gICAgICAgIHRoYXQuc2NoZWR1bGVMaXN0ZW5lcnMgPSBbXTtcblxuICAgICAgICB0aGF0LmFkZEludGVydmFsTGlzdGVuZXIgPSBmdW5jdGlvbiAoaW50ZXJ2YWwsIGZuKSB7XG4gICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBmbG9jay5zY2hlZHVsZXIubWFrZVJlcGVhdGluZ1ZhbHVlTGlzdGVuZXIoaW50ZXJ2YWwsIGZuKTtcbiAgICAgICAgICAgIGxpc3RlbmVyLndyYXBwZWRMaXN0ZW5lciA9IGZuO1xuICAgICAgICAgICAgdGhhdC5pbnRlcnZhbExpc3RlbmVyc1tpbnRlcnZhbF0gPSB0aGF0LmludGVydmFsTGlzdGVuZXJzW2ludGVydmFsXSB8fCBbXTtcbiAgICAgICAgICAgIHRoYXQuaW50ZXJ2YWxMaXN0ZW5lcnNbaW50ZXJ2YWxdLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICAgICAgdGhhdC5pbnRlcnZhbENsb2NrLmV2ZW50cy50aWNrLmFkZExpc3RlbmVyKGxpc3RlbmVyKTtcblxuICAgICAgICAgICAgcmV0dXJuIGxpc3RlbmVyO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQuYWRkU2NoZWR1bGVMaXN0ZW5lciA9IGZ1bmN0aW9uICh0aW1lLCBmbikge1xuICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gZmxvY2suc2NoZWR1bGVyLm1ha2VPbmVTaG90VmFsdWVMaXN0ZW5lcih0aW1lLCBmbiwgdGhhdC5jbGVhcik7XG4gICAgICAgICAgICBsaXN0ZW5lci53cmFwcGVkTGlzdGVuZXIgPSBmbjtcbiAgICAgICAgICAgIHRoYXQuc2NoZWR1bGVMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgICAgICB0aGF0LnNjaGVkdWxlQ2xvY2suZXZlbnRzLnRpY2suYWRkTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gICAgICAgICAgICByZXR1cm4gbGlzdGVuZXI7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5zY2hlZHVsZUNoYW5nZSA9IGZ1bmN0aW9uICh0aW1lLCBjaGFuZ2VTcGVjLCBhZGRMaXN0ZW5lckZuLCBjbG9jaykge1xuICAgICAgICAgICAgdmFyIG1zID0gdGhhdC50aW1lQ29udmVydGVyLnZhbHVlKHRpbWUpLFxuICAgICAgICAgICAgICAgIGZuID0gZmxvY2suc2NoZWR1bGVyLmFzeW5jLnByZXBhcmVTY2hlZHVsZXJGbihjaGFuZ2VTcGVjLCB0aGF0LmV2ZW50cyksXG4gICAgICAgICAgICAgICAgbGlzdGVuZXIgPSBhZGRMaXN0ZW5lckZuKG1zLCBmbik7XG5cbiAgICAgICAgICAgIGNsb2NrLnNjaGVkdWxlKG1zKTtcbiAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lcjtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0LnJlcGVhdCA9IGZ1bmN0aW9uIChpbnRlcnZhbCwgY2hhbmdlU3BlYykge1xuICAgICAgICAgICAgcmV0dXJuIHRoYXQuc2NoZWR1bGVDaGFuZ2UoaW50ZXJ2YWwsIGNoYW5nZVNwZWMsIHRoYXQuYWRkSW50ZXJ2YWxMaXN0ZW5lciwgdGhhdC5pbnRlcnZhbENsb2NrKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0Lm9uY2UgPSBmdW5jdGlvbiAodGltZSwgY2hhbmdlU3BlYykge1xuICAgICAgICAgICAgcmV0dXJuIHRoYXQuc2NoZWR1bGVDaGFuZ2UodGltZSwgY2hhbmdlU3BlYywgdGhhdC5hZGRTY2hlZHVsZUxpc3RlbmVyLCB0aGF0LnNjaGVkdWxlQ2xvY2spO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQuc2VxdWVuY2UgPSBmdW5jdGlvbiAodGltZXMsIGNoYW5nZVNwZWMpIHtcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSBbXSxcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcjtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyID0gdGhhdC5vbmNlKHRpbWVzW2ldLCBjaGFuZ2VTcGVjKTtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lcnM7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5zY2hlZHVsZSA9IGZ1bmN0aW9uIChzY2hlZHVsZXMpIHtcbiAgICAgICAgICAgIHNjaGVkdWxlcyA9IGZsb2NrLmlzSXRlcmFibGUoc2NoZWR1bGVzKSA/IHNjaGVkdWxlcyA6IFtzY2hlZHVsZXNdO1xuXG4gICAgICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgICAgICBzY2hlZHVsZTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNjaGVkdWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlID0gc2NoZWR1bGVzW2ldO1xuICAgICAgICAgICAgICAgIGZsb2NrLmludm9rZSh0aGF0LCBzY2hlZHVsZS5pbnRlcnZhbCwgW3NjaGVkdWxlLnRpbWUsIHNjaGVkdWxlLmNoYW5nZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQuY2xlYXIgPSBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGlmICghbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRPRE86IFJhdGhlciBpbmVmZmljaWVudC5cbiAgICAgICAgICAgIHZhciBpZHggPSB0aGF0LnNjaGVkdWxlTGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpLFxuICAgICAgICAgICAgICAgIGludGVydmFsO1xuICAgICAgICAgICAgaWYgKGlkeCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5zY2hlZHVsZUNsb2NrLmV2ZW50cy50aWNrLnJlbW92ZUxpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB0aGF0LnNjaGVkdWxlTGlzdGVuZXJzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhhdC5pbnRlcnZhbENsb2NrLmV2ZW50cy50aWNrLnJlbW92ZUxpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIGZvciAoaW50ZXJ2YWwgaW4gdGhhdC5pbnRlcnZhbExpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIGlkeCA9IHRoYXQuaW50ZXJ2YWxMaXN0ZW5lcnNbaW50ZXJ2YWxdLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIGlmIChpZHggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGF0LmludGVydmFsTGlzdGVuZXJzW2ludGVydmFsXS5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5jbGVhclJlcGVhdCA9IGZ1bmN0aW9uIChpbnRlcnZhbCkge1xuICAgICAgICAgICAgdGhhdC5pbnRlcnZhbENsb2NrLmNsZWFyKGludGVydmFsKTtcblxuICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoYXQuaW50ZXJ2YWxMaXN0ZW5lcnNbaW50ZXJ2YWxdLFxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgbGlzdGVuZXI7XG5cbiAgICAgICAgICAgIGlmICghbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV07XG4gICAgICAgICAgICAgICAgdGhhdC5pbnRlcnZhbENsb2NrLmV2ZW50cy50aWNrLnJlbW92ZUxpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpc3RlbmVycy5sZW5ndGggPSAwO1xuXG4gICAgICAgICAgICByZXR1cm4gbGlzdGVuZXI7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5jbGVhckFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQuaW50ZXJ2YWxDbG9jay5jbGVhckFsbCgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaW50ZXJ2YWwgaW4gdGhhdC5pbnRlcnZhbExpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIHRoYXQuY2xlYXJSZXBlYXQoaW50ZXJ2YWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGF0LnNjaGVkdWxlQ2xvY2suY2xlYXJBbGwoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGxpc3RlbmVyIGluIHRoYXQuc2NoZWR1bGVMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICB0aGF0LmNsZWFyKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0LmVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQuaW50ZXJ2YWxDbG9jay5lbmQoKTtcbiAgICAgICAgICAgIHRoYXQuc2NoZWR1bGVDbG9jay5lbmQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodGhhdC5vcHRpb25zLnNjb3JlKSB7XG4gICAgICAgICAgICB0aGF0LnNjaGVkdWxlKHRoYXQub3B0aW9ucy5zY29yZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZmxvY2suc2NoZWR1bGVyLmFzeW5jLnByZXBhcmVTY2hlZHVsZXJGbiA9IGZ1bmN0aW9uIChjaGFuZ2VTcGVjLCBldmVudHMpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgY2hhbmdlU3BlYyxcbiAgICAgICAgICAgIGZuO1xuXG4gICAgICAgIGlmICh0eXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIC8vIFRoZSB1c2VyIGhhcyBzY2hlZHVsZWQgYSByYXcgZnVuY3Rpb24gcG9pbnRlci5cbiAgICAgICAgICAgIGZuID0gY2hhbmdlU3BlYztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAvLyBBbiBldmVudCB3YXMgc2NoZWR1bGVkIGJ5IG5hbWUuXG4gICAgICAgICAgICBmbiA9IGV2ZW50c1tjaGFuZ2VTcGVjXS5maXJlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQSBjaGFuZ2Ugc3BlYyBvYmplY3Qgd2FzIHNjaGVkdWxlZC5cbiAgICAgICAgICAgIGZuID0gZmxvY2suc2NoZWR1bGVyLmFzeW5jLmV2YWx1YXRlQ2hhbmdlU3BlYyhjaGFuZ2VTcGVjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmbjtcbiAgICB9O1xuXG4gICAgZmxvY2suc2NoZWR1bGVyLmFzeW5jLmV2YWx1YXRlQ2hhbmdlU3BlYyA9IGZ1bmN0aW9uIChjaGFuZ2VTcGVjKSB7XG4gICAgICAgIHZhciBzeW50aHMgPSB7fSxcbiAgICAgICAgICAgIHN0YXRpY0NoYW5nZXMgPSB7fTtcblxuICAgICAgICAvLyBGaW5kIGFsbCBzeW50aERlZnMgYW5kIGNyZWF0ZSBkZW1hbmQgcmF0ZSBzeW50aHMgZm9yIHRoZW0uXG4gICAgICAgIGZvciAodmFyIHBhdGggaW4gY2hhbmdlU3BlYy52YWx1ZXMpIHtcbiAgICAgICAgICAgIHZhciBjaGFuZ2UgPSBjaGFuZ2VTcGVjLnZhbHVlc1twYXRoXTtcbiAgICAgICAgICAgIGlmIChjaGFuZ2Uuc3ludGhEZWYpIHtcbiAgICAgICAgICAgICAgICBzeW50aHNbcGF0aF0gPSBmbG9jay5zeW50aC52YWx1ZShjaGFuZ2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0aWNDaGFuZ2VzW3BhdGhdID0gY2hhbmdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgc2NoZWR1bGVyIGxpc3RlbmVyIHRoYXQgZXZhbHVhdGVzIHRoZSBjaGFuZ2VTcGVjIGFuZCB1cGRhdGVzIHRoZSBzeW50aC5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHBhdGggaW4gc3ludGhzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN5bnRoID0gc3ludGhzW3BhdGhdO1xuICAgICAgICAgICAgICAgIHN0YXRpY0NoYW5nZXNbcGF0aF0gPSBzeW50aC52YWx1ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUT0RPOiBIYXJkY29kZWQgdG8gdGhlIHNoYXJlZCBlbnZpcm9ubWVudC5cbiAgICAgICAgICAgIHZhciB0YXJnZXRTeW50aCA9IHR5cGVvZiBjaGFuZ2VTcGVjLnN5bnRoID09PSBcInN0cmluZ1wiID9cbiAgICAgICAgICAgICAgICBmbG9jay5lbnZpcm8uc2hhcmVkLm5hbWVkTm9kZXNbY2hhbmdlU3BlYy5zeW50aF0gOiBjaGFuZ2VTcGVjLnN5bnRoO1xuICAgICAgICAgICAgdGFyZ2V0U3ludGguc2V0KHN0YXRpY0NoYW5nZXMpO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsb2NrLnNjaGVkdWxlci5hc3luYy50ZW1wb1wiLCB7XG4gICAgICAgIGdyYWRlTmFtZXM6IFtcImZsb2NrLnNjaGVkdWxlci5hc3luY1wiLCBcImF1dG9Jbml0XCJdLFxuXG4gICAgICAgIGJwbTogNjAsXG5cbiAgICAgICAgY29tcG9uZW50czoge1xuICAgICAgICAgICAgdGltZUNvbnZlcnRlcjoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZmxvY2suY29udmVydC5iZWF0c1wiLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgYnBtOiBcInt0ZW1wb30ub3B0aW9ucy5icG1cIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG5cbiAgICAvKioqKioqKioqKioqKioqKioqKlxuICAgICAqIFRpbWUgQ29udmVyc2lvbiAqXG4gICAgICoqKioqKioqKioqKioqKioqKiovXG5cbiAgICBmbHVpZC5yZWdpc3Rlck5hbWVzcGFjZShcImZsb2NrLmNvbnZlcnRcIik7XG5cbiAgICBmbG9jay5jb252ZXJ0Lm1ha2VTdGF0ZWxlc3NDb252ZXJ0ZXIgPSBmdW5jdGlvbiAoY29udmVydEZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBjb252ZXJ0Rm5cbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIGZsb2NrLmNvbnZlcnQubXMgPSBmbG9jay5jb252ZXJ0Lm1ha2VTdGF0ZWxlc3NDb252ZXJ0ZXIoZmx1aWQuaWRlbnRpdHkpO1xuXG4gICAgZmxvY2suY29udmVydC5zZWNvbmRzID0gZmxvY2suY29udmVydC5tYWtlU3RhdGVsZXNzQ29udmVydGVyKGZ1bmN0aW9uIChzZWNzKSB7XG4gICAgICAgIHJldHVybiBzZWNzICogMTAwMDtcbiAgICB9KTtcblxuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmxvY2suY29udmVydC5iZWF0c1wiLCB7XG4gICAgICAgIGdyYWRlTmFtZXM6IFtcImZsdWlkLmxpdHRsZUNvbXBvbmVudFwiLCBcImF1dG9Jbml0XCJdLFxuICAgICAgICBicG06IDYwXG4gICAgfSk7XG5cbiAgICBmbG9jay5jb252ZXJ0LmJlYXRzLmZpbmFsSW5pdCA9IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICAgIHRoYXQudmFsdWUgPSBmdW5jdGlvbiAoYmVhdHMpIHtcbiAgICAgICAgICAgIHZhciBicG0gPSB0aGF0Lm9wdGlvbnMuYnBtO1xuICAgICAgICAgICAgcmV0dXJuIGJwbSA8PSAwID8gMCA6IChiZWF0cyAvIGJwbSkgKiA2MDAwMDtcbiAgICAgICAgfTtcbiAgICB9O1xufSgpKTtcbjsvKlxuKiBGbG9ja2luZyBXZWJBdWRpbyBTdHJhdGVneVxuKiBodHRwOi8vZ2l0aHViLmNvbS9jb2xpbmJkY2xhcmsvZmxvY2tpbmdcbipcbiogQ29weXJpZ2h0IDIwMTMtMjAxNCwgQ29saW4gQ2xhcmtcbiogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGFuZCBHUEwgVmVyc2lvbiAyIGxpY2Vuc2VzLlxuKi9cblxuLypnbG9iYWwgcmVxdWlyZSwgTWVkaWFTdHJlYW1UcmFjaywgalF1ZXJ5Ki9cbi8qanNoaW50IHdoaXRlOiBmYWxzZSwgbmV3Y2FwOiB0cnVlLCByZWdleHA6IHRydWUsIGJyb3dzZXI6IHRydWUsXG4gICAgZm9yaW46IGZhbHNlLCBub21lbjogdHJ1ZSwgYml0d2lzZTogZmFsc2UsIG1heGVycjogMTAwLFxuICAgIGluZGVudDogNCwgcGx1c3BsdXM6IGZhbHNlLCBjdXJseTogdHJ1ZSwgZXFlcWVxOiB0cnVlLFxuICAgIGZyZWV6ZTogdHJ1ZSwgbGF0ZWRlZjogdHJ1ZSwgbm9hcmc6IHRydWUsIG5vbmV3OiB0cnVlLCBxdW90bWFyazogZG91YmxlLCB1bmRlZjogdHJ1ZSxcbiAgICB1bnVzZWQ6IHRydWUsIHN0cmljdDogdHJ1ZSwgYXNpOiBmYWxzZSwgYm9zczogZmFsc2UsIGV2aWw6IGZhbHNlLCBleHByOiBmYWxzZSxcbiAgICBmdW5jc2NvcGU6IGZhbHNlKi9cblxudmFyIGZsdWlkID0gZmx1aWQgfHwgcmVxdWlyZShcImluZnVzaW9uXCIpLFxuICAgIGZsb2NrID0gZmx1aWQucmVnaXN0ZXJOYW1lc3BhY2UoXCJmbG9ja1wiKTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGZsdWlkLnJlZ2lzdGVyTmFtZXNwYWNlKFwiZmxvY2sud2ViQXVkaW9cIik7XG5cbiAgICBmbG9jay53ZWJBdWRpby5jcmVhdGVOb2RlID0gZnVuY3Rpb24gKGNvbnRleHQsIHR5cGUsIGFyZ3MsIHBhcmFtcykge1xuICAgICAgICAvLyBTZWNvbmQgYXJndW1lbnQgaXMgYSBOb2RlU3BlYyBvYmplY3QuXG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgYXJncyA9IHR5cGUuYXJncztcbiAgICAgICAgICAgIHBhcmFtcyA9IHR5cGUucGFyYW1zO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUubm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFyZ3MgPSBhcmdzID09PSB1bmRlZmluZWQgfHwgYXJncyA9PT0gbnVsbCA/IFtdIDpcbiAgICAgICAgICAgIGZsdWlkLmlzQXJyYXlhYmxlKGFyZ3MpID8gYXJncyA6IFthcmdzXTtcblxuICAgICAgICB2YXIgY3JlYXRvck5hbWUgPSBcImNyZWF0ZVwiICsgdHlwZSxcbiAgICAgICAgICAgIG5vZGVTdHJJZHggPSBjcmVhdG9yTmFtZS5pbmRleE9mKFwiTm9kZVwiKTtcblxuICAgICAgICAvLyBUcmltIG9mZiBcIk5vZGVcIiBpZiBpdCBpcyBwcmVzZW50LlxuICAgICAgICBpZiAobm9kZVN0cklkeCA+IC0xKSB7XG4gICAgICAgICAgICBjcmVhdG9yTmFtZSA9IGNyZWF0b3JOYW1lLnN1YnN0cmluZygwLCBub2RlU3RySWR4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBub2RlID0gY29udGV4dFtjcmVhdG9yTmFtZV0uYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIGZsb2NrLndlYkF1ZGlvLmluaXRpYWxpemVOb2RlSW5wdXRzKG5vZGUsIHBhcmFtcyk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcblxuICAgIC8vIFRPRE86IEFkZCBzdXBwb3J0IGZvciBvdGhlciB0eXBlcyBvZiBBdWRpb1BhcmFtcy5cbiAgICBmbG9jay53ZWJBdWRpby5pbml0aWFsaXplTm9kZUlucHV0cyA9IGZ1bmN0aW9uIChub2RlLCBwYXJhbVNwZWMpIHtcbiAgICAgICAgaWYgKCFub2RlIHx8ICFwYXJhbVNwZWMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGlucHV0TmFtZSBpbiBwYXJhbVNwZWMpIHtcbiAgICAgICAgICAgIG5vZGVbaW5wdXROYW1lXS52YWx1ZSA9IHBhcmFtU3BlY1tpbnB1dE5hbWVdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcblxuXG4gICAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgd2hlbiBDaHJvbWUgaW1wbGVtZW50cyBuYXZpZ2F0b3IuZ2V0TWVkaWFEZXZpY2VzKCkuXG4gICAgZmx1aWQucmVnaXN0ZXJOYW1lc3BhY2UoXCJmbG9jay53ZWJBdWRpby5jaHJvbWVcIik7XG5cbiAgICBmbG9jay53ZWJBdWRpby5jaHJvbWUuZ2V0U291cmNlcyA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gTWVkaWFTdHJlYW1UcmFjay5nZXRTb3VyY2VzKGZ1bmN0aW9uIChpbmZvU3BlY3MpIHtcbiAgICAgICAgICAgIHZhciBub3JtYWxpemVkID0gZmx1aWQudHJhbnNmb3JtKGluZm9TcGVjcywgZnVuY3Rpb24gKGluZm9TcGVjKSB7XG4gICAgICAgICAgICAgICAgaW5mb1NwZWMuZGV2aWNlSWQgPSBpbmZvU3BlYy5pZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5mb1NwZWM7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY2FsbGJhY2sobm9ybWFsaXplZCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmbG9jay53ZWJBdWRpby5tZWRpYVN0cmVhbUZhaWx1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZsb2NrLmZhaWwoXCJNZWRpYSBDYXB0dXJlIGFuZCBTdHJlYW1zIGFyZSBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgYnJvd3Nlci5cIik7XG4gICAgfTtcblxuICAgIHZhciB3ZWJBdWRpb1NoaW1zID0ge1xuICAgICAgICBBdWRpb0NvbnRleHQ6IHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCxcblxuICAgICAgICBnZXRVc2VyTWVkaWFJbXBsOiBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhIHx8IG5hdmlnYXRvci53ZWJraXRHZXRVc2VyTWVkaWEgfHxcbiAgICAgICAgICAgIG5hdmlnYXRvci5tb3pHZXRVc2VyTWVkaWEgfHwgbmF2aWdhdG9yLm1zR2V0VXNlck1lZGlhIHx8IGZsb2NrLndlYkF1ZGlvLm1lZGlhU3RyZWFtRmFpbHVyZSxcblxuICAgICAgICBnZXRVc2VyTWVkaWE6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZsb2NrLnNoaW0uZ2V0VXNlck1lZGlhSW1wbC5hcHBseShuYXZpZ2F0b3IsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0TWVkaWFEZXZpY2VzSW1wbDogbmF2aWdhdG9yLmdldE1lZGlhRGV2aWNlcyA/IG5hdmlnYXRvci5nZXRNZWRpYURldmljZXMgOlxuICAgICAgICAgICAgdHlwZW9mIHdpbmRvdy5NZWRpYVN0cmVhbVRyYWNrICE9PSBcInVuZGVmaW5lZFwiID9cbiAgICAgICAgICAgIGZsb2NrLndlYkF1ZGlvLmNocm9tZS5nZXRTb3VyY2VzIDogZmxvY2sud2ViQXVkaW8ubWVkaWFTdHJlYW1GYWlsdXJlLFxuXG4gICAgICAgIGdldE1lZGlhRGV2aWNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmbG9jay5zaGltLmdldE1lZGlhRGV2aWNlc0ltcGwuYXBwbHkobmF2aWdhdG9yLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGpRdWVyeS5leHRlbmQoZmxvY2suc2hpbSwgd2ViQXVkaW9TaGltcyk7XG5cblxuICAgIC8qKlxuICAgICAqIFdlYiBBdWRpbyBBUEkgQXVkaW8gU3RyYXRlZ3lcbiAgICAgKi9cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsb2NrLmF1ZGlvU3RyYXRlZ3kud2ViXCIsIHtcbiAgICAgICAgZ3JhZGVOYW1lczogW1wiZmxvY2suYXVkaW9TdHJhdGVneVwiLCBcImF1dG9Jbml0XCJdLFxuXG4gICAgICAgIG1lbWJlcnM6IHtcbiAgICAgICAgICAgIGNvbnRleHQ6IFwie2NvbnRleHRXcmFwcGVyfS5jb250ZXh0XCIsXG4gICAgICAgICAgICBzYW1wbGVSYXRlOiBcInt0aGF0fS5jb250ZXh0LnNhbXBsZVJhdGVcIixcbiAgICAgICAgICAgIGNoYW5zOiB7XG4gICAgICAgICAgICAgICAgZXhwYW5kZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY05hbWU6IFwiZmxvY2suYXVkaW9TdHJhdGVneS53ZWIuY2FsY3VsYXRlQ2hhbm5lbHNcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW1wie2NvbnRleHRXcmFwcGVyfS5jb250ZXh0XCIsIFwie2Vudmlyb30ub3B0aW9ucy5hdWRpb1NldHRpbmdzLmNoYW5zXCJdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGpzTm9kZToge1xuICAgICAgICAgICAgICAgIGV4cGFuZGVyOiB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcImZsb2NrLmF1ZGlvU3RyYXRlZ3kud2ViLmNyZWF0ZVNjcmlwdFByb2Nlc3NvclwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBcIntjb250ZXh0V3JhcHBlcn0uY29udGV4dFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ7ZW52aXJvfS5vcHRpb25zLmF1ZGlvU2V0dGluZ3MuYnVmZmVyU2l6ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ7ZW52aXJvfS5vcHRpb25zLmF1ZGlvU2V0dGluZ3MubnVtSW5wdXRCdXNlc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ7dGhhdH0uY2hhbnNcIlxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1vZGVsOiB7XG4gICAgICAgICAgICBpc0dlbmVyYXRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgc2hvdWxkSW5pdElPUzogZmxvY2sucGxhdGZvcm0uaXNJT1MsXG4gICAgICAgICAgICBrclBlcmlvZHM6IHtcbiAgICAgICAgICAgICAgICBleHBhbmRlcjoge1xuICAgICAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJmbG9jay5hdWRpb1N0cmF0ZWd5LndlYi5jYWxjTnVtS3JQZXJpb2RzXCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFwie2Vudmlyb30ub3B0aW9ucy5hdWRpb1NldHRpbmdzXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW52b2tlcnM6IHtcbiAgICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgICAgZnVuYzogXCJ7dGhhdH0uZXZlbnRzLm9uU3RhcnQuZmlyZVwiXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzdG9wOiB7XG4gICAgICAgICAgICAgICAgZnVuYzogXCJ7dGhhdH0uZXZlbnRzLm9uU3RvcC5maXJlXCJcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICAgICAgZnVuYzogXCJ7dGhhdH0uZXZlbnRzLm9uUmVzZXQuZmlyZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29tcG9uZW50czoge1xuICAgICAgICAgICAgY29udGV4dFdyYXBwZXI6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZsb2NrLndlYkF1ZGlvLmNvbnRleHRXcmFwcGVyXCJcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG5hdGl2ZU5vZGVNYW5hZ2VyOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJmbG9jay53ZWJBdWRpby5uYXRpdmVOb2RlTWFuYWdlclwiXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBpbnB1dERldmljZU1hbmFnZXI6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZsb2NrLndlYkF1ZGlvLmlucHV0RGV2aWNlTWFuYWdlclwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXZlbnRzOiB7XG4gICAgICAgICAgICBvblN0YXJ0OiBudWxsLFxuICAgICAgICAgICAgb25TdG9wOiBudWxsLFxuICAgICAgICAgICAgb25SZXNldDogbnVsbFxuICAgICAgICB9LFxuXG4gICAgICAgIGxpc3RlbmVyczoge1xuICAgICAgICAgICAgb25DcmVhdGU6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcImZsb2NrLmF1ZGlvU3RyYXRlZ3kud2ViLnNldENoYW5uZWxTdGF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXCJ7dGhhdH0uY2hhbnNcIiwgXCJ7Y29udGV4dFdyYXBwZXJ9LmNvbnRleHQuZGVzdGluYXRpb25cIl1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY05hbWU6IFwiZmxvY2suYXVkaW9TdHJhdGVneS53ZWIucHVzaEF1ZGlvU2V0dGluZ3NcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW1wie3RoYXR9LnNhbXBsZVJhdGVcIiwgXCJ7dGhhdH0uY2hhbnNcIiwgXCJ7ZW52aXJvfS5vcHRpb25zLmF1ZGlvU2V0dGluZ3NcIl1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY05hbWU6IFwiZmxvY2suYXVkaW9TdHJhdGVneS53ZWIuYmluZFdyaXRlclwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBcInt0aGF0fS5qc05vZGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwie25vZGVFdmFsdWF0b3J9XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIntuYXRpdmVOb2RlTWFuYWdlcn1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwie3RoYXR9Lm1vZGVsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIntlbnZpcm99Lm9wdGlvbnMuYXVkaW9TZXR0aW5nc1wiXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuXG4gICAgICAgICAgICBvblN0YXJ0OiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBmdW5jOiBcInt0aGF0fS5hcHBsaWVyLmNoYW5nZVwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXCJpc0dlbmVyYXRpbmdcIiwgdHJ1ZV1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogUmVwbGFjZSB0aGlzIHdpdGggc29tZSBwcm9ncmVzc2l2ZSBlbmhhbmNlbWVudCBhY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcImZsb2NrLmF1ZGlvU3RyYXRlZ3kud2ViLmlPU1N0YXJ0XCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtcInt0aGF0fS5tb2RlbFwiLCBcInt0aGF0fS5hcHBsaWVyXCIsIFwie2NvbnRleHRXcmFwcGVyfS5jb250ZXh0XCIsIFwie3RoYXR9LmpzTm9kZVwiXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBmdW5jOiBcIntuYXRpdmVOb2RlTWFuYWdlcn0uY29ubmVjdFwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSxcblxuICAgICAgICAgICAgb25TdG9wOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBmdW5jOiBcInt0aGF0fS5hcHBsaWVyLmNoYW5nZVwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXCJpc0dlbmVyYXRpbmdcIiwgZmFsc2VdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmM6IFwie25hdGl2ZU5vZGVNYW5hZ2VyfS5kaXNjb25uZWN0XCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuXG4gICAgICAgICAgICBvblJlc2V0OiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBmdW5jOiBcInt0aGF0fS5zdG9wXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuYzogXCJ7bmF0aXZlTm9kZU1hbmFnZXJ9LnJlbW92ZUFsbElucHV0c1wiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmM6IFwie3RoYXR9LmFwcGxpZXIuY2hhbmdlXCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtcInBsYXlTdGF0ZS53cml0dGVuXCIsIDBdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBmbG9jay5hdWRpb1N0cmF0ZWd5LndlYi5jYWxjdWxhdGVDaGFubmVscyA9IGZ1bmN0aW9uIChjb250ZXh0LCBjaGFucykge1xuICAgICAgICAvLyBUT0RPOiBSZW1vdmUgdGhpcyBjb25kaXRpb25hbCB3aGVuIFNhZmFyaSBhZGRzIHN1cHBvcnQgZm9yIG11bHRpcGxlIGNoYW5uZWxzLlxuICAgICAgICByZXR1cm4gZmxvY2sucGxhdGZvcm0uYnJvd3Nlci5zYWZhcmkgPyAgY29udGV4dC5kZXN0aW5hdGlvbi5jaGFubmVsQ291bnQgOlxuICAgICAgICAgICAgTWF0aC5taW4oY2hhbnMsIGNvbnRleHQuZGVzdGluYXRpb24ubWF4Q2hhbm5lbENvdW50KTtcbiAgICB9O1xuXG4gICAgLy8gVE9ETzogUmVmYWN0b3IgaW50byBhIHNoYXJlZCBlbnZpcm9ubWVudC1sZXZlbCBtb2RlbCBwcm9wZXJ0eS5cbiAgICBmbG9jay5hdWRpb1N0cmF0ZWd5LndlYi5wdXNoQXVkaW9TZXR0aW5ncyA9IGZ1bmN0aW9uIChzYW1wbGVSYXRlLCBjaGFucywgYXVkaW9TZXR0aW5ncykge1xuICAgICAgICBhdWRpb1NldHRpbmdzLnJhdGVzLmF1ZGlvID0gc2FtcGxlUmF0ZTtcbiAgICAgICAgYXVkaW9TZXR0aW5ncy5jaGFucyA9IGNoYW5zO1xuICAgIH07XG5cbiAgICBmbG9jay5hdWRpb1N0cmF0ZWd5LndlYi5zZXRDaGFubmVsU3RhdGUgPSBmdW5jdGlvbiAoY2hhbnMsIGRlc3RpbmF0aW9uTm9kZSkge1xuICAgICAgICAvLyBTYWZhcmkgd2lsbCB0aHJvdyBhbiBJbnZhbGlkU3RhdGVFcnJvciBET00gRXhjZXB0aW9uIDExIHdoZW5cbiAgICAgICAgLy8gYXR0ZW1wdGluZyB0byBzZXQgY2hhbm5lbENvdW50IG9uIHRoZSBhdWRpb0NvbnRleHQncyBkZXN0aW5hdGlvbi5cbiAgICAgICAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgY29uZGl0aW9uYWwgd2hlbiBTYWZhcmkgYWRkcyBzdXBwb3J0IGZvciBtdWx0aXBsZSBjaGFubmVscy5cbiAgICAgICAgaWYgKCFmbG9jay5wbGF0Zm9ybS5icm93c2VyLnNhZmFyaSkge1xuICAgICAgICAgICAgZGVzdGluYXRpb25Ob2RlLmNoYW5uZWxDb3VudCA9IGNoYW5zO1xuICAgICAgICAgICAgZGVzdGluYXRpb25Ob2RlLmNoYW5uZWxDb3VudE1vZGUgPSBcImV4cGxpY2l0XCI7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbk5vZGUuY2hhbm5lbEludGVycHJldGF0aW9uID0gXCJkaXNjcmV0ZVwiO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZsb2NrLmF1ZGlvU3RyYXRlZ3kud2ViLmNhbGNOdW1LclBlcmlvZHMgPSBmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gcy5idWZmZXJTaXplIC8gcy5ibG9ja1NpemU7XG4gICAgfTtcblxuICAgIGZsb2NrLmF1ZGlvU3RyYXRlZ3kud2ViLmNyZWF0ZVNjcmlwdFByb2Nlc3NvciA9IGZ1bmN0aW9uIChjdHgsIGJ1ZmZlclNpemUsIG51bUlucHV0cywgY2hhbnMpIHtcbiAgICAgICAgdmFyIGpzTm9kZU5hbWUgPSBjdHguY3JlYXRlU2NyaXB0UHJvY2Vzc29yID8gXCJjcmVhdGVTY3JpcHRQcm9jZXNzb3JcIiA6IFwiY3JlYXRlSmF2YVNjcmlwdE5vZGVcIixcbiAgICAgICAgICAgIGpzTm9kZSA9IGN0eFtqc05vZGVOYW1lXShidWZmZXJTaXplLCBudW1JbnB1dHMsIGNoYW5zKTtcblxuICAgICAgICBqc05vZGUuY2hhbm5lbENvdW50TW9kZSA9IFwiZXhwbGljaXRcIjtcblxuICAgICAgICByZXR1cm4ganNOb2RlO1xuICAgIH07XG5cbiAgICBmbG9jay5hdWRpb1N0cmF0ZWd5LndlYi5iaW5kV3JpdGVyID0gZnVuY3Rpb24gKGpzTm9kZSwgbm9kZUV2YWx1YXRvciwgbmF0aXZlTm9kZU1hbmFnZXIsIG1vZGVsLCBhdWRpb1NldHRpbmdzKSB7XG4gICAgICAgIGpzTm9kZS5tb2RlbCA9IG1vZGVsO1xuICAgICAgICBqc05vZGUuZXZhbHVhdG9yID0gbm9kZUV2YWx1YXRvcjtcbiAgICAgICAganNOb2RlLmF1ZGlvU2V0dGluZ3MgPSBhdWRpb1NldHRpbmdzO1xuICAgICAgICBqc05vZGUuaW5wdXROb2RlcyA9IG5hdGl2ZU5vZGVNYW5hZ2VyLmlucHV0Tm9kZXM7XG4gICAgICAgIGpzTm9kZS5vbmF1ZGlvcHJvY2VzcyA9IGZsb2NrLmF1ZGlvU3RyYXRlZ3kud2ViLndyaXRlU2FtcGxlcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogV3JpdGVzIHNhbXBsZXMgdG8gdGhlIGF1ZGlvIHN0cmF0ZWd5J3MgU2NyaXB0UHJvY2Vzc29yTm9kZS5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gbXVzdCBiZSBib3VuZCBhcyBhIGxpc3RlbmVyIHRvIHRoZSBub2RlJ3NcbiAgICAgKiBvbmF1ZGlvcHJvY2VzcyBldmVudC4gSXQgZXhwZWN0cyB0byBiZSBjYWxsZWQgaW4gdGhlIGNvbnRleHRcbiAgICAgKiBvZiBhIFwidGhpc1wiIGluc3RhbmNlIGNvbnRhaW5pbmcgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAqICAtIG1vZGVsOiB0aGUgc3RyYXRlZ3kncyBtb2RlbCBvYmplY3RcbiAgICAgKiAgLSBpbnB1dE5vZGVzOiBhIGxpc3Qgb2YgbmF0aXZlIGlucHV0IG5vZGVzIHRvIGJlIHJlYWQgaW50byBpbnB1dCBidXNlc1xuICAgICAqICAtIG5vZGVFdmFsdWF0b3I6IGEgbm9kZUV2YWx1YXRvciBpbnN0YW5jZVxuICAgICAqICAtIGF1ZGlvU2V0dGluZ3M6IHRoZSBlbnZpb3JubWVudCdzIGF1ZGlvIHNldHRpbmdzXG4gICAgICovXG4gICAgZmxvY2suYXVkaW9TdHJhdGVneS53ZWIud3JpdGVTYW1wbGVzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgbnVtSW5wdXROb2RlcyA9IHRoaXMuaW5wdXROb2Rlcy5sZW5ndGgsXG4gICAgICAgICAgICBldmFsdWF0b3IgPSB0aGlzLmV2YWx1YXRvcixcbiAgICAgICAgICAgIHMgPSB0aGlzLmF1ZGlvU2V0dGluZ3MsXG4gICAgICAgICAgICBpbkJ1ZnMgPSBlLmlucHV0QnVmZmVyLFxuICAgICAgICAgICAgb3V0QnVmcyA9IGUub3V0cHV0QnVmZmVyLFxuICAgICAgICAgICAga3JQZXJpb2RzID0gbS5rclBlcmlvZHMsXG4gICAgICAgICAgICBidXNlcyA9IGV2YWx1YXRvci5idXNlcyxcbiAgICAgICAgICAgIGJsb2NrU2l6ZSA9IHMuYmxvY2tTaXplLFxuICAgICAgICAgICAgY2hhbnMgPSBzLmNoYW5zLFxuICAgICAgICAgICAgaW5DaGFucyA9IGluQnVmcy5udW1iZXJPZkNoYW5uZWxzLFxuICAgICAgICAgICAgY2hhbixcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBzYW1wO1xuXG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBub2RlcyBwcm92aWRpbmcgc2FtcGxlcywgd3JpdGUgb3V0IHNpbGVuY2UuXG4gICAgICAgIGlmIChldmFsdWF0b3Iubm9kZXMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgZm9yIChjaGFuID0gMDsgY2hhbiA8IGNoYW5zOyBjaGFuKyspIHtcbiAgICAgICAgICAgICAgICBmbG9jay5nZW5lcmF0ZS5zaWxlbmNlKG91dEJ1ZnMuZ2V0Q2hhbm5lbERhdGEoY2hhbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogTWFrZSBhIGZvcm1hbCBkaXN0aW5jdGlvbiBiZXR3ZWVuIGlucHV0IGJ1c2VzLFxuICAgICAgICAvLyBvdXRwdXQgYnVzZXMsIGFuZCBpbnRlcmNvbm5lY3QgYnVzZXMgaW4gdGhlIGVudmlyb25tZW50IVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga3JQZXJpb2RzOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBpICogYmxvY2tTaXplO1xuXG4gICAgICAgICAgICBldmFsdWF0b3IuY2xlYXJCdXNlcygpO1xuXG4gICAgICAgICAgICAvLyBSZWFkIHRoaXMgU2NyaXB0UHJvY2Vzc29yTm9kZSdzIGlucHV0IGJ1ZmZlcnNcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGVudmlyb25tZW50LlxuICAgICAgICAgICAgaWYgKG51bUlucHV0Tm9kZXMgPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjaGFuID0gMDsgY2hhbiA8IGluQ2hhbnM7IGNoYW4rKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5CdWYgPSBpbkJ1ZnMuZ2V0Q2hhbm5lbERhdGEoY2hhbiksXG4gICAgICAgICAgICAgICAgICAgICAgICBpbkJ1c051bWJlciA9IGNoYW5zICsgY2hhbiwgLy8gSW5wdXQgYnVzZXMgYXJlIGxvY2F0ZWQgYWZ0ZXIgb3V0cHV0IGJ1c2VzLlxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0QnVmID0gYnVzZXNbaW5CdXNOdW1iZXJdO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoc2FtcCA9IDA7IHNhbXAgPCBibG9ja1NpemU7IHNhbXArKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0QnVmW3NhbXBdID0gaW5CdWZbc2FtcCArIG9mZnNldF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV2YWx1YXRvci5nZW4oKTtcblxuICAgICAgICAgICAgLy8gT3V0cHV0IHRoZSBlbnZpcm9ubWVudCdzIHNpZ25hbFxuICAgICAgICAgICAgLy8gdG8gdGhpcyBTY3JpcHRQcm9jZXNzb3JOb2RlJ3Mgb3V0cHV0IGNoYW5uZWxzLlxuICAgICAgICAgICAgZm9yIChjaGFuID0gMDsgY2hhbiA8IGNoYW5zOyBjaGFuKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlQnVmID0gYnVzZXNbY2hhbl0sXG4gICAgICAgICAgICAgICAgICAgIG91dEJ1ZiA9IG91dEJ1ZnMuZ2V0Q2hhbm5lbERhdGEoY2hhbik7XG5cbiAgICAgICAgICAgICAgICAvLyBBbmQgb3V0cHV0IGVhY2ggc2FtcGxlLlxuICAgICAgICAgICAgICAgIGZvciAoc2FtcCA9IDA7IHNhbXAgPCBibG9ja1NpemU7IHNhbXArKykge1xuICAgICAgICAgICAgICAgICAgICBvdXRCdWZbc2FtcCArIG9mZnNldF0gPSBzb3VyY2VCdWZbc2FtcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZsb2NrLmF1ZGlvU3RyYXRlZ3kud2ViLmlPU1N0YXJ0ID0gZnVuY3Rpb24gKG1vZGVsLCBhcHBsaWVyLCBjdHgsIGpzTm9kZSkge1xuICAgICAgICAvLyBXb3JrIGFyb3VuZCBhIGJ1ZyBpbiBpT1MgU2FmYXJpIHdoZXJlIGl0IG5vdyByZXF1aXJlcyBhIG5vdGVPbigpXG4gICAgICAgIC8vIG1lc3NhZ2UgdG8gYmUgaW52b2tlZCBiZWZvcmUgc291bmQgd2lsbCB3b3JrIGF0IGFsbC4gSnVzdCBjb25uZWN0aW5nIGFcbiAgICAgICAgLy8gU2NyaXB0UHJvY2Vzc29yTm9kZSBpbnNpZGUgYSB1c2VyIGV2ZW50IGhhbmRsZXIgaXNuJ3Qgc3VmZmljaWVudC5cbiAgICAgICAgaWYgKG1vZGVsLnNob3VsZEluaXRJT1MpIHtcbiAgICAgICAgICAgIHZhciBzID0gY3R4LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuICAgICAgICAgICAgcy5jb25uZWN0KGpzTm9kZSk7XG4gICAgICAgICAgICBzLnN0YXJ0KDApO1xuICAgICAgICAgICAgcy5zdG9wKDApO1xuICAgICAgICAgICAgcy5kaXNjb25uZWN0KDApO1xuICAgICAgICAgICAgYXBwbGllci5jaGFuZ2UoXCJzaG91bGRJbml0SU9TXCIsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIEFuIEluZnVzaW9uIGNvbXBvbmVudCB3cmFwcGVyIGZvciBhIFdlYiBBdWRpbyBBUEkgQXVkaW9Db250ZXh0IGluc3RhbmNlLlxuICAgICAqL1xuICAgIC8vIFRPRE86IFJlZmFjdG9yIHRoaXMgaW50byBhbiBcImF1ZGlvIHN5c3RlbVwiIGNvbXBvbmVudCAod2l0aCBjcm9zcy1wbGF0Zm9ybSBiYXNlIGdyYWRlKVxuICAgIC8vIHRoYXQgc2VydmVzIGFzIHRoZSBjYW5vbmljYWwgc291cmNlIGZvciBzaGFyZWQgYXVkaW8gc2V0dGluZ3Mgc3VjaCBhc1xuICAgIC8vIHNhbXBsZSByYXRlLCBudW1iZXIgb2YgY2hhbm5lbHMsIGV0Yy5cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsb2NrLndlYkF1ZGlvLmNvbnRleHRXcmFwcGVyXCIsIHtcbiAgICAgICAgZ3JhZGVOYW1lczogW1wiZmx1aWQuZXZlbnRlZENvbXBvbmVudFwiLCBcImF1dG9Jbml0XCJdLFxuXG4gICAgICAgIG1lbWJlcnM6IHtcbiAgICAgICAgICAgIGNvbnRleHQ6IFwiQGV4cGFuZDpmbG9jay53ZWJBdWRpby5jb250ZXh0V3JhcHBlci5jcmVhdGUoKVwiXG4gICAgICAgIH0sXG5cbiAgICAgICAgbGlzdGVuZXJzOiB7XG4gICAgICAgICAgICBvbkNyZWF0ZTogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY05hbWU6IFwiZmxvY2sud2ViQXVkaW8uY29udGV4dFdyYXBwZXIucmVnaXN0ZXJTaW5nbGV0b25cIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW1wie3RoYXR9XCJdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBmbG9jay53ZWJBdWRpby5jb250ZXh0V3JhcHBlci5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzaW5nbGV0b24gPSBmbHVpZC5zdGF0aWNFbnZpcm9ubWVudC53ZWJBdWRpb0NvbnRleHRXcmFwcGVyO1xuICAgICAgICByZXR1cm4gc2luZ2xldG9uID8gc2luZ2xldG9uLmNvbnRleHQgOiBuZXcgZmxvY2suc2hpbS5BdWRpb0NvbnRleHQoKTtcbiAgICB9O1xuXG4gICAgZmxvY2sud2ViQXVkaW8uY29udGV4dFdyYXBwZXIucmVnaXN0ZXJTaW5nbGV0b24gPSBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgICBmbHVpZC5zdGF0aWNFbnZpcm9ubWVudC53ZWJBdWRpb0NvbnRleHRXcmFwcGVyID0gdGhhdDtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBNYW5hZ2VzIGEgY29sbGVjdGlvbiBvZiBpbnB1dCBub2RlcyBhbmQgYW4gb3V0cHV0IG5vZGUsXG4gICAgICogd2l0aCBhIEpTIG5vZGUgaW4gYmV0d2Vlbi5cbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgY29tcG9uZW50IGlzIHNsYXRlZCBmb3IgcmVtb3ZhbCB3aGVuIFdlYiBBdWRpb1xuICAgICAqIFwiaXNsYW5kc1wiIGFyZSBpbXBsZW1lbnRlZC5cbiAgICAgKi9cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsb2NrLndlYkF1ZGlvLm5hdGl2ZU5vZGVNYW5hZ2VyXCIsIHtcbiAgICAgICAgZ3JhZGVOYW1lczogW1wiZmx1aWQuZXZlbnRlZENvbXBvbmVudFwiLCBcImF1dG9Jbml0XCJdLFxuXG4gICAgICAgIGF1ZGlvU2V0dGluZ3M6IFwie2Vudmlyb30ub3B0aW9ucy5hdWRpb1NldHRpbmdzXCIsXG5cbiAgICAgICAgbWVtYmVyczoge1xuICAgICAgICAgICAgb3V0cHV0Tm9kZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaW5wdXROb2RlczogW10sXG4gICAgICAgICAgICBtZXJnZXI6IHtcbiAgICAgICAgICAgICAgICBleHBhbmRlcjoge1xuICAgICAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJmbG9jay53ZWJBdWRpby5uYXRpdmVOb2RlTWFuYWdlci5jcmVhdGVJbnB1dE1lcmdlclwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBcIntjb250ZXh0V3JhcHBlcn0uY29udGV4dFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ7ZW52aXJvfS5vcHRpb25zLmF1ZGlvU2V0dGluZ3MubnVtSW5wdXRCdXNlc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ7d2VifS5qc05vZGVcIlxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGludm9rZXJzOiB7XG4gICAgICAgICAgICBjb25uZWN0OiB7XG4gICAgICAgICAgICAgICAgZnVuY05hbWU6IFwiZmxvY2sud2ViQXVkaW8ubmF0aXZlTm9kZU1hbmFnZXIuY29ubmVjdFwiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICAgICAgXCJ7dGhhdH0ubWVyZ2VyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwie3dlYn0uanNOb2RlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwie3RoYXR9Lm91dHB1dE5vZGVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ7Y29udGV4dFdyYXBwZXJ9LmNvbnRleHQuZGVzdGluYXRpb25cIlxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNyZWF0ZU5vZGU6IHtcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJmbG9jay53ZWJBdWRpby5jcmVhdGVOb2RlXCIsXG4gICAgICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgICAgICBcIntjb250ZXh0V3JhcHBlcn0uY29udGV4dFwiLFxuICAgICAgICAgICAgICAgICAgICBcInthcmd1bWVudHN9LjBcIiwgLy8gTm9kZSB0eXBlLlxuICAgICAgICAgICAgICAgICAgICBcInthcmd1bWVudHN9LjFcIiwgLy8gQ29uc3RydWN0b3IgYXJncy5cbiAgICAgICAgICAgICAgICAgICAgXCJ7YXJndW1lbnRzfS4yXCIgIC8vIEF1ZGlvUGFyYW0gY29ubmVjdGlvbnMuXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgY3JlYXRlSW5wdXROb2RlOiB7XG4gICAgICAgICAgICAgICAgZnVuY05hbWU6IFwiZmxvY2sud2ViQXVkaW8ubmF0aXZlTm9kZU1hbmFnZXIuY3JlYXRlSW5wdXROb2RlXCIsXG4gICAgICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgICAgICBcInt0aGF0fVwiLFxuICAgICAgICAgICAgICAgICAgICBcInthcmd1bWVudHN9LjBcIiwgLy8gTm9kZSB0eXBlLlxuICAgICAgICAgICAgICAgICAgICBcInthcmd1bWVudHN9LjFcIiwgLy8gQ29uc3RydWN0b3IgYXJncy5cbiAgICAgICAgICAgICAgICAgICAgXCJ7YXJndW1lbnRzfS4yXCIsIC8vIEF1ZGlvUGFyYW0gY29ubmVjdGlvbnMuXG4gICAgICAgICAgICAgICAgICAgIFwie2FyZ3VtZW50c30uM1wiICAvLyB7b3B0aW9uYWx9IFRoZSBpbnB1dCBidXMgbnVtYmVyIHRvIGluc2VydCBpdCBhdC5cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBjcmVhdGVNZWRpYVN0cmVhbUlucHV0OiB7XG4gICAgICAgICAgICAgICAgZnVuY05hbWU6IFwiZmxvY2sud2ViQXVkaW8ubmF0aXZlTm9kZU1hbmFnZXIuY3JlYXRlSW5wdXROb2RlXCIsXG4gICAgICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgICAgICBcInt0aGF0fVwiLFxuICAgICAgICAgICAgICAgICAgICBcIk1lZGlhU3RyZWFtU291cmNlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwie2FyZ3VtZW50c30uMFwiLCAvLyBUaGUgTWVkaWFTdHJlYW0sXG4gICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgXCJ7YXJndW1lbnRzfS4xXCIgIC8vIHtvcHRpb25hbH0gVGhlIGlucHV0IGJ1cyBudW1iZXIgdG8gaW5zZXJ0IGl0IGF0LlxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNyZWF0ZU1lZGlhRWxlbWVudElucHV0OiB7XG4gICAgICAgICAgICAgICAgZnVuY05hbWU6IFwiZmxvY2sud2ViQXVkaW8ubmF0aXZlTm9kZU1hbmFnZXIuY3JlYXRlSW5wdXROb2RlXCIsXG4gICAgICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgICAgICBcInt0aGF0fVwiLFxuICAgICAgICAgICAgICAgICAgICBcIk1lZGlhRWxlbWVudFNvdXJjZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInthcmd1bWVudHN9LjBcIiwgLy8gVGhlIEhUTUxNZWRpYUVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBcInthcmd1bWVudHN9LjFcIiAgLy8ge29wdGlvbmFsfSBUaGUgaW5wdXQgYnVzIG51bWJlciB0byBpbnNlcnQgaXQgYXQuXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgY3JlYXRlT3V0cHV0Tm9kZToge1xuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcImZsb2NrLndlYkF1ZGlvLm5hdGl2ZU5vZGVNYW5hZ2VyLmNyZWF0ZU91dHB1dE5vZGVcIixcbiAgICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgICAgIFwie3RoYXR9XCIsXG4gICAgICAgICAgICAgICAgICAgIFwie2FyZ3VtZW50c30uMFwiLCAvLyBOb2RlIHR5cGUuXG4gICAgICAgICAgICAgICAgICAgIFwie2FyZ3VtZW50c30uMVwiLCAvLyBDb25zdHJ1Y3RvciBhcmdzLlxuICAgICAgICAgICAgICAgICAgICBcInthcmd1bWVudHN9LjJcIiAgLy8gQXVkaW9QYXJhbSBjb25uZWN0aW9ucy5cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBkaXNjb25uZWN0OiB7XG4gICAgICAgICAgICAgICAgZnVuY05hbWU6IFwiZmxvY2sud2ViQXVkaW8ubmF0aXZlTm9kZU1hbmFnZXIuZGlzY29ubmVjdFwiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtcInt0aGF0fS5tZXJnZXJcIiwgXCJ7d2VifS5qc05vZGVcIiwgXCJ7dGhhdH0ub3V0cHV0Tm9kZVwiXVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaW5zZXJ0SW5wdXQ6IHtcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJmbG9jay53ZWJBdWRpby5uYXRpdmVOb2RlTWFuYWdlci5pbnNlcnRJbnB1dFwiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICAgICAgXCJ7dGhhdH1cIixcbiAgICAgICAgICAgICAgICAgICAgXCJ7ZW52aXJvfVwiLFxuICAgICAgICAgICAgICAgICAgICBcInthcmd1bWVudHN9LjBcIiwgLy8gVGhlIG5vZGUgdG8gaW5zZXJ0LlxuICAgICAgICAgICAgICAgICAgICBcInthcmd1bWVudHN9LjFcIiAgLy8ge29wdGlvbmFsfSBUaGUgYnVzIG51bWJlciB0byBpbnNlcnQgaXQgYXQuXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcmVtb3ZlSW5wdXQ6IHtcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJmbG9jay53ZWJBdWRpby5uYXRpdmVOb2RlTWFuYWdlci5yZW1vdmVJbnB1dFwiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtcInthcmd1bWVudHN9LjBcIiwgXCJ7dGhhdH0uaW5wdXROb2Rlc1wiXVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcmVtb3ZlQWxsSW5wdXRzOiB7XG4gICAgICAgICAgICAgICAgZnVuY05hbWU6IFwiZmxvY2sud2ViQXVkaW8ubmF0aXZlTm9kZU1hbmFnZXIucmVtb3ZlQWxsSW5wdXRzXCIsXG4gICAgICAgICAgICAgICAgYXJnczogXCJ7dGhhdH0uaW5wdXROb2Rlc1wiXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBpbnNlcnRPdXRwdXQ6IHtcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJmbG9jay53ZWJBdWRpby5uYXRpdmVOb2RlTWFuYWdlci5pbnNlcnRPdXRwdXRcIixcbiAgICAgICAgICAgICAgICBhcmdzOiBbXCJ7dGhhdH1cIiwgXCJ7YXJndW1lbnRzfS4wXCJdXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICByZW1vdmVPdXRwdXQ6IHtcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJmbG9jay53ZWJBdWRpby5uYXRpdmVOb2RlTWFuYWdlci5yZW1vdmVPdXRwdXRcIixcbiAgICAgICAgICAgICAgICBhcmdzOiBbXCJ7d2VifS5qc05vZGVcIl1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBsaXN0ZW5lcnM6IHtcbiAgICAgICAgICAgIG9uQ3JlYXRlOiB7XG4gICAgICAgICAgICAgICAgZnVuYzogXCJ7dGhhdH0uaW5zZXJ0T3V0cHV0XCIsXG4gICAgICAgICAgICAgICAgYXJnczogXCJ7d2VifS5qc05vZGVcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBmbG9jay53ZWJBdWRpby5uYXRpdmVOb2RlTWFuYWdlci5jcmVhdGVJbnB1dE5vZGUgPSBmdW5jdGlvbiAodGhhdCwgdHlwZSwgYXJncywgcGFyYW1zLCBidXNOdW0pIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGF0LmNyZWF0ZU5vZGUodHlwZSwgYXJncywgcGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHRoYXQuaW5zZXJ0SW5wdXQobm9kZSwgYnVzTnVtKTtcbiAgICB9O1xuXG4gICAgZmxvY2sud2ViQXVkaW8ubmF0aXZlTm9kZU1hbmFnZXIuY3JlYXRlT3V0cHV0Tm9kZSA9IGZ1bmN0aW9uICh0aGF0LCB0eXBlLCBhcmdzLCBwYXJhbXMpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGF0LmNyZWF0ZU5vZGUodHlwZSwgYXJncywgcGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHRoYXQuaW5zZXJ0T3V0cHV0KG5vZGUpO1xuICAgIH07XG5cbiAgICBmbG9jay53ZWJBdWRpby5uYXRpdmVOb2RlTWFuYWdlci5jcmVhdGVJbnB1dE1lcmdlciA9IGZ1bmN0aW9uIChjdHgsIG51bUlucHV0QnVzZXMsIGpzTm9kZSkge1xuICAgICAgICB2YXIgbWVyZ2VyID0gY3R4LmNyZWF0ZUNoYW5uZWxNZXJnZXIobnVtSW5wdXRCdXNlcyk7XG4gICAgICAgIG1lcmdlci5jaGFubmVsSW50ZXJwcmV0YXRpb24gPSBcImRpc2NyZXRlXCI7XG4gICAgICAgIG1lcmdlci5jb25uZWN0KGpzTm9kZSk7XG5cbiAgICAgICAgcmV0dXJuIG1lcmdlcjtcbiAgICB9O1xuXG4gICAgZmxvY2sud2ViQXVkaW8ubmF0aXZlTm9kZU1hbmFnZXIuY29ubmVjdCA9IGZ1bmN0aW9uIChtZXJnZXIsIGpzTm9kZSwgb3V0cHV0Tm9kZSwgZGVzdGluYXRpb24pIHtcbiAgICAgICAgbWVyZ2VyLmNvbm5lY3QoanNOb2RlKTtcbiAgICAgICAgb3V0cHV0Tm9kZS5jb25uZWN0KGRlc3RpbmF0aW9uKTtcbiAgICAgICAgaWYgKGpzTm9kZSAhPT0gb3V0cHV0Tm9kZSkge1xuICAgICAgICAgICAganNOb2RlLmNvbm5lY3Qob3V0cHV0Tm9kZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZmxvY2sud2ViQXVkaW8ubmF0aXZlTm9kZU1hbmFnZXIuZGlzY29ubmVjdCA9IGZ1bmN0aW9uIChtZXJnZXIsIGpzTm9kZSwgb3V0cHV0Tm9kZSkge1xuICAgICAgICBtZXJnZXIuZGlzY29ubmVjdCgwKTtcbiAgICAgICAganNOb2RlLmRpc2Nvbm5lY3QoMCk7XG4gICAgICAgIG91dHB1dE5vZGUuZGlzY29ubmVjdCgwKTtcbiAgICB9O1xuXG4gICAgZmxvY2sud2ViQXVkaW8ubmF0aXZlTm9kZU1hbmFnZXIucmVtb3ZlQWxsSW5wdXRzID0gZnVuY3Rpb24gKGlucHV0Tm9kZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGlucHV0Tm9kZXNbaV07XG4gICAgICAgICAgICBub2RlLmRpc2Nvbm5lY3QoMCk7XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXROb2Rlcy5sZW5ndGggPSAwO1xuICAgIH07XG5cbiAgICBmbG9jay53ZWJBdWRpby5uYXRpdmVOb2RlTWFuYWdlci5pbnNlcnRJbnB1dCA9IGZ1bmN0aW9uICh0aGF0LCBlbnZpcm8sIG5vZGUsIGJ1c051bSkge1xuICAgICAgICB2YXIgbWF4SW5wdXRzID0gdGhhdC5vcHRpb25zLmF1ZGlvU2V0dGluZ3MubnVtSW5wdXRCdXNlcztcbiAgICAgICAgaWYgKHRoYXQuaW5wdXROb2Rlcy5sZW5ndGggPj0gbWF4SW5wdXRzKSB7XG4gICAgICAgICAgICBmbG9jay5mYWlsKFwiVGhlcmUgYXJlIHRvbyBtYW55IGlucHV0IG5vZGVzIGNvbm5lY3RlZCB0byBGbG9ja2luZy4gXCIgK1xuICAgICAgICAgICAgICAgIFwiVGhlIG1heGltdW0gbnVtYmVyIG9mIGlucHV0IGJ1c2VzIGlzIGN1cnJlbnRseSBzZXQgdG8gXCIgKyBtYXhJbnB1dHMgKyBcIi4gXCIgK1xuICAgICAgICAgICAgICAgIFwiRWl0aGVyIHJlbW92ZSBhbiBleGlzdGluZyBpbnB1dCBub2RlIG9yIGluY3JlYXNlIEZsb2NraW5ncyBudW1JbnB1dEJ1c2VzIG9wdGlvbi5cIik7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJ1c051bSA9IGJ1c051bSA9PT0gdW5kZWZpbmVkID8gZW52aXJvLmFjcXVpcmVOZXh0QnVzKFwiaW5wdXRcIikgOiBidXNOdW07XG4gICAgICAgIHZhciBpZHggPSBidXNOdW0gLSBlbnZpcm8uYXVkaW9TZXR0aW5ncy5jaGFucztcblxuICAgICAgICB0aGF0LmlucHV0Tm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgbm9kZS5jb25uZWN0KHRoYXQubWVyZ2VyLCAwLCBpZHgpO1xuXG4gICAgICAgIHJldHVybiBidXNOdW07XG4gICAgfTtcblxuICAgIGZsb2NrLndlYkF1ZGlvLm5hdGl2ZU5vZGVNYW5hZ2VyLnJlbW92ZUlucHV0ID0gZnVuY3Rpb24gKG5vZGUsIGlucHV0Tm9kZXMpIHtcbiAgICAgICAgdmFyIGlkeCA9IGlucHV0Tm9kZXMuaW5kZXhPZihub2RlKTtcbiAgICAgICAgaWYgKGlkeCA+IC0xKSB7XG4gICAgICAgICAgICBpbnB1dE5vZGVzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZS5kaXNjb25uZWN0KDApO1xuICAgIH07XG5cbiAgICBmbG9jay53ZWJBdWRpby5uYXRpdmVOb2RlTWFuYWdlci5pbnNlcnRPdXRwdXQgPSBmdW5jdGlvbiAodGhhdCwgbm9kZSkge1xuICAgICAgICBpZiAodGhhdC5vdXRwdXROb2RlKSB7XG4gICAgICAgICAgICB0aGF0Lm91dHB1dE5vZGUuZGlzY29ubmVjdCgwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoYXQub3V0cHV0Tm9kZSA9IG5vZGU7XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcblxuICAgIGZsb2NrLndlYkF1ZGlvLm5hdGl2ZU5vZGVNYW5hZ2VyLnJlbW92ZU91dHB1dCA9IGZ1bmN0aW9uIChqc05vZGUpIHtcbiAgICAgICAgLy8gUmVwbGFjZSB0aGUgY3VycmVudCBvdXRwdXQgbm9kZSB3aXRoIHRoZSBqc05vZGUuXG4gICAgICAgIGZsb2NrLndlYkF1ZGlvLm5hdGl2ZU5vZGVNYW5hZ2VyLmluc2VydE91dHB1dChqc05vZGUpO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIE1hbmFnZXMgYXVkaW8gaW5wdXQgZGV2aWNlcyB1c2luZyB0aGUgV2ViIEF1ZGlvIEFQSS5cbiAgICAgKi9cbiAgICAvLyBBZGQgYSBtZWFucyBmb3IgZGlzY29ubmVjdGluZyBhdWRpbyBpbnB1dCBub2Rlcy5cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsb2NrLndlYkF1ZGlvLmlucHV0RGV2aWNlTWFuYWdlclwiLCB7XG4gICAgICAgIGdyYWRlTmFtZXM6IFtcImZsdWlkLmV2ZW50ZWRDb21wb25lbnRcIiwgXCJhdXRvSW5pdFwiXSxcblxuICAgICAgICBtZW1iZXJzOiB7XG4gICAgICAgICAgICBjb250ZXh0OiBcIntjb250ZXh0V3JhcHBlcn0uY29udGV4dFwiXG4gICAgICAgIH0sXG5cbiAgICAgICAgaW52b2tlcnM6IHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogT3BlbnMgdGhlIHNwZWNpZmllZCBhdWRpbyBkZXZpY2UuXG4gICAgICAgICAgICAgKiBJZiBubyBkZXZpY2UgaXMgc3BlY2lmaWVkLCB0aGUgZGVmYXVsdCBkZXZpY2UgaXMgb3BlbmVkLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZXZpY2VTcGVjIGEgZGV2aWNlIHNwZWMgY29udGFpbmluZywgb3B0aW9uYWxseSwgYW4gJ2lkJyBvciAnbGFiZWwnIHBhcmFtZXRlclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBvcGVuQXVkaW9EZXZpY2U6IHtcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJmbG9jay53ZWJBdWRpby5pbnB1dERldmljZU1hbmFnZXIub3BlbkF1ZGlvRGV2aWNlXCIsXG4gICAgICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgICAgICBcInthcmd1bWVudHN9LjBcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ7dGhhdH0ub3BlbkF1ZGlvRGV2aWNlV2l0aElkXCIsXG4gICAgICAgICAgICAgICAgICAgIFwie3RoYXR9Lm9wZW5GaXJzdEF1ZGlvRGV2aWNlV2l0aExhYmVsXCIsXG4gICAgICAgICAgICAgICAgICAgIFwie3RoYXR9Lm9wZW5BdWRpb0RldmljZVdpdGhDb25zdHJhaW50c1wiXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBPcGVucyBhbiBhdWRpbyBkZXZpY2Ugd2l0aCB0aGUgc3BlY2lmaWVkIFdlYlJUQyBjb25zdHJhaW50cy5cbiAgICAgICAgICAgICAqIElmIG5vIGNvbnN0cmFpbnRzIGFyZSBzcGVjaWZpZWQsIHRoZSBkZWZhdWx0IGF1ZGlvIGRldmljZSBpcyBvcGVuZWQuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbnN0cmFpbnRzIGEgV2ViUlRDLWNvbXBhdGlibGUgY29uc3RyYWludHMgb2JqZWN0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG9wZW5BdWRpb0RldmljZVdpdGhDb25zdHJhaW50czoge1xuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcImZsb2NrLndlYkF1ZGlvLmlucHV0RGV2aWNlTWFuYWdlci5vcGVuQXVkaW9EZXZpY2VXaXRoQ29uc3RyYWludHNcIixcbiAgICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgICAgIFwie3RoYXR9LmNvbnRleHRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ7ZW52aXJvfVwiLFxuICAgICAgICAgICAgICAgICAgICBcIntuYXRpdmVOb2RlTWFuYWdlcn0uY3JlYXRlTWVkaWFTdHJlYW1JbnB1dFwiLFxuICAgICAgICAgICAgICAgICAgICBcInthcmd1bWVudHN9LjBcIlxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogT3BlbnMgYW4gYXVkaW8gZGV2aWNlIHdpdGggdGhlIHNwZWNpZmllZCBXZWJSVEMgZGV2aWNlIGlkLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBhIGRldmljZSBpZGVudGlmaWVyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG9wZW5BdWRpb0RldmljZVdpdGhJZDoge1xuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcImZsb2NrLndlYkF1ZGlvLmlucHV0RGV2aWNlTWFuYWdlci5vcGVuQXVkaW9EZXZpY2VXaXRoSWRcIixcbiAgICAgICAgICAgICAgICBhcmdzOiBbXCJ7YXJndW1lbnRzfS4wXCIsIFwie3RoYXR9Lm9wZW5BdWRpb0RldmljZVdpdGhDb25zdHJhaW50c1wiXVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBPcGVucyB0aGUgZmlyc3QgYXVkaW8gZGV2aWNlIGZvdW5kIHdpdGggdGhlIHNwZWNpZmllZCBsYWJlbC5cbiAgICAgICAgICAgICAqIFRoZSBsYWJlbCBtdXN0IGJlIGFuIGV4YWN0LCBjYXNlLWluc2Vuc2l0aXZlIG1hdGNoLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYWJlbCBhIGRldmljZSBsYWJlbFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBvcGVuRmlyc3RBdWRpb0RldmljZVdpdGhMYWJlbDoge1xuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcImZsb2NrLndlYkF1ZGlvLmlucHV0RGV2aWNlTWFuYWdlci5vcGVuRmlyc3RBdWRpb0RldmljZVdpdGhMYWJlbFwiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtcInthcmd1bWVudHN9LjBcIiwgXCJ7dGhhdH0ub3BlbkF1ZGlvRGV2aWNlV2l0aElkXCJdXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZsb2NrLndlYkF1ZGlvLmlucHV0RGV2aWNlTWFuYWdlci5vcGVuQXVkaW9EZXZpY2UgPSBmdW5jdGlvbiAoc291cmNlU3BlYywgaWRPcGVuZXIsIGxhYmVsT3BlbmVyLCBzcGVjT3BlbmVyKSB7XG4gICAgICAgIGlmIChzb3VyY2VTcGVjKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlU3BlYy5pZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpZE9wZW5lcihzb3VyY2VTcGVjLmlkKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlU3BlYy5sYWJlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsYWJlbE9wZW5lcihzb3VyY2VTcGVjLmxhYmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzcGVjT3BlbmVyKCk7XG4gICAgfTtcblxuXG4gICAgZmxvY2sud2ViQXVkaW8uaW5wdXREZXZpY2VNYW5hZ2VyLm9wZW5BdWRpb0RldmljZVdpdGhJZCA9IGZ1bmN0aW9uIChpZCwgZGV2aWNlT3BlbmVyKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgYXVkaW86IHtcbiAgICAgICAgICAgICAgICBvcHRpb25hbDogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VJZDogaWRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBkZXZpY2VPcGVuZXIob3B0aW9ucyk7XG4gICAgfTtcblxuICAgIGZsb2NrLndlYkF1ZGlvLmlucHV0RGV2aWNlTWFuYWdlci5vcGVuRmlyc3RBdWRpb0RldmljZVdpdGhMYWJlbCA9IGZ1bmN0aW9uIChsYWJlbCwgZGV2aWNlT3BlbmVyKSB7XG4gICAgICAgIGlmICghbGFiZWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IENhbid0IGFjY2VzcyBkZXZpY2UgbGFiZWxzIHVudGlsIHRoZSB1c2VyIGFncmVlc1xuICAgICAgICAvLyB0byBhbGxvdyBhY2Nlc3MgdG8gdGhlIGN1cnJlbnQgZGV2aWNlLlxuICAgICAgICBmbG9jay5zaGltLmdldE1lZGlhRGV2aWNlcyhmdW5jdGlvbiAoZGV2aWNlSW5mb1NwZWNzKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IGRldmljZUluZm9TcGVjcy5maWx0ZXIoZnVuY3Rpb24gKGRldmljZSkge1xuICAgICAgICAgICAgICAgIGlmIChkZXZpY2UubGFiZWwudG9Mb3dlckNhc2UoKSA9PT0gbGFiZWwudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGRldmljZU9wZW5lcihtYXRjaGVzWzBdLmRldmljZUlkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmx1aWQubG9nKGZsdWlkLmxvZ0xldmVsLklNUE9SVEFOVCxcbiAgICAgICAgICAgICAgICAgICAgXCJBbiBhdWRpbyBkZXZpY2UgbmFtZWQgJ1wiICsgbGFiZWwgKyBcIicgY291bGQgbm90IGJlIGZvdW5kLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZsb2NrLndlYkF1ZGlvLmlucHV0RGV2aWNlTWFuYWdlci5vcGVuQXVkaW9EZXZpY2VXaXRoQ29uc3RyYWludHMgPSBmdW5jdGlvbiAoY29udGV4dCwgZW52aXJvLCBvcGVuTWVkaWFTdHJlYW0sIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge1xuICAgICAgICAgICAgYXVkaW86IHRydWVcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBBY3F1aXJlIGFuIGlucHV0IGJ1cyBhaGVhZCBvZiB0aW1lIHNvIHdlIGNhbiBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIG5vdGlmeSB0aGUgY2xpZW50IHdoZXJlIGl0cyBvdXRwdXQgd2lsbCBiZS5cbiAgICAgICAgdmFyIGJ1c051bSA9IGVudmlyby5hY3F1aXJlTmV4dEJ1cyhcImlucHV0XCIpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGVycm9yIChlcnIpIHtcbiAgICAgICAgICAgIGZsdWlkLmxvZyhmbHVpZC5sb2dMZXZlbC5JTVBPUlRBTlQsXG4gICAgICAgICAgICAgICAgXCJBbiBlcnJvciBvY2N1cnJlZCB3aGlsZSB0cnlpbmcgdG8gYWNjZXNzIHRoZSB1c2VyJ3MgbWljcm9waG9uZS4gXCIgK1xuICAgICAgICAgICAgICAgIGVycik7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzdWNjZXNzIChtZWRpYVN0cmVhbSkge1xuICAgICAgICAgICAgb3Blbk1lZGlhU3RyZWFtKG1lZGlhU3RyZWFtLCBidXNOdW0pO1xuICAgICAgICB9XG5cblxuICAgICAgICBmbG9jay5zaGltLmdldFVzZXJNZWRpYShvcHRpb25zLCBzdWNjZXNzLCBlcnJvcik7XG5cbiAgICAgICAgcmV0dXJuIGJ1c051bTtcbiAgICB9O1xuXG4gICAgZmx1aWQuZGVtYW5kcyhcImZsb2NrLmF1ZGlvU3RyYXRlZ3kucGxhdGZvcm1cIiwgXCJmbG9jay5wbGF0Zm9ybS53ZWJBdWRpb1wiLCB7XG4gICAgICAgIGZ1bmNOYW1lOiBcImZsb2NrLmF1ZGlvU3RyYXRlZ3kud2ViXCJcbiAgICB9KTtcblxufSgpKTtcbjsvKlxuKiBGbG9ja2luZyBVbml0IEdlbmVyYXRvcnNcbiogaHR0cDovL2dpdGh1Yi5jb20vY29saW5iZGNsYXJrL2Zsb2NraW5nXG4qXG4qIENvcHlyaWdodCAyMDExLTIwMTQsIENvbGluIENsYXJrXG4qIER1YWwgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBhbmQgR1BMIFZlcnNpb24gMiBsaWNlbnNlcy5cbiovXG5cbi8qZ2xvYmFsIHJlcXVpcmUsIEZsb2F0MzJBcnJheSwgUmFuZG9tKi9cbi8qanNoaW50IHdoaXRlOiBmYWxzZSwgbmV3Y2FwOiB0cnVlLCByZWdleHA6IHRydWUsIGJyb3dzZXI6IHRydWUsXG4gICAgZm9yaW46IGZhbHNlLCBub21lbjogdHJ1ZSwgYml0d2lzZTogZmFsc2UsIG1heGVycjogMTAwLFxuICAgIGluZGVudDogNCwgcGx1c3BsdXM6IGZhbHNlLCBjdXJseTogdHJ1ZSwgZXFlcWVxOiB0cnVlLFxuICAgIGZyZWV6ZTogdHJ1ZSwgbGF0ZWRlZjogdHJ1ZSwgbm9hcmc6IHRydWUsIG5vbmV3OiB0cnVlLCBxdW90bWFyazogZG91YmxlLCB1bmRlZjogdHJ1ZSxcbiAgICB1bnVzZWQ6IHRydWUsIHN0cmljdDogdHJ1ZSwgYXNpOiBmYWxzZSwgYm9zczogZmFsc2UsIGV2aWw6IGZhbHNlLCBleHByOiBmYWxzZSxcbiAgICBmdW5jc2NvcGU6IGZhbHNlKi9cblxudmFyIGZsdWlkID0gZmx1aWQgfHwgcmVxdWlyZShcImluZnVzaW9uXCIpLFxuICAgIGZsb2NrID0gZmx1aWQucmVnaXN0ZXJOYW1lc3BhY2UoXCJmbG9ja1wiKTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciAkID0gZmx1aWQucmVnaXN0ZXJOYW1lc3BhY2UoXCJqUXVlcnlcIiksXG4gICAgICAgIERTUCA9IGZsb2NrLnJlcXVpcmVNb2R1bGUoXCJkc3BhcGlcIiwgXCJEU1BcIiksXG4gICAgICAgIEZpbHRlciA9IGZsb2NrLnJlcXVpcmVNb2R1bGUoXCJkc3BhcGlcIiwgXCJGaWx0ZXJcIik7XG5cbiAgICAvKioqKioqKioqKioqKlxuICAgICAqIFV0aWxpdGllcyAqXG4gICAgICoqKioqKioqKioqKiovXG5cbiAgICBmbG9jay5pc1VHZW4gPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogJiYgb2JqLnRhZ3MgJiYgb2JqLnRhZ3MuaW5kZXhPZihcImZsb2NrLnVnZW5cIikgPiAtMTtcbiAgICB9O1xuXG4gICAgLy8gVE9ETzogQ2hlY2sgQVBJOyB3cml0ZSB1bml0IHRlc3RzLlxuICAgIGZsb2NrLmFsaWFzVUdlbiA9IGZ1bmN0aW9uIChzb3VyY2VQYXRoLCBhbGlhc05hbWUsIGlucHV0RGVmYXVsdHMsIGRlZmF1bHRPcHRpb25zKSB7XG4gICAgICAgIHZhciByb290ID0gZmxvY2suZ2V0KHNvdXJjZVBhdGgpO1xuICAgICAgICBmbG9jay5zZXQocm9vdCwgYWxpYXNOYW1lLCBmdW5jdGlvbiAoaW5wdXRzLCBvdXRwdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3QoaW5wdXRzLCBvdXRwdXQsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICAgICAgZmx1aWQuZGVmYXVsdHMoc291cmNlUGF0aCArIFwiLlwiICsgYWxpYXNOYW1lLCBpbnB1dERlZmF1bHRzKTtcbiAgICB9O1xuXG4gICAgLy8gVE9ETzogQ2hlY2sgQVBJOyB3cml0ZSB1bml0IHRlc3RzLlxuICAgIGZsb2NrLmFsaWFzVUdlbnMgPSBmdW5jdGlvbiAoc291cmNlUGF0aCwgYWxpYXNlc1NwZWMpIHtcbiAgICAgICAgdmFyIGFsaWFzTmFtZSxcbiAgICAgICAgICAgIHNldHRpbmdzO1xuXG4gICAgICAgIGZvciAoYWxpYXNOYW1lIGluIGFsaWFzZXNTcGVjKSB7XG4gICAgICAgICAgICBzZXR0aW5ncyA9IGFsaWFzZXNTcGVjW2FsaWFzTmFtZV07XG4gICAgICAgICAgICBmbG9jay5hbGlhc1VHZW4oc291cmNlUGF0aCwgYWxpYXNOYW1lLCB7aW5wdXRzOiBzZXR0aW5ncy5pbnB1dERlZmF1bHRzfSwgc2V0dGluZ3Mub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZmxvY2sua3JNdWwgPSBmdW5jdGlvbiAobnVtU2FtcHMsIG91dHB1dCwgbXVsSW5wdXQpIHtcbiAgICAgICAgdmFyIG11bCA9IG11bElucHV0Lm91dHB1dFswXSxcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bVNhbXBzOyBpKyspIHtcbiAgICAgICAgICAgIG91dHB1dFtpXSA9IG91dHB1dFtpXSAqIG11bDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmbG9jay5tdWwgPSBmdW5jdGlvbiAobnVtU2FtcHMsIG91dHB1dCwgbXVsSW5wdXQpIHtcbiAgICAgICAgdmFyIG11bCA9IG11bElucHV0Lm91dHB1dCxcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bVNhbXBzOyBpKyspIHtcbiAgICAgICAgICAgIG91dHB1dFtpXSA9IG91dHB1dFtpXSAqIG11bFtpXTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmbG9jay5rckFkZCA9IGZ1bmN0aW9uIChudW1TYW1wcywgb3V0cHV0LCBtdWxJbnB1dCwgYWRkSW5wdXQpIHtcbiAgICAgICAgdmFyIGFkZCA9IGFkZElucHV0Lm91dHB1dFswXSxcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bVNhbXBzOyBpKyspIHtcbiAgICAgICAgICAgIG91dHB1dFtpXSA9IG91dHB1dFtpXSArIGFkZDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmbG9jay5hZGQgPSBmdW5jdGlvbiAobnVtU2FtcHMsIG91dHB1dCwgbXVsSW5wdXQsIGFkZElucHV0KSB7XG4gICAgICAgIHZhciBhZGQgPSBhZGRJbnB1dC5vdXRwdXQsXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1TYW1wczsgaSsrKSB7XG4gICAgICAgICAgICBvdXRwdXRbaV0gPSBvdXRwdXRbaV0gKyBhZGRbaV07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZmxvY2sua3JNdWxBZGQgPSBmdW5jdGlvbiAobnVtU2FtcHMsIG91dHB1dCwgbXVsSW5wdXQsIGFkZElucHV0KSB7XG4gICAgICAgIHZhciBtdWwgPSBtdWxJbnB1dC5vdXRwdXRbMF0sXG4gICAgICAgICAgICBhZGQgPSBhZGRJbnB1dC5vdXRwdXQsXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1TYW1wczsgaSsrKSB7XG4gICAgICAgICAgICBvdXRwdXRbaV0gPSBvdXRwdXRbaV0gKiBtdWwgKyBhZGRbaV07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZmxvY2subXVsS3JBZGQgPSBmdW5jdGlvbiAobnVtU2FtcHMsIG91dHB1dCwgbXVsSW5wdXQsIGFkZElucHV0KSB7XG4gICAgICAgIHZhciBtdWwgPSBtdWxJbnB1dC5vdXRwdXQsXG4gICAgICAgICAgICBhZGQgPSBhZGRJbnB1dC5vdXRwdXRbMF0sXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1TYW1wczsgaSsrKSB7XG4gICAgICAgICAgICBvdXRwdXRbaV0gPSBvdXRwdXRbaV0gKiBtdWxbaV0gKyBhZGQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZmxvY2sua3JNdWxLckFkZCA9IGZ1bmN0aW9uIChudW1TYW1wcywgb3V0cHV0LCBtdWxJbnB1dCwgYWRkSW5wdXQpIHtcbiAgICAgICAgdmFyIG11bCA9IG11bElucHV0Lm91dHB1dFswXSxcbiAgICAgICAgICAgIGFkZCA9IGFkZElucHV0Lm91dHB1dFswXSxcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bVNhbXBzOyBpKyspIHtcbiAgICAgICAgICAgIG91dHB1dFtpXSA9IG91dHB1dFtpXSAqIG11bCArIGFkZDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmbG9jay5tdWxBZGQgPSBmdW5jdGlvbiAobnVtU2FtcHMsIG91dHB1dCwgbXVsSW5wdXQsIGFkZElucHV0KSB7XG4gICAgICAgIHZhciBtdWwgPSBtdWxJbnB1dC5vdXRwdXQsXG4gICAgICAgICAgICBhZGQgPSBhZGRJbnB1dC5vdXRwdXQsXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1TYW1wczsgaSsrKSB7XG4gICAgICAgICAgICBvdXRwdXRbaV0gPSBvdXRwdXRbaV0gKiBtdWxbaV0gKyBhZGRbaV07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZmxvY2sub25NdWxBZGRJbnB1dENoYW5nZWQgPSBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgICB2YXIgbXVsID0gdGhhdC5pbnB1dHMubXVsLFxuICAgICAgICAgICAgYWRkID0gdGhhdC5pbnB1dHMuYWRkLFxuICAgICAgICAgICAgZm47XG5cbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBubyBtdWwgb3IgYWRkIGlucHV0cywgYmFpbCBpbW1lZGlhdGVseS5cbiAgICAgICAgaWYgKCFtdWwgJiYgIWFkZCkge1xuICAgICAgICAgICAgdGhhdC5tdWxBZGQgPSBmbG9jay5ub09wO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtdWwpIHsgLy8gT25seSBhZGQuXG4gICAgICAgICAgICBmbiA9IGFkZC5yYXRlICE9PSBmbG9jay5yYXRlcy5BVURJTyA/IGZsb2NrLmtyQWRkIDogZmxvY2suYWRkO1xuICAgICAgICB9IGVsc2UgaWYgKCFhZGQpIHsgLy8gT25seSBtdWwuXG4gICAgICAgICAgICBmbiA9IG11bC5yYXRlICE9PSBmbG9jay5yYXRlcy5BVURJTyA/IGZsb2NrLmtyTXVsIDogZmxvY2subXVsO1xuICAgICAgICB9IGVsc2UgeyAvLyBCb3RoIG11bCBhbmQgYWRkLlxuICAgICAgICAgICAgZm4gPSBtdWwucmF0ZSAhPT0gZmxvY2sucmF0ZXMuQVVESU8gP1xuICAgICAgICAgICAgICAgIChhZGQucmF0ZSAhPT0gZmxvY2sucmF0ZXMuQVVESU8gPyBmbG9jay5rck11bEtyQWRkIDogZmxvY2sua3JNdWxBZGQpIDpcbiAgICAgICAgICAgICAgICAoYWRkLnJhdGUgIT09IGZsb2NrLnJhdGVzLkFVRElPID8gZmxvY2subXVsS3JBZGQgOiBmbG9jay5tdWxBZGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhhdC5tdWxBZGQgPSBmdW5jdGlvbiAobnVtU2FtcHMpIHtcbiAgICAgICAgICAgIGZuKG51bVNhbXBzLCB0aGF0Lm91dHB1dCwgbXVsLCBhZGQpO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKlxuICAgICAqIFVuaXQgR2VuZXJhdG9ycyAqXG4gICAgICoqKioqKioqKioqKioqKioqKiovXG5cbiAgICBmbG9jay51Z2VuID0gZnVuY3Rpb24gKGlucHV0cywgb3V0cHV0LCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIHZhciB0aGF0ID0ge1xuICAgICAgICAgICAgcmF0ZTogb3B0aW9ucy5yYXRlIHx8IGZsb2NrLnJhdGVzLkFVRElPLFxuICAgICAgICAgICAgaW5wdXRzOiBpbnB1dHMsXG4gICAgICAgICAgICBvdXRwdXQ6IG91dHB1dCxcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgICAgICBtb2RlbDogb3B0aW9ucy5tb2RlbCB8fCB7XG4gICAgICAgICAgICAgICAgdW5zY2FsZWRWYWx1ZTogMC4wLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAwLjBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtdWx0aUlucHV0czoge30sXG4gICAgICAgICAgICB0YWdzOiBbXCJmbG9jay51Z2VuXCJdXG4gICAgICAgIH07XG4gICAgICAgIHRoYXQubGFzdE91dHB1dElkeCA9IHRoYXQub3V0cHV0Lmxlbmd0aCAtIDE7XG5cbiAgICAgICAgdGhhdC5nZXQgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZsb2NrLmlucHV0LmdldCh0aGF0LmlucHV0cywgcGF0aCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBpbnB1dCBhdCB0aGUgc3BlY2lmaWVkIHBhdGguXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIHRoZSBpbnB1dHMncyBwYXRoIHJlbGF0aXZlIHRvIHRoaXMgdWdlblxuICAgICAgICAgKiBAcGFyYW0ge051bWJlciB8fCBVR2VuRGVmfSB2YWwgYSBzY2FsYXIgdmFsdWUgKGZvciBWYWx1ZSB1Z2Vucykgb3IgYSBVR2VuRGVmIG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJuIHtVR2VufSB0aGUgbmV3bHktY3JlYXRlZCBVR2VuIHRoYXQgd2FzIHNldCBhdCB0aGUgc3BlY2lmaWVkIHBhdGhcbiAgICAgICAgICovXG4gICAgICAgIHRoYXQuc2V0ID0gZnVuY3Rpb24gKHBhdGgsIHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZsb2NrLmlucHV0LnNldCh0aGF0LmlucHV0cywgcGF0aCwgdmFsLCB0aGF0LCBmdW5jdGlvbiAodWdlbkRlZikge1xuICAgICAgICAgICAgICAgIGlmICh1Z2VuRGVmID09PSBudWxsIHx8IHVnZW5EZWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZsb2NrLnBhcnNlLnVnZW5EZWYodWdlbkRlZiwge1xuICAgICAgICAgICAgICAgICAgICBhdWRpb1NldHRpbmdzOiB0aGF0Lm9wdGlvbnMuYXVkaW9TZXR0aW5ncyxcbiAgICAgICAgICAgICAgICAgICAgYnVzZXM6IHRoYXQub3B0aW9ucy5hdWRpb1NldHRpbmdzLmJ1c2VzLFxuICAgICAgICAgICAgICAgICAgICBidWZmZXJzOiB0aGF0Lm9wdGlvbnMuYXVkaW9TZXR0aW5ncy5idWZmZXJzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBuYW1lZCB1bml0IGdlbmVyYXRvciBpbnB1dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGggdGhlIGlucHV0IHBhdGhcbiAgICAgICAgICogQHBhcmFtIHtVR2VuRGVmfSB2YWwgW29wdGlvbmFsXSBhIHNjYWxhciB2YWx1ZSwgdWdlbkRlZiwgb3IgYXJyYXkgb2YgdWdlbkRlZnMgdGhhdCB3aWxsIGJlIGFzc2lnbmVkIHRvIHRoZSBzcGVjaWZpZWQgaW5wdXQgbmFtZVxuICAgICAgICAgKiBAcmV0dXJuIHtOdW1iZXJ8VUdlbn0gYSBzY2FsYXIgdmFsdWUgaW4gdGhlIGNhc2Ugb2YgYSB2YWx1ZSB1Z2VuLCBvdGhlcndpc2UgdGhlIHVnZW4gaXRzZWxmXG4gICAgICAgICAqL1xuICAgICAgICB0aGF0LmlucHV0ID0gZnVuY3Rpb24gKHBhdGgsIHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuICFwYXRoID8gdW5kZWZpbmVkIDogdHlwZW9mIChwYXRoKSA9PT0gXCJzdHJpbmdcIiA/XG4gICAgICAgICAgICAgICAgYXJndW1lbnRzLmxlbmd0aCA8IDIgPyB0aGF0LmdldChwYXRoKSA6IHRoYXQuc2V0KHBhdGgsIHZhbCkgOlxuICAgICAgICAgICAgICAgIGZsb2NrLmlzSXRlcmFibGUocGF0aCkgPyB0aGF0LmdldChwYXRoKSA6IHRoYXQuc2V0KHBhdGgsIHZhbCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIGludG8gYSBncmFkZS5cbiAgICAgICAgdGhhdC5jYWxjdWxhdGVTdHJpZGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG0gPSB0aGF0Lm1vZGVsLFxuICAgICAgICAgICAgICAgIHN0cmlkZU5hbWVzID0gdGhhdC5vcHRpb25zLnN0cmlkZUlucHV0cyxcbiAgICAgICAgICAgICAgICBpbnB1dHMgPSB0aGF0LmlucHV0cyxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgaW5wdXQ7XG5cbiAgICAgICAgICAgIG0uc3RyaWRlcyA9IG0uc3RyaWRlcyB8fCB7fTtcblxuICAgICAgICAgICAgaWYgKCFzdHJpZGVOYW1lcykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHN0cmlkZU5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IHN0cmlkZU5hbWVzW2ldO1xuICAgICAgICAgICAgICAgIGlucHV0ID0gaW5wdXRzW25hbWVdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIG0uc3RyaWRlc1tuYW1lXSA9IGlucHV0LnJhdGUgPT09IGZsb2NrLnJhdGVzLkFVRElPID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZmx1aWQubG9nKGZsdWlkLmxvZ0xldmVsLldBUk4sIFwiQW4gaW52YWxpZCBpbnB1dCAoJ1wiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgKyBcIicpIHdhcyBmb3VuZCBvbiBhIHVuaXQgZ2VuZXJhdG9yOiBcIiArIHRoYXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0LmNvbGxlY3RNdWx0aUlucHV0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtdWx0aUlucHV0TmFtZXMgPSB0aGF0Lm9wdGlvbnMubXVsdGlJbnB1dE5hbWVzLFxuICAgICAgICAgICAgICAgIG11bHRpSW5wdXRzID0gdGhhdC5tdWx0aUlucHV0cyxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIGlucHV0TmFtZSxcbiAgICAgICAgICAgICAgICBpbnB1dENoYW5uZWxDYWNoZSxcbiAgICAgICAgICAgICAgICBpbnB1dDtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG11bHRpSW5wdXROYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlucHV0TmFtZSA9IG11bHRpSW5wdXROYW1lc1tpXTtcbiAgICAgICAgICAgICAgICBpbnB1dENoYW5uZWxDYWNoZSA9IG11bHRpSW5wdXRzW2lucHV0TmFtZV07XG5cbiAgICAgICAgICAgICAgICBpZiAoIWlucHV0Q2hhbm5lbENhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0Q2hhbm5lbENhY2hlID0gbXVsdGlJbnB1dHNbaW5wdXROYW1lXSA9IFtdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENsZWFyIHRoZSBjdXJyZW50IGFycmF5IG9mIGJ1ZmZlcnMuXG4gICAgICAgICAgICAgICAgICAgIGlucHV0Q2hhbm5lbENhY2hlLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaW5wdXQgPSB0aGF0LmlucHV0c1tpbnB1dE5hbWVdO1xuICAgICAgICAgICAgICAgIGZsb2NrLnVnZW4uY29sbGVjdE11bHRpSW5wdXRzKGlucHV0LCBpbnB1dENoYW5uZWxDYWNoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQmFzZSBvbklucHV0Q2hhbmdlZCgpIGltcGxlbWVudGF0aW9uLlxuICAgICAgICB0aGF0Lm9uSW5wdXRDaGFuZ2VkID0gZnVuY3Rpb24gKGlucHV0TmFtZSkge1xuICAgICAgICAgICAgdmFyIG11bHRpSW5wdXROYW1lcyA9IHRoYXQub3B0aW9ucy5tdWx0aUlucHV0TmFtZXM7XG5cbiAgICAgICAgICAgIGZsb2NrLm9uTXVsQWRkSW5wdXRDaGFuZ2VkKHRoYXQpO1xuICAgICAgICAgICAgaWYgKHRoYXQub3B0aW9ucy5zdHJpZGVJbnB1dHMpIHtcbiAgICAgICAgICAgICAgICB0aGF0LmNhbGN1bGF0ZVN0cmlkZXMoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG11bHRpSW5wdXROYW1lcyAmJiAoIWlucHV0TmFtZSB8fCBtdWx0aUlucHV0TmFtZXMuaW5kZXhPZihpbnB1dE5hbWUpKSkge1xuICAgICAgICAgICAgICAgIHRoYXQuY29sbGVjdE11bHRpSW5wdXRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRhZ3MgPSBmbHVpZC5tYWtlQXJyYXkodGhhdC5vcHRpb25zLnRhZ3MpLFxuICAgICAgICAgICAgICAgIG0gPSB0aGF0Lm1vZGVsLFxuICAgICAgICAgICAgICAgIG8gPSB0aGF0Lm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICBzLFxuICAgICAgICAgICAgICAgIHZhbHVlRGVmO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGFncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoYXQudGFncy5wdXNoKHRhZ3NbaV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzID0gby5hdWRpb1NldHRpbmdzID0gby5hdWRpb1NldHRpbmdzIHx8IGZsb2NrLmVudmlyby5zaGFyZWQuYXVkaW9TZXR0aW5ncztcbiAgICAgICAgICAgIG0uc2FtcGxlUmF0ZSA9IG8uc2FtcGxlUmF0ZSB8fCBzLnJhdGVzW3RoYXQucmF0ZV07XG4gICAgICAgICAgICBtLm55cXVpc3RSYXRlID0gbS5zYW1wbGVSYXRlO1xuICAgICAgICAgICAgbS5ibG9ja1NpemUgPSB0aGF0LnJhdGUgPT09IGZsb2NrLnJhdGVzLkFVRElPID8gcy5ibG9ja1NpemUgOiAxO1xuICAgICAgICAgICAgbS5zYW1wbGVEdXIgPSAxLjAgLyBtLnNhbXBsZVJhdGU7XG5cbiAgICAgICAgICAgIC8vIEFzc2lnbnMgYW4gaW50ZXJwb2xhdG9yIGZ1bmN0aW9uIHRvIHRoZSBVR2VuLlxuICAgICAgICAgICAgLy8gVGhpcyBpcyBpbmFjdGl2ZSBieSBkZWZhdWx0LCBidXQgY2FuIGJlIHVzZWQgaW4gY3VzdG9tIGdlbigpIGZ1bmN0aW9ucy5cbiAgICAgICAgICAgIHRoYXQuaW50ZXJwb2xhdGUgPSBmbG9jay5pbnRlcnBvbGF0ZS5ub25lO1xuICAgICAgICAgICAgaWYgKG8uaW50ZXJwb2xhdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciBmbiA9IGZsb2NrLmludGVycG9sYXRlW28uaW50ZXJwb2xhdGlvbl07XG4gICAgICAgICAgICAgICAgaWYgKCFmbikge1xuICAgICAgICAgICAgICAgICAgICBmbHVpZC5sb2coZmx1aWQubG9nTGV2ZWwuSU1QT1JUQU5ULFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJBbiBpbnZhbGlkIGludGVycG9sYXRpb24gdHlwZSBvZiAnXCIgKyBvLmludGVycG9sYXRpb24gK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCInIHdhcyBzcGVjaWZpZWQuIERlZmF1bHRpbmcgdG8gbm9uZS5cIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5pbnRlcnBvbGF0ZSA9IGZuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoYXQucmF0ZSA9PT0gZmxvY2sucmF0ZXMuREVNQU5EICYmIHRoYXQuaW5wdXRzLmZyZXEpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZURlZiA9IGZsb2NrLnBhcnNlLnVnZW5EZWZGb3JDb25zdGFudFZhbHVlKDEuMCk7XG4gICAgICAgICAgICAgICAgdGhhdC5pbnB1dHMuZnJlcSA9IGZsb2NrLnBhcnNlLnVnZW5EZWYodmFsdWVEZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQuaW5pdCgpO1xuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICB9O1xuXG4gICAgLy8gVGhlIHRlcm0gXCJtdWx0aSBpbnB1dFwiIGlzIGEgYml0IGFtYmlndW91cyxcbiAgICAvLyBidXQgaXQgcHJvdmlkZXMgYSB2ZXJ5IGxpZ2h0IChhbmQgcG9zc2libHkgcG9vcikgYWJzdHJhY3Rpb24gZm9yIHR3byBkaWZmZXJlbnQgY2FzZXM6XG4gICAgLy8gICAxLiBpbnB1dHMgdGhhdCBjb25zaXN0IG9mIGFuIGFycmF5IG9mIG11bHRpcGxlIHVuaXQgZ2VuZXJhdG9yc1xuICAgIC8vICAgMi4gaW5wdXRzIHRoYXQgY29uc2lzdCBvZiBhIHNpbmdsZSB1bml0IGdlbmVyYXRvciB0aGF0IGhhcyBtdWx0aXBsZSBvdXB1dCBjaGFubmVsc1xuICAgIC8vIEluIGVpdGhlciBjYXNlLCBlYWNoIGNoYW5uZWwgb2YgZWFjaCBpbnB1dCB1bml0IGdlbmVyYXRvciB3aWxsIGJlIGdhdGhlcmVkIHVwIGludG9cbiAgICAvLyBhbiBhcnJheSBvZiBcInByb3h5IHVnZW5cIiBvYmplY3RzIGFuZCBrZXllZCBieSB0aGUgaW5wdXQgbmFtZSwgbWFraW5nIGVhc3kgdG8gaXRlcmF0ZVxuICAgIC8vIG92ZXIgc291cmNlcyBvZiBpbnB1dCBxdWlja2x5LlxuICAgIC8vIEEgcHJveHkgdWdlbiBjb25zaXN0cyBvZiBhIHNpbXBsZSBvYmplY3QgY29uZm9ybWluZyB0byB0aGlzIGNvbnRyYWN0OlxuICAgIC8vICAge3JhdGU6IDxyYXRlIG9mIHBhcmVudCB1Z2VuPiwgb3V0cHV0OiA8RmxvYXQzMkFycmF5Pn1cbiAgICBmbG9jay51Z2VuLmNvbGxlY3RNdWx0aUlucHV0cyA9IGZ1bmN0aW9uIChpbnB1dHMsIGlucHV0Q2hhbm5lbENhY2hlKSB7XG4gICAgICAgIGlmICghZmxvY2suaXNJdGVyYWJsZShpbnB1dHMpKSB7XG4gICAgICAgICAgICBpbnB1dHMgPSBpbnB1dHMgPSBmbHVpZC5tYWtlQXJyYXkoaW5wdXRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSBpbnB1dHNbaV07XG4gICAgICAgICAgICBmbG9jay51Z2VuLmNvbGxlY3RDaGFubmVsc0ZvcklucHV0KGlucHV0LCBpbnB1dENoYW5uZWxDYWNoZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5wdXRDaGFubmVsQ2FjaGU7XG4gICAgfTtcblxuICAgIGZsb2NrLnVnZW4uY29sbGVjdENoYW5uZWxzRm9ySW5wdXQgPSBmdW5jdGlvbiAoaW5wdXQsIGlucHV0Q2hhbm5lbENhY2hlKSB7XG4gICAgICAgIHZhciBpc011bHRpID0gZmxvY2suaGFzVGFnKGlucHV0LCBcImZsb2NrLnVnZW4ubXVsdGlDaGFubmVsT3V0cHV0XCIpLFxuICAgICAgICAgICAgY2hhbm5lbHMgPSBpc011bHRpID8gaW5wdXQub3V0cHV0IDogW2lucHV0Lm91dHB1dF0sXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjaGFubmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaW5wdXRDaGFubmVsQ2FjaGUucHVzaCh7XG4gICAgICAgICAgICAgICAgcmF0ZTogaW5wdXQucmF0ZSxcbiAgICAgICAgICAgICAgICBvdXRwdXQ6IGNoYW5uZWxzW2ldXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbnB1dENoYW5uZWxDYWNoZTtcbiAgICB9O1xuXG4gICAgZmxvY2sudWdlbi5sYXN0T3V0cHV0VmFsdWUgPSBmdW5jdGlvbiAobnVtU2FtcHMsIG91dCkge1xuICAgICAgICByZXR1cm4gb3V0W251bVNhbXBzIC0gMV07XG4gICAgfTtcblxuXG4gICAgZmxvY2sudWdlbi52YWx1ZSA9IGZ1bmN0aW9uIChpbnB1dHMsIG91dHB1dCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgdGhhdCA9IGZsb2NrLnVnZW4oaW5wdXRzLCBvdXRwdXQsIG9wdGlvbnMpO1xuXG4gICAgICAgIHRoYXQudmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhhdC5tb2RlbC52YWx1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0LmR5bmFtaWNHZW4gPSBmdW5jdGlvbiAobnVtU2FtcHMpIHtcbiAgICAgICAgICAgIHZhciBvdXQgPSB0aGF0Lm91dHB1dCxcbiAgICAgICAgICAgICAgICBtID0gdGhhdC5tb2RlbDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1TYW1wczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0W2ldID0gbS51bnNjYWxlZFZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGF0Lm11bEFkZChudW1TYW1wcyk7XG4gICAgICAgICAgICBtLnZhbHVlID0gZmxvY2sudWdlbi5sYXN0T3V0cHV0VmFsdWUobnVtU2FtcHMsIG91dCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5vbklucHV0Q2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dHMgPSB0aGF0LmlucHV0cyxcbiAgICAgICAgICAgICAgICBtID0gdGhhdC5tb2RlbDtcblxuICAgICAgICAgICAgbS52YWx1ZSA9IG0udW5zY2FsZWRWYWx1ZSA9IGlucHV0cy52YWx1ZTtcblxuICAgICAgICAgICAgaWYgKHRoYXQucmF0ZSAhPT0gXCJjb25zdGFudFwiKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5nZW4gPSB0aGF0LmR5bmFtaWNHZW47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoYXQuZ2VuID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmbG9jay5vbk11bEFkZElucHV0Q2hhbmdlZCh0aGF0KTtcbiAgICAgICAgICAgIHRoYXQuZHluYW1pY0dlbigxKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0Lm9uSW5wdXRDaGFuZ2VkKCk7XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgIH07XG5cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsb2NrLnVnZW4udmFsdWVcIiwge1xuICAgICAgICByYXRlOiBcImNvbnRyb2xcIixcblxuICAgICAgICBpbnB1dHM6IHtcbiAgICAgICAgICAgIHZhbHVlOiAxLjAsXG4gICAgICAgICAgICBtdWw6IG51bGwsXG4gICAgICAgICAgICBhZGQ6IG51bGxcbiAgICAgICAgfSxcblxuICAgICAgICB1Z2VuT3B0aW9uczoge1xuICAgICAgICAgICAgbW9kZWw6IHtcbiAgICAgICAgICAgICAgICB1bnNjYWxlZFZhbHVlOiAxLjAsXG4gICAgICAgICAgICAgICAgdmFsdWU6IDEuMFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgdGFnczogW1wiZmxvY2sudWdlbi52YWx1ZVR5cGVcIl1cbiAgICAgICAgfVxuICAgIH0pO1xuXG5cbiAgICBmbG9jay51Z2VuLnNpbGVuY2UgPSBmdW5jdGlvbiAoaW5wdXRzLCBvdXRwdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHRoYXQgPSBmbG9jay51Z2VuKGlucHV0cywgb3V0cHV0LCBvcHRpb25zKTtcblxuICAgICAgICB0aGF0Lm9uSW5wdXRDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGF0Lm91dHB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoYXQub3V0cHV0W2ldID0gMC4wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQub25JbnB1dENoYW5nZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfTtcblxuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmxvY2sudWdlbi5zaWxlbmNlXCIsIHtcbiAgICAgICAgcmF0ZTogXCJjb25zdGFudFwiXG4gICAgfSk7XG5cblxuICAgIGZsb2NrLnVnZW4ucGFzc1Rocm91Z2ggPSBmdW5jdGlvbiAoaW5wdXRzLCBvdXRwdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHRoYXQgPSBmbG9jay51Z2VuKGlucHV0cywgb3V0cHV0LCBvcHRpb25zKTtcblxuICAgICAgICB0aGF0LmdlbiA9IGZ1bmN0aW9uIChudW1TYW1wcykge1xuICAgICAgICAgICAgdmFyIG0gPSB0aGF0Lm1vZGVsLFxuICAgICAgICAgICAgICAgIHNvdXJjZSA9IHRoYXQuaW5wdXRzLnNvdXJjZS5vdXRwdXQsXG4gICAgICAgICAgICAgICAgb3V0ID0gdGhhdC5vdXRwdXQsXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICB2YWw7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvdXRbaV0gPSB2YWwgPSBzb3VyY2VbaV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoOyBpIDwgbnVtU2FtcHM7IGkrKykge1xuICAgICAgICAgICAgICAgIG91dFtpXSA9IHZhbCA9IDAuMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbS51bnNjYWxlZFZhbHVlID0gdmFsO1xuICAgICAgICAgICAgdGhhdC5tdWxBZGQobnVtU2FtcHMpO1xuICAgICAgICAgICAgbS52YWx1ZSA9IGZsb2NrLnVnZW4ubGFzdE91dHB1dFZhbHVlKG51bVNhbXBzLCBvdXQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQub25JbnB1dENoYW5nZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfTtcblxuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmxvY2sudWdlbi5wYXNzVGhyb3VnaFwiLCB7XG4gICAgICAgIHJhdGU6IFwiYXVkaW9cIixcblxuICAgICAgICBpbnB1dHM6IHtcbiAgICAgICAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgICAgICAgIG11bDogbnVsbCxcbiAgICAgICAgICAgIGFkZDogbnVsbFxuICAgICAgICB9XG4gICAgfSk7XG5cblxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgZnJvbSB0aGUgPGNvZGU+aW5pdGlhbDwvY29kZT4gaW5wdXQgdG8gdGhlIDxjb2RlPnRhcmdldDwvY29kZT4gaW5wdXRcbiAgICAgKiBhdCB0aGUgc3BlY2lmaWVkIDxjb2RlPnRpbWU8L2NvZGU+LiBBbiBvcHRpb25hbCA8Y29kZT5jcm9zc2ZhZGU8L2NvZGU+IGR1cmF0aW9uXG4gICAgICogbWF5IGJlIHNwZWNpZmllZCB0byBsaW5lYXJseSBjcm9zc2ZhZGUgYmV0d2VlbiB0aGUgdHdvIGlucHV0cy5cbiAgICAgKlxuICAgICAqIENhbiBiZSB1c2VkIHRvIHNjaGVkdWxlIHNhbXBsZS1hY2N1cmF0ZSBjaGFuZ2VzLlxuICAgICAqIE5vdGUgdGhhdCB0aGUgPGNvZGU+dGFyZ2V0PC9jb2RlPiBpbnB1dCB3aWxsIGJlIGV2YWx1YXRlZCBmcm9tIHRoZSBiZWdpbm5pbmcsXG4gICAgICogZXZlbiBpZiBpdHMgdmFsdWUgaXNuJ3QgeWV0IG91dHB1dC5cbiAgICAgKlxuICAgICAqL1xuICAgIGZsb2NrLnVnZW4uY2hhbmdlID0gZnVuY3Rpb24gKGlucHV0cywgb3V0cHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB0aGF0ID0gZmxvY2sudWdlbihpbnB1dHMsIG91dHB1dCwgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhhdC5nZW4gPSBmdW5jdGlvbiAobnVtU2FtcHMpIHtcbiAgICAgICAgICAgIHZhciBtID0gdGhhdC5tb2RlbCxcbiAgICAgICAgICAgICAgICBpbml0aWFsID0gdGhhdC5pbnB1dHMuaW5pdGlhbC5vdXRwdXQsXG4gICAgICAgICAgICAgICAgaW5pdGlhbEluYyA9IG0uc3RyaWRlcy5pbml0aWFsLFxuICAgICAgICAgICAgICAgIHRhcmdldCA9IHRoYXQuaW5wdXRzLnRhcmdldC5vdXRwdXQsXG4gICAgICAgICAgICAgICAgdGFyZ2V0SW5jID0gbS5zdHJpZGVzLnRhcmdldCxcbiAgICAgICAgICAgICAgICBvdXQgPSB0aGF0Lm91dHB1dCxcbiAgICAgICAgICAgICAgICBzYW1wbGVzTGVmdCA9IG0uc2FtcGxlc0xlZnQsXG4gICAgICAgICAgICAgICAgY3Jvc3NmYWRlTGV2ZWwgPSBtLmNyb3NzZmFkZUxldmVsLFxuICAgICAgICAgICAgICAgIHZhbDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSAwLCBrID0gMDsgaSA8IG51bVNhbXBzOyBpKyssIGogKz0gaW5pdGlhbEluYywgayArPSB0YXJnZXRJbmMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2FtcGxlc0xlZnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmVuJ3QgaGl0IHRoZSBzY2hlZHVsZWQgdGltZSB5ZXQuXG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IGluaXRpYWxbal07XG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZXNMZWZ0LS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjcm9zc2ZhZGVMZXZlbCA+IDAuMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSd2ZSBoaXQgdGhlIHNjaGVkdWxlZCB0aW1lLCBidXQgd2Ugc3RpbGwgbmVlZCB0byBwZWZvcm0gdGhlIGNyb3NzZmFkZS5cbiAgICAgICAgICAgICAgICAgICAgdmFsID0gKGluaXRpYWxbal0gKiBjcm9zc2ZhZGVMZXZlbCkgKyAodGFyZ2V0W2tdICogKDEuMCAtIGNyb3NzZmFkZUxldmVsKSk7XG4gICAgICAgICAgICAgICAgICAgIGNyb3NzZmFkZUxldmVsIC09IG0uY3Jvc3NmYWRlU3RlcFNpemU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UncmUgZG9uZS5cbiAgICAgICAgICAgICAgICAgICAgdmFsID0gdGFyZ2V0W2tdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG91dFtpXSA9IHZhbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbS5zYW1wbGVzTGVmdCA9IHNhbXBsZXNMZWZ0O1xuICAgICAgICAgICAgbS5jcm9zc2ZhZGVMZXZlbCA9IGNyb3NzZmFkZUxldmVsO1xuICAgICAgICAgICAgbS52YWx1ZSA9IG0udW5zY2FsZWRWYWx1ZSA9IHZhbDtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0Lm9uSW5wdXRDaGFuZ2VkID0gZnVuY3Rpb24gKGlucHV0TmFtZSkge1xuICAgICAgICAgICAgdmFyIG0gPSB0aGF0Lm1vZGVsLFxuICAgICAgICAgICAgICAgIGlucHV0cyA9IHRoYXQuaW5wdXRzO1xuXG4gICAgICAgICAgICBpZiAoaW5wdXROYW1lID09PSBcInRpbWVcIiB8fCAhaW5wdXROYW1lKSB7XG4gICAgICAgICAgICAgICAgbS5zYW1wbGVzTGVmdCA9IE1hdGgucm91bmQoaW5wdXRzLnRpbWUub3V0cHV0WzBdICogbS5zYW1wbGVSYXRlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlucHV0TmFtZSA9PT0gXCJjcm9zc2ZhZGVcIiB8fCAhaW5wdXROYW1lKSB7XG4gICAgICAgICAgICAgICAgbS5jcm9zc2ZhZGVTdGVwU2l6ZSA9IDEuMCAvIE1hdGgucm91bmQoaW5wdXRzLmNyb3NzZmFkZS5vdXRwdXRbMF0gKiBtLnNhbXBsZVJhdGUpO1xuICAgICAgICAgICAgICAgIG0uY3Jvc3NmYWRlTGV2ZWwgPSBpbnB1dHMuY3Jvc3NmYWRlLm91dHB1dFswXSA+IDAuMCA/IDEuMCA6IDAuMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhhdC5jYWxjdWxhdGVTdHJpZGVzKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5vbklucHV0Q2hhbmdlZCgpO1xuXG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgIH07XG5cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsb2NrLnVnZW4uY2hhbmdlXCIsIHtcbiAgICAgICAgcmF0ZTogXCJhdWRpb1wiLFxuXG4gICAgICAgIGlucHV0czoge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBbiBpbnB1dCB1bml0IGdlbmVyYXRvciB0byBvdXRwdXQgaW5pdGlhbGx5LlxuICAgICAgICAgICAgICogQ2FuIGJlIGF1ZGlvLCBjb250cm9sLCBvciBjb25zdGFudCByYXRlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpbml0aWFsOiAwLjAsXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHVuaXQgZ2VuZXJhdG9yIHRvIG91dHB1dCBhZnRlciB0aGUgc3BlY2lmaWVkIHRpbWUuXG4gICAgICAgICAgICAgKiBDYW4gYmUgYXVkaW8sIGNvbnRyb2wsIG9yIGNvbnN0YW50IHJhdGUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRhcmdldDogMC4wLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSBzYW1wbGUtYWNjdXJhdGUgdGltZSAoaW4gc2Vjb25kcykgYXQgd2hpY2ggdGhlXG4gICAgICAgICAgICAgKiB0aGUgY2hhbmdlIHNob3VsZCBvY2N1ci5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGltZTogMC4wLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSBkdXJhdGlvbiBvZiB0aGUgb3B0aW9uYWwgbGluZWFyIGNyb3NzZmFkZSBiZXR3ZWVuXG4gICAgICAgICAgICAgKiB0aGUgdHdvIHZhbHVlcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY3Jvc3NmYWRlOiAwLjBcbiAgICAgICAgfSxcblxuICAgICAgICB1Z2VuT3B0aW9uczoge1xuICAgICAgICAgICAgbW9kZWw6IHtcbiAgICAgICAgICAgICAgICBzYW1wbGVzTGVmdDogMC4wLFxuICAgICAgICAgICAgICAgIGNyb3NzZmFkZVN0ZXBTaXplOiAwLFxuICAgICAgICAgICAgICAgIGNyb3NzZmFkZUxldmVsOiAwLjAsXG4gICAgICAgICAgICAgICAgdW5zY2FsZWRWYWx1ZTogMC4wLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAwLjBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdHJpZGVJbnB1dHM6IFtcImluaXRpYWxcIiwgXCJ0YXJnZXRcIl1cbiAgICAgICAgfVxuICAgIH0pO1xuXG5cbiAgICBmbG9jay51Z2VuLnZhbHVlQ2hhbmdlVHJpZ2dlciA9IGZ1bmN0aW9uIChpbnB1dHMsIG91dHB1dCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgdGhhdCA9IGZsb2NrLnVnZW4oaW5wdXRzLCBvdXRwdXQsIG9wdGlvbnMpO1xuXG4gICAgICAgIHRoYXQuZ2VuID0gZnVuY3Rpb24gKG51bVNhbXBzKSB7XG4gICAgICAgICAgICB2YXIgbSA9IHRoYXQubW9kZWwsXG4gICAgICAgICAgICAgICAgc291cmNlID0gdGhhdC5pbnB1dHMuc291cmNlLm91dHB1dCxcbiAgICAgICAgICAgICAgICBvdXQgPSB0aGF0Lm91dHB1dCxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIGosXG4gICAgICAgICAgICAgICAgdmFsO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IG51bVNhbXBzOyBpKyssIGogKz0gbS5zdHJpZGVzLnNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHZhbCA9IHNvdXJjZVtqXTtcbiAgICAgICAgICAgICAgICBvdXRbaV0gPSB2YWwgIT09IG0ucHJldlZhbCA/IDEuMCA6IDAuMDtcbiAgICAgICAgICAgICAgICBtLnByZXZWYWwgPSB2YWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG0udmFsdWUgPSBtLnVuc2NhbGVkVmFsdWUgPSB2YWw7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5vbklucHV0Q2hhbmdlZCA9IGZ1bmN0aW9uIChpbnB1dE5hbWUpIHtcbiAgICAgICAgICAgIHRoYXQuY2FsY3VsYXRlU3RyaWRlcygpO1xuXG4gICAgICAgICAgICBpZiAoaW5wdXROYW1lID09PSBcInNvdXJjZVwiKSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yY2UgYSB0cmlnZ2VyIHRvIGJlIG91dHB1dCB3aGVuZXZlciB0aGUgaW5wdXQgaXMgY2hhbmdlZCxcbiAgICAgICAgICAgICAgICAvLyBldmVuIGlmIGl0J3MgdGhlIHNhbWUgdmFsdWUgYXMgd2FzIHByZXZpb3VzbHkgaGVsZC5cbiAgICAgICAgICAgICAgICB0aGF0Lm1vZGVsLnByZXZWYWwgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQuY2FsY3VsYXRlU3RyaWRlcygpO1xuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICB9O1xuXG4gICAgZmx1aWQuZGVmYXVsdHMoXCJmbG9jay51Z2VuLnZhbHVlQ2hhbmdlVHJpZ2dlclwiLCB7XG4gICAgICAgIHJhdGU6IFwiY29udHJvbFwiLFxuXG4gICAgICAgIGlucHV0czoge1xuICAgICAgICAgICAgc291cmNlOiAwLjBcbiAgICAgICAgfSxcbiAgICAgICAgdWdlbk9wdGlvbnM6IHtcbiAgICAgICAgICAgIG1vZGVsOiB7XG4gICAgICAgICAgICAgICAgdW5zY2FsZWRWYWx1ZTogMC4wLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAwLjAsXG4gICAgICAgICAgICAgICAgcHJldlZhbDogMC4wXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzdHJpZGVJbnB1dHM6IFtcInNvdXJjZVwiXVxuICAgICAgICB9XG4gICAgfSk7XG5cblxuICAgIGZsb2NrLnVnZW4uaW5wdXRDaGFuZ2VUcmlnZ2VyID0gZnVuY3Rpb24gKGlucHV0cywgb3V0cHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB0aGF0ID0gZmxvY2sudWdlbihpbnB1dHMsIG91dHB1dCwgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhhdC5nZW4gPSBmdW5jdGlvbiAobnVtU2FtcHMpIHtcbiAgICAgICAgICAgIHZhciBtID0gdGhhdC5tb2RlbCxcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSB0aGF0LmlucHV0cy5zb3VyY2Uub3V0cHV0LFxuICAgICAgICAgICAgICAgIHNvdXJjZUluYyA9IG0uc3RyaWRlcy5zb3VyY2UsXG4gICAgICAgICAgICAgICAgZHVyYXRpb24gPSB0aGF0LmlucHV0cy5kdXJhdGlvbi5vdXRwdXQsXG4gICAgICAgICAgICAgICAgZHVyYXRpb25JbmMgPSBtLnN0cmlkZXMuZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgcHJldkR1ciA9IG0ucHJldkR1cixcbiAgICAgICAgICAgICAgICBvdXQgPSB0aGF0Lm91dHB1dCxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIGosXG4gICAgICAgICAgICAgICAgayxcbiAgICAgICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICAgICAgZHVyO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSBqID0gayA9IDA7IGkgPCBudW1TYW1wczsgaSsrLCBqICs9IHNvdXJjZUluYywgayArPSBkdXJhdGlvbkluYykge1xuICAgICAgICAgICAgICAgIHZhbCA9IHNvdXJjZVtqXTtcbiAgICAgICAgICAgICAgICBkdXIgPSBkdXJhdGlvbltrXTtcblxuICAgICAgICAgICAgICAgIGlmIChkdXIgIT09IHByZXZEdXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbS5wcmV2RHVyID0gZHVyO1xuICAgICAgICAgICAgICAgICAgICBtLnJlbWFpbmluZ09wZW5TYW1wbGVzID0gdmFsID4gMCA/IChkdXIgPiAwID8gbS5zYW1wbGVSYXRlICogZHVyIDogMSkgOiAwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChtLnJlbWFpbmluZ09wZW5TYW1wbGVzID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBvdXRbaV0gPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgIG0ucmVtYWluaW5nT3BlblNhbXBsZXMtLTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdXRbaV0gPSAwLjA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtLnZhbHVlID0gbS51bnNjYWxlZFZhbHVlID0gZmxvY2sudWdlbi5sYXN0T3V0cHV0VmFsdWUobnVtU2FtcHMsIG91dCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5vbklucHV0Q2hhbmdlZCA9IGZ1bmN0aW9uIChpbnB1dE5hbWUpIHtcbiAgICAgICAgICAgIHRoYXQuY2FsY3VsYXRlU3RyaWRlcygpO1xuXG4gICAgICAgICAgICBpZiAoaW5wdXROYW1lID09PSBcInNvdXJjZVwiKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5tb2RlbC5wcmV2RHVyID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0LmNhbGN1bGF0ZVN0cmlkZXMoKTtcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfTtcblxuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmxvY2sudWdlbi5pbnB1dENoYW5nZVRyaWdnZXJcIiwge1xuICAgICAgICByYXRlOiBcImNvbnRyb2xcIixcblxuICAgICAgICBpbnB1dHM6IHtcbiAgICAgICAgICAgIHNvdXJjZTogMCxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0sXG5cbiAgICAgICAgdWdlbk9wdGlvbnM6IHtcbiAgICAgICAgICAgIG1vZGVsOiB7XG4gICAgICAgICAgICAgICAgdW5zY2FsZWRWYWx1ZTogMC4wLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAwLjAsXG4gICAgICAgICAgICAgICAgcHJldkR1cmF0aW9uOiAwLFxuICAgICAgICAgICAgICAgIHJlbWFpbmluZ09wZW5TYW1wbGVzOiAwXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzdHJpZGVJbnB1dHM6IFtcInNvdXJjZVwiLCBcImR1cmF0aW9uXCJdXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZsb2NrLnVnZW4udHJpZ2dlckNhbGxiYWNrID0gZnVuY3Rpb24gKGlucHV0cywgb3V0cHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB0aGF0ID0gZmxvY2sudWdlbihpbnB1dHMsIG91dHB1dCwgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhhdC5nZW4gPSBmdW5jdGlvbiAobnVtU2FtcHMpIHtcbiAgICAgICAgICAgIHZhciBtID0gdGhhdC5tb2RlbCxcbiAgICAgICAgICAgICAgICBvID0gdGhhdC5vcHRpb25zLFxuICAgICAgICAgICAgICAgIG91dCA9IHRoYXQub3V0cHV0LFxuICAgICAgICAgICAgICAgIGlucHV0cyA9IHRoYXQuaW5wdXRzLFxuICAgICAgICAgICAgICAgIHRyaWdnZXJJbmMgPSBtLnN0cmlkZXMudHJpZ2dlcixcbiAgICAgICAgICAgICAgICBzb3VyY2VJbmMgPSBtLnN0cmlkZXMuc291cmNlLFxuICAgICAgICAgICAgICAgIHRyaWcgPSBpbnB1dHMudHJpZ2dlci5vdXRwdXQsXG4gICAgICAgICAgICAgICAgc291cmNlID0gaW5wdXRzLnNvdXJjZS5vdXRwdXQsXG4gICAgICAgICAgICAgICAgY2JTcGVjID0gby5jYWxsYmFjayxcbiAgICAgICAgICAgICAgICBmbiA9IGNiU3BlYy5mdW5jLFxuICAgICAgICAgICAgICAgIGFyZ3MgPSBjYlNwZWMuYXJncyxcbiAgICAgICAgICAgICAgICBjYlRoaXMgPSBjYlNwZWMudGhpcyxcbiAgICAgICAgICAgICAgICBsYXN0QXJnSWR4ID0gbS5sYXN0QXJnSWR4LFxuICAgICAgICAgICAgICAgIHByZXZUcmlnID0gbS5wcmV2VHJpZyxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIGosXG4gICAgICAgICAgICAgICAgayxcbiAgICAgICAgICAgICAgICBjdXJyVHJpZyxcbiAgICAgICAgICAgICAgICBzb3VyY2VWYWw7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IGogPSBrID0gMDsgaSA8IG51bVNhbXBzOyBpKyssIGogKz0gdHJpZ2dlckluYywgayArPSBzb3VyY2VJbmMpIHtcbiAgICAgICAgICAgICAgICBjdXJyVHJpZyA9IHRyaWdbal07XG4gICAgICAgICAgICAgICAgc291cmNlVmFsID0gc291cmNlW2tdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJUcmlnID4gMC4wICYmIHByZXZUcmlnIDw9IDAuMCAmJiBmbikge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbnNlcnQgdGhlIGN1cnJlbnQgc291cmNlIHZhbHVlIGludG8gdGhlIGFyZ3VtZW50cyBsaXN0XG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCB0aGVuIGludm9rZSB0aGUgc3BlY2lmaWVkIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICAgICAgICBhcmdzW2xhc3RBcmdJZHhdID0gc291cmNlVmFsO1xuICAgICAgICAgICAgICAgICAgICBmbi5hcHBseShjYlRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG91dFtpXSA9IHNvdXJjZVZhbDtcbiAgICAgICAgICAgICAgICBwcmV2VHJpZyA9IGN1cnJUcmlnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtLnByZXZUcmlnID0gcHJldlRyaWc7XG4gICAgICAgICAgICBtLnZhbHVlID0gbS51bnNjYWxlZFZhbHVlID0gc291cmNlVmFsO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQub25JbnB1dENoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbyA9IHRoYXQub3B0aW9ucyxcbiAgICAgICAgICAgICAgICBtID0gdGhhdC5tb2RlbCxcbiAgICAgICAgICAgICAgICBjYlNwZWMgPSBvLmNhbGxiYWNrLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lID0gY2JTcGVjLmZ1bmNOYW1lO1xuXG4gICAgICAgICAgICBpZiAoZnVuY05hbWUpIHtcbiAgICAgICAgICAgICAgICBjYlNwZWMuZnVuYyA9IGZsdWlkLmdldEdsb2JhbFZhbHVlKGZ1bmNOYW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2JTcGVjLnRoaXMgJiYgY2JTcGVjLm1ldGhvZCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2JTcGVjLnRoaXMgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZmxvY2sudWdlbi50cmlnZ2VyQ2FsbGJhY2sgZG9lc24ndCBzdXBwb3J0IHJhdyAndGhpcycgb2JqZWN0cy5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlVzZSBhIGdsb2JhbCBrZXkgcGF0aCBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2JTcGVjLnRoaXMgPSB0eXBlb2YgY2JTcGVjLnRoaXMgPT09IFwic3RyaW5nXCIgP1xuICAgICAgICAgICAgICAgICAgICBmbHVpZC5nZXRHbG9iYWxWYWx1ZShjYlNwZWMudGhpcykgOiBjYlNwZWMudGhpcztcbiAgICAgICAgICAgICAgICBjYlNwZWMuZnVuYyA9IGZsdWlkLmdldChjYlNwZWMudGhpcywgY2JTcGVjLm1ldGhvZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG0ubGFzdEFyZ0lkeCA9IGNiU3BlYy5hcmdzLmxlbmd0aDtcbiAgICAgICAgICAgIHRoYXQuY2FsY3VsYXRlU3RyaWRlcygpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQub25JbnB1dENoYW5nZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfTtcblxuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmxvY2sudWdlbi50cmlnZ2VyQ2FsbGJhY2tcIiwge1xuICAgICAgICByYXRlOiBcImF1ZGlvXCIsXG4gICAgICAgIGlucHV0czoge1xuICAgICAgICAgICAgc291cmNlOiAwLFxuICAgICAgICAgICAgdHJpZ2dlcjogMFxuICAgICAgICB9LFxuICAgICAgICB1Z2VuT3B0aW9uczoge1xuICAgICAgICAgICAgbW9kZWw6IHtcbiAgICAgICAgICAgICAgICB1bnNjYWxlZFZhbHVlOiAwLjAsXG4gICAgICAgICAgICAgICAgdmFsdWU6IDAuMCxcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGxhc3RBcmdJZHg6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYWxsYmFjazoge1xuICAgICAgICAgICAgICAgIFwidGhpc1wiOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgZnVuYzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RyaWRlSW5wdXRzOiBbXCJzb3VyY2VcIiwgXCJ0cmlnZ2VyXCJdXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZsb2NrLnVnZW4ubWF0aCA9IGZ1bmN0aW9uIChpbnB1dHMsIG91dHB1dCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgdGhhdCA9IGZsb2NrLnVnZW4oaW5wdXRzLCBvdXRwdXQsIG9wdGlvbnMpO1xuICAgICAgICB0aGF0LmV4cGFuZGVkU291cmNlID0gbmV3IEZsb2F0MzJBcnJheSh0aGF0Lm9wdGlvbnMuYXVkaW9TZXR0aW5ncy5ibG9ja1NpemUpO1xuXG4gICAgICAgIHRoYXQua3JTb3VyY2VLcklucHV0R2VuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG0gPSB0aGF0Lm1vZGVsLFxuICAgICAgICAgICAgICAgIG9wID0gdGhhdC5hY3RpdmVJbnB1dCxcbiAgICAgICAgICAgICAgICBpbnB1dCA9IHRoYXQuaW5wdXRzW29wXSxcbiAgICAgICAgICAgICAgICBvdXQgPSB0aGF0Lm91dHB1dCxcbiAgICAgICAgICAgICAgICBzb3VyY2VCdWYgPSBmbG9jay5nZW5lcmF0ZSh0aGF0LmV4cGFuZGVkU291cmNlLCB0aGF0LmlucHV0cy5zb3VyY2Uub3V0cHV0WzBdKTtcblxuICAgICAgICAgICAgRFNQW29wXShvdXQsIHNvdXJjZUJ1ZiwgaW5wdXQub3V0cHV0WzBdKTtcbiAgICAgICAgICAgIG0udmFsdWUgPSBtLnVuc2NhbGVkVmFsdWUgPSBvdXRbb3V0Lmxlbmd0aCAtIDFdO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQua3JTb3VyY2VBcklucHV0R2VuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG0gPSB0aGF0Lm1vZGVsLFxuICAgICAgICAgICAgICAgIG9wID0gdGhhdC5hY3RpdmVJbnB1dCxcbiAgICAgICAgICAgICAgICBpbnB1dCA9IHRoYXQuaW5wdXRzW29wXSxcbiAgICAgICAgICAgICAgICBvdXQgPSB0aGF0Lm91dHB1dCxcbiAgICAgICAgICAgICAgICBzb3VyY2VCdWYgPSBmbG9jay5nZW5lcmF0ZSh0aGF0LmV4cGFuZGVkU291cmNlLCB0aGF0LmlucHV0cy5zb3VyY2Uub3V0cHV0WzBdKTtcblxuICAgICAgICAgICAgRFNQW29wXShvdXQsIHNvdXJjZUJ1ZiwgaW5wdXQub3V0cHV0KTtcbiAgICAgICAgICAgIG0udmFsdWUgPSBtLnVuc2NhbGVkVmFsdWUgPSBvdXRbb3V0Lmxlbmd0aCAtIDFdO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQuYXJTb3VyY2VLcklucHV0R2VuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG0gPSB0aGF0Lm1vZGVsLFxuICAgICAgICAgICAgICAgIG9wID0gdGhhdC5hY3RpdmVJbnB1dCxcbiAgICAgICAgICAgICAgICBpbnB1dCA9IHRoYXQuaW5wdXRzW29wXSxcbiAgICAgICAgICAgICAgICBvdXQgPSB0aGF0Lm91dHB1dCxcbiAgICAgICAgICAgICAgICBzb3VyY2VCdWYgPSB0aGF0LmlucHV0cy5zb3VyY2Uub3V0cHV0O1xuXG4gICAgICAgICAgICBEU1Bbb3BdKG91dCwgc291cmNlQnVmLCBpbnB1dC5vdXRwdXRbMF0pO1xuICAgICAgICAgICAgbS52YWx1ZSA9IG0udW5zY2FsZWRWYWx1ZSA9IG91dFtvdXQubGVuZ3RoIC0gMV07XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5hclNvdXJjZUFySW5wdXRHZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbSA9IHRoYXQubW9kZWwsXG4gICAgICAgICAgICAgICAgb3AgPSB0aGF0LmFjdGl2ZUlucHV0LFxuICAgICAgICAgICAgICAgIGlucHV0ID0gdGhhdC5pbnB1dHNbb3BdLFxuICAgICAgICAgICAgICAgIG91dCA9IHRoYXQub3V0cHV0O1xuXG4gICAgICAgICAgICBEU1Bbb3BdKHRoYXQub3V0cHV0LCB0aGF0LmlucHV0cy5zb3VyY2Uub3V0cHV0LCBpbnB1dC5vdXRwdXQpO1xuICAgICAgICAgICAgbS52YWx1ZSA9IG0udW5zY2FsZWRWYWx1ZSA9IG91dFtvdXQubGVuZ3RoIC0gMV07XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5vbklucHV0Q2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIGZpcnN0IGlucHV0IGFuZCB1c2UgaXQuIE11bHRpcGxlIGlucHV0dGVycywgYmV3YXJlLlxuICAgICAgICAgICAgLy8gVE9ETzogU3VwcG9ydCBtdWx0aXBsZSBvcGVyYXRpb25zLlxuICAgICAgICAgICAgdmFyIGlucHV0cyA9IE9iamVjdC5rZXlzKHRoYXQuaW5wdXRzKSxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIGlzSW5wdXRBdWRpb1JhdGU7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpbnB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IGlucHV0c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQgIT09IFwic291cmNlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5hY3RpdmVJbnB1dCA9IGlucHV0O1xuICAgICAgICAgICAgICAgICAgICBpc0lucHV0QXVkaW9SYXRlID0gdGhhdC5pbnB1dHNbaW5wdXRdLnJhdGUgPT09IFwiYXVkaW9cIjtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5nZW4gPSB0aGF0LmlucHV0cy5zb3VyY2UucmF0ZSA9PT0gXCJhdWRpb1wiID9cbiAgICAgICAgICAgICAgICAgICAgICAgIChpc0lucHV0QXVkaW9SYXRlID8gdGhhdC5hclNvdXJjZUFySW5wdXRHZW4gOiB0aGF0LmFyU291cmNlS3JJbnB1dEdlbikgOlxuICAgICAgICAgICAgICAgICAgICAgICAgKGlzSW5wdXRBdWRpb1JhdGUgPyB0aGF0LmtyU291cmNlQXJJbnB1dEdlbiA6IHRoYXQua3JTb3VyY2VLcklucHV0R2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKERTUCkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEU1AgaXMgdW5kZWZpbmVkLiBQbGVhc2UgaW5jbHVkZSBkc3BhcGkuanMgdG8gdXNlIHRoZSBmbG9jay5tYXRoIHVuaXQgZ2VuZXJhdG9yLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoYXQub25JbnB1dENoYW5nZWQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0LmluaXQoKTtcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfTtcblxuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmxvY2sudWdlbi5tYXRoXCIsIHtcbiAgICAgICAgcmF0ZTogXCJhdWRpb1wiLFxuICAgICAgICBpbnB1dHM6IHtcbiAgICAgICAgICAgIC8vIEFueSBXZWIgQXJyYXkgTWF0aCBvcGVyYXRvciBpcyBzdXBwb3J0ZWQgYXMgYW4gaW5wdXQuXG4gICAgICAgICAgICBzb3VyY2U6IG51bGxcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cbiAgICBmbG9jay51Z2VuLnN1bSA9IGZ1bmN0aW9uIChpbnB1dHMsIG91dHB1dCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgdGhhdCA9IGZsb2NrLnVnZW4oaW5wdXRzLCBvdXRwdXQsIG9wdGlvbnMpO1xuXG4gICAgICAgIHRoYXQuY29weUdlbiA9IGZ1bmN0aW9uIChudW1TYW1wcykge1xuICAgICAgICAgICAgdmFyIG0gPSB0aGF0Lm1vZGVsLFxuICAgICAgICAgICAgICAgIG91dCA9IHRoYXQub3V0cHV0LFxuICAgICAgICAgICAgICAgIHNvdXJjZSA9IHRoYXQuaW5wdXRzLnNvdXJjZXMub3V0cHV0LFxuICAgICAgICAgICAgICAgIGk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1TYW1wczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0W2ldID0gc291cmNlW2ldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtLnZhbHVlID0gbS51bnNjYWxlZFZhbHVlID0gZmxvY2sudWdlbi5sYXN0T3V0cHV0VmFsdWUobnVtU2FtcHMsIG91dCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5zdW1HZW4gPSBmdW5jdGlvbiAobnVtU2FtcHMpIHtcbiAgICAgICAgICAgIHZhciBtID0gdGhhdC5tb2RlbCxcbiAgICAgICAgICAgICAgICBzb3VyY2VzID0gdGhhdC5pbnB1dHMuc291cmNlcyxcbiAgICAgICAgICAgICAgICBvdXQgPSB0aGF0Lm91dHB1dCxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIHNvdXJjZUlkeCxcbiAgICAgICAgICAgICAgICBzdW07XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1TYW1wczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc3VtID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKHNvdXJjZUlkeCA9IDA7IHNvdXJjZUlkeCA8IHNvdXJjZXMubGVuZ3RoOyBzb3VyY2VJZHgrKykge1xuICAgICAgICAgICAgICAgICAgICBzdW0gKz0gc291cmNlc1tzb3VyY2VJZHhdLm91dHB1dFtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0W2ldID0gc3VtO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtLnZhbHVlID0gbS51bnNjYWxlZFZhbHVlID0gZmxvY2sudWdlbi5sYXN0T3V0cHV0VmFsdWUobnVtU2FtcHMsIG91dCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5vbklucHV0Q2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKHRoYXQuaW5wdXRzLnNvdXJjZXMubGVuZ3RoKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgYW4gYXJyYXkgb2Ygc291cmNlcyB0aGF0IG5lZWQgdG8gYmUgc3VtbWVkLlxuICAgICAgICAgICAgICAgIHRoYXQuZ2VuID0gdGhhdC5zdW1HZW47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoYXQuZ2VuID0gdGhhdC5jb3B5R2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQub25JbnB1dENoYW5nZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfTtcblxuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmxvY2sudWdlbi5zdW1cIiwge1xuICAgICAgICByYXRlOiBcImF1ZGlvXCIsXG4gICAgICAgIGlucHV0czoge1xuICAgICAgICAgICAgc291cmNlczogbnVsbFxuICAgICAgICB9XG4gICAgfSk7XG5cblxuICAgIC8qKioqKioqKioqKioqKipcbiAgICAgKiBPc2NpbGxhdG9ycyAqXG4gICAgICoqKioqKioqKioqKioqKi9cblxuICAgIGZsb2NrLnVnZW4ub3NjID0gZnVuY3Rpb24gKGlucHV0cywgb3V0cHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB0aGF0ID0gZmxvY2sudWdlbihpbnB1dHMsIG91dHB1dCwgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhhdC5nZW4gPSBmdW5jdGlvbiAobnVtU2FtcHMpIHtcbiAgICAgICAgICAgIHZhciBtID0gdGhhdC5tb2RlbCxcbiAgICAgICAgICAgICAgICBpbnB1dHMgPSB0aGF0LmlucHV0cyxcbiAgICAgICAgICAgICAgICBmcmVxID0gaW5wdXRzLmZyZXEub3V0cHV0LFxuICAgICAgICAgICAgICAgIHBoYXNlT2Zmc2V0ID0gaW5wdXRzLnBoYXNlLm91dHB1dCxcbiAgICAgICAgICAgICAgICB0YWJsZSA9IGlucHV0cy50YWJsZSxcbiAgICAgICAgICAgICAgICB0YWJsZUxlbiA9IG0udGFibGVMZW4sXG4gICAgICAgICAgICAgICAgdGFibGVJbmNIeiA9IG0udGFibGVJbmNIeixcbiAgICAgICAgICAgICAgICB0YWJsZUluY1JhZCA9IG0udGFibGVJbmNSYWQsXG4gICAgICAgICAgICAgICAgb3V0ID0gdGhhdC5vdXRwdXQsXG4gICAgICAgICAgICAgICAgcGhhc2UgPSBtLnBoYXNlLFxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgaixcbiAgICAgICAgICAgICAgICBrLFxuICAgICAgICAgICAgICAgIGlkeCxcbiAgICAgICAgICAgICAgICB2YWw7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGogPSAwLCBrID0gMDsgaSA8IG51bVNhbXBzOyBpKyssIGogKz0gbS5zdHJpZGVzLnBoYXNlLCBrICs9IG0uc3RyaWRlcy5mcmVxKSB7XG4gICAgICAgICAgICAgICAgaWR4ID0gcGhhc2UgKyBwaGFzZU9mZnNldFtqXSAqIHRhYmxlSW5jUmFkO1xuICAgICAgICAgICAgICAgIGlmIChpZHggPj0gdGFibGVMZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWR4IC09IHRhYmxlTGVuO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaWR4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBpZHggKz0gdGFibGVMZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dFtpXSA9IHZhbCA9IHRoYXQuaW50ZXJwb2xhdGUoaWR4LCB0YWJsZSk7XG4gICAgICAgICAgICAgICAgcGhhc2UgKz0gZnJlcVtrXSAqIHRhYmxlSW5jSHo7XG4gICAgICAgICAgICAgICAgaWYgKHBoYXNlID49IHRhYmxlTGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHBoYXNlIC09IHRhYmxlTGVuO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGhhc2UgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHBoYXNlICs9IHRhYmxlTGVuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbS5waGFzZSA9IHBoYXNlO1xuICAgICAgICAgICAgbS51bnNjYWxlZFZhbHVlID0gdmFsO1xuICAgICAgICAgICAgdGhhdC5tdWxBZGQobnVtU2FtcHMpO1xuICAgICAgICAgICAgbS52YWx1ZSA9IGZsb2NrLnVnZW4ubGFzdE91dHB1dFZhbHVlKG51bVNhbXBzLCBvdXQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQub25JbnB1dENoYW5nZWQgPSBmdW5jdGlvbiAoaW5wdXROYW1lKSB7XG4gICAgICAgICAgICBmbG9jay51Z2VuLm9zYy5vbklucHV0Q2hhbmdlZCh0aGF0KTtcblxuICAgICAgICAgICAgLy8gUHJlY2FsY3VsYXRlIHRhYmxlLXJlbGF0ZWQgdmFsdWVzLlxuICAgICAgICAgICAgaWYgKCFpbnB1dE5hbWUgfHwgaW5wdXROYW1lID09PSBcInRhYmxlXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbSA9IHRoYXQubW9kZWwsXG4gICAgICAgICAgICAgICAgICAgIHRhYmxlID0gdGhhdC5pbnB1dHMudGFibGU7XG5cbiAgICAgICAgICAgICAgICBpZiAodGFibGUubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgICAgICAgICB0YWJsZSA9IHRoYXQuaW5wdXRzLnRhYmxlID0gZmxvY2sudWdlbi5vc2MuZW1wdHlUYWJsZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtLnRhYmxlTGVuID0gdGFibGUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIG0udGFibGVJbmNIeiA9IG0udGFibGVMZW4gLyBtLnNhbXBsZVJhdGU7XG4gICAgICAgICAgICAgICAgbS50YWJsZUluY1JhZCA9ICBtLnRhYmxlTGVuIC8gZmxvY2suVFdPUEk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5vbklucHV0Q2hhbmdlZCgpO1xuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICB9O1xuXG4gICAgZmxvY2sudWdlbi5vc2MuZW1wdHlUYWJsZSA9IG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDBdKTtcblxuICAgIGZsb2NrLnVnZW4ub3NjLm9uSW5wdXRDaGFuZ2VkID0gZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgICAgdGhhdC5jYWxjdWxhdGVTdHJpZGVzKCk7XG4gICAgICAgIGZsb2NrLm9uTXVsQWRkSW5wdXRDaGFuZ2VkKHRoYXQpO1xuICAgIH07XG5cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsb2NrLnVnZW4ub3NjXCIsIHtcbiAgICAgICAgcmF0ZTogXCJhdWRpb1wiLFxuICAgICAgICBpbnB1dHM6IHtcbiAgICAgICAgICAgIGZyZXE6IDQ0MC4wLFxuICAgICAgICAgICAgcGhhc2U6IDAuMCxcbiAgICAgICAgICAgIHRhYmxlOiBbXSxcbiAgICAgICAgICAgIG11bDogbnVsbCxcbiAgICAgICAgICAgIGFkZDogbnVsbFxuICAgICAgICB9LFxuICAgICAgICB1Z2VuT3B0aW9uczoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGlvbjogXCJsaW5lYXJcIixcbiAgICAgICAgICAgIG1vZGVsOiB7XG4gICAgICAgICAgICAgICAgcGhhc2U6IDAuMCxcbiAgICAgICAgICAgICAgICB1bnNjYWxlZFZhbHVlOiAwLjAsXG4gICAgICAgICAgICAgICAgdmFsdWU6IDAuMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0cmlkZUlucHV0czogW1xuICAgICAgICAgICAgICAgIFwiZnJlcVwiLFxuICAgICAgICAgICAgICAgIFwicGhhc2VcIlxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICB0YWJsZVNpemU6IDgxOTJcbiAgICB9KTtcblxuICAgIGZsb2NrLnVnZW4ub3NjLmRlZmluZSA9IGZ1bmN0aW9uIChuYW1lLCB0YWJsZUZpbGxGbikge1xuICAgICAgICB2YXIgbGFzdFNlZ0lkeCA9IG5hbWUubGFzdEluZGV4T2YoXCIuXCIpLFxuICAgICAgICAgICAgbmFtZXNwYWNlID0gbmFtZS5zdWJzdHJpbmcoMCwgbGFzdFNlZ0lkeCksXG4gICAgICAgICAgICBvc2NOYW1lID0gbmFtZS5zdWJzdHJpbmcobGFzdFNlZ0lkeCArIDEpLFxuICAgICAgICAgICAgbmFtZXNwYWNlT2JqID0gZmxvY2suZ2V0KG5hbWVzcGFjZSk7XG5cbiAgICAgICAgbmFtZXNwYWNlT2JqW29zY05hbWVdID0gZnVuY3Rpb24gKGlucHV0cywgb3V0cHV0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBBd2t3YXJkIG9wdGlvbnMgcHJlLW1lcmdpbmcuIFJlZmFjdG9yIG9zYyBBUEkuXG4gICAgICAgICAgICB2YXIgZGVmYXVsdHMgPSBmbHVpZC5kZWZhdWx0cyhcImZsb2NrLnVnZW4ub3NjXCIpLFxuICAgICAgICAgICAgICAgIG1lcmdlZCA9IGZsdWlkLm1lcmdlKG51bGwsIGRlZmF1bHRzLCBvcHRpb25zKSxcbiAgICAgICAgICAgICAgICBzID0gbWVyZ2VkLnRhYmxlU2l6ZTtcbiAgICAgICAgICAgIGlucHV0cy50YWJsZSA9IGZsb2NrLmZpbGxUYWJsZShzLCB0YWJsZUZpbGxGbik7XG4gICAgICAgICAgICByZXR1cm4gZmxvY2sudWdlbi5vc2MoaW5wdXRzLCBvdXRwdXQsIG9wdGlvbnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZsdWlkLmRlZmF1bHRzKG5hbWUsIGZsdWlkLmRlZmF1bHRzKFwiZmxvY2sudWdlbi5vc2NcIikpO1xuICAgIH07XG5cbiAgICBmbG9jay51Z2VuLm9zYy5kZWZpbmUoXCJmbG9jay51Z2VuLnNpbk9zY1wiLCBmbG9jay50YWJsZUdlbmVyYXRvcnMuc2luKTtcbiAgICBmbG9jay51Z2VuLm9zYy5kZWZpbmUoXCJmbG9jay51Z2VuLnRyaU9zY1wiLCBmbG9jay50YWJsZUdlbmVyYXRvcnMudHJpKTtcbiAgICBmbG9jay51Z2VuLm9zYy5kZWZpbmUoXCJmbG9jay51Z2VuLnNhd09zY1wiLCBmbG9jay50YWJsZUdlbmVyYXRvcnMuc2F3KTtcbiAgICBmbG9jay51Z2VuLm9zYy5kZWZpbmUoXCJmbG9jay51Z2VuLnNxdWFyZU9zY1wiLCBmbG9jay50YWJsZUdlbmVyYXRvcnMuc3F1YXJlKTtcblxuXG4gICAgZmxvY2sudWdlbi5zaW4gPSBmdW5jdGlvbiAoaW5wdXRzLCBvdXRwdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHRoYXQgPSBmbG9jay51Z2VuKGlucHV0cywgb3V0cHV0LCBvcHRpb25zKTtcblxuICAgICAgICB0aGF0LmdlbiA9IGZ1bmN0aW9uIChudW1TYW1wcykge1xuICAgICAgICAgICAgdmFyIG0gPSB0aGF0Lm1vZGVsLFxuICAgICAgICAgICAgICAgIGZyZXEgPSB0aGF0LmlucHV0cy5mcmVxLm91dHB1dCxcbiAgICAgICAgICAgICAgICBwaGFzZU9mZnNldCA9IHRoYXQuaW5wdXRzLnBoYXNlLm91dHB1dCxcbiAgICAgICAgICAgICAgICBvdXQgPSB0aGF0Lm91dHB1dCxcbiAgICAgICAgICAgICAgICBwaGFzZSA9IG0ucGhhc2UsXG4gICAgICAgICAgICAgICAgc2FtcGxlUmF0ZSA9IG0uc2FtcGxlUmF0ZSxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIGosXG4gICAgICAgICAgICAgICAgayxcbiAgICAgICAgICAgICAgICB2YWw7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGogPSAwLCBrID0gMDsgaSA8IG51bVNhbXBzOyBpKyssIGogKz0gbS5zdHJpZGVzLnBoYXNlLCBrICs9IG0uc3RyaWRlcy5mcmVxKSB7XG4gICAgICAgICAgICAgICAgb3V0W2ldID0gdmFsID0gTWF0aC5zaW4ocGhhc2UgKyBwaGFzZU9mZnNldFtqXSk7XG4gICAgICAgICAgICAgICAgcGhhc2UgKz0gZnJlcVtrXSAvIHNhbXBsZVJhdGUgKiBmbG9jay5UV09QSTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbS5waGFzZSA9IHBoYXNlO1xuICAgICAgICAgICAgbS51bnNjYWxlZFZhbHVlID0gdmFsO1xuICAgICAgICAgICAgdGhhdC5tdWxBZGQobnVtU2FtcHMpO1xuICAgICAgICAgICAgbS52YWx1ZSA9IGZsb2NrLnVnZW4ubGFzdE91dHB1dFZhbHVlKG51bVNhbXBzLCBvdXQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQub25JbnB1dENoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmbG9jay51Z2VuLm9zYy5vbklucHV0Q2hhbmdlZCh0aGF0KTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0Lm9uSW5wdXRDaGFuZ2VkKCk7XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgIH07XG5cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsb2NrLnVnZW4uc2luXCIsIHtcbiAgICAgICAgcmF0ZTogXCJhdWRpb1wiLFxuICAgICAgICBpbnB1dHM6IHtcbiAgICAgICAgICAgIGZyZXE6IDQ0MC4wLFxuICAgICAgICAgICAgcGhhc2U6IDAuMCxcbiAgICAgICAgICAgIG11bDogbnVsbCxcbiAgICAgICAgICAgIGFkZDogbnVsbFxuICAgICAgICB9LFxuICAgICAgICB1Z2VuT3B0aW9uczoge1xuICAgICAgICAgICAgbW9kZWw6IHtcbiAgICAgICAgICAgICAgICBwaGFzZTogMC4wLFxuICAgICAgICAgICAgICAgIHVuc2NhbGVkVmFsdWU6IDAuMCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogMC4wXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RyaWRlSW5wdXRzOiBbXG4gICAgICAgICAgICAgICAgXCJmcmVxXCIsXG4gICAgICAgICAgICAgICAgXCJwaGFzZVwiXG4gICAgICAgICAgICBdXG4gICAgICAgIH1cbiAgICB9KTtcblxuXG4gICAgZmxvY2sudWdlbi5sZlNhdyA9IGZ1bmN0aW9uIChpbnB1dHMsIG91dHB1dCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgdGhhdCA9IGZsb2NrLnVnZW4oaW5wdXRzLCBvdXRwdXQsIG9wdGlvbnMpO1xuXG4gICAgICAgIHRoYXQuZ2VuID0gZnVuY3Rpb24gKG51bVNhbXBzKSB7XG4gICAgICAgICAgICB2YXIgbSA9IHRoYXQubW9kZWwsXG4gICAgICAgICAgICAgICAgZnJlcSA9IHRoYXQuaW5wdXRzLmZyZXEub3V0cHV0LFxuICAgICAgICAgICAgICAgIG91dCA9IHRoYXQub3V0cHV0LFxuICAgICAgICAgICAgICAgIHNjYWxlID0gbS5zY2FsZSxcbiAgICAgICAgICAgICAgICBwaGFzZU9mZnNldCA9IHRoYXQuaW5wdXRzLnBoYXNlLm91dHB1dFswXSwgLy8gUGhhc2UgaXMgY29udHJvbCByYXRlXG4gICAgICAgICAgICAgICAgcGhhc2UgPSBtLnBoYXNlLCAvLyBUT0RPOiBQcmltZSBzeW50aCBncmFwaCBvbiBpbnN0YW50aWF0aW9uLlxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgaixcbiAgICAgICAgICAgICAgICB2YWw7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbnVtU2FtcHM7IGkrKywgaiArPSBtLnN0cmlkZXMuZnJlcSkge1xuICAgICAgICAgICAgICAgIG91dFtpXSA9IHZhbCA9IHBoYXNlICsgcGhhc2VPZmZzZXQ7XG4gICAgICAgICAgICAgICAgcGhhc2UgKz0gZnJlcVtqXSAqIHNjYWxlO1xuICAgICAgICAgICAgICAgIGlmIChwaGFzZSA+PSAxLjApIHtcbiAgICAgICAgICAgICAgICAgICAgcGhhc2UgLT0gMi4wO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGhhc2UgPD0gLTEuMCkge1xuICAgICAgICAgICAgICAgICAgICBwaGFzZSArPSAyLjA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtLnBoYXNlID0gcGhhc2U7XG4gICAgICAgICAgICBtLnVuc2NhbGVkVmFsdWUgPSB2YWw7XG4gICAgICAgICAgICB0aGF0Lm11bEFkZChudW1TYW1wcyk7XG4gICAgICAgICAgICBtLnZhbHVlID0gZmxvY2sudWdlbi5sYXN0T3V0cHV0VmFsdWUobnVtU2FtcHMsIG91dCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5vbklucHV0Q2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtID0gdGhhdC5tb2RlbDtcbiAgICAgICAgICAgIG0uZnJlcUluYyA9IHRoYXQuaW5wdXRzLmZyZXEucmF0ZSA9PT0gZmxvY2sucmF0ZXMuQVVESU8gPyAxIDogMDtcbiAgICAgICAgICAgIG0ucGhhc2UgPSAwLjA7XG4gICAgICAgICAgICB0aGF0LmNhbGN1bGF0ZVN0cmlkZXMoKTtcbiAgICAgICAgICAgIGZsb2NrLm9uTXVsQWRkSW5wdXRDaGFuZ2VkKHRoYXQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQubW9kZWwuc2NhbGUgPSAyICogKDEgLyB0aGF0Lm9wdGlvbnMuc2FtcGxlUmF0ZSk7XG4gICAgICAgICAgICB0aGF0Lm9uSW5wdXRDaGFuZ2VkKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5pbml0KCk7XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgIH07XG5cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsb2NrLnVnZW4ubGZTYXdcIiwge1xuICAgICAgICByYXRlOiBcImF1ZGlvXCIsXG4gICAgICAgIGlucHV0czoge1xuICAgICAgICAgICAgZnJlcTogNDQwLFxuICAgICAgICAgICAgcGhhc2U6IDAuMCxcbiAgICAgICAgICAgIG11bDogbnVsbCxcbiAgICAgICAgICAgIGFkZDogbnVsbFxuICAgICAgICB9LFxuICAgICAgICB1Z2VuT3B0aW9uczoge1xuICAgICAgICAgICAgbW9kZWw6IHtcbiAgICAgICAgICAgICAgICBwaGFzZTogMC4wLFxuICAgICAgICAgICAgICAgIGZyZXFJbmM6IDEsXG4gICAgICAgICAgICAgICAgdW5zY2FsZWRWYWx1ZTogMC4wLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAwLjBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdHJpZGVJbnB1dHM6IFtcImZyZXFcIl1cbiAgICAgICAgfVxuICAgIH0pO1xuXG5cbiAgICBmbG9jay51Z2VuLmxmUHVsc2UgPSBmdW5jdGlvbiAoaW5wdXRzLCBvdXRwdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHRoYXQgPSBmbG9jay51Z2VuKGlucHV0cywgb3V0cHV0LCBvcHRpb25zKTtcblxuICAgICAgICB0aGF0LmdlbiA9IGZ1bmN0aW9uIChudW1TYW1wcykge1xuICAgICAgICAgICAgdmFyIGlucHV0cyA9IHRoYXQuaW5wdXRzLFxuICAgICAgICAgICAgICAgIG0gPSB0aGF0Lm1vZGVsLFxuICAgICAgICAgICAgICAgIGZyZXEgPSBpbnB1dHMuZnJlcS5vdXRwdXQsXG4gICAgICAgICAgICAgICAgZnJlcUluYyA9IG0uZnJlcUluYyxcbiAgICAgICAgICAgICAgICB3aWR0aCA9IGlucHV0cy53aWR0aC5vdXRwdXRbMF0sIC8vIFRPRE86IEFyZSB3ZSBoYW5kbGluZyB3aWR0aCBjb3JyZWN0bHkgaGVyZT9cbiAgICAgICAgICAgICAgICBvdXQgPSB0aGF0Lm91dHB1dCxcbiAgICAgICAgICAgICAgICBzY2FsZSA9IG0uc2NhbGUsXG4gICAgICAgICAgICAgICAgcGhhc2UgPSBtLnBoYXNlICE9PSB1bmRlZmluZWQgPyBtLnBoYXNlIDogaW5wdXRzLnBoYXNlLm91dHB1dFswXSwgLy8gVE9ETzogVW5uZWNlc3NhcnkgaWYgd2Uga25ldyB0aGUgc3ludGggZ3JhcGggaGFkIGJlZW4gcHJpbWVkLlxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgaixcbiAgICAgICAgICAgICAgICB2YWw7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbnVtU2FtcHM7IGkrKywgaiArPSBmcmVxSW5jKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBoYXNlID49IDEuMCkge1xuICAgICAgICAgICAgICAgICAgICBwaGFzZSAtPSAxLjA7XG4gICAgICAgICAgICAgICAgICAgIG91dFtpXSA9IHZhbCA9IHdpZHRoIDwgMC41ID8gMS4wIDogLTEuMDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdXRbaV0gPSB2YWwgPSBwaGFzZSA8IHdpZHRoID8gMS4wIDogLTEuMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGhhc2UgKz0gZnJlcVtqXSAqIHNjYWxlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtLnBoYXNlID0gcGhhc2U7XG4gICAgICAgICAgICBtLnVuc2NhbGVkVmFsdWUgPSB2YWw7XG4gICAgICAgICAgICB0aGF0Lm11bEFkZChudW1TYW1wcyk7XG4gICAgICAgICAgICBtLnZhbHVlID0gZmxvY2sudWdlbi5sYXN0T3V0cHV0VmFsdWUobnVtU2FtcHMsIG91dCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5vbklucHV0Q2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQubW9kZWwuZnJlcUluYyA9IHRoYXQuaW5wdXRzLmZyZXEucmF0ZSA9PT0gZmxvY2sucmF0ZXMuQVVESU8gPyAxIDogMDtcbiAgICAgICAgICAgIGZsb2NrLm9uTXVsQWRkSW5wdXRDaGFuZ2VkKHRoYXQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQubW9kZWwuc2NhbGUgPSAxIC8gdGhhdC5vcHRpb25zLnNhbXBsZVJhdGU7XG4gICAgICAgICAgICB0aGF0Lm9uSW5wdXRDaGFuZ2VkKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5pbml0KCk7XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgIH07XG5cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsb2NrLnVnZW4ubGZQdWxzZVwiLCB7XG4gICAgICAgIHJhdGU6IFwiYXVkaW9cIixcbiAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICBmcmVxOiA0NDAsXG4gICAgICAgICAgICBwaGFzZTogMC4wLFxuICAgICAgICAgICAgd2lkdGg6IDAuNSxcbiAgICAgICAgICAgIG11bDogbnVsbCxcbiAgICAgICAgICAgIGFkZDogbnVsbFxuICAgICAgICB9LFxuICAgICAgICB1Z2VuT3B0aW9uczoge1xuICAgICAgICAgICAgbW9kZWw6IHtcbiAgICAgICAgICAgICAgICBwaGFzZTogMC4wLFxuICAgICAgICAgICAgICAgIGZyZXFJbmM6IDEsXG4gICAgICAgICAgICAgICAgdW5zY2FsZWRWYWx1ZTogMC4wLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAwLjBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG5cbiAgICBmbG9jay51Z2VuLmltcHVsc2UgPSBmdW5jdGlvbiAoaW5wdXRzLCBvdXRwdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHRoYXQgPSBmbG9jay51Z2VuKGlucHV0cywgb3V0cHV0LCBvcHRpb25zKTtcblxuICAgICAgICB0aGF0LmdlbiA9IGZ1bmN0aW9uIChudW1TYW1wcykge1xuICAgICAgICAgICAgdmFyIGlucHV0cyA9IHRoYXQuaW5wdXRzLFxuICAgICAgICAgICAgICAgIG0gPSB0aGF0Lm1vZGVsLFxuICAgICAgICAgICAgICAgIG91dCA9IHRoYXQub3V0cHV0LFxuICAgICAgICAgICAgICAgIGZyZXEgPSBpbnB1dHMuZnJlcS5vdXRwdXQsXG4gICAgICAgICAgICAgICAgZnJlcUluYyA9IG0uc3RyaWRlcy5mcmVxLFxuICAgICAgICAgICAgICAgIHBoYXNlT2Zmc2V0ID0gaW5wdXRzLnBoYXNlLm91dHB1dFswXSxcbiAgICAgICAgICAgICAgICBwaGFzZSA9IG0ucGhhc2UsXG4gICAgICAgICAgICAgICAgc2NhbGUgPSBtLnNjYWxlLFxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgaixcbiAgICAgICAgICAgICAgICB2YWw7XG5cbiAgICAgICAgICAgIHBoYXNlICs9IHBoYXNlT2Zmc2V0O1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IG51bVNhbXBzOyBpKyssIGogKz0gZnJlcUluYykge1xuICAgICAgICAgICAgICAgIGlmIChwaGFzZSA+PSAxLjApIHtcbiAgICAgICAgICAgICAgICAgICAgcGhhc2UgLT0gMS4wO1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSAxLjA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gMC4wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXRbaV0gPSB2YWw7XG4gICAgICAgICAgICAgICAgcGhhc2UgKz0gZnJlcVtqXSAqIHNjYWxlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtLnBoYXNlID0gcGhhc2UgLSBwaGFzZU9mZnNldDtcbiAgICAgICAgICAgIG0udW5zY2FsZWRWYWx1ZSA9IHZhbDtcbiAgICAgICAgICAgIHRoYXQubXVsQWRkKG51bVNhbXBzKTtcbiAgICAgICAgICAgIG0udmFsdWUgPSBmbG9jay51Z2VuLmxhc3RPdXRwdXRWYWx1ZShudW1TYW1wcywgb3V0KTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0Lm9uSW5wdXRDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5jYWxjdWxhdGVTdHJpZGVzKCk7XG4gICAgICAgICAgICBmbG9jay5vbk11bEFkZElucHV0Q2hhbmdlZCh0aGF0KTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0LmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0Lm1vZGVsLnNjYWxlID0gMS4wIC8gdGhhdC5tb2RlbC5zYW1wbGVSYXRlO1xuICAgICAgICAgICAgdGhhdC5vbklucHV0Q2hhbmdlZCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQuaW5pdCgpO1xuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICB9O1xuXG4gICAgZmx1aWQuZGVmYXVsdHMoXCJmbG9jay51Z2VuLmltcHVsc2VcIiwge1xuICAgICAgICByYXRlOiBcImF1ZGlvXCIsXG4gICAgICAgIGlucHV0czoge1xuICAgICAgICAgICAgZnJlcTogNDQwLFxuICAgICAgICAgICAgcGhhc2U6IDAuMCxcbiAgICAgICAgICAgIG11bDogbnVsbCxcbiAgICAgICAgICAgIGFkZDogbnVsbFxuICAgICAgICB9LFxuICAgICAgICB1Z2VuT3B0aW9uczoge1xuICAgICAgICAgICAgbW9kZWw6IHtcbiAgICAgICAgICAgICAgICBwaGFzZTogMC4wLFxuICAgICAgICAgICAgICAgIHNjYWxlOiAwLjAsXG4gICAgICAgICAgICAgICAgdW5zY2FsZWRWYWx1ZTogMC4wLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAwLjBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdHJpZGVJbnB1dHM6IFtcImZyZXFcIl1cbiAgICAgICAgfVxuICAgIH0pO1xuXG5cbiAgICBmbG9jay51Z2VuLnQyYSA9IGZ1bmN0aW9uIChpbnB1dHMsIG91dHB1dCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgdGhhdCA9IGZsb2NrLnVnZW4oaW5wdXRzLCBvdXRwdXQsIG9wdGlvbnMpO1xuXG4gICAgICAgIHRoYXQuZ2VuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG0gPSB0aGF0Lm1vZGVsLFxuICAgICAgICAgICAgICAgIHRyaWcgPSB0aGF0LmlucHV0cy5zb3VyY2Uub3V0cHV0WzBdLFxuICAgICAgICAgICAgICAgIG9mZnNldCA9IHRoYXQuaW5wdXRzLm9mZnNldC5vdXRwdXRbMF0gfCAwLFxuICAgICAgICAgICAgICAgIG91dCA9IHRoYXQub3V0cHV0LFxuICAgICAgICAgICAgICAgIHZhbDtcblxuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIG91dHB1dCBidWZmZXIuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG91dFtpXSA9IHZhbCA9IDAuMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gV3JpdGUgdGhlIHRyaWdnZXIgdmFsdWUgdG8gdGhlIGF1ZGlvIHN0cmVhbSBpZiBpdCdzIG9wZW4uXG4gICAgICAgICAgICBpZiAodHJpZyA+IDAuMCAmJiBtLnByZXZUcmlnIDw9IDAuMCkge1xuICAgICAgICAgICAgICAgIG91dFtvZmZzZXRdID0gdmFsID0gdHJpZztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbS5wcmV2VHJpZyA9IHRyaWc7XG4gICAgICAgICAgICBtLnZhbHVlID0gbS51bnNjYWxlZFZhbHVlID0gdmFsO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgIH07XG5cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsb2NrLnVnZW4udDJhXCIsIHtcbiAgICAgICAgcmF0ZTogXCJhdWRpb1wiLFxuICAgICAgICBpbnB1dHM6IHtcbiAgICAgICAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICB9LFxuICAgICAgICB1Z2VuT3B0aW9uczoge1xuICAgICAgICAgICAgbW9kZWw6IHtcbiAgICAgICAgICAgICAgICBwcmV2VHJpZzogMC4wLFxuICAgICAgICAgICAgICAgIHVuc2NhbGVkVmFsdWU6IDAuMCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogMC4wXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG4gICAgZmxvY2sudWdlbi5sYXRjaCA9IGZ1bmN0aW9uIChpbnB1dHMsIG91dHB1dCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgdGhhdCA9IGZsb2NrLnVnZW4oaW5wdXRzLCBvdXRwdXQsIG9wdGlvbnMpO1xuXG4gICAgICAgIHRoYXQuYXJHZW4gPSBmdW5jdGlvbiAobnVtU2FtcHMpIHtcbiAgICAgICAgICAgIHZhciBtID0gdGhhdC5tb2RlbCxcbiAgICAgICAgICAgICAgICBpbnB1dHMgPSB0aGF0LmlucHV0cyxcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSBpbnB1dHMuc291cmNlLm91dHB1dCxcbiAgICAgICAgICAgICAgICB0cmlnID0gaW5wdXRzLnRyaWdnZXIsXG4gICAgICAgICAgICAgICAgc291cmNlSW5jID0gbS5zdHJpZGVzLnNvdXJjZSxcbiAgICAgICAgICAgICAgICBvdXQgPSB0aGF0Lm91dHB1dCxcbiAgICAgICAgICAgICAgICBpLCBqLFxuICAgICAgICAgICAgICAgIGN1cnJUcmlnLFxuICAgICAgICAgICAgICAgIHZhbDtcblxuICAgICAgICAgICAgaWYgKG0uaG9sZFZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbS5ob2xkVmFsID0gc291cmNlWzBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IG51bVNhbXBzOyBpKyssIGogKz0gc291cmNlSW5jKSB7XG4gICAgICAgICAgICAgICAgY3VyclRyaWcgPSB0cmlnLm91dHB1dFtpXTtcbiAgICAgICAgICAgICAgICBvdXRbaV0gPSB2YWwgPSAoY3VyclRyaWcgPiAwLjAgJiYgbS5wcmV2VHJpZyA8PSAwLjApID8gbS5ob2xkVmFsID0gc291cmNlW2pdIDogbS5ob2xkVmFsO1xuICAgICAgICAgICAgICAgIG0ucHJldlRyaWcgPSBjdXJyVHJpZztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbS51bnNjYWxlZFZhbHVlID0gdmFsO1xuICAgICAgICAgICAgdGhhdC5tdWxBZGQobnVtU2FtcHMpO1xuICAgICAgICAgICAgbS52YWx1ZSA9IGZsb2NrLnVnZW4ubGFzdE91dHB1dFZhbHVlKG51bVNhbXBzLCBvdXQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQua3JHZW4gPSBmdW5jdGlvbiAobnVtU2FtcHMpIHtcbiAgICAgICAgICAgIHZhciBtID0gdGhhdC5tb2RlbCxcbiAgICAgICAgICAgICAgICBvdXQgPSB0aGF0Lm91dHB1dCxcbiAgICAgICAgICAgICAgICBjdXJyVHJpZyA9IHRoYXQuaW5wdXRzLnRyaWdnZXIub3V0cHV0WzBdLFxuICAgICAgICAgICAgICAgIGk7XG5cbiAgICAgICAgICAgIGlmIChtLmhvbGRWYWwgPT09IHVuZGVmaW5lZCB8fCBjdXJyVHJpZyA+IDAuMCAmJiBtLnByZXZUcmlnIDw9IDAuMCkge1xuICAgICAgICAgICAgICAgIG0uaG9sZFZhbCA9IHRoYXQuaW5wdXRzLnNvdXJjZS5vdXRwdXRbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtLnByZXZUcmlnID0gY3VyclRyaWc7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1TYW1wczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0W2ldID0gbS5ob2xkVmFsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtLnVuc2NhbGVkVmFsdWUgPSBtLmhvbGRWYWw7XG4gICAgICAgICAgICB0aGF0Lm11bEFkZChudW1TYW1wcyk7XG4gICAgICAgICAgICBtLnZhbHVlID0gZmxvY2sudWdlbi5sYXN0T3V0cHV0VmFsdWUobnVtU2FtcHMsIG91dCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5vbklucHV0Q2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQuY2FsY3VsYXRlU3RyaWRlcygpO1xuICAgICAgICAgICAgdGhhdC5nZW4gPSB0aGF0LmlucHV0cy50cmlnZ2VyLnJhdGUgPT09IGZsb2NrLnJhdGVzLkFVRElPID8gdGhhdC5hckdlbiA6IHRoYXQua3JHZW47XG4gICAgICAgICAgICBmbG9jay5vbk11bEFkZElucHV0Q2hhbmdlZCh0aGF0KTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0Lm9uSW5wdXRDaGFuZ2VkKCk7XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgIH07XG5cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsb2NrLnVnZW4ubGF0Y2hcIiwge1xuICAgICAgICByYXRlOiBcImF1ZGlvXCIsXG4gICAgICAgIGlucHV0czoge1xuICAgICAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICAgICAgdHJpZ2dlcjogMC4wLFxuICAgICAgICAgICAgbXVsOiBudWxsLFxuICAgICAgICAgICAgYWRkOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIHVnZW5PcHRpb25zOiB7XG4gICAgICAgICAgICBzdHJpZGVJbnB1dHM6IFtcInNvdXJjZVwiXSxcbiAgICAgICAgICAgIG1vZGVsOiB7XG4gICAgICAgICAgICAgICAgcHJldlRyaWc6IDAuMCxcbiAgICAgICAgICAgICAgICB1bnNjYWxlZFZhbHVlOiAwLjAsXG4gICAgICAgICAgICAgICAgdmFsdWU6IDAuMFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cblxuICAgIC8qKioqKioqKioqKioqKioqXG4gICAgICogQnVmZmVyIFVHZW5zICpcbiAgICAgKioqKioqKioqKioqKioqKi9cblxuICAgIC8qKlxuICAgICAqIE1peGVzIGJ1ZmZlci1yZWxhdGVkIGZ1bmN0aW9uYWxpdHkgaW50byBhIHVuaXQgZ2VuZXJhdG9yLlxuICAgICAqL1xuICAgIGZsb2NrLnVnZW4uYnVmZmVyID0gZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgICAgdGhhdC5vbkJ1ZmZlcklucHV0Q2hhbmdlZCA9IGZ1bmN0aW9uIChpbnB1dE5hbWUpIHtcbiAgICAgICAgICAgIHZhciBtID0gdGhhdC5tb2RlbCxcbiAgICAgICAgICAgICAgICBpbnB1dHMgPSB0aGF0LmlucHV0cztcblxuICAgICAgICAgICAgaWYgKG0uYnVmRGVmICE9PSBpbnB1dHMuYnVmZmVyIHx8IGlucHV0TmFtZSA9PT0gXCJidWZmZXJcIikge1xuICAgICAgICAgICAgICAgIG0uYnVmRGVmID0gaW5wdXRzLmJ1ZmZlcjtcbiAgICAgICAgICAgICAgICBmbG9jay5wYXJzZS5idWZmZXJGb3JEZWYobS5idWZEZWYsIHRoYXQsIGZsb2NrLmVudmlyby5zaGFyZWQpOyAvLyBUT0RPOiBTaGFyZWQgZW52aXJvIHJlZmVyZW5jZS5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0LnNldEJ1ZmZlciA9IGZ1bmN0aW9uIChidWZEZXNjKSB7XG4gICAgICAgICAgICB0aGF0LmJ1ZmZlciA9IGJ1ZkRlc2M7XG4gICAgICAgICAgICBpZiAodGhhdC5vbkJ1ZmZlclJlYWR5KSB7XG4gICAgICAgICAgICAgICAgdGhhdC5vbkJ1ZmZlclJlYWR5KGJ1ZkRlc2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQuaW5pdEJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFN0YXJ0IHdpdGggYSB6ZXJvZWQgYnVmZmVyLCBzaW5jZSB0aGUgYnVmZmVyIGlucHV0IG1heSBiZSBsb2FkZWQgYXN5bmNocm9ub3VzbHkuXG4gICAgICAgICAgICB0aGF0LmJ1ZmZlciA9IHRoYXQubW9kZWwuYnVmRGVmID0gZmxvY2suYnVmZmVyRGVzYyh7XG4gICAgICAgICAgICAgICAgZm9ybWF0OiB7XG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZVJhdGU6IHRoYXQub3B0aW9ucy5hdWRpb1NldHRpbmdzLnJhdGVzLmF1ZGlvXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWxzOiBbbmV3IEZsb2F0MzJBcnJheSh0aGF0Lm91dHB1dC5sZW5ndGgpXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH07XG5cblxuICAgIGZsb2NrLnVnZW4ucGxheUJ1ZmZlciA9IGZ1bmN0aW9uIChpbnB1dHMsIG91dHB1dCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgdGhhdCA9IGZsb2NrLnVnZW4oaW5wdXRzLCBvdXRwdXQsIG9wdGlvbnMpO1xuXG4gICAgICAgIHRoYXQuZGVmYXVsdEtyVHJpZ2dlckdlbiA9IGZ1bmN0aW9uIChudW1TYW1wcykge1xuICAgICAgICAgICAgdmFyIG0gPSB0aGF0Lm1vZGVsLFxuICAgICAgICAgICAgICAgIG91dCA9IHRoYXQub3V0cHV0LFxuICAgICAgICAgICAgICAgIGNoYW4gPSB0aGF0LmlucHV0cy5jaGFubmVsLm91dHB1dFswXSxcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSB0aGF0LmJ1ZmZlci5kYXRhLmNoYW5uZWxzW2NoYW5dLFxuICAgICAgICAgICAgICAgIGJ1ZklkeCA9IG0uaWR4LFxuICAgICAgICAgICAgICAgIGxvb3AgPSB0aGF0LmlucHV0cy5sb29wLm91dHB1dFswXSxcbiAgICAgICAgICAgICAgICB0cmlnVmFsID0gaW5wdXRzLnRyaWdnZXIub3V0cHV0WzBdLFxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgc2FtcDtcblxuICAgICAgICAgICAgaWYgKHRyaWdWYWwgPiAwLjAgJiYgbS5wcmV2VHJpZyA8PSAwLjApIHtcbiAgICAgICAgICAgICAgICBidWZJZHggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbS5wcmV2VHJpZyA9IHRyaWdWYWw7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1TYW1wczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJ1ZklkeCA+IG0ubGFzdElkeCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9vcCA+IDAuMCAmJiB0cmlnVmFsID4gMC4wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZJZHggPSAwO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0W2ldID0gc2FtcCA9IDAuMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2FtcCA9IHRoYXQuaW50ZXJwb2xhdGUoYnVmSWR4LCBzb3VyY2UpO1xuICAgICAgICAgICAgICAgIG91dFtpXSA9IHNhbXA7XG4gICAgICAgICAgICAgICAgYnVmSWR4Kys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG0uaWR4ID0gYnVmSWR4O1xuICAgICAgICAgICAgbS51bnNjYWxlZFZhbHVlID0gc2FtcDtcbiAgICAgICAgICAgIHRoYXQubXVsQWRkKG51bVNhbXBzKTtcbiAgICAgICAgICAgIG0udmFsdWUgPSBmbG9jay51Z2VuLmxhc3RPdXRwdXRWYWx1ZShudW1TYW1wcywgb3V0KTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0Lm90aGVyd2lzZUdlbiA9IGZ1bmN0aW9uIChudW1TYW1wcykge1xuICAgICAgICAgICAgdmFyIG0gPSB0aGF0Lm1vZGVsLFxuICAgICAgICAgICAgICAgIG91dCA9IHRoYXQub3V0cHV0LFxuICAgICAgICAgICAgICAgIGNoYW4gPSB0aGF0LmlucHV0cy5jaGFubmVsLm91dHB1dFswXSxcbiAgICAgICAgICAgICAgICBzcGVlZCA9IHRoYXQuaW5wdXRzLnNwZWVkLm91dHB1dCxcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSB0aGF0LmJ1ZmZlci5kYXRhLmNoYW5uZWxzW2NoYW5dLFxuICAgICAgICAgICAgICAgIHRyaWcgPSBpbnB1dHMudHJpZ2dlci5vdXRwdXQsXG4gICAgICAgICAgICAgICAgYnVmSWR4ID0gbS5pZHgsXG4gICAgICAgICAgICAgICAgbG9vcCA9IHRoYXQuaW5wdXRzLmxvb3Aub3V0cHV0WzBdLFxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gKHRoYXQuaW5wdXRzLnN0YXJ0Lm91dHB1dFswXSAqIG0ubGFzdElkeCkgfCAwLFxuICAgICAgICAgICAgICAgIGVuZCA9ICh0aGF0LmlucHV0cy5lbmQub3V0cHV0WzBdICogbS5sYXN0SWR4KSB8IDAsXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICBqLFxuICAgICAgICAgICAgICAgIGssXG4gICAgICAgICAgICAgICAgdHJpZ1ZhbCxcbiAgICAgICAgICAgICAgICBzcGVlZFZhbCxcbiAgICAgICAgICAgICAgICBzYW1wO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBqID0gMCwgayA9IDA7IGkgPCBudW1TYW1wczsgaSsrLCBqICs9IG0uc3RyaWRlcy50cmlnZ2VyLCBrICs9IG0uc3RyaWRlcy5zcGVlZCkge1xuICAgICAgICAgICAgICAgIHRyaWdWYWwgPSB0cmlnW2pdO1xuICAgICAgICAgICAgICAgIHNwZWVkVmFsID0gc3BlZWRba107XG5cbiAgICAgICAgICAgICAgICBpZiAodHJpZ1ZhbCA+IDAuMCAmJiBtLnByZXZUcmlnIDw9IDAuMCkge1xuICAgICAgICAgICAgICAgICAgICBidWZJZHggPSBmbG9jay51Z2VuLnBsYXlCdWZmZXIucmVzZXRJbmRleChzcGVlZFZhbCwgc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChidWZJZHggPCBzdGFydCB8fCBidWZJZHggPiBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvb3AgPiAwLjAgJiYgdHJpZ1ZhbCA+IDAuMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmSWR4ID0gZmxvY2sudWdlbi5wbGF5QnVmZmVyLnJlc2V0SW5kZXgoc3BlZWRWYWwsIHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0W2ldID0gc2FtcCA9IDAuMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG0ucHJldlRyaWcgPSB0cmlnW2pdO1xuXG4gICAgICAgICAgICAgICAgc2FtcCA9IHRoYXQuaW50ZXJwb2xhdGUoYnVmSWR4LCBzb3VyY2UpO1xuICAgICAgICAgICAgICAgIG91dFtpXSA9IHNhbXA7XG4gICAgICAgICAgICAgICAgYnVmSWR4ICs9IG0uc3RlcFNpemUgKiBzcGVlZFZhbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbS5pZHggPSBidWZJZHg7XG4gICAgICAgICAgICBtLnVuc2NhbGVkVmFsdWUgPSBzYW1wO1xuICAgICAgICAgICAgdGhhdC5tdWxBZGQobnVtU2FtcHMpO1xuICAgICAgICAgICAgbS52YWx1ZSA9IGZsb2NrLnVnZW4ubGFzdE91dHB1dFZhbHVlKG51bVNhbXBzLCBvdXQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQub25JbnB1dENoYW5nZWQgPSBmdW5jdGlvbiAoaW5wdXROYW1lKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRzID0gdGhhdC5pbnB1dHMsXG4gICAgICAgICAgICAgICAgc3BlZWQgPSBpbnB1dHMuc3BlZWQsXG4gICAgICAgICAgICAgICAgc3RhcnQgPSBpbnB1dHMuc3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kID0gaW5wdXRzLmVuZCxcbiAgICAgICAgICAgICAgICB0cmlnID0gaW5wdXRzLnRyaWdnZXI7XG5cbiAgICAgICAgICAgIHRoYXQub25CdWZmZXJJbnB1dENoYW5nZWQoaW5wdXROYW1lKTtcblxuICAgICAgICAgICAgLy8gVE9ETzogT3B0aW1pemUgZm9yIG5vbi1yZWd1bGFyIHNwZWVkIGNvbnN0YW50IHJhdGUgaW5wdXQuXG4gICAgICAgICAgICB0aGF0LmdlbiA9IChzcGVlZC5yYXRlID09PSBmbG9jay5yYXRlcy5DT05TVEFOVCAmJiBzcGVlZC5vdXRwdXRbMF0gPT09IDEuMCkgJiZcbiAgICAgICAgICAgICAgICAoc3RhcnQucmF0ZSA9PT0gZmxvY2sucmF0ZXMuQ09OU1RBTlQgJiYgc3RhcnQub3V0cHV0WzBdID09PSAwLjApICYmXG4gICAgICAgICAgICAgICAgKGVuZC5yYXRlID09PSBmbG9jay5yYXRlcy5DT05TVEFOVCAmJiBlbmQub3V0cHV0WzBdID09PSAxLjApICYmXG4gICAgICAgICAgICAgICAgKHRyaWcucmF0ZSAhPT0gZmxvY2sucmF0ZXMuQVVESU8pID9cbiAgICAgICAgICAgICAgICB0aGF0LmRlZmF1bHRLclRyaWdnZXJHZW4gOiB0aGF0Lm90aGVyd2lzZUdlbjtcblxuICAgICAgICAgICAgdGhhdC5jYWxjdWxhdGVTdHJpZGVzKCk7XG4gICAgICAgICAgICBmbG9jay5vbk11bEFkZElucHV0Q2hhbmdlZCh0aGF0KTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0Lm9uQnVmZmVyUmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbSA9IHRoYXQubW9kZWwsXG4gICAgICAgICAgICAgICAgZW5kID0gdGhhdC5pbnB1dHMuZW5kLm91dHB1dFswXSxcbiAgICAgICAgICAgICAgICBjaGFuID0gdGhhdC5pbnB1dHMuY2hhbm5lbC5vdXRwdXRbMF0sXG4gICAgICAgICAgICAgICAgYnVmID0gdGhhdC5idWZmZXIuZGF0YS5jaGFubmVsc1tjaGFuXSxcbiAgICAgICAgICAgICAgICBsZW4gPSBidWYubGVuZ3RoO1xuXG4gICAgICAgICAgICBtLmlkeCA9IChlbmQgKiBsZW4pIHwgMDtcbiAgICAgICAgICAgIG0ubGFzdElkeCA9IGxlbiAtIDE7XG4gICAgICAgICAgICBtLnN0ZXBTaXplID0gdGhhdC5idWZmZXIuZm9ybWF0LnNhbXBsZVJhdGUgLyBtLnNhbXBsZVJhdGU7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZmxvY2sudWdlbi5idWZmZXIodGhhdCk7XG4gICAgICAgICAgICB0aGF0LmluaXRCdWZmZXIoKTtcbiAgICAgICAgICAgIHRoYXQub25JbnB1dENoYW5nZWQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0LmluaXQoKTtcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfTtcblxuICAgIGZsb2NrLnVnZW4ucGxheUJ1ZmZlci5yZXNldEluZGV4ID0gZnVuY3Rpb24gKHNwZWVkLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIHJldHVybiBzcGVlZCA+IDAgPyBzdGFydCA6IGVuZDtcbiAgICB9O1xuXG4gICAgZmx1aWQuZGVmYXVsdHMoXCJmbG9jay51Z2VuLnBsYXlCdWZmZXJcIiwge1xuICAgICAgICByYXRlOiBcImF1ZGlvXCIsXG4gICAgICAgIGlucHV0czoge1xuICAgICAgICAgICAgY2hhbm5lbDogMCxcbiAgICAgICAgICAgIGxvb3A6IDAuMCxcbiAgICAgICAgICAgIHNwZWVkOiAxLjAsXG4gICAgICAgICAgICBzdGFydDogMC4wLFxuICAgICAgICAgICAgZW5kOiAxLjAsXG4gICAgICAgICAgICB0cmlnZ2VyOiAxLjAsXG4gICAgICAgICAgICBidWZmZXI6IG51bGwsXG4gICAgICAgICAgICBtdWw6IG51bGwsXG4gICAgICAgICAgICBhZGQ6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgdWdlbk9wdGlvbnM6IHtcbiAgICAgICAgICAgIG1vZGVsOiB7XG4gICAgICAgICAgICAgICAgZmluaXNoZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHVuc2NhbGVkVmFsdWU6IDAuMCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogMC4wLFxuICAgICAgICAgICAgICAgIGlkeDogMCxcbiAgICAgICAgICAgICAgICBzdGVwU2l6ZTogMCxcbiAgICAgICAgICAgICAgICBwcmV2VHJpZzogMCxcbiAgICAgICAgICAgICAgICBjaGFubmVsOiB1bmRlZmluZWRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdHJpZGVJbnB1dHM6IFtcInRyaWdnZXJcIiwgXCJzcGVlZFwiXSxcbiAgICAgICAgICAgIGludGVycG9sYXRpb246IFwibGluZWFyXCJcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmVhZHMgdmFsdWVzIG91dCBvZiBhIGJ1ZmZlciBhdCB0aGUgc3BlY2lmaWVkIHBoYXNlIGluZGV4LlxuICAgICAqIFRoaXMgdW5pdCBnZW5lcmF0b3IgaXMgdHlwaWNhbGx5IHVzZWQgd2l0aCBmbG9jay51Z2VuLnBoYXNvciBvciBzaW1pbGFyIHVuaXQgZ2VuZXJhdG9yIHRvXG4gICAgICogc2NhbiB0aHJvdWdoIHRoZSBidWZmZXIgYXQgYSBwYXJ0aWN1bGFyIHJhdGUuXG4gICAgICpcbiAgICAgKiBJbnB1dHM6XG4gICAgICogIC0gYnVmZmVyOiBhIGJ1ZkRlZiByZXByZXNlbnRpbmcgdGhlIGJ1ZmZlciB0byByZWFkIGZyb21cbiAgICAgKiAgLSBjaGFubmVsOiB0aGUgY2hhbm5lbCBvZiB0aGUgYnVmZmVyIHRvIHJlYWQgZnJvbVxuICAgICAqICAtIHBoYXNlOiB0aGUgcGhhc2Ugb2YgdGhlIGJ1ZmZlciB0byByZWFkICh0aGlzIHNob3VsZCBiZSBhIHZhbHVlIGJldHdlZW4gMC4uMSlcbiAgICAgKi9cbiAgICAvLyBUT0RPOiBUaGlzIHNob3VsZCBiZSByZWZhY3RvcmVkIGJhc2VkIG9uIHRoZSBtb2RlbCBvZiBidWZmZXJQaGFzZVN0ZXAgYmVsb3cuXG4gICAgZmxvY2sudWdlbi5yZWFkQnVmZmVyID0gZnVuY3Rpb24gKGlucHV0cywgb3V0cHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB0aGF0ID0gZmxvY2sudWdlbihpbnB1dHMsIG91dHB1dCwgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhhdC5nZW4gPSBmdW5jdGlvbiAobnVtU2FtcHMpIHtcbiAgICAgICAgICAgIHZhciBtID0gdGhhdC5tb2RlbCxcbiAgICAgICAgICAgICAgICBwaGFzZVMgPSBtLnN0cmlkZXMucGhhc2UsXG4gICAgICAgICAgICAgICAgb3V0ID0gdGhhdC5vdXRwdXQsXG4gICAgICAgICAgICAgICAgY2hhbiA9IHRoYXQuaW5wdXRzLmNoYW5uZWwub3V0cHV0WzBdLFxuICAgICAgICAgICAgICAgIHBoYXNlID0gdGhhdC5pbnB1dHMucGhhc2Uub3V0cHV0LFxuICAgICAgICAgICAgICAgIHNvdXJjZSA9IHRoYXQuYnVmZmVyLmRhdGEuY2hhbm5lbHNbY2hhbl0sXG4gICAgICAgICAgICAgICAgc291cmNlTGVuID0gc291cmNlLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIGJ1ZklkeCxcbiAgICAgICAgICAgICAgICBqLFxuICAgICAgICAgICAgICAgIHZhbDtcblxuICAgICAgICAgICAgZm9yIChpID0gaiA9IDA7IGkgPCBudW1TYW1wczsgaSsrLCBqICs9IHBoYXNlUykge1xuICAgICAgICAgICAgICAgIGJ1ZklkeCA9IHBoYXNlW2pdICogc291cmNlTGVuO1xuICAgICAgICAgICAgICAgIHZhbCA9IHRoYXQuaW50ZXJwb2xhdGUoYnVmSWR4LCBzb3VyY2UpO1xuICAgICAgICAgICAgICAgIG91dFtpXSA9IHZhbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbS51bnNjYWxlZFZhbHVlID0gdmFsO1xuICAgICAgICAgICAgdGhhdC5tdWxBZGQobnVtU2FtcHMpO1xuICAgICAgICAgICAgbS52YWx1ZSA9IGZsb2NrLnVnZW4ubGFzdE91dHB1dFZhbHVlKG51bVNhbXBzLCBvdXQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQub25JbnB1dENoYW5nZWQgPSBmdW5jdGlvbiAoaW5wdXROYW1lKSB7XG4gICAgICAgICAgICB0aGF0Lm9uQnVmZmVySW5wdXRDaGFuZ2VkKGlucHV0TmFtZSk7XG4gICAgICAgICAgICB0aGF0LmNhbGN1bGF0ZVN0cmlkZXMoKTtcbiAgICAgICAgICAgIGZsb2NrLm9uTXVsQWRkSW5wdXRDaGFuZ2VkKHRoYXQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZsb2NrLnVnZW4uYnVmZmVyKHRoYXQpO1xuICAgICAgICAgICAgdGhhdC5pbml0QnVmZmVyKCk7XG4gICAgICAgICAgICB0aGF0Lm9uSW5wdXRDaGFuZ2VkKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5pbml0KCk7XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgIH07XG5cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsb2NrLnVnZW4ucmVhZEJ1ZmZlclwiLCB7XG4gICAgICAgIHJhdGU6IFwiYXVkaW9cIixcblxuICAgICAgICBpbnB1dHM6IHtcbiAgICAgICAgICAgIGJ1ZmZlcjogbnVsbCxcbiAgICAgICAgICAgIGNoYW5uZWw6IDAsXG4gICAgICAgICAgICBwaGFzZTogMCxcbiAgICAgICAgICAgIG11bDogbnVsbCxcbiAgICAgICAgICAgIGFkZDogbnVsbFxuICAgICAgICB9LFxuXG4gICAgICAgIHVnZW5PcHRpb25zOiB7XG4gICAgICAgICAgICBtb2RlbDoge1xuICAgICAgICAgICAgICAgIGNoYW5uZWw6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB1bnNjYWxlZFZhbHVlOiAwLjAsXG4gICAgICAgICAgICAgICAgdmFsdWU6IDAuMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0cmlkZUlucHV0czogW1xuICAgICAgICAgICAgICAgIFwicGhhc2VcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGludGVycG9sYXRpb246IFwibGluZWFyXCJcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogT3V0cHV0cyB0aGUgZHVyYXRpb24gb2YgdGhlIHNwZWNpZmllZCBidWZmZXIuIFJ1bnMgYXQgZWl0aGVyIGNvbnN0YW50IG9yIGNvbnRyb2wgcmF0ZS5cbiAgICAgKiBVc2UgY29udHJvbCByYXRlIG9ubHkgd2hlbiB0aGUgdW5kZXJseWluZyBidWZmZXIgbWF5IGNoYW5nZSBkeW5hbWljYWxseS5cbiAgICAgKlxuICAgICAqIElucHV0czpcbiAgICAgKiAgYnVmZmVyOiBhIGJ1ZkRlZiBvYmplY3Qgc3BlY2lmeWluZyB0aGUgYnVmZmVyIHRvIHRyYWNrXG4gICAgICovXG4gICAgZmxvY2sudWdlbi5idWZmZXJEdXJhdGlvbiA9IGZ1bmN0aW9uIChpbnB1dHMsIG91dHB1dCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgdGhhdCA9IGZsb2NrLnVnZW4oaW5wdXRzLCBvdXRwdXQsIG9wdGlvbnMpO1xuXG4gICAgICAgIHRoYXQua3JHZW4gPSBmdW5jdGlvbiAobnVtU2FtcHMpIHtcbiAgICAgICAgICAgIHZhciBtID0gdGhhdC5tb2RlbCxcbiAgICAgICAgICAgICAgICBvdXQgPSB0aGF0Lm91dHB1dCxcbiAgICAgICAgICAgICAgICBjaGFuID0gdGhhdC5pbnB1dHMuY2hhbm5lbC5vdXRwdXRbMF0sXG4gICAgICAgICAgICAgICAgc291cmNlID0gdGhhdC5idWZmZXIuZGF0YS5jaGFubmVsc1tjaGFuXSxcbiAgICAgICAgICAgICAgICByYXRlID0gdGhhdC5idWZmZXIuZm9ybWF0LnNhbXBsZVJhdGUsXG4gICAgICAgICAgICAgICAgaTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bVNhbXBzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvdXRbaV0gPSBzb3VyY2UubGVuZ3RoIC8gcmF0ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbS51bnNjYWxlZFZhbHVlID0gbS52YWx1ZSA9IGZsb2NrLnVnZW4ubGFzdE91dHB1dFZhbHVlKG51bVNhbXBzLCBvdXQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQub25JbnB1dENoYW5nZWQgPSBmdW5jdGlvbiAoaW5wdXROYW1lKSB7XG4gICAgICAgICAgICB0aGF0Lm9uQnVmZmVySW5wdXRDaGFuZ2VkKGlucHV0TmFtZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5vbkJ1ZmZlclJlYWR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5rckdlbigxKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0LmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgciA9IHRoYXQucmF0ZTtcbiAgICAgICAgICAgIHRoYXQuZ2VuID0gKHIgPT09IGZsb2NrLnJhdGVzLkNPTlRST0wgfHwgciA9PT0gZmxvY2sucmF0ZXMuQVVESU8pID8gdGhhdC5rckdlbiA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoYXQub3V0cHV0WzBdID0gMC4wO1xuICAgICAgICAgICAgZmxvY2sudWdlbi5idWZmZXIodGhhdCk7XG4gICAgICAgICAgICB0aGF0LmluaXRCdWZmZXIoKTtcbiAgICAgICAgICAgIHRoYXQub25JbnB1dENoYW5nZWQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0LmluaXQoKTtcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfTtcblxuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmxvY2sudWdlbi5idWZmZXJEdXJhdGlvblwiLCB7XG4gICAgICAgIHJhdGU6IFwiY29uc3RhbnRcIixcbiAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICBidWZmZXI6IG51bGwsXG4gICAgICAgICAgICBjaGFubmVsOiAwXG4gICAgICAgIH0sXG4gICAgICAgIHVnZW5PcHRpb25zOiB7XG4gICAgICAgICAgICBtb2RlbDoge1xuICAgICAgICAgICAgICAgIHVuc2NhbGVkVmFsdWU6IDAuMCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogMC4wXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIE91dHB1dHMgdGhlIGxlbmd0aCBvZiB0aGUgc3BlY2lmaWVkIGJ1ZmZlciBpbiBzYW1wbGVzLiBSdW5zIGF0IGVpdGhlciBjb25zdGFudCBvciBjb250cm9sIHJhdGUuXG4gICAgICogVXNlIGNvbnRyb2wgcmF0ZSBvbmx5IHdoZW4gdGhlIHVuZGVybHlpbmcgYnVmZmVyIG1heSBjaGFuZ2UgZHluYW1pY2FsbHkuXG4gICAgICpcbiAgICAgKiBJbnB1dHM6XG4gICAgICogIGJ1ZmZlcjogYSBidWZEZWYgb2JqZWN0IHNwZWNpZnlpbmcgdGhlIGJ1ZmZlciB0byB0cmFja1xuICAgICAqL1xuICAgIGZsb2NrLnVnZW4uYnVmZmVyTGVuZ3RoID0gZnVuY3Rpb24gKGlucHV0cywgb3V0cHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB0aGF0ID0gZmxvY2sudWdlbihpbnB1dHMsIG91dHB1dCwgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhhdC5rckdlbiA9IGZ1bmN0aW9uIChudW1TYW1wcykge1xuICAgICAgICAgICAgdmFyIG0gPSB0aGF0Lm1vZGVsLFxuICAgICAgICAgICAgICAgIG91dCA9IHRoYXQub3V0cHV0LFxuICAgICAgICAgICAgICAgIGNoYW4gPSB0aGF0LmlucHV0cy5jaGFubmVsLm91dHB1dFswXSxcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSB0aGF0LmJ1ZmZlci5kYXRhLmNoYW5uZWxzW2NoYW5dLFxuICAgICAgICAgICAgICAgIGxlbiA9IHNvdXJjZS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgaTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bVNhbXBzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvdXRbaV0gPSBsZW47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG0udmFsdWUgPSBtLnVuc2NhbGVkVmFsdWUgPSBsZW47XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5vbklucHV0Q2hhbmdlZCA9IGZ1bmN0aW9uIChpbnB1dE5hbWUpIHtcbiAgICAgICAgICAgIHRoYXQub25CdWZmZXJJbnB1dENoYW5nZWQoaW5wdXROYW1lKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0Lm9uQnVmZmVyUmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0LmtyR2VuKDEpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByID0gdGhhdC5yYXRlO1xuICAgICAgICAgICAgdGhhdC5nZW4gPSAociA9PT0gZmxvY2sucmF0ZXMuQ09OVFJPTCB8fCByID09PSBmbG9jay5yYXRlcy5BVURJTykgPyB0aGF0LmtyR2VuIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhhdC5vdXRwdXRbMF0gPSAwLjA7XG4gICAgICAgICAgICBmbG9jay51Z2VuLmJ1ZmZlcih0aGF0KTtcbiAgICAgICAgICAgIHRoYXQuaW5pdEJ1ZmZlcigpO1xuICAgICAgICAgICAgdGhhdC5vbklucHV0Q2hhbmdlZCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQuaW5pdCgpO1xuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICB9O1xuXG4gICAgZmx1aWQuZGVmYXVsdHMoXCJmbG9jay51Z2VuLmJ1ZmZlckxlbmd0aFwiLCB7XG4gICAgICAgIHJhdGU6IFwiY29uc3RhbnRcIixcbiAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICBidWZmZXI6IG51bGwsXG4gICAgICAgICAgICBjaGFubmVsOiAwXG4gICAgICAgIH0sXG4gICAgICAgIHVnZW5PcHRpb25zOiB7XG4gICAgICAgICAgICBtb2RlbDoge1xuICAgICAgICAgICAgICAgIHVuc2NhbGVkVmFsdWU6IDAuMCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogMC4wXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIE91dHB1dHMgYSBwaGFzZSBzdGVwIHZhbHVlIGZvciBwbGF5aW5nIHRoZSBzcGVjaWZpZWQgYnVmZmVyIGF0IGl0cyBub3JtYWwgcGxheWJhY2sgcmF0ZS5cbiAgICAgKiBUaGlzIHVuaXQgZ2VuZXJhdG9yIHRha2VzIGludG8gYWNjb3VudCBhbnkgZGlmZmVyZW5jZXMgYmV0d2VlbiB0aGUgc291bmQgZmlsZSdzIHNhbXBsZSByYXRlIGFuZFxuICAgICAqIHRoZSBlbnZpcm9ubWVudCdzIGF1ZGlvIHJhdGUuXG4gICAgICpcbiAgICAgKiBJbnB1dHM6XG4gICAgICogIGJ1ZmZlcjogYSBidWZEZWYgb2JqZWN0IHNwZWNpZnlpbmcgdGhlIGJ1ZmZlciB0byB0cmFja1xuICAgICAqL1xuICAgIGZsb2NrLnVnZW4uYnVmZmVyUGhhc2VTdGVwID0gZnVuY3Rpb24gKGlucHV0cywgb3V0cHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB0aGF0ID0gZmxvY2sudWdlbihpbnB1dHMsIG91dHB1dCwgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhhdC5rckdlbiA9IGZ1bmN0aW9uIChudW1TYW1wcykge1xuICAgICAgICAgICAgdmFyIG0gPSB0aGF0Lm1vZGVsLFxuICAgICAgICAgICAgICAgIG91dCA9IHRoYXQub3V0cHV0LFxuICAgICAgICAgICAgICAgIHZhbCA9IG0udW5zY2FsZWRWYWx1ZSxcbiAgICAgICAgICAgICAgICBpO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtU2FtcHM7IGkrKykge1xuICAgICAgICAgICAgICAgIG91dFtpXSA9IHZhbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhhdC5tdWxBZGQobnVtU2FtcHMpO1xuICAgICAgICAgICAgbS52YWx1ZSA9IGZsb2NrLnVnZW4ubGFzdE91dHB1dFZhbHVlKG51bVNhbXBzLCBvdXQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQub25JbnB1dENoYW5nZWQgPSBmdW5jdGlvbiAoaW5wdXROYW1lKSB7XG4gICAgICAgICAgICB0aGF0Lm9uQnVmZmVySW5wdXRDaGFuZ2VkKGlucHV0TmFtZSk7XG4gICAgICAgICAgICBmbG9jay5vbk11bEFkZElucHV0Q2hhbmdlZCh0aGF0KTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0Lm9uQnVmZmVyUmVhZHkgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgICAgICB2YXIgbSA9IHRoYXQubW9kZWwsXG4gICAgICAgICAgICAgICAgY2hhbiA9IHRoYXQuaW5wdXRzLmNoYW5uZWwub3V0cHV0WzBdLFxuICAgICAgICAgICAgICAgIHNvdXJjZSA9IGJ1ZmZlci5kYXRhLmNoYW5uZWxzW2NoYW5dLFxuICAgICAgICAgICAgICAgIGVudmlyb1JhdGUgPSB0aGF0Lm9wdGlvbnMuYXVkaW9TZXR0aW5ncy5yYXRlcy5hdWRpbyxcbiAgICAgICAgICAgICAgICBidWZmZXJSYXRlID0gdGhhdC5idWZmZXIuZm9ybWF0LnNhbXBsZVJhdGUgfHwgZW52aXJvUmF0ZTtcblxuICAgICAgICAgICAgbS5zY2FsZSA9IGJ1ZmZlclJhdGUgLyBlbnZpcm9SYXRlO1xuICAgICAgICAgICAgdGhhdC5vdXRwdXRbMF0gPSBtLnVuc2NhbGVkVmFsdWUgPSAxIC8gKHNvdXJjZS5sZW5ndGggKiBtLnNjYWxlKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0LmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgciA9IHRoYXQucmF0ZTtcbiAgICAgICAgICAgIHRoYXQuZ2VuID0gKHIgPT09IGZsb2NrLnJhdGVzLkNPTlRST0wgfHwgciA9PT0gZmxvY2sucmF0ZXMuQVVESU8pID8gdGhhdC5rckdlbiA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoYXQub3V0cHV0WzBdID0gMC4wO1xuICAgICAgICAgICAgZmxvY2sudWdlbi5idWZmZXIodGhhdCk7XG4gICAgICAgICAgICB0aGF0LmluaXRCdWZmZXIoKTtcbiAgICAgICAgICAgIHRoYXQub25JbnB1dENoYW5nZWQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0LmluaXQoKTtcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfTtcblxuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmxvY2sudWdlbi5idWZmZXJQaGFzZVN0ZXBcIiwge1xuICAgICAgICByYXRlOiBcImNvbnN0YW50XCIsXG4gICAgICAgIGlucHV0czoge1xuICAgICAgICAgICAgYnVmZmVyOiBudWxsLFxuICAgICAgICAgICAgY2hhbm5lbDogMFxuICAgICAgICB9LFxuICAgICAgICB1Z2VuT3B0aW9uczoge1xuICAgICAgICAgICAgbW9kZWw6IHtcbiAgICAgICAgICAgICAgICBzY2FsZTogMS4wLFxuICAgICAgICAgICAgICAgIHVuc2NhbGVkVmFsdWU6IDAuMCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogMC4wXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnN0YW50LXJhdGUgdW5pdCBnZW5lcmF0b3IgdGhhdCBvdXRwdXRzIHRoZSBlbnZpcm9ubWVudCdzIGN1cnJlbnQgYXVkaW8gc2FtcGxlIHJhdGUuXG4gICAgICovXG4gICAgZmxvY2sudWdlbi5zYW1wbGVSYXRlID0gZnVuY3Rpb24gKGlucHV0cywgb3V0cHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB0aGF0ID0gZmxvY2sudWdlbihpbnB1dHMsIG91dHB1dCwgb3B0aW9ucyksXG4gICAgICAgICAgICBtID0gdGhhdC5tb2RlbDtcblxuICAgICAgICB0aGF0Lm91dHB1dFswXSA9IG0udmFsdWUgPSBtLnVuc2NhbGVkVmFsdWUgPSB0aGF0Lm9wdGlvbnMuYXVkaW9TZXR0aW5ncy5yYXRlcy5hdWRpbztcblxuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICB9O1xuXG4gICAgZmx1aWQuZGVmYXVsdHMoXCJmbG9jay51Z2VuLnNhbXBsZVJhdGVcIiwge1xuICAgICAgICByYXRlOiBcImNvbnN0YW50XCIsXG4gICAgICAgIGlucHV0czoge31cbiAgICB9KTtcblxuXG4gICAgLyoqKioqKioqKlxuICAgICAqIE5vaXNlICpcbiAgICAgKioqKioqKioqL1xuXG4gICAgZmxvY2sudWdlbi5kdXN0ID0gZnVuY3Rpb24gKGlucHV0cywgb3V0cHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB0aGF0ID0gZmxvY2sudWdlbihpbnB1dHMsIG91dHB1dCwgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhhdC5nZW4gPSBmdW5jdGlvbiAobnVtU2FtcHMpIHtcbiAgICAgICAgICAgIHZhciBtID0gdGhhdC5tb2RlbCxcbiAgICAgICAgICAgICAgICBvdXQgPSB0aGF0Lm91dHB1dCxcbiAgICAgICAgICAgICAgICBkZW5zaXR5ID0gaW5wdXRzLmRlbnNpdHkub3V0cHV0WzBdLCAvLyBEZW5zaXR5IGlzIGtyLlxuICAgICAgICAgICAgICAgIHRocmVzaG9sZCxcbiAgICAgICAgICAgICAgICBzY2FsZSxcbiAgICAgICAgICAgICAgICByYW5kLFxuICAgICAgICAgICAgICAgIHZhbCxcbiAgICAgICAgICAgICAgICBpO1xuXG4gICAgICAgICAgICBpZiAoZGVuc2l0eSAhPT0gbS5kZW5zaXR5KSB7XG4gICAgICAgICAgICAgICAgbS5kZW5zaXR5ID0gZGVuc2l0eTtcbiAgICAgICAgICAgICAgICB0aHJlc2hvbGQgPSBtLnRocmVzaG9sZCA9IGRlbnNpdHkgKiBtLnNhbXBsZUR1cjtcbiAgICAgICAgICAgICAgICBzY2FsZSA9IG0uc2NhbGUgPSB0aHJlc2hvbGQgPiAwLjAgPyAxLjAgLyB0aHJlc2hvbGQgOiAwLjA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocmVzaG9sZCA9IG0udGhyZXNob2xkO1xuICAgICAgICAgICAgICAgIHNjYWxlID0gbS5zY2FsZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bVNhbXBzOyBpKyspIHtcbiAgICAgICAgICAgICAgICByYW5kID0gTWF0aC5yYW5kb20oKTtcbiAgICAgICAgICAgICAgICB2YWwgPSAocmFuZCA8IHRocmVzaG9sZCkgPyByYW5kICogc2NhbGUgOiAwLjA7XG4gICAgICAgICAgICAgICAgb3V0W2ldID0gdmFsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtLnVuc2NhbGVkVmFsdWUgPSB2YWw7XG4gICAgICAgICAgICB0aGF0Lm11bEFkZChudW1TYW1wcyk7XG4gICAgICAgICAgICBtLnZhbHVlID0gZmxvY2sudWdlbi5sYXN0T3V0cHV0VmFsdWUobnVtU2FtcHMsIG91dCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5vbklucHV0Q2hhbmdlZCgpO1xuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICB9O1xuXG4gICAgZmx1aWQuZGVmYXVsdHMoXCJmbG9jay51Z2VuLmR1c3RcIiwge1xuICAgICAgICByYXRlOiBcImF1ZGlvXCIsXG4gICAgICAgIGlucHV0czoge1xuICAgICAgICAgICAgZGVuc2l0eTogMS4wLFxuICAgICAgICAgICAgbXVsOiBudWxsLFxuICAgICAgICAgICAgYWRkOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIHVnZW5PcHRpb25zOiB7XG4gICAgICAgICAgICBtb2RlbDoge1xuICAgICAgICAgICAgICAgIGRlbnNpdHk6IDAuMCxcbiAgICAgICAgICAgICAgICBzY2FsZTogMC4wLFxuICAgICAgICAgICAgICAgIHRocmVzaG9sZDogMC4wLFxuICAgICAgICAgICAgICAgIHVuc2NhbGVkVmFsdWU6IDAuMCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogMC4wXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG4gICAgZmxvY2sudWdlbi53aGl0ZU5vaXNlID0gZnVuY3Rpb24gKGlucHV0cywgb3V0cHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB0aGF0ID0gZmxvY2sudWdlbihpbnB1dHMsIG91dHB1dCwgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhhdC5nZW4gPSBmdW5jdGlvbiAobnVtU2FtcHMpIHtcbiAgICAgICAgICAgIHZhciBtID0gdGhhdC5tb2RlbCxcbiAgICAgICAgICAgICAgICBvdXQgPSB0aGF0Lm91dHB1dCxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIHZhbDtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bVNhbXBzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvdXRbaV0gPSB2YWwgPSBNYXRoLnJhbmRvbSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtLnVuc2NhbGVkVmFsdWUgPSB2YWw7XG4gICAgICAgICAgICB0aGF0Lm11bEFkZChudW1TYW1wcyk7XG4gICAgICAgICAgICBtLnZhbHVlID0gZmxvY2sudWdlbi5sYXN0T3V0cHV0VmFsdWUobnVtU2FtcHMsIG91dCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5vbklucHV0Q2hhbmdlZCgpO1xuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICB9O1xuXG4gICAgZmx1aWQuZGVmYXVsdHMoXCJmbG9jay51Z2VuLndoaXRlTm9pc2VcIiwge1xuICAgICAgICByYXRlOiBcImF1ZGlvXCIsXG4gICAgICAgIGlucHV0czoge1xuICAgICAgICAgICAgbXVsOiBudWxsLFxuICAgICAgICAgICAgYWRkOiBudWxsXG4gICAgICAgIH1cbiAgICB9KTtcblxuXG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50cyBMYXJyeSBUcmFtaWVsJ3MgZmlyc3QgUGluayBOb2lzZSBhbGdvcml0aG1cbiAgICAgKiBkZXNjcmliZWQgYXQgaHR0cDovL2hvbWUuZWFydGhsaW5rLm5ldC9+bHRyYW1tZWxsL3RlY2gvcGlua2FsZy5odG0sXG4gICAgICogYmFzZWQgb24gYSB2ZXJzaW9uIGJ5IERhdmlkIExvd2VuZmVscyBwb3N0ZWQgdG8gbXVzaWNkc3A6XG4gICAgICogaHR0cDovL3d3dy5tdXNpY2RzcC5vcmcvc2hvd29uZS5waHA/aWQ9MjIwLlxuICAgICAqL1xuICAgIGZsb2NrLnVnZW4ucGlua05vaXNlID0gZnVuY3Rpb24gKGlucHV0cywgb3V0cHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB0aGF0ID0gZmxvY2sudWdlbihpbnB1dHMsIG91dHB1dCwgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhhdC5nZW4gPSBmdW5jdGlvbiAobnVtU2FtcHMpIHtcbiAgICAgICAgICAgIHZhciBtID0gdGhhdC5tb2RlbCxcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IG0uc3RhdGUsXG4gICAgICAgICAgICAgICAgYSA9IHRoYXQuYSxcbiAgICAgICAgICAgICAgICBwID0gdGhhdC5wLFxuICAgICAgICAgICAgICAgIG9mZnNldCA9IG0ub2Zmc2V0LFxuICAgICAgICAgICAgICAgIG91dCA9IHRoYXQub3V0cHV0LFxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgaixcbiAgICAgICAgICAgICAgICByYW5kLFxuICAgICAgICAgICAgICAgIHZhbDtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bVNhbXBzOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBzdGF0ZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICByYW5kID0gTWF0aC5yYW5kb20oKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVbal0gPSBwW2pdICogKHN0YXRlW2pdIC0gcmFuZCkgKyByYW5kO1xuICAgICAgICAgICAgICAgICAgICB2YWwgKz0gYVtqXSAqIHN0YXRlW2pdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWwgPSB2YWwgKiAyIC0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIG91dFtpXSA9IHZhbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbS51bnNjYWxlZFZhbHVlID0gdmFsO1xuICAgICAgICAgICAgdGhhdC5tdWxBZGQobnVtU2FtcHMpO1xuICAgICAgICAgICAgbS52YWx1ZSA9IGZsb2NrLnVnZW4ubGFzdE91dHB1dFZhbHVlKG51bVNhbXBzLCBvdXQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQuYSA9IG5ldyBGbG9hdDMyQXJyYXkodGhhdC5vcHRpb25zLmNvZWZmcy5hKTtcbiAgICAgICAgICAgIHRoYXQucCA9IG5ldyBGbG9hdDMyQXJyYXkodGhhdC5vcHRpb25zLmNvZWZmcy5wKTtcbiAgICAgICAgICAgIHRoYXQubW9kZWwuc3RhdGUgPSBuZXcgRmxvYXQzMkFycmF5KHRoYXQuYS5sZW5ndGgpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoYXQuYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoYXQubW9kZWwub2Zmc2V0ICs9IHRoYXQuYVtpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhhdC5vbklucHV0Q2hhbmdlZCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQuaW5pdCgpO1xuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICB9O1xuXG4gICAgZmx1aWQuZGVmYXVsdHMoXCJmbG9jay51Z2VuLnBpbmtOb2lzZVwiLCB7XG4gICAgICAgIHJhdGU6IFwiYXVkaW9cIixcbiAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICBtdWw6IG51bGwsXG4gICAgICAgICAgICBhZGQ6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgdWdlbk9wdGlvbnM6IHtcbiAgICAgICAgICAgIG1vZGVsOiB7XG4gICAgICAgICAgICAgICAgc3RhdGU6IDAuMCxcbiAgICAgICAgICAgICAgICB1bnNjYWxlZFZhbHVlOiAwLjAsXG4gICAgICAgICAgICAgICAgdmFsdWU6IDAuMCxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb2VmZnM6IHtcbiAgICAgICAgICAgICAgICBhOiBbMC4wMjEwOTIzOCwgMC4wNzExMzQ3OCwgMC42ODg3MzU1OF0sXG4gICAgICAgICAgICAgICAgcDogWzAuMzE5MCwgMC43NzU2LCAwLjk2MTNdXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZsb2NrLnVnZW4ubGZOb2lzZSA9IGZ1bmN0aW9uIChpbnB1dHMsIG91dHB1dCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgdGhhdCA9IGZsb2NrLnVnZW4oaW5wdXRzLCBvdXRwdXQsIG9wdGlvbnMpO1xuXG4gICAgICAgIHRoYXQuZ2VuID0gZnVuY3Rpb24gKG51bVNhbXBzKSB7XG4gICAgICAgICAgICB2YXIgbSA9IHRoYXQubW9kZWwsXG4gICAgICAgICAgICAgICAgZnJlcSA9IGlucHV0cy5mcmVxLm91dHB1dFswXSwgLy8gRnJlcSBpcyBrci5cbiAgICAgICAgICAgICAgICByZW1haW4gPSBudW1TYW1wcyxcbiAgICAgICAgICAgICAgICBvdXQgPSB0aGF0Lm91dHB1dCxcbiAgICAgICAgICAgICAgICBjdXJyU2FtcCA9IDAsXG4gICAgICAgICAgICAgICAgc2FtcHNGb3JMZXZlbCxcbiAgICAgICAgICAgICAgICBpO1xuXG4gICAgICAgICAgICBmcmVxID0gZnJlcSA+IDAuMDAxID8gZnJlcSA6IDAuMDAxO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGlmIChtLmNvdW50ZXIgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICBtLmNvdW50ZXIgPSBtLnNhbXBsZVJhdGUgLyBmcmVxO1xuICAgICAgICAgICAgICAgICAgICBtLmNvdW50ZXIgPSBtLmNvdW50ZXIgPiAxID8gbS5jb3VudGVyIDogMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQub3B0aW9ucy5pbnRlcnBvbGF0aW9uID09PSBcImxpbmVhclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtLnN0YXJ0ID0gbS51bnNjYWxlZFZhbHVlID0gbS5lbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBtLmVuZCA9IE1hdGgucmFuZG9tKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtLnJhbXAgPSBtLnJhbXAgPSAobS5lbmQgLSBtLnN0YXJ0KSAvIG0uY291bnRlcjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uc3RhcnQgPSBtLnVuc2NhbGVkVmFsdWUgPSBNYXRoLnJhbmRvbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbS5yYW1wID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzYW1wc0ZvckxldmVsID0gcmVtYWluIDwgbS5jb3VudGVyID8gcmVtYWluIDogbS5jb3VudGVyO1xuICAgICAgICAgICAgICAgIHJlbWFpbiAtPSBzYW1wc0ZvckxldmVsO1xuICAgICAgICAgICAgICAgIG0uY291bnRlciAtPSBzYW1wc0ZvckxldmVsO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzYW1wc0ZvckxldmVsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0W2N1cnJTYW1wXSA9IG0udW5zY2FsZWRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFRoaXMgcmV1c2Ugb2YgXCJ1bnNjYWxlZFZhbHVlXCIgd2lsbCBjYXVzZSB0aGUgbW9kZWwgdG8gYmUgb3V0IG9mIHN5bmNcbiAgICAgICAgICAgICAgICAgICAgIC8vIHdpdGggdGhlIGFjdHVhbCBvdXRwdXQgb2YgdGhlIHVuaXQgZ2VuZXJhdG9yLlxuICAgICAgICAgICAgICAgICAgICBtLnVuc2NhbGVkVmFsdWUgKz0gbS5yYW1wO1xuICAgICAgICAgICAgICAgICAgICBjdXJyU2FtcCsrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSB3aGlsZSAocmVtYWluKTtcblxuICAgICAgICAgICAgdGhhdC5tdWxBZGQobnVtU2FtcHMpO1xuICAgICAgICAgICAgbS52YWx1ZSA9IGZsb2NrLnVnZW4ubGFzdE91dHB1dFZhbHVlKG51bVNhbXBzLCBvdXQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQuaW5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0Lm1vZGVsLmVuZCA9IE1hdGgucmFuZG9tKCk7XG4gICAgICAgICAgICB0aGF0Lm9uSW5wdXRDaGFuZ2VkKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5pbnB1dCgpO1xuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICB9O1xuXG4gICAgZmx1aWQuZGVmYXVsdHMoXCJmbG9jay51Z2VuLmxmTm9pc2VcIiwge1xuICAgICAgICByYXRlOiBcImF1ZGlvXCIsXG4gICAgICAgIGlucHV0czoge1xuICAgICAgICAgICAgZnJlcTogNDQwLFxuICAgICAgICAgICAgbXVsOiBudWxsLFxuICAgICAgICAgICAgYWRkOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIHVnZW5PcHRpb25zOiB7XG4gICAgICAgICAgICBtb2RlbDoge1xuICAgICAgICAgICAgICAgIGNvdW50ZXI6IDAsXG4gICAgICAgICAgICAgICAgbGV2ZWw6IDAsXG4gICAgICAgICAgICAgICAgdW5zY2FsZWRWYWx1ZTogMC4wLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAwLjBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICogUmFuZG9tIGRpc3RyaWJ1dGlvbnMgdXNpbmcgU2ltLmpzJyBSYW5kb20gbGlicmFyeSAqXG4gICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgLy8gVE9ETzogVW5pdCB0ZXN0cy5cbiAgICBmbG9jay51Z2VuLnJhbmRvbSA9IGZ1bmN0aW9uIChpbnB1dHMsIG91dHB1dCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgdGhhdCA9IGZsb2NrLnVnZW4oaW5wdXRzLCBvdXRwdXQsIG9wdGlvbnMpO1xuXG4gICAgICAgIHRoYXQuZ2VuID0gZnVuY3Rpb24gKG51bVNhbXBzKSB7XG4gICAgICAgICAgICB2YXIgbSA9IHRoYXQubW9kZWwsXG4gICAgICAgICAgICAgICAgZ2VuZXJhdG9yID0gdGhhdC5nZW5lcmF0b3IsXG4gICAgICAgICAgICAgICAgb3V0ID0gdGhhdC5vdXRwdXQsXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICB2YWw7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1TYW1wczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0W2ldID0gdmFsID0gZ2VuZXJhdG9yLnVuaWZvcm0oLTEsIDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtLnVuc2NhbGVkVmFsdWUgPSB2YWw7XG4gICAgICAgICAgICB0aGF0Lm11bEFkZChudW1TYW1wcyk7XG4gICAgICAgICAgICBtLnZhbHVlID0gZmxvY2sudWdlbi5sYXN0T3V0cHV0VmFsdWUobnVtU2FtcHMsIG91dCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5vbklucHV0Q2hhbmdlZCA9IGZ1bmN0aW9uIChpbnB1dE5hbWUpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dE5hbWUgPT09IFwic2VlZFwiKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5pbml0R2VuZXJhdG9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbG9jay5vbk11bEFkZElucHV0Q2hhbmdlZCh0aGF0KTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0LmluaXRHZW5lcmF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc2VlZCA9IHRoYXQuaW5wdXRzLnNlZWQ7XG4gICAgICAgICAgICB0aGF0LmdlbmVyYXRvciA9IHNlZWQgPyBuZXcgUmFuZG9tKHNlZWQpIDogbmV3IFJhbmRvbSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQuaW5pdEdlbmVyYXRvcigpO1xuICAgICAgICAgICAgdGhhdC5jYWxjdWxhdGVTdHJpZGVzKCk7XG4gICAgICAgICAgICB0aGF0Lm9uSW5wdXRDaGFuZ2VkKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5pbml0KCk7XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgIH07XG5cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsb2NrLnVnZW4ucmFuZG9tXCIsIHtcbiAgICAgICAgcmF0ZTogXCJhdWRpb1wiLFxuICAgICAgICBpbnB1dHM6IHtcbiAgICAgICAgICAgIHNlZWQ6IG51bGwsXG4gICAgICAgICAgICBtdWw6IG51bGwsXG4gICAgICAgICAgICBhZGQ6IG51bGxcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gVE9ETzogVW5pdCB0ZXN0cy5cbiAgICBmbG9jay51Z2VuLnJhbmRvbS5leHBvbmVudGlhbCA9IGZ1bmN0aW9uIChpbnB1dHMsIG91dHB1dCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgdGhhdCA9IGZsb2NrLnVnZW4ucmFuZG9tKGlucHV0cywgb3V0cHV0LCBvcHRpb25zKTtcblxuICAgICAgICB0aGF0LmdlbiA9IGZ1bmN0aW9uIChudW1TYW1wcykge1xuICAgICAgICAgICAgdmFyIG0gPSB0aGF0Lm1vZGVsLFxuICAgICAgICAgICAgICAgIGdlbmVyYXRvciA9IHRoYXQuZ2VuZXJhdG9yLFxuICAgICAgICAgICAgICAgIG91dCA9IHRoYXQub3V0cHV0LFxuICAgICAgICAgICAgICAgIGxhbWJkYSA9IHRoYXQuaW5wdXRzLmxhbWJkYS5vdXRwdXQsXG4gICAgICAgICAgICAgICAgbGFtYmRhSW5jID0gdGhhdC5tb2RlbC5zdHJpZGVzLmxhbWJkYSxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIGosXG4gICAgICAgICAgICAgICAgdmFsO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSBqID0gMDsgaSA8IG51bVNhbXBzOyBpKyssIGogKz0gbGFtYmRhSW5jKSB7XG4gICAgICAgICAgICAgICAgb3V0W2ldID0gdmFsID0gZ2VuZXJhdG9yLmV4cG9uZW50aWFsKGxhbWJkYVtqXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG0udW5zY2FsZWRWYWx1ZSA9IHZhbDtcbiAgICAgICAgICAgIHRoYXQubXVsQWRkKG51bVNhbXBzKTtcbiAgICAgICAgICAgIG0udmFsdWUgPSBmbG9jay51Z2VuLmxhc3RPdXRwdXRWYWx1ZShudW1TYW1wcywgb3V0KTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICB9O1xuXG4gICAgZmx1aWQuZGVmYXVsdHMoXCJmbG9jay51Z2VuLnJhbmRvbS5leHBvbmVudGlhbFwiLCB7XG4gICAgICAgIHJhdGU6IFwiYXVkaW9cIixcbiAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICBzZWVkOiBudWxsLFxuICAgICAgICAgICAgbGFtYmRhOiAxLFxuICAgICAgICAgICAgbXVsOiBudWxsLFxuICAgICAgICAgICAgYWRkOiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgdWdlbk9wdGlvbnM6IHtcbiAgICAgICAgICAgIHN0cmlkZUlucHV0czogW1wibGFtYmRhXCJdXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFRPRE86IFVuaXQgdGVzdHMuXG4gICAgZmxvY2sudWdlbi5yYW5kb20uZ2FtbWEgPSBmdW5jdGlvbiAoaW5wdXRzLCBvdXRwdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHRoYXQgPSBmbG9jay51Z2VuLnJhbmRvbShpbnB1dHMsIG91dHB1dCwgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhhdC5nZW4gPSBmdW5jdGlvbiAobnVtU2FtcHMpIHtcbiAgICAgICAgICAgIHZhciBtID0gdGhhdC5tb2RlbCxcbiAgICAgICAgICAgICAgICBpbnB1dHMgPSB0aGF0LmlucHV0cyxcbiAgICAgICAgICAgICAgICBnZW5lcmF0b3IgPSB0aGF0LmdlbmVyYXRvcixcbiAgICAgICAgICAgICAgICBvdXQgPSB0aGF0Lm91dHB1dCxcbiAgICAgICAgICAgICAgICBhbHBoYUluYyA9IG0uc3RyaWRlcy5hbHBoYSxcbiAgICAgICAgICAgICAgICBhbHBoYSA9IGlucHV0cy5hbHBoYS5vdXRwdXQsXG4gICAgICAgICAgICAgICAgYmV0YUluYyA9IG0uc3RyaWRlcy5iZXRhLFxuICAgICAgICAgICAgICAgIGJldGEgPSBpbnB1dHMuYmV0YS5vdXRwdXQsXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICBqLFxuICAgICAgICAgICAgICAgIGssXG4gICAgICAgICAgICAgICAgdmFsO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSBqID0gayA9IDA7IGkgPCBudW1TYW1wczsgaSsrLCBqICs9IGFscGhhSW5jLCBrICs9IGJldGFJbmMpIHtcbiAgICAgICAgICAgICAgICBvdXRbaV0gPSB2YWwgPSBnZW5lcmF0b3IuZ2FtbWEoYWxwaGFbal0sIGJldGFba10pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtLnVuc2NhbGVkVmFsdWUgPSB2YWw7XG4gICAgICAgICAgICB0aGF0Lm11bEFkZChudW1TYW1wcyk7XG4gICAgICAgICAgICBtLnZhbHVlID0gZmxvY2sudWdlbi5sYXN0T3V0cHV0VmFsdWUobnVtU2FtcHMsIG91dCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfTtcblxuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmxvY2sudWdlbi5yYW5kb20uZ2FtbWFcIiwge1xuICAgICAgICByYXRlOiBcImF1ZGlvXCIsXG4gICAgICAgIGlucHV0czoge1xuICAgICAgICAgICAgc2VlZDogbnVsbCxcbiAgICAgICAgICAgIGFscGhhOiAxLFxuICAgICAgICAgICAgYmV0YTogMixcbiAgICAgICAgICAgIG11bDogbnVsbCxcbiAgICAgICAgICAgIGFkZDogbnVsbFxuICAgICAgICB9LFxuXG4gICAgICAgIHVnZW5PcHRpb25zOiB7XG4gICAgICAgICAgICBzdHJpZGVJbnB1dHM6IFtcImFscGhhXCIsIFwiYmV0YVwiXVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBUT0RPOiBVbml0IHRlc3RzLlxuICAgIGZsb2NrLnVnZW4ucmFuZG9tLm5vcm1hbCA9IGZ1bmN0aW9uIChpbnB1dHMsIG91dHB1dCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgdGhhdCA9IGZsb2NrLnVnZW4ucmFuZG9tKGlucHV0cywgb3V0cHV0LCBvcHRpb25zKTtcblxuICAgICAgICB0aGF0LmdlbiA9IGZ1bmN0aW9uIChudW1TYW1wcykge1xuICAgICAgICAgICAgdmFyIG0gPSB0aGF0Lm1vZGVsLFxuICAgICAgICAgICAgICAgIG91dCA9IHRoYXQub3V0cHV0LFxuICAgICAgICAgICAgICAgIGlucHV0cyA9IHRoYXQuaW5wdXRzLFxuICAgICAgICAgICAgICAgIGdlbmVyYXRvciA9IHRoYXQuZ2VuZXJhdG9yLFxuICAgICAgICAgICAgICAgIG11SW5jID0gbS5zdHJpZGVzLm11LFxuICAgICAgICAgICAgICAgIG11ID0gaW5wdXRzLm11Lm91dHB1dCxcbiAgICAgICAgICAgICAgICBzaWdtYUluYyA9IG0uc3RyaWRlcy5zaWdtYSxcbiAgICAgICAgICAgICAgICBzaWdtYSA9IGlucHV0cy5zaWdtYS5vdXRwdXQsXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICBqLFxuICAgICAgICAgICAgICAgIGssXG4gICAgICAgICAgICAgICAgdmFsO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSBqID0gayA9IDA7IGkgPCBudW1TYW1wczsgaSsrLCBqICs9IG11SW5jLCBrICs9IHNpZ21hSW5jKSB7XG4gICAgICAgICAgICAgICAgb3V0W2ldID0gdmFsID0gZ2VuZXJhdG9yLm5vcm1hbChtdVtqXSwgc2lnbWFba10pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtLnVuc2NhbGVkVmFsdWUgPSB2YWw7XG4gICAgICAgICAgICB0aGF0Lm11bEFkZChudW1TYW1wcyk7XG4gICAgICAgICAgICBtLnZhbHVlID0gZmxvY2sudWdlbi5sYXN0T3V0cHV0VmFsdWUobnVtU2FtcHMsIG91dCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfTtcblxuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmxvY2sudWdlbi5yYW5kb20ubm9ybWFsXCIsIHtcbiAgICAgICAgcmF0ZTogXCJhdWRpb1wiLFxuICAgICAgICBpbnB1dHM6IHtcbiAgICAgICAgICAgIHNlZWQ6IG51bGwsXG4gICAgICAgICAgICBtdTogMCxcbiAgICAgICAgICAgIHNpZ21hOiAxLFxuICAgICAgICAgICAgbXVsOiBudWxsLFxuICAgICAgICAgICAgYWRkOiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgdWdlbk9wdGlvbnM6IHtcbiAgICAgICAgICAgIHN0cmlkZUlucHV0czogW1wibXVcIiwgXCJzaWdtYVwiXVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBUT0RPOiBVbml0IHRlc3RzLlxuICAgIGZsb2NrLnVnZW4ucmFuZG9tLnBhcmV0byA9IGZ1bmN0aW9uIChpbnB1dHMsIG91dHB1dCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgdGhhdCA9IGZsb2NrLnVnZW4ucmFuZG9tKGlucHV0cywgb3V0cHV0LCBvcHRpb25zKTtcblxuICAgICAgICB0aGF0LmdlbiA9IGZ1bmN0aW9uIChudW1TYW1wcykge1xuICAgICAgICAgICAgdmFyIG0gPSB0aGF0Lm1vZGVsLFxuICAgICAgICAgICAgICAgIGdlbmVyYXRvciA9IHRoYXQuZ2VuZXJhdG9yLFxuICAgICAgICAgICAgICAgIG91dCA9IHRoYXQub3V0cHV0LFxuICAgICAgICAgICAgICAgIGFscGhhSW5jID0gdGhhdC5tb2RlbC5zdHJpZGVzLmFscGhhLFxuICAgICAgICAgICAgICAgIGFscGhhID0gdGhhdC5pbnB1dHMuYWxwaGEub3V0cHV0LFxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgaixcbiAgICAgICAgICAgICAgICB2YWw7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IGogPSAwOyBpIDwgbnVtU2FtcHM7IGkrKywgaiArPSBhbHBoYUluYykge1xuICAgICAgICAgICAgICAgIG91dFtpXSA9IHZhbCA9IGdlbmVyYXRvci5wYXJldG8oYWxwaGFbal0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtLnVuc2NhbGVkVmFsdWUgPSB2YWw7XG4gICAgICAgICAgICB0aGF0Lm11bEFkZChudW1TYW1wcyk7XG4gICAgICAgICAgICBtLnZhbHVlID0gZmxvY2sudWdlbi5sYXN0T3V0cHV0VmFsdWUobnVtU2FtcHMsIG91dCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfTtcblxuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmxvY2sudWdlbi5yYW5kb20ucGFyZXRvXCIsIHtcbiAgICAgICAgcmF0ZTogXCJhdWRpb1wiLFxuICAgICAgICBpbnB1dHM6IHtcbiAgICAgICAgICAgIHNlZWQ6IG51bGwsXG4gICAgICAgICAgICBhbHBoYTogNSxcbiAgICAgICAgICAgIG11bDogbnVsbCxcbiAgICAgICAgICAgIGFkZDogbnVsbFxuICAgICAgICB9LFxuXG4gICAgICAgIHVnZW5PcHRpb25zOiB7XG4gICAgICAgICAgICBzdHJpZGVJbnB1dHM6IFtcImFscGhhXCJdXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFRPRE86IFVuaXQgdGVzdHMuXG4gICAgZmxvY2sudWdlbi5yYW5kb20udHJpYW5ndWxhciA9IGZ1bmN0aW9uIChpbnB1dHMsIG91dHB1dCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgdGhhdCA9IGZsb2NrLnVnZW4ucmFuZG9tKGlucHV0cywgb3V0cHV0LCBvcHRpb25zKTtcblxuICAgICAgICB0aGF0LmdlbiA9IGZ1bmN0aW9uIChudW1TYW1wcykge1xuICAgICAgICAgICAgdmFyIG0gPSB0aGF0Lm1vZGVsLFxuICAgICAgICAgICAgICAgIGdlbmVyYXRvciA9IHRoYXQuZ2VuZXJhdG9yLFxuICAgICAgICAgICAgICAgIG91dCA9IHRoYXQub3V0cHV0LFxuICAgICAgICAgICAgICAgIG1vZGVJbmMgPSB0aGF0Lm1vZGVsLnN0cmlkZXMubW9kZSxcbiAgICAgICAgICAgICAgICBtb2RlID0gdGhhdC5pbnB1dHMubW9kZS5vdXRwdXQsXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICBqLFxuICAgICAgICAgICAgICAgIHZhbDtcblxuICAgICAgICAgICAgZm9yIChpID0gaiA9IDA7IGkgPCBudW1TYW1wczsgaSsrLCBqICs9IG1vZGVJbmMpIHtcbiAgICAgICAgICAgICAgICBvdXRbaV0gPSB2YWwgPSBnZW5lcmF0b3IudHJpYW5ndWxhcigtMSwgMSwgbW9kZVtqXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG0udW5zY2FsZWRWYWx1ZSA9IHZhbDtcbiAgICAgICAgICAgIHRoYXQubXVsQWRkKG51bVNhbXBzKTtcbiAgICAgICAgICAgIG0udmFsdWUgPSBmbG9jay51Z2VuLmxhc3RPdXRwdXRWYWx1ZShudW1TYW1wcywgb3V0KTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICB9O1xuXG4gICAgZmx1aWQuZGVmYXVsdHMoXCJmbG9jay51Z2VuLnJhbmRvbS50cmlhbmd1bGFyXCIsIHtcbiAgICAgICAgcmF0ZTogXCJhdWRpb1wiLFxuICAgICAgICBpbnB1dHM6IHtcbiAgICAgICAgICAgIHNlZWQ6IG51bGwsXG4gICAgICAgICAgICBtb2RlOiAwLjUsXG4gICAgICAgICAgICBtdWw6IG51bGwsXG4gICAgICAgICAgICBhZGQ6IG51bGxcbiAgICAgICAgfSxcblxuICAgICAgICB1Z2VuT3B0aW9uczoge1xuICAgICAgICAgICAgc3RyaWRlSW5wdXRzOiBbXCJtb2RlXCJdXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFRPRE86IFVuaXQgdGVzdHMuXG4gICAgZmxvY2sudWdlbi5yYW5kb20ud2VpYnVsbCA9IGZ1bmN0aW9uIChpbnB1dHMsIG91dHB1dCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgdGhhdCA9IGZsb2NrLnVnZW4ucmFuZG9tKGlucHV0cywgb3V0cHV0LCBvcHRpb25zKTtcblxuICAgICAgICB0aGF0LmdlbiA9IGZ1bmN0aW9uIChudW1TYW1wcykge1xuICAgICAgICAgICAgdmFyIG0gPSB0aGF0Lm1vZGVsLFxuICAgICAgICAgICAgICAgIGlucHV0cyA9IHRoYXQuaW5wdXRzLFxuICAgICAgICAgICAgICAgIGdlbmVyYXRvciA9IHRoYXQuZ2VuZXJhdG9yLFxuICAgICAgICAgICAgICAgIG91dCA9IHRoYXQub3V0cHV0LFxuICAgICAgICAgICAgICAgIGFscGhhSW5jID0gbS5zdHJpZGVzLmFscGhhLFxuICAgICAgICAgICAgICAgIGFscGhhID0gaW5wdXRzLmFscGhhLm91dHB1dCxcbiAgICAgICAgICAgICAgICBiZXRhSW5jID0gbS5zdHJpZGVzLmJldGEsXG4gICAgICAgICAgICAgICAgYmV0YSA9IGlucHV0cy5iZXRhLm91dHB1dCxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIGosXG4gICAgICAgICAgICAgICAgayxcbiAgICAgICAgICAgICAgICB2YWw7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IGogPSBrID0gMDsgaSA8IG51bVNhbXBzOyBpKyssIGogKz0gYWxwaGFJbmMsIGsgKz0gYmV0YUluYykge1xuICAgICAgICAgICAgICAgIG91dFtpXSA9IHZhbCA9IGdlbmVyYXRvci53ZWlidWxsKGFscGhhW2pdLCBiZXRhW2tdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbS51bnNjYWxlZFZhbHVlID0gdmFsO1xuICAgICAgICAgICAgdGhhdC5tdWxBZGQobnVtU2FtcHMpO1xuICAgICAgICAgICAgbS52YWx1ZSA9IGZsb2NrLnVnZW4ubGFzdE91dHB1dFZhbHVlKG51bVNhbXBzLCBvdXQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgIH07XG5cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsb2NrLnVnZW4ucmFuZG9tLndlaWJ1bGxcIiwge1xuICAgICAgICByYXRlOiBcImF1ZGlvXCIsXG4gICAgICAgIGlucHV0czoge1xuICAgICAgICAgICAgc2VlZDogbnVsbCxcbiAgICAgICAgICAgIGFscGhhOiAxLFxuICAgICAgICAgICAgYmV0YTogMSxcbiAgICAgICAgICAgIG11bDogbnVsbCxcbiAgICAgICAgICAgIGFkZDogbnVsbFxuICAgICAgICB9LFxuXG4gICAgICAgIHVnZW5PcHRpb25zOiB7XG4gICAgICAgICAgICBzdHJpZGVJbnB1dHM6IFtcImFscGhhXCIsIFwiYmV0YVwiXVxuICAgICAgICB9XG4gICAgfSk7XG5cblxuICAgIC8qKlxuICAgICAqIExvb3BzIHRocm91Z2ggYSBsaW5lYXIgcmFtcCBmcm9tIHN0YXJ0IHRvIGVuZCwgaW5jcmVtZW50aW5nIHRoZSBvdXRwdXQgYnkgc3RlcC5cbiAgICAgKiBFcXVpdmFsZW50IHRvIFN1cGVyQ29sbGlkZXIncyBvciBDU291bmQncyBQaGFzb3IgdW5pdCBnZW5lcmF0b3IuXG4gICAgICpcbiAgICAgKiBJbnB1dHM6XG4gICAgICogIHN0YXJ0OiB0aGUgdmFsdWUgdG8gc3RhcnQgcmFtcGluZyBmcm9tXG4gICAgICogIGVuZDogdGhlIHZhbHVlIHRvIHJhbXAgdG9cbiAgICAgKiAgc3RlcDogdGhlIHZhbHVlIHRvIGluY3JlbWVudCBwZXIgc2FtcGxlXG4gICAgICogIHJlc2V0OiB0aGUgdmFsdWUgdG8gcmV0dXJuIHRvIHdoZW4gdGhlIGxvb3AgaXMgcmVzZXQgYnkgYSB0cmlnZ2VyIHNpZ25hbFxuICAgICAqICB0cmlnZ2VyOiBhIHRyaWdnZXIgc2lnbmFsIHRoYXQsIHdoZW4gaXQgY3Jvc3MgdGhlIHplcm8gbGluZSwgd2lsbCByZXNldCB0aGUgbG9vcCBiYWNrIHRvIHRoZSByZXNldCBwb2ludFxuICAgICAqL1xuICAgIGZsb2NrLnVnZW4ucGhhc29yID0gZnVuY3Rpb24gKGlucHV0cywgb3V0cHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB0aGF0ID0gZmxvY2sudWdlbihpbnB1dHMsIG91dHB1dCwgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhhdC5nZW4gPSBmdW5jdGlvbiAobnVtU2FtcHMpIHtcbiAgICAgICAgICAgIHZhciBtID0gdGhhdC5tb2RlbCxcbiAgICAgICAgICAgICAgICBpbnB1dHMgPSB0aGF0LmlucHV0cyxcbiAgICAgICAgICAgICAgICBvdXQgPSB0aGF0Lm91dHB1dCxcbiAgICAgICAgICAgICAgICBzdGVwID0gaW5wdXRzLnN0ZXAub3V0cHV0LFxuICAgICAgICAgICAgICAgIHRyaWcgPSBpbnB1dHMudHJpZ2dlci5vdXRwdXQsXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICBqLFxuICAgICAgICAgICAgICAgIGs7XG5cbiAgICAgICAgICAgIC8vIFRPRE86IEFkZCBzYW1wbGUgcHJpbWluZyB0byB0aGUgdWdlbiBncmFwaCB0byByZW1vdmUgdGhpcyBjb25kaXRpb25hbC5cbiAgICAgICAgICAgIGlmIChtLnVuc2NhbGVkVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG0udW5zY2FsZWRWYWx1ZSA9IGlucHV0cy5zdGFydC5vdXRwdXRbMF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGogPSAwLCBrID0gMDsgaSA8IG51bVNhbXBzOyBpKyssIGogKz0gbS5zdHJpZGVzLnRyaWdnZXIsIGsgKz0gbS5zdHJpZGVzLnN0ZXApIHtcbiAgICAgICAgICAgICAgICBpZiAoKHRyaWdbal0gPiAwLjAgJiYgbS5wcmV2VHJpZyA8PSAwLjApKSB7XG4gICAgICAgICAgICAgICAgICAgIG0udW5zY2FsZWRWYWx1ZSA9IGlucHV0cy5yZXNldC5vdXRwdXRbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG0ucHJldlRyaWcgPSB0cmlnW2pdO1xuXG4gICAgICAgICAgICAgICAgaWYgKG0udW5zY2FsZWRWYWx1ZSA+PSBpbnB1dHMuZW5kLm91dHB1dFswXSkge1xuICAgICAgICAgICAgICAgICAgICBtLnVuc2NhbGVkVmFsdWUgPSBpbnB1dHMuc3RhcnQub3V0cHV0WzBdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG91dFtpXSA9IG0udW5zY2FsZWRWYWx1ZTtcbiAgICAgICAgICAgICAgICBtLnVuc2NhbGVkVmFsdWUgKz0gc3RlcFtrXTsgLy8gVE9ETzogTW9kZWwgb3V0IG9mIHN5bmMgd2l0aCBsYXN0IG91dHB1dCBzYW1wbGUuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoYXQubXVsQWRkKG51bVNhbXBzKTtcbiAgICAgICAgICAgIG0udmFsdWUgPSBmbG9jay51Z2VuLmxhc3RPdXRwdXRWYWx1ZShudW1TYW1wcywgb3V0KTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0Lm9uSW5wdXRDaGFuZ2VkKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfTtcblxuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmxvY2sudWdlbi5waGFzb3JcIiwge1xuICAgICAgICByYXRlOiBcImNvbnRyb2xcIixcbiAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICBzdGFydDogMC4wLFxuICAgICAgICAgICAgZW5kOiAxLjAsXG4gICAgICAgICAgICByZXNldDogMC4wLFxuICAgICAgICAgICAgc3RlcDogMC4xLFxuICAgICAgICAgICAgdHJpZ2dlcjogMC4wLFxuICAgICAgICAgICAgbXVsOiBudWxsLFxuICAgICAgICAgICAgYWRkOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIHVnZW5PcHRpb25zOiB7XG4gICAgICAgICAgICBtb2RlbDoge1xuICAgICAgICAgICAgICAgIHVuc2NhbGVkVmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogMC4wXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzdHJpZGVJbnB1dHM6IFtcbiAgICAgICAgICAgICAgICBcInRyaWdnZXJcIixcbiAgICAgICAgICAgICAgICBcInN0ZXBcIlxuICAgICAgICAgICAgXVxuICAgICAgICB9XG4gICAgfSk7XG5cblxuICAgIGZsb2NrLnVnZW4uYW1wbGl0dWRlID0gZnVuY3Rpb24gKGlucHV0cywgb3V0cHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB0aGF0ID0gZmxvY2sudWdlbihpbnB1dHMsIG91dHB1dCwgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhhdC5nZW4gPSBmdW5jdGlvbiAobnVtU2FtcHMpIHtcbiAgICAgICAgICAgIHZhciBtID0gdGhhdC5tb2RlbCxcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSB0aGF0LmlucHV0cy5zb3VyY2Uub3V0cHV0LFxuICAgICAgICAgICAgICAgIG91dCA9IHRoYXQub3V0cHV0LFxuICAgICAgICAgICAgICAgIHByZXZBdHQgPSBtLmF0dGFja1RpbWUsXG4gICAgICAgICAgICAgICAgbmV4dEF0dCA9IHRoYXQuaW5wdXRzLmF0dGFjay5vdXRwdXRbMF0sXG4gICAgICAgICAgICAgICAgcHJldlJlbCA9IG0ucmVsZWFzZVRpbWUsXG4gICAgICAgICAgICAgICAgbmV4dFJlbCA9IHRoYXQuaW5wdXRzLnJlbGVhc2Uub3V0cHV0WzBdLFxuICAgICAgICAgICAgICAgIHByZXZWYWwgPSBtLnByZXZWYWwsXG4gICAgICAgICAgICAgICAgYXR0Q29lZiA9IG0uYXR0YWNrQ29lZixcbiAgICAgICAgICAgICAgICByZWxDb2VmID0gbS5yZWxlYXNlQ29lZixcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIHZhbCxcbiAgICAgICAgICAgICAgICBjb2VmO1xuXG4gICAgICAgICAgICAvLyBDb252ZXJ0IDYwIGRCIGF0dGFjayBhbmQgcmVsZWFzZSB0aW1lcyB0byBjb2VmZmljaWVudHMgaWYgdGhleSd2ZSBjaGFuZ2VkLlxuICAgICAgICAgICAgaWYgKG5leHRBdHQgIT09IHByZXZBdHQpIHtcbiAgICAgICAgICAgICAgICBtLmF0dGFja1RpbWUgPSBuZXh0QXR0O1xuICAgICAgICAgICAgICAgIGF0dENvZWYgPSBtLmF0dGFja0NvZWYgPVxuICAgICAgICAgICAgICAgICAgICBuZXh0QXR0ID09PSAwLjAgPyAwLjAgOiBNYXRoLmV4cChmbG9jay5MT0cwMSAvIChuZXh0QXR0ICogbS5zYW1wbGVSYXRlKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChuZXh0UmVsICE9PSBwcmV2UmVsKSB7XG4gICAgICAgICAgICAgICAgbS5yZWxlYXNlVGltZSA9IG5leHRSZWw7XG4gICAgICAgICAgICAgICAgcmVsQ29lZiA9IG0ucmVsZWFzZUNvZWYgPVxuICAgICAgICAgICAgICAgICAgICAobmV4dFJlbCA9PT0gMC4wKSA/IDAuMCA6IE1hdGguZXhwKGZsb2NrLkxPRzAxIC8gKG5leHRSZWwgKiBtLnNhbXBsZVJhdGUpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bVNhbXBzOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBNYXRoLmFicyhzb3VyY2VbaV0pO1xuICAgICAgICAgICAgICAgIGNvZWYgPSB2YWwgPCBwcmV2VmFsID8gcmVsQ29lZiA6IGF0dENvZWY7XG4gICAgICAgICAgICAgICAgb3V0W2ldID0gcHJldlZhbCA9IHZhbCArIChwcmV2VmFsIC0gdmFsKSAqIGNvZWY7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG0udW5zY2FsZWRWYWx1ZSA9IG0ucHJldlZhbCA9IHByZXZWYWw7XG4gICAgICAgICAgICB0aGF0Lm11bEFkZChudW1TYW1wcyk7XG4gICAgICAgICAgICBtLnZhbHVlID0gZmxvY2sudWdlbi5sYXN0T3V0cHV0VmFsdWUobnVtU2FtcHMsIG91dCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5vbklucHV0Q2hhbmdlZCgpO1xuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICB9O1xuXG4gICAgZmx1aWQuZGVmYXVsdHMoXCJmbG9jay51Z2VuLmFtcGxpdHVkZVwiLCB7XG4gICAgICAgIHJhdGU6IFwiYXVkaW9cIixcbiAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICBzb3VyY2U6IG51bGwsXG4gICAgICAgICAgICBhdHRhY2s6IDAuMDEsXG4gICAgICAgICAgICByZWxlYXNlOiAwLjAxLFxuICAgICAgICAgICAgbXVsOiBudWxsLFxuICAgICAgICAgICAgYWRkOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIHVnZW5PcHRpb25zOiB7XG4gICAgICAgICAgICBtb2RlbDoge1xuICAgICAgICAgICAgICAgIHByZXZWYWw6IDAuMCxcbiAgICAgICAgICAgICAgICB1bnNjYWxlZFZhbHVlOiAwLjAsXG4gICAgICAgICAgICAgICAgdmFsdWU6IDAuMFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBmbG9jay51Z2VuLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChpbnB1dHMsIG91dHB1dCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgdGhhdCA9IGZsb2NrLnVnZW4oaW5wdXRzLCBvdXRwdXQsIG9wdGlvbnMpO1xuXG4gICAgICAgIHRoYXQuZ2VuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG0gPSB0aGF0Lm1vZGVsLFxuICAgICAgICAgICAgICAgIG91dCA9IHRoYXQub3V0cHV0LFxuICAgICAgICAgICAgICAgIG1heCA9IHRoYXQuaW5wdXRzLm1heC5vdXRwdXRbMF0sIC8vIE1heCBpcyBrci5cbiAgICAgICAgICAgICAgICBzb3VyY2UgPSB0aGF0LmlucHV0cy5zb3VyY2Uub3V0cHV0O1xuXG4gICAgICAgICAgICAvLyBOb3RlLCB0aGlzIG5vcm1hbGl6ZXMgdGhlIHNvdXJjZSBpbnB1dCB1Z2VuJ3Mgb3V0cHV0IGJ1ZmZlciBkaXJlY3RseSBpbiBwbGFjZS5cbiAgICAgICAgICAgIGZsb2NrLm5vcm1hbGl6ZShzb3VyY2UsIG1heCwgb3V0KTtcbiAgICAgICAgICAgIG0udmFsdWUgPSBtLnVuc2NhbGVkVmFsdWUgPSBvdXRbb3V0Lmxlbmd0aCAtIDFdO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQub25JbnB1dENoYW5nZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfTtcblxuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmxvY2sudWdlbi5ub3JtYWxpemVcIiwge1xuICAgICAgICByYXRlOiBcImF1ZGlvXCIsXG4gICAgICAgIGlucHV0czoge1xuICAgICAgICAgICAgbWF4OiAxLjAsXG4gICAgICAgICAgICBzb3VyY2U6IG51bGxcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQSBnYXRlIHRoYXQgYWxsb3dzIHRoZSBzb3VyY2UgaW5wdXQgc2lnbmFsIHRvIHBhc3Mgd2hlbmV2ZXIgdGhlIHNpZGVDaGFpbiBpbnB1dFxuICAgICAqIHNpZ25hbCBpcyBncmVhdGVyIHRoYW4gdGhlIHRocmVzaG9sZC5cbiAgICAgKlxuICAgICAqIElmIHNpZGVDaGFpbiBpc24ndCBzcGVjaWZlZCwgdGhlIHNvdXJjZSBzaWduYWwgaXRzZWxmIGlzIHVzZWQgdG8gb3BlbiB0aGUgZ2F0ZS5cbiAgICAgKiBCeSBkZWZhdWx0LCB0aGUgZ2F0ZSB3aWxsIG91dHB1dCAwLjAgaWYgaXQgaXMgY2xvc2VkLCBidXQgc2V0dGluZyB0aGUgaG9sZExhc3RWYWx1ZVxuICAgICAqIG9wdGlvbiB0byB0cnVlIGVuYWJsZXMgaXQgdG8gaG9sZCB0aGUgdmFsdWUgb2YgdGhlIGdhdGUgd2hlbiBpdCB3YXMgbGFzdCBvcGVuLlxuICAgICAqXG4gICAgICogSW5wdXRzOlxuICAgICAqICAgICBzb3VyY2U6IHRoZSBzaWduYWwgdGhhdCB3aWxsIGJlIG91dHB1dHRlZCB3aGVuZXZlciB0aGUgZ2F0ZSBpcyBvcGVuLlxuICAgICAqICAgICBzaWRlQ2hhaW46IChvcHRpb25hbCkgYSBzaWRlIGNoYWluIHNpZ25hbCB0aGF0IHdpbGxcbiAgICAgKiAgICAgICAgIGNhdXNlIHRoZSBnYXRlIHRvIG9wZW4gYW5kIGNsb3NlXG4gICAgICogICAgIHRocmVzaG9sZDogdGhlIG1pbmltdW0gdmFsdWUgYXQgd2hpY2ggdGhlIGdhdGUgd2lsbCBvcGVuXG4gICAgICogT3B0aW9uczpcbiAgICAgKiAgICAgIGhvbGRMYXN0VmFsdWU6IGRldGVybWluZXMgd2hldGhlciB0aGUgZ2F0ZSBzaG91bGQgaG9sZCBpdHMgbGFzdCBvcGVuIHZhbHVlIG9yIG91dHB1dCBzaWxlbmNlXG4gICAgICovXG4gICAgZmxvY2sudWdlbi5nYXRlID0gZnVuY3Rpb24gKGlucHV0cywgb3V0cHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB0aGF0ID0gZmxvY2sudWdlbihpbnB1dHMsIG91dHB1dCwgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhhdC5nZW4gPSBmdW5jdGlvbiAobnVtU2FtcHMpIHtcbiAgICAgICAgICAgIHZhciBtID0gdGhhdC5tb2RlbCxcbiAgICAgICAgICAgICAgICBzdHJpZGVzID0gbS5zdHJpZGVzLFxuICAgICAgICAgICAgICAgIG91dCA9IHRoYXQub3V0cHV0LFxuICAgICAgICAgICAgICAgIGlucHV0cyA9IHRoYXQuaW5wdXRzLFxuICAgICAgICAgICAgICAgIHNvdXJjZSA9IGlucHV0cy5zb3VyY2Uub3V0cHV0LFxuICAgICAgICAgICAgICAgIHNpZGVDaGFpbiA9IGlucHV0cy5zaWRlQ2hhaW4ub3V0cHV0LFxuICAgICAgICAgICAgICAgIHNpZGVDaGFpbkluYyA9IHN0cmlkZXMuc2lkZUNoYWluLFxuICAgICAgICAgICAgICAgIHRocmVzaG9sZCA9IGlucHV0cy50aHJlc2hvbGQub3V0cHV0LFxuICAgICAgICAgICAgICAgIHRocmVzaG9sZEluYyA9IHN0cmlkZXMudGhyZXNob2xkLFxuICAgICAgICAgICAgICAgIGhvbGRMYXN0ID0gdGhhdC5vcHRpb25zLmhvbGRMYXN0VmFsdWUsXG4gICAgICAgICAgICAgICAgbGFzdFZhbHVlID0gbS5sYXN0VmFsdWUsXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICBqLFxuICAgICAgICAgICAgICAgIGssXG4gICAgICAgICAgICAgICAgdmFsO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSBqID0gayA9IDA7IGkgPCBudW1TYW1wczsgaSsrLCBqICs9IHNpZGVDaGFpbkluYywgayArPSB0aHJlc2hvbGRJbmMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2lkZUNoYWluW2pdID49IHRocmVzaG9sZFtrXSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRbaV0gPSB2YWwgPSBsYXN0VmFsdWUgPSBzb3VyY2VbaV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogRG9uJ3QgY2hlY2sgaG9sZExhc3Qgb24gZWFjaCBzYW1wbGUuXG4gICAgICAgICAgICAgICAgICAgIG91dFtpXSA9IHZhbCA9IGhvbGRMYXN0ID8gbGFzdFZhbHVlIDogMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG0ubGFzdFZhbHVlID0gbGFzdFZhbHVlO1xuICAgICAgICAgICAgbS51bnNjYWxlZFZhbHVlID0gdmFsO1xuICAgICAgICAgICAgdGhhdC5tdWxBZGQobnVtU2FtcHMpO1xuICAgICAgICAgICAgbS52YWx1ZSA9IGZsb2NrLnVnZW4ubGFzdE91dHB1dFZhbHVlKG51bVNhbXBzLCBvdXQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQub25JbnB1dENoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoYXQuaW5wdXRzLnNpZGVDaGFpbikge1xuICAgICAgICAgICAgICAgIHRoYXQuaW5wdXRzLnNpZGVDaGFpbiA9IHRoYXQuaW5wdXRzLnNvdXJjZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmxvY2sub25NdWxBZGRJbnB1dENoYW5nZWQodGhhdCk7XG4gICAgICAgICAgICB0aGF0LmNhbGN1bGF0ZVN0cmlkZXMoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0Lm9uSW5wdXRDaGFuZ2VkKCk7XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgIH07XG5cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsb2NrLnVnZW4uZ2F0ZVwiLCB7XG4gICAgICAgIHJhdGU6IFwiYXVkaW9cIixcbiAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICBzb3VyY2U6IG51bGwsXG4gICAgICAgICAgICBzaWRlQ2hhaW46IG51bGwsXG4gICAgICAgICAgICB0aHJlc2hvbGQ6IE51bWJlci5NSU5fVkFMVUUsXG4gICAgICAgICAgICBtdWw6IG51bGwsXG4gICAgICAgICAgICBhZGQ6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgdWdlbk9wdGlvbnM6IHtcbiAgICAgICAgICAgIG1vZGVsOiB7XG4gICAgICAgICAgICAgICAgdW5zY2FsZWRWYWx1ZTogMC4wLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAwLjAsXG4gICAgICAgICAgICAgICAgbGFzdFZhbHVlOiAwLjBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBob2xkTGFzdFZhbHVlOiBmYWxzZSxcbiAgICAgICAgICAgIHN0cmlkZUlucHV0czogW1wic2lkZUNoYWluXCIsIFwidGhyZXNob2xkXCJdXG4gICAgICAgIH1cbiAgICB9KTtcblxuXG4gICAgLyoqXG4gICAgICogQW4gZXF1YWwgcG93ZXIgc3RlcmVvIHBhbm5lci5cbiAgICAgKlxuICAgICAqIFRoaXMgdW5pdCBnZW5lcmF0b3Igc2NhbGVzIHRoZSBsZWZ0IGFuZCByaWdodCBjaGFubmVsc1xuICAgICAqIHdpdGggYSBxdWFydGVyLXdhdmUgc2luL2NvcyBjdXJ2ZSBzbyB0aGF0IHRoZSBsZXZlbHMgYXQgdGhlIGNlbnRyZVxuICAgICAqIGFyZSBtb3JlIGJhbGFuY2VkIHRoYW4gYSBsaW5lYXIgcGFuLCByZWR1Y2luZyB0aGUgaW1wcmVzc2lvbiB0aGF0XG4gICAgICogdGhlIHNvdW5kIGlzIGZhZGluZyBpbnRvIHRoZSBkaXN0YW5jZSBhcyBpdCByZWFjaGVzIHRoZSBjZW50cmVwb2ludC5cbiAgICAgKlxuICAgICAqIElucHV0czpcbiAgICAgKiAgIHNvdXJjZTogdGhlIHNvdXJjZSAobW9ubykgdW5pdCBzaWduYWxcbiAgICAgKiAgIHBhbjogYSB2YWx1ZSBiZXR3ZWVuIC0xIChoYXJkIGxlZnQpIGFuZCAxIChoYXJkIHJpZ2h0KVxuICAgICAqL1xuICAgIGZsb2NrLnVnZW4ucGFuMiA9IGZ1bmN0aW9uIChpbnB1dHMsIG91dHB1dCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgdGhhdCA9IGZsb2NrLnVnZW4oaW5wdXRzLCBvdXRwdXQsIG9wdGlvbnMpO1xuXG4gICAgICAgIHRoYXQuZ2VuID0gZnVuY3Rpb24gKG51bVNhbXBzKSB7XG4gICAgICAgICAgICB2YXIgbSA9IHRoYXQubW9kZWwsXG4gICAgICAgICAgICAgICAgb3V0cHV0cyA9IHRoYXQub3V0cHV0LFxuICAgICAgICAgICAgICAgIGxlZnQgPSBvdXRwdXRzWzBdLFxuICAgICAgICAgICAgICAgIHJpZ2h0ID0gb3V0cHV0c1sxXSxcbiAgICAgICAgICAgICAgICBpbnB1dHMgPSB0aGF0LmlucHV0cyxcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSBpbnB1dHMuc291cmNlLm91dHB1dCxcbiAgICAgICAgICAgICAgICBwYW4gPSBpbnB1dHMucGFuLm91dHB1dCxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIGosXG4gICAgICAgICAgICAgICAgc291cmNlVmFsLFxuICAgICAgICAgICAgICAgIHBhblZhbDtcblxuICAgICAgICAgICAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBudW1TYW1wczsgaSsrLCBqICs9IG0uc3RyaWRlcy5wYW4pIHtcbiAgICAgICAgICAgICAgICBzb3VyY2VWYWwgPSBzb3VyY2VbaV07XG4gICAgICAgICAgICAgICAgcGFuVmFsID0gcGFuW2pdICogMC41ICsgMC41O1xuXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogUmVwbGFjZSB0aGlzIHdpdGggYSBsb29rdXAgdGFibGUuXG4gICAgICAgICAgICAgICAgcmlnaHRbaV0gPSBzb3VyY2VWYWwgKiBNYXRoLnNpbihwYW5WYWwgKiBmbG9jay5IQUxGUEkpO1xuICAgICAgICAgICAgICAgIGxlZnRbaV0gPSBzb3VyY2VWYWwgKiBNYXRoLmNvcyhwYW5WYWwgKiBmbG9jay5IQUxGUEkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUT0RPOiBBZGQgbXVsdGljaGFubmVsIHN1cHBvcnQgZm9yIG11bC9hZGQuXG4gICAgICAgICAgICB2YXIgbGFzdElkeCA9IG51bVNhbXBzIC0gMTtcbiAgICAgICAgICAgIG0udmFsdWVbMF0gPSBvdXRwdXRzWzBdW2xhc3RJZHhdO1xuICAgICAgICAgICAgbS52YWx1ZVsxXSA9IG91dHB1dHNbMV1bbGFzdElkeF07XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5vbklucHV0Q2hhbmdlZCgpO1xuICAgICAgICAgICAgdGhhdC5tb2RlbC51bnNjYWxlZFZhbHVlID0gdGhhdC5tb2RlbC52YWx1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0LmluaXQoKTtcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfTtcblxuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmxvY2sudWdlbi5wYW4yXCIsIHtcbiAgICAgICAgcmF0ZTogXCJhdWRpb1wiLFxuXG4gICAgICAgIGlucHV0czoge1xuICAgICAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICAgICAgcGFuOiAwIC8vIC0xIChoYXJkIGxlZnQpLi4wIChjZW50cmUpLi4xIChoYXJkIHJpZ2h0KVxuICAgICAgICB9LFxuXG4gICAgICAgIHVnZW5PcHRpb25zOiB7XG4gICAgICAgICAgICBtb2RlbDoge1xuICAgICAgICAgICAgICAgIHVuc2NhbGVkVmFsdWU6IFswLjAsIDAuMF0sXG4gICAgICAgICAgICAgICAgdmFsdWU6IFswLjAsIDAuMF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0YWdzOiBbXCJmbG9jay51Z2VuLm11bHRpQ2hhbm5lbE91dHB1dFwiXSxcbiAgICAgICAgICAgIHN0cmlkZUlucHV0czogW1xuICAgICAgICAgICAgICAgIFwicGFuXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBudW1PdXRwdXRzOiAyXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKioqKioqKioqKioqKioqKioqXG4gICAgICogQnVzLUxldmVsIFVHZW5zICpcbiAgICAgKioqKioqKioqKioqKioqKioqKi9cblxuICAgIGZsb2NrLnVnZW4ub3V0ID0gZnVuY3Rpb24gKGlucHV0cywgb3V0cHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB0aGF0ID0gZmxvY2sudWdlbihpbnB1dHMsIG91dHB1dCwgb3B0aW9ucyk7XG5cbiAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IGEgXCJzdHJhaWdodCBvdXRcIiBnZW4gZnVuY3Rpb24gZm9yIGNhc2VzIHdoZXJlIHRoZSBudW1iZXJcbiAgICAgICAgLy8gb2Ygc291cmNlcyBtYXRjaGVzIHRoZSBudW1iZXIgb2Ygb3V0cHV0IGJ1c2VzIChpLmUuIHdoZXJlIG5vIGV4cGFuc2lvbiBpcyBuZWNlc3NhcnkpLlxuICAgICAgICAvLyBUT0RPOiBUaGlzIGZ1bmN0aW9uIGlzIG1hcmtlZCBhcyB1bm9wdGltaXplZCBieSB0aGUgQ2hyb21lIHByb2ZpbGVyLlxuICAgICAgICB0aGF0LmdlbiA9IGZ1bmN0aW9uIChudW1TYW1wcykge1xuICAgICAgICAgICAgdmFyIG0gPSB0aGF0Lm1vZGVsLFxuICAgICAgICAgICAgICAgIHNvdXJjZXMgPSB0aGF0Lm11bHRpSW5wdXRzLnNvdXJjZXMsXG4gICAgICAgICAgICAgICAgYnVzZXMgPSB0aGF0Lm9wdGlvbnMuYXVkaW9TZXR0aW5ncy5idXNlcyxcbiAgICAgICAgICAgICAgICBidWZTdGFydCA9IHRoYXQuaW5wdXRzLmJ1cy5vdXRwdXRbMF0sXG4gICAgICAgICAgICAgICAgZXhwYW5kID0gdGhhdC5pbnB1dHMuZXhwYW5kLm91dHB1dFswXSxcbiAgICAgICAgICAgICAgICBudW1Tb3VyY2VzLFxuICAgICAgICAgICAgICAgIG51bU91dHB1dEJ1c2VzLFxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgaixcbiAgICAgICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICAgICAgcmF0ZSxcbiAgICAgICAgICAgICAgICBidXMsXG4gICAgICAgICAgICAgICAgaW5jLFxuICAgICAgICAgICAgICAgIG91dElkeDtcblxuICAgICAgICAgICAgbnVtU291cmNlcyA9IHNvdXJjZXMubGVuZ3RoO1xuICAgICAgICAgICAgbnVtT3V0cHV0QnVzZXMgPSBNYXRoLm1heChleHBhbmQsIG51bVNvdXJjZXMpO1xuXG4gICAgICAgICAgICBpZiAobnVtU291cmNlcyA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1PdXRwdXRCdXNlczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc291cmNlID0gc291cmNlc1tpICUgbnVtU291cmNlc107XG4gICAgICAgICAgICAgICAgcmF0ZSA9IHNvdXJjZS5yYXRlO1xuICAgICAgICAgICAgICAgIGJ1cyA9IGJ1c2VzW2J1ZlN0YXJ0ICsgaV07XG4gICAgICAgICAgICAgICAgaW5jID0gcmF0ZSA9PT0gZmxvY2sucmF0ZXMuQVVESU8gPyAxIDogMDtcbiAgICAgICAgICAgICAgICBvdXRJZHggPSAwO1xuXG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IG51bVNhbXBzOyBqKyssIG91dElkeCArPSBpbmMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogU3VwcG9ydCBjb250cm9sIHJhdGUgaW50ZXJwb2xhdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogRG9uJ3QgYXR0ZW1wdCB0byB3cml0ZSB0byBidXNlcyBiZXlvbmQgdGhlIGF2YWlsYWJsZSBudW1iZXIuXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgIFByb3ZpZGUgYW4gZXJyb3IgYXQgb25JbnB1dENoYW5nZWQgdGltZSBpZiB0aGUgdW5pdCBnZW5lcmF0b3IgaXMgY29uZmlndXJlZFxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICB3aXRoIG1vcmUgc291cmNlcyB0aGFuIGF2YWlsYWJsZSBidWZmZXJzLlxuICAgICAgICAgICAgICAgICAgICBidXNbal0gPSBidXNbal0gKyBzb3VyY2Uub3V0cHV0W291dElkeF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUT0RPOiBDb25zaWRlciBob3cgd2Ugc2hvdWxkIGhhbmRsZSBcInZhbHVlXCIgd2hlbiB0aGUgbnVtYmVyXG4gICAgICAgICAgICAvLyBvZiBpbnB1dCBjaGFubmVscyBmb3IgXCJzb3VyY2VzXCIgY2FuIGJlIHZhcmlhYmxlLlxuICAgICAgICAgICAgLy8gSW4gdGhlIG1lYW50aW1lLCB3ZSBqdXN0IG91dHB1dCB0aGUgbGFzdCBzb3VyY2UncyBsYXN0IHNhbXBsZS5cbiAgICAgICAgICAgIG0udmFsdWUgPSBtLnVuc2NhbGVkVmFsdWUgPSBzb3VyY2Uub3V0cHV0W291dElkeF07XG4gICAgICAgICAgICB0aGF0Lm11bEFkZChudW1TYW1wcyk7IC8vIFRPRE86IERvZXMgdGhpcyBldmVuIHdvcms/XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5zb3VyY2VCdWZmZXJzID0gW107XG4gICAgICAgICAgICB0aGF0Lm9uSW5wdXRDaGFuZ2VkKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5pbml0KCk7XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgIH07XG5cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsb2NrLnVnZW4ub3V0XCIsIHtcbiAgICAgICAgcmF0ZTogXCJhdWRpb1wiLFxuICAgICAgICBpbnB1dHM6IHtcbiAgICAgICAgICAgIHNvdXJjZXM6IG51bGwsXG4gICAgICAgICAgICBidXM6IDAsXG4gICAgICAgICAgICBleHBhbmQ6IDJcbiAgICAgICAgfSxcbiAgICAgICAgdWdlbk9wdGlvbnM6IHtcbiAgICAgICAgICAgIHRhZ3M6IFtcImZsb2NrLnVnZW4ub3V0cHV0VHlwZVwiXSxcbiAgICAgICAgICAgIG11bHRpSW5wdXROYW1lczogW1wic291cmNlc1wiXVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBOb3RlOiB0aGlzIHVuaXQgZ2VuZXJhdG9yIGN1cnJlbnRseSBvbmx5IG91dHB1dHMgdmFsdWVzIGF0IGNvbnRyb2wgcmF0ZS5cbiAgICAvLyBUT0RPOiBVbml0IHRlc3RzLlxuICAgIGZsb2NrLnVnZW4udmFsdWVPdXQgPSBmdW5jdGlvbiAoaW5wdXRzLCBvdXRwdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHRoYXQgPSBmbG9jay51Z2VuKGlucHV0cywgb3V0cHV0LCBvcHRpb25zKTtcblxuICAgICAgICB0aGF0LmFycmF5U291cmNlR2VuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG0gPSB0aGF0Lm1vZGVsLFxuICAgICAgICAgICAgICAgIHNvdXJjZXMgPSB0aGF0LmlucHV0cy5zb3VyY2VzLFxuICAgICAgICAgICAgICAgIGk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbS52YWx1ZVtpXSA9IHNvdXJjZXNbaV0ub3V0cHV0WzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQudWdlblNvdXJjZUdlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQubW9kZWwudmFsdWUgPSB0aGF0Lm1vZGVsLnVuc2NhbGVkVmFsdWUgPSB0aGF0LmlucHV0cy5zb3VyY2VzLm91dHB1dFswXTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0Lm9uSW5wdXRDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG0gPSB0aGF0Lm1vZGVsLFxuICAgICAgICAgICAgICAgIHNvdXJjZXMgPSB0aGF0LmlucHV0cy5zb3VyY2VzO1xuXG4gICAgICAgICAgICBpZiAoZmxvY2suaXNJdGVyYWJsZShzb3VyY2VzKSkge1xuICAgICAgICAgICAgICAgIHRoYXQuZ2VuID0gdGhhdC5hcnJheVNvdXJjZUdlbjtcbiAgICAgICAgICAgICAgICBtLnZhbHVlID0gbmV3IEZsb2F0MzJBcnJheShzb3VyY2VzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgbS51bnNjYWxlZFZhbHVlID0gbS52YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhhdC5nZW4gPSB0aGF0LnVnZW5Tb3VyY2VHZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5vbklucHV0Q2hhbmdlZCgpO1xuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICB9O1xuXG4gICAgZmx1aWQuZGVmYXVsdHMoXCJmbG9jay51Z2VuLnZhbHVlT3V0XCIsIHtcbiAgICAgICAgcmF0ZTogXCJjb250cm9sXCIsXG5cbiAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICBzb3VyY2VzOiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgdWdlbk9wdGlvbnM6IHtcbiAgICAgICAgICAgIG1vZGVsOiB7XG4gICAgICAgICAgICAgICAgdW5zY2FsZWRWYWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgdGFnczogW1wiZmxvY2sudWdlbi5vdXRwdXRUeXBlXCIsIFwiZmxvY2sudWdlbi52YWx1ZVR5cGVcIl1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gVE9ETzogZml4IG5hbWluZy5cbiAgICBmbG9jay51Z2VuW1wiaW5cIl0gPSBmdW5jdGlvbiAoaW5wdXRzLCBvdXRwdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHRoYXQgPSBmbG9jay51Z2VuKGlucHV0cywgb3V0cHV0LCBvcHRpb25zKTtcblxuICAgICAgICB0aGF0LnNpbmdsZUJ1c0dlbiA9IGZ1bmN0aW9uIChudW1TYW1wcykge1xuICAgICAgICAgICAgdmFyIG0gPSB0aGF0Lm1vZGVsLFxuICAgICAgICAgICAgICAgIG91dCA9IHRoYXQub3V0cHV0O1xuXG4gICAgICAgICAgICBmbG9jay51Z2VuLmluLnJlYWRCdXMobnVtU2FtcHMsIG91dCwgdGhhdC5pbnB1dHMuYnVzLFxuICAgICAgICAgICAgICAgIHRoYXQub3B0aW9ucy5hdWRpb1NldHRpbmdzLmJ1c2VzKTtcblxuICAgICAgICAgICAgbS51bnNjYWxlZFZhbHVlID0gZmxvY2sudWdlbi5sYXN0T3V0cHV0VmFsdWUobnVtU2FtcHMsIG91dCk7XG4gICAgICAgICAgICB0aGF0Lm11bEFkZChudW1TYW1wcyk7XG4gICAgICAgICAgICBtLnZhbHVlID0gZmxvY2sudWdlbi5sYXN0T3V0cHV0VmFsdWUobnVtU2FtcHMsIG91dCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5tdWx0aUJ1c0dlbiA9IGZ1bmN0aW9uIChudW1TYW1wcykge1xuICAgICAgICAgICAgdmFyIG0gPSB0aGF0Lm1vZGVsLFxuICAgICAgICAgICAgICAgIGJ1c2VzSW5wdXQgPSB0aGF0LmlucHV0cy5idXMsXG4gICAgICAgICAgICAgICAgZW52aXJvQnVzZXMgPSB0aGF0Lm9wdGlvbnMuYXVkaW9TZXR0aW5ncy5idXNlcyxcbiAgICAgICAgICAgICAgICBvdXQgPSB0aGF0Lm91dHB1dCxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIGosXG4gICAgICAgICAgICAgICAgYnVzSWR4LFxuICAgICAgICAgICAgICAgIHZhbDtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bVNhbXBzOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YWwgPSAwOyAvLyBDbGVhciBwcmV2aW91cyBvdXRwdXQgdmFsdWVzIGJlZm9yZSBzdW1taW5nIGEgbmV3IHNldC5cbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgYnVzZXNJbnB1dC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBidXNJZHggPSBidXNlc0lucHV0W2pdLm91dHB1dFswXSB8IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhbCArPSBlbnZpcm9CdXNlc1tidXNJZHhdW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXRbaV0gPSB2YWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG0udW5zY2FsZWRWYWx1ZSA9IHZhbDtcbiAgICAgICAgICAgIHRoYXQubXVsQWRkKG51bVNhbXBzKTtcbiAgICAgICAgICAgIG0udmFsdWUgPSBmbG9jay51Z2VuLmxhc3RPdXRwdXRWYWx1ZShudW1TYW1wcywgb3V0KTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0Lm9uSW5wdXRDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5nZW4gPSBmbG9jay5pc0l0ZXJhYmxlKHRoYXQuaW5wdXRzLmJ1cykgPyB0aGF0Lm11bHRpQnVzR2VuIDogdGhhdC5zaW5nbGVCdXNHZW47XG4gICAgICAgICAgICBmbG9jay5vbk11bEFkZElucHV0Q2hhbmdlZCh0aGF0KTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0Lm9uSW5wdXRDaGFuZ2VkKCk7XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgIH07XG5cbiAgICBmbG9jay51Z2VuLmluLnJlYWRCdXMgPSBmdW5jdGlvbiAobnVtU2FtcHMsIG91dCwgYnVzSW5wdXQsIGJ1c2VzKSB7XG4gICAgICAgIHZhciBidXNOdW0gPSBidXNJbnB1dC5vdXRwdXRbMF0gfCAwLFxuICAgICAgICAgICAgYnVzID0gYnVzZXNbYnVzTnVtXSxcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bVNhbXBzOyBpKyspIHtcbiAgICAgICAgICAgIG91dFtpXSA9IGJ1c1tpXTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsb2NrLnVnZW4uaW5cIiwge1xuICAgICAgICByYXRlOiBcImF1ZGlvXCIsXG4gICAgICAgIGlucHV0czoge1xuICAgICAgICAgICAgYnVzOiAwLFxuICAgICAgICAgICAgbXVsOiBudWxsLFxuICAgICAgICAgICAgYWRkOiBudWxsXG4gICAgICAgIH1cbiAgICB9KTtcblxuXG4gICAgZmxvY2sudWdlbi5hdWRpb0luID0gZnVuY3Rpb24gKGlucHV0cywgb3V0cHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB0aGF0ID0gZmxvY2sudWdlbihpbnB1dHMsIG91dHB1dCwgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhhdC5nZW4gPSBmdW5jdGlvbiAobnVtU2FtcHMpIHtcbiAgICAgICAgICAgIHZhciBtID0gdGhhdC5tb2RlbCxcbiAgICAgICAgICAgICAgICBvdXQgPSB0aGF0Lm91dHB1dCxcbiAgICAgICAgICAgICAgICBidXMgPSB0aGF0LmJ1cyxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIHZhbDtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bVNhbXBzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvdXRbaV0gPSB2YWwgPSBidXNbaV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG0udW5zY2FsZWRWYWx1ZSA9IHZhbDtcbiAgICAgICAgICAgIHRoYXQubXVsQWRkKG51bVNhbXBzKTtcbiAgICAgICAgICAgIG0udmFsdWUgPSBmbG9jay51Z2VuLmxhc3RPdXRwdXRWYWx1ZShudW1TYW1wcywgb3V0KTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0Lm9uSW5wdXRDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZmxvY2sub25NdWxBZGRJbnB1dENoYW5nZWQodGhhdCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gVE9ETzogRGlyZWN0IHJlZmVyZW5jZSB0byB0aGUgc2hhcmVkIGVudmlyb25tZW50LlxuICAgICAgICAgICAgdmFyIGJ1c051bSA9IGZsb2NrLmVudmlyby5zaGFyZWQuYXVkaW9TdHJhdGVneS5pbnB1dERldmljZU1hbmFnZXIub3BlbkF1ZGlvRGV2aWNlKG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhhdC5idXMgPSB0aGF0Lm9wdGlvbnMuYXVkaW9TZXR0aW5ncy5idXNlc1tidXNOdW1dO1xuXG4gICAgICAgICAgICB0aGF0Lm9uSW5wdXRDaGFuZ2VkKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5pbml0KCk7XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgIH07XG5cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsb2NrLnVnZW4uYXVkaW9JblwiLCB7XG4gICAgICAgIHJhdGU6IFwiYXVkaW9cIixcbiAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICBtdWw6IG51bGwsXG4gICAgICAgICAgICBhZGQ6IG51bGxcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cbiAgICAvKioqKioqKioqKipcbiAgICAgKiBGaWx0ZXJzICpcbiAgICAgKioqKioqKioqKiovXG5cbiAgICAvKipcbiAgICAgKiBBIGdlbmVyaWMgRklSIGFuZCBJSVIgZmlsdGVyIGVuZ2luZS4gWW91IHNwZWNpZnkgdGhlIGNvZWZmaWNpZW50cywgYW5kIHRoaXMgd2lsbCBkbyB0aGUgcmVzdC5cbiAgICAgKi9cbiAgICAgLy8gVE9ETzogVW5pdCB0ZXN0cy5cbiAgICBmbG9jay51Z2VuLmZpbHRlciA9IGZ1bmN0aW9uIChpbnB1dHMsIG91dHB1dCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgdGhhdCA9IGZsb2NrLnVnZW4oaW5wdXRzLCBvdXRwdXQsIG9wdGlvbnMpO1xuXG4gICAgICAgIHRoYXQuZ2VuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG0gPSB0aGF0Lm1vZGVsLFxuICAgICAgICAgICAgICAgIG91dCA9IHRoYXQub3V0cHV0LFxuICAgICAgICAgICAgICAgIGlucHV0cyA9IHRoYXQuaW5wdXRzLFxuICAgICAgICAgICAgICAgIHEgPSBpbnB1dHMucS5vdXRwdXRbMF0sXG4gICAgICAgICAgICAgICAgZnJlcSA9IGlucHV0cy5mcmVxLm91dHB1dFswXTtcblxuICAgICAgICAgICAgaWYgKG0ucHJldkZyZXEgIT09IGZyZXEgfHwgbS5wcmV2USAhPT0gcSkge1xuICAgICAgICAgICAgICAgIHRoYXQudXBkYXRlQ29lZmZpY2llbnRzKG0sIGZyZXEsIHEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGF0LmZpbHRlckVuZ2luZS5maWx0ZXIob3V0LCB0aGF0LmlucHV0cy5zb3VyY2Uub3V0cHV0KTtcblxuICAgICAgICAgICAgbS5wcmV2USA9IHE7XG4gICAgICAgICAgICBtLnByZXZGcmVxID0gZnJlcTtcbiAgICAgICAgICAgIG0udmFsdWUgPSBtLnVuc2NhbGVkVmFsdWUgPSBvdXRbb3V0Lmxlbmd0aCAtIDFdO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZWNpcGVPcHQgPSB0aGF0Lm9wdGlvbnMucmVjaXBlO1xuICAgICAgICAgICAgdmFyIHJlY2lwZSA9IHR5cGVvZiAocmVjaXBlT3B0KSA9PT0gXCJzdHJpbmdcIiA/IGZsb2NrLmdldChyZWNpcGVPcHQpIDogcmVjaXBlT3B0O1xuXG4gICAgICAgICAgICBpZiAoIXJlY2lwZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGluc3RhbnRpYXRlIGEgZmxvY2sudWdlbi5maWx0ZXIoKSB3aXRob3V0IHNwZWNpZnlpbmcgYSBmaWx0ZXIgY29lZmZpY2llbnQgcmVjaXBlLlwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhhdC5maWx0ZXJFbmdpbmUgPSBuZXcgRmlsdGVyKHJlY2lwZS5zaXplcy5iLCByZWNpcGUuc2l6ZXMuYSk7XG4gICAgICAgICAgICB0aGF0Lm1vZGVsLmNvZWZmcyA9IHtcbiAgICAgICAgICAgICAgICBhOiB0aGF0LmZpbHRlckVuZ2luZS5hLFxuICAgICAgICAgICAgICAgIGI6IHRoYXQuZmlsdGVyRW5naW5lLmJcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoYXQudXBkYXRlQ29lZmZpY2llbnRzID0gZmxvY2suZ2V0KHJlY2lwZSwgdGhhdC5vcHRpb25zLnR5cGUpO1xuICAgICAgICAgICAgdGhhdC5vbklucHV0Q2hhbmdlZCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQuaW5pdCgpO1xuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICB9O1xuXG4gICAgZmx1aWQuZGVmYXVsdHMoXCJmbG9jay51Z2VuLmZpbHRlclwiLCB7XG4gICAgICAgIHJhdGU6IFwiYXVkaW9cIixcblxuICAgICAgICBpbnB1dHM6IHtcbiAgICAgICAgICAgIGZyZXE6IDQ0MCxcbiAgICAgICAgICAgIHE6IDEuMCxcbiAgICAgICAgICAgIHNvdXJjZTogbnVsbFxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBBbiBvcHRpbWl6ZWQgYmlxdWFkIGZpbHRlciB1bml0IGdlbmVyYXRvci5cbiAgICAgKi9cbiAgICAvLyBUT0RPOiBVbml0IHRlc3RzLlxuICAgIGZsb2NrLnVnZW4uZmlsdGVyLmJpcXVhZCA9IGZ1bmN0aW9uIChpbnB1dHMsIG91dHB1dCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgdGhhdCA9IGZsb2NrLnVnZW4oaW5wdXRzLCBvdXRwdXQsIG9wdGlvbnMpO1xuXG4gICAgICAgIHRoYXQuZ2VuID0gZnVuY3Rpb24gKG51bVNhbXBzKSB7XG4gICAgICAgICAgICB2YXIgbSA9IHRoYXQubW9kZWwsXG4gICAgICAgICAgICAgICAgaW5wdXRzID0gdGhhdC5pbnB1dHMsXG4gICAgICAgICAgICAgICAgb3V0ID0gdGhhdC5vdXRwdXQsXG4gICAgICAgICAgICAgICAgY28gPSBtLmNvZWZmcyxcbiAgICAgICAgICAgICAgICBmcmVxID0gaW5wdXRzLmZyZXEub3V0cHV0WzBdLFxuICAgICAgICAgICAgICAgIHEgPSBpbnB1dHMucS5vdXRwdXRbMF0sXG4gICAgICAgICAgICAgICAgc291cmNlID0gaW5wdXRzLnNvdXJjZS5vdXRwdXQsXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICB3O1xuXG4gICAgICAgICAgICBpZiAobS5wcmV2RnJlcSAhPT0gZnJlcSB8fCBtLnByZXZRICE9PSBxKSB7XG4gICAgICAgICAgICAgICAgdGhhdC51cGRhdGVDb2VmZmljaWVudHMobSwgZnJlcSwgcSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1TYW1wczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdyA9IHNvdXJjZVtpXSAtIGNvLmFbMF0gKiBtLmQwIC0gY28uYVsxXSAqIG0uZDE7XG4gICAgICAgICAgICAgICAgb3V0W2ldID0gY28uYlswXSAqIHcgKyBjby5iWzFdICogbS5kMCArIGNvLmJbMl0gKiBtLmQxO1xuICAgICAgICAgICAgICAgIG0uZDEgPSBtLmQwO1xuICAgICAgICAgICAgICAgIG0uZDAgPSB3O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtLnByZXZRID0gcTtcbiAgICAgICAgICAgIG0ucHJldkZyZXEgPSBmcmVxO1xuICAgICAgICAgICAgbS52YWx1ZSA9IG0udW5zY2FsZWRWYWx1ZSA9IGZsb2NrLnVnZW4ubGFzdE91dHB1dFZhbHVlKG51bVNhbXBzLCBvdXQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQub25JbnB1dENoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdHlwZU9wdCA9IHRoYXQub3B0aW9ucy50eXBlO1xuICAgICAgICAgICAgdGhhdC51cGRhdGVDb2VmZmljaWVudHMgPSB0eXBlb2YgKHR5cGVPcHQpID09PSBcInN0cmluZ1wiID9cbiAgICAgICAgICAgICAgICBmbG9jay5nZXQodHlwZU9wdCkgOiB0eXBlT3B0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQubW9kZWwuZDAgPSAwLjA7XG4gICAgICAgICAgICB0aGF0Lm1vZGVsLmQxID0gMC4wO1xuICAgICAgICAgICAgdGhhdC5tb2RlbC5jb2VmZnMgPSB7XG4gICAgICAgICAgICAgICAgYTogbmV3IEZsb2F0MzJBcnJheSgyKSxcbiAgICAgICAgICAgICAgICBiOiBuZXcgRmxvYXQzMkFycmF5KDMpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhhdC5vbklucHV0Q2hhbmdlZCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQuaW5pdCgpO1xuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICB9O1xuXG4gICAgZmx1aWQuZGVmYXVsdHMoXCJmbG9jay51Z2VuLmZpbHRlci5iaXF1YWRcIiwge1xuICAgICAgICBpbnB1dHM6IHtcbiAgICAgICAgICAgIGZyZXE6IDQ0MCxcbiAgICAgICAgICAgIHE6IDEuMCxcbiAgICAgICAgICAgIHNvdXJjZTogbnVsbFxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBmbG9jay51Z2VuLmZpbHRlci5iaXF1YWQudHlwZXMgPSB7XG4gICAgICAgIFwiaHBcIjoge1xuICAgICAgICAgICAgaW5wdXREZWZhdWx0czoge1xuICAgICAgICAgICAgICAgIGZyZXE6IDQ0MCxcbiAgICAgICAgICAgICAgICBxOiAxLjBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJmbG9jay5jb2VmZmljaWVudHMuYnV0dGVyd29ydGguaGlnaFBhc3NcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInJocFwiOiB7XG4gICAgICAgICAgICBpbnB1dERlZmF1bHRzOiB7XG4gICAgICAgICAgICAgICAgZnJlcTogNDQwLFxuICAgICAgICAgICAgICAgIHE6IDEuMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZsb2NrLmNvZWZmaWNpZW50cy5yYmouaGlnaFBhc3NcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImxwXCI6IHtcbiAgICAgICAgICAgIGlucHV0RGVmYXVsdHM6IHtcbiAgICAgICAgICAgICAgICBmcmVxOiA0NDAsXG4gICAgICAgICAgICAgICAgcTogMS4wXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZmxvY2suY29lZmZpY2llbnRzLmJ1dHRlcndvcnRoLmxvd1Bhc3NcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInJscFwiOiB7XG4gICAgICAgICAgICBpbnB1dERlZmF1bHRzOiB7XG4gICAgICAgICAgICAgICAgZnJlcTogNDQwLFxuICAgICAgICAgICAgICAgIHE6IDEuMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZsb2NrLmNvZWZmaWNpZW50cy5yYmoubG93UGFzc1wiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiYnBcIjoge1xuICAgICAgICAgICAgaW5wdXREZWZhdWx0czoge1xuICAgICAgICAgICAgICAgIGZyZXE6IDQ0MCxcbiAgICAgICAgICAgICAgICBxOiA0LjBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJmbG9jay5jb2VmZmljaWVudHMuYnV0dGVyd29ydGguYmFuZFBhc3NcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImJyXCI6IHtcbiAgICAgICAgICAgIGlucHV0RGVmYXVsdHM6IHtcbiAgICAgICAgICAgICAgICBmcmVxOiA0NDAsXG4gICAgICAgICAgICAgICAgcTogMS4wXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZmxvY2suY29lZmZpY2llbnRzLmJ1dHRlcndvcnRoLmJhbmRSZWplY3RcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIENvbnZlbmllbmNlIG1ldGhvZHMgZm9yIGluc3RhbnRpYXRpbmcgY29tbW9uIHR5cGVzIG9mIGJpcXVhZCBmaWx0ZXJzLlxuICAgIGZsb2NrLmFsaWFzVUdlbnMoXCJmbG9jay51Z2VuLmZpbHRlci5iaXF1YWRcIiwgZmxvY2sudWdlbi5maWx0ZXIuYmlxdWFkLnR5cGVzKTtcblxuICAgIGZsb2NrLmNvZWZmaWNpZW50cyA9IHtcbiAgICAgICAgYnV0dGVyd29ydGg6IHtcbiAgICAgICAgICAgIHNpemVzOiB7XG4gICAgICAgICAgICAgICAgYTogMixcbiAgICAgICAgICAgICAgICBiOiAzXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBsb3dQYXNzOiBmdW5jdGlvbiAobW9kZWwsIGZyZXEpIHtcbiAgICAgICAgICAgICAgICB2YXIgY28gPSBtb2RlbC5jb2VmZnM7XG4gICAgICAgICAgICAgICAgdmFyIGxhbWJkYSA9IDEgLyBNYXRoLnRhbihNYXRoLlBJICogZnJlcSAvIG1vZGVsLnNhbXBsZVJhdGUpO1xuICAgICAgICAgICAgICAgIHZhciBsYW1iZGFTcXVhcmVkID0gbGFtYmRhICogbGFtYmRhO1xuICAgICAgICAgICAgICAgIHZhciByb290VHdvTGFtYmRhID0gZmxvY2suUk9PVDIgKiBsYW1iZGE7XG4gICAgICAgICAgICAgICAgdmFyIGIwID0gMSAvICgxICsgcm9vdFR3b0xhbWJkYSArIGxhbWJkYVNxdWFyZWQpO1xuICAgICAgICAgICAgICAgIGNvLmJbMF0gPSBiMDtcbiAgICAgICAgICAgICAgICBjby5iWzFdID0gMiAqIGIwO1xuICAgICAgICAgICAgICAgIGNvLmJbMl0gPSBiMDtcbiAgICAgICAgICAgICAgICBjby5hWzBdID0gMiAqICgxIC0gbGFtYmRhU3F1YXJlZCkgKiBiMDtcbiAgICAgICAgICAgICAgICBjby5hWzFdID0gKDEgLSByb290VHdvTGFtYmRhICsgbGFtYmRhU3F1YXJlZCkgKiBiMDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGhpZ2hQYXNzOiBmdW5jdGlvbiAobW9kZWwsIGZyZXEpIHtcbiAgICAgICAgICAgICAgICB2YXIgY28gPSBtb2RlbC5jb2VmZnM7XG4gICAgICAgICAgICAgICAgdmFyIGxhbWJkYSA9IE1hdGgudGFuKE1hdGguUEkgKiBmcmVxIC8gbW9kZWwuc2FtcGxlUmF0ZSk7XG4gICAgICAgICAgICAgICAgLy8gV29ya3MgYXJvdW5kIE5hTiB2YWx1ZXMgaW4gY2FzZXMgd2hlcmUgdGhlIGZyZXF1ZW5jeVxuICAgICAgICAgICAgICAgIC8vIGlzIHByZWNpc2VseSBoYWxmIHRoZSBzYW1wbGluZyByYXRlLCBhbmQgdGh1cyBsYW1iZGFcbiAgICAgICAgICAgICAgICAvLyBpcyBJbmZpbml0ZS5cbiAgICAgICAgICAgICAgICBpZiAobGFtYmRhID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgICAgICAgICBsYW1iZGEgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbGFtYmRhU3F1YXJlZCA9IGxhbWJkYSAqIGxhbWJkYTtcbiAgICAgICAgICAgICAgICB2YXIgcm9vdFR3b0xhbWJkYSA9IGZsb2NrLlJPT1QyICogbGFtYmRhO1xuICAgICAgICAgICAgICAgIHZhciBiMCA9IDEgLyAoMSArIHJvb3RUd29MYW1iZGEgKyBsYW1iZGFTcXVhcmVkKTtcblxuICAgICAgICAgICAgICAgIGNvLmJbMF0gPSBiMDtcbiAgICAgICAgICAgICAgICBjby5iWzFdID0gLTIgKiBiMDtcbiAgICAgICAgICAgICAgICBjby5iWzJdID0gYjA7XG4gICAgICAgICAgICAgICAgY28uYVswXSA9IDIgKiAobGFtYmRhU3F1YXJlZCAtIDEpICogYjA7XG4gICAgICAgICAgICAgICAgY28uYVsxXSA9ICgxIC0gcm9vdFR3b0xhbWJkYSArIGxhbWJkYVNxdWFyZWQpICogYjA7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBiYW5kUGFzczogZnVuY3Rpb24gKG1vZGVsLCBmcmVxLCBxKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvID0gbW9kZWwuY29lZmZzO1xuICAgICAgICAgICAgICAgIHZhciBidyA9IGZyZXEgLyBxO1xuICAgICAgICAgICAgICAgIHZhciBsYW1iZGEgPSAxIC8gTWF0aC50YW4oTWF0aC5QSSAqIGJ3IC8gbW9kZWwuc2FtcGxlUmF0ZSk7XG4gICAgICAgICAgICAgICAgdmFyIHRoZXRhID0gMiAqIE1hdGguY29zKGZsb2NrLlRXT1BJICogZnJlcSAvIG1vZGVsLnNhbXBsZVJhdGUpO1xuICAgICAgICAgICAgICAgIHZhciBiMCA9IDEgLyAoMSArIGxhbWJkYSk7XG5cbiAgICAgICAgICAgICAgICBjby5iWzBdID0gYjA7XG4gICAgICAgICAgICAgICAgY28uYlsxXSA9IDA7XG4gICAgICAgICAgICAgICAgY28uYlsyXSA9IC1iMDtcbiAgICAgICAgICAgICAgICBjby5hWzBdID0gLShsYW1iZGEgKiB0aGV0YSAqIGIwKTtcbiAgICAgICAgICAgICAgICBjby5hWzFdID0gYjAgKiAobGFtYmRhIC0gMSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBiYW5kUmVqZWN0OiBmdW5jdGlvbiAobW9kZWwsIGZyZXEsIHEpIHtcbiAgICAgICAgICAgICAgICB2YXIgY28gPSBtb2RlbC5jb2VmZnM7XG4gICAgICAgICAgICAgICAgdmFyIGJ3ID0gZnJlcSAvIHE7XG4gICAgICAgICAgICAgICAgdmFyIGxhbWJkYSA9IE1hdGgudGFuKE1hdGguUEkgKiBidyAvIG1vZGVsLnNhbXBsZVJhdGUpO1xuICAgICAgICAgICAgICAgIHZhciB0aGV0YSA9IDIgKiBNYXRoLmNvcyhmbG9jay5UV09QSSAqIGZyZXEgLyBtb2RlbC5zYW1wbGVSYXRlKTtcbiAgICAgICAgICAgICAgICB2YXIgYjAgPSAxIC8gKDEgKyBsYW1iZGEpO1xuICAgICAgICAgICAgICAgIHZhciBiMSA9IC10aGV0YSAqIGIwO1xuXG4gICAgICAgICAgICAgICAgY28uYlswXSA9IGIwO1xuICAgICAgICAgICAgICAgIGNvLmJbMV0gPSBiMTtcbiAgICAgICAgICAgICAgICBjby5iWzJdID0gYjA7XG4gICAgICAgICAgICAgICAgY28uYVswXSA9IGIxO1xuICAgICAgICAgICAgICAgIGNvLmFbMV0gPSAoMSAtIGxhbWJkYSkgKiBiMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBGcm9tIFJvYmVydCBCcmlzb3ctSm9obnN0b24ncyBGaWx0ZXIgQ29va2Jvb2s6XG4gICAgICAgIC8vIGh0dHA6Ly9kc3B3aWtpLmNvbS9pbmRleC5waHA/dGl0bGU9Q29va2Jvb2tfRm9ybXVsYWVfZm9yX2F1ZGlvX0VRX2JpcXVhZF9maWx0ZXJfY29lZmZpY2llbnRzXG4gICAgICAgIHJiajoge1xuICAgICAgICAgICAgc2l6ZXM6IHtcbiAgICAgICAgICAgICAgICBhOiAyLFxuICAgICAgICAgICAgICAgIGI6IDNcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGxvd1Bhc3M6IGZ1bmN0aW9uIChtb2RlbCwgZnJlcSwgcSkge1xuICAgICAgICAgICAgICAgIHZhciBjbyA9IG1vZGVsLmNvZWZmcztcbiAgICAgICAgICAgICAgICB2YXIgdzAgPSBmbG9jay5UV09QSSAqIGZyZXEgLyBtb2RlbC5zYW1wbGVSYXRlO1xuICAgICAgICAgICAgICAgIHZhciBjb3N3MCA9IE1hdGguY29zKHcwKTtcbiAgICAgICAgICAgICAgICB2YXIgc2ludzAgPSBNYXRoLnNpbih3MCk7XG4gICAgICAgICAgICAgICAgdmFyIGFscGhhID0gc2ludzAgLyAoMiAqIHEpO1xuICAgICAgICAgICAgICAgIHZhciBvbmVMZXNzQ29zdzAgPSAxIC0gY29zdzA7XG4gICAgICAgICAgICAgICAgdmFyIGEwID0gMSArIGFscGhhO1xuICAgICAgICAgICAgICAgIHZhciBiMCA9IChvbmVMZXNzQ29zdzAgLyAyKSAvIGEwO1xuXG4gICAgICAgICAgICAgICAgY28uYlswXSA9IGIwO1xuICAgICAgICAgICAgICAgIGNvLmJbMV0gPSBvbmVMZXNzQ29zdzAgLyBhMDtcbiAgICAgICAgICAgICAgICBjby5iWzJdID0gYjA7XG4gICAgICAgICAgICAgICAgY28uYVswXSA9ICgtMiAqIGNvc3cwKSAvIGEwO1xuICAgICAgICAgICAgICAgIGNvLmFbMV0gPSAoMSAtIGFscGhhKSAvIGEwO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaGlnaFBhc3M6IGZ1bmN0aW9uIChtb2RlbCwgZnJlcSwgcSkge1xuICAgICAgICAgICAgICAgIHZhciBjbyA9IG1vZGVsLmNvZWZmcztcbiAgICAgICAgICAgICAgICB2YXIgdzAgPSBmbG9jay5UV09QSSAqIGZyZXEgLyBtb2RlbC5zYW1wbGVSYXRlO1xuICAgICAgICAgICAgICAgIHZhciBjb3N3MCA9IE1hdGguY29zKHcwKTtcbiAgICAgICAgICAgICAgICB2YXIgc2ludzAgPSBNYXRoLnNpbih3MCk7XG4gICAgICAgICAgICAgICAgdmFyIGFscGhhID0gc2ludzAgLyAoMiAqIHEpO1xuICAgICAgICAgICAgICAgIHZhciBvbmVQbHVzQ29zdzAgPSAxICsgY29zdzA7XG4gICAgICAgICAgICAgICAgdmFyIGEwID0gMSArIGFscGhhO1xuICAgICAgICAgICAgICAgIHZhciBiMCA9IChvbmVQbHVzQ29zdzAgLyAyKSAvIGEwO1xuXG4gICAgICAgICAgICAgICAgY28uYlswXSA9IGIwO1xuICAgICAgICAgICAgICAgIGNvLmJbMV0gPSAoLW9uZVBsdXNDb3N3MCkgLyBhMDtcbiAgICAgICAgICAgICAgICBjby5iWzJdID0gYjA7XG4gICAgICAgICAgICAgICAgY28uYVswXSA9ICgtMiAqIGNvc3cwKSAvIGEwO1xuICAgICAgICAgICAgICAgIGNvLmFbMV0gPSAoMSAtIGFscGhhKSAvIGEwO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgYmFuZFBhc3M6IGZ1bmN0aW9uIChtb2RlbCwgZnJlcSwgcSkge1xuICAgICAgICAgICAgICAgIHZhciBjbyA9IG1vZGVsLmNvZWZmcztcbiAgICAgICAgICAgICAgICB2YXIgdzAgPSBmbG9jay5UV09QSSAqIGZyZXEgLyBtb2RlbC5zYW1wbGVSYXRlO1xuICAgICAgICAgICAgICAgIHZhciBjb3N3MCA9IE1hdGguY29zKHcwKTtcbiAgICAgICAgICAgICAgICB2YXIgc2ludzAgPSBNYXRoLnNpbih3MCk7XG4gICAgICAgICAgICAgICAgdmFyIGFscGhhID0gc2ludzAgLyAoMiAqIHEpO1xuICAgICAgICAgICAgICAgIHZhciBhMCA9IDEgKyBhbHBoYTtcbiAgICAgICAgICAgICAgICB2YXIgcUJ5QWxwaGEgPSBxICogYWxwaGE7XG5cbiAgICAgICAgICAgICAgICBjby5iWzBdID0gcUJ5QWxwaGEgLyBhMDtcbiAgICAgICAgICAgICAgICBjby5iWzFdID0gMDtcbiAgICAgICAgICAgICAgICBjby5iWzJdID0gLXFCeUFscGhhIC8gYTA7XG4gICAgICAgICAgICAgICAgY28uYVswXSA9ICgtMiAqIGNvc3cwKSAvIGEwO1xuICAgICAgICAgICAgICAgIGNvLmFbMV0gPSAoMSAtIGFscGhhKSAvIGEwO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgYmFuZFJlamVjdDogZnVuY3Rpb24gKG1vZGVsLCBmcmVxLCBxKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvID0gbW9kZWwuY29lZmZzO1xuICAgICAgICAgICAgICAgIHZhciB3MCA9IGZsb2NrLlRXT1BJICogZnJlcSAvIG1vZGVsLnNhbXBsZVJhdGU7XG4gICAgICAgICAgICAgICAgdmFyIGNvc3cwID0gTWF0aC5jb3ModzApO1xuICAgICAgICAgICAgICAgIHZhciBzaW53MCA9IE1hdGguc2luKHcwKTtcbiAgICAgICAgICAgICAgICB2YXIgYWxwaGEgPSBzaW53MCAvICgyICogcSk7XG4gICAgICAgICAgICAgICAgdmFyIGEwID0gMSArIGFscGhhO1xuICAgICAgICAgICAgICAgIHZhciByYTAgPSAxIC8gYTA7XG4gICAgICAgICAgICAgICAgdmFyIGIxID0gKC0yICogY29zdzApIC8gYTA7XG4gICAgICAgICAgICAgICAgY28uYlswXSA9IHJhMDtcbiAgICAgICAgICAgICAgICBjby5iWzFdID0gYjE7XG4gICAgICAgICAgICAgICAgY28uYlsyXSA9IHJhMDtcbiAgICAgICAgICAgICAgICBjby5hWzBdID0gYjE7XG4gICAgICAgICAgICAgICAgY28uYVsxXSA9ICgxIC0gYWxwaGEpIC8gYTA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQSBNb29nLXN0eWxlIDI0ZGIgcmVzb25hbnQgbG93LXBhc3MgZmlsdGVyLlxuICAgICAqXG4gICAgICogVGhpcyB1bml0IGdlbmVyYXRvciBpcyBiYXNlZCBvbiB0aGUgZm9sbG93aW5nIG11c2ljZHNwIHNuaXBwZXQ6XG4gICAgICogaHR0cDovL3d3dy5tdXNpY2RzcC5vcmcvc2hvd0FyY2hpdmVDb21tZW50LnBocD9BcmNoaXZlSUQ9MjZcbiAgICAgKlxuICAgICAqIElucHV0czpcbiAgICAgKiAgIC0gc291cmNlOiB0aGUgc291cmNlIHNpZ25hbCB0byBwcm9jZXNzXG4gICAgICogICAtIGN1dG9mZjogdGhlIGN1dG9mZiBmcmVxdWVuY3lcbiAgICAgKiAgIC0gcmVzb25hbmNlOiB0aGUgZmlsdGVyIHJlc29uYW5jZSBbYmV0d2VlbiAwIGFuZCA0LCB3aGVyZSA0IGlzIHNlbGYtb3NjaWxsYXRpb25dXG4gICAgICovXG4gICAgLy8gVE9ETzogVW5pdCB0ZXN0cy5cbiAgICBmbG9jay51Z2VuLmZpbHRlci5tb29nID0gZnVuY3Rpb24gKGlucHV0cywgb3V0cHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB0aGF0ID0gZmxvY2sudWdlbihpbnB1dHMsIG91dHB1dCwgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhhdC5nZW4gPSBmdW5jdGlvbiAobnVtU2FtcHMpIHtcbiAgICAgICAgICAgIHZhciBtID0gdGhhdC5tb2RlbCxcbiAgICAgICAgICAgICAgICBpbnB1dHMgPSB0aGF0LmlucHV0cyxcbiAgICAgICAgICAgICAgICBvdXQgPSB0aGF0Lm91dHB1dCxcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSBpbnB1dHMuc291cmNlLm91dHB1dCxcbiAgICAgICAgICAgICAgICBzb3VyY2VJbmMgPSBtLnN0cmlkZXMuc291cmNlLFxuICAgICAgICAgICAgICAgIHJlcyA9IGlucHV0cy5yZXNvbmFuY2Uub3V0cHV0LFxuICAgICAgICAgICAgICAgIHJlc0luYyA9IG0uc3RyaWRlcy5yZXNvbmFuY2UsXG4gICAgICAgICAgICAgICAgY3V0b2ZmID0gaW5wdXRzLmN1dG9mZi5vdXRwdXQsXG4gICAgICAgICAgICAgICAgY3V0b2ZmSW5jID0gbS5zdHJpZGVzLmN1dG9mZixcbiAgICAgICAgICAgICAgICBmID0gbS5mLFxuICAgICAgICAgICAgICAgIGZTcSA9IG0uZlNxLFxuICAgICAgICAgICAgICAgIGZTcVNxID0gbS5mU3FTcSxcbiAgICAgICAgICAgICAgICBvbmVNaW51c0YgPSBtLm9uZU1pbnVzRixcbiAgICAgICAgICAgICAgICBmYiA9IG0uZmIsXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICBqLFxuICAgICAgICAgICAgICAgIGssXG4gICAgICAgICAgICAgICAgbCxcbiAgICAgICAgICAgICAgICBjdXJyQ3V0b2ZmLFxuICAgICAgICAgICAgICAgIGN1cnJSZXMsXG4gICAgICAgICAgICAgICAgdmFsO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSBqID0gayA9IGwgPSAwOyBpIDwgbnVtU2FtcHM7IGkrKywgaiArPSBzb3VyY2VJbmMsIGsgKz0gcmVzSW5jLCBsICs9IGN1dG9mZkluYykge1xuICAgICAgICAgICAgICAgIGN1cnJDdXRvZmYgPSBjdXRvZmZbbF07XG4gICAgICAgICAgICAgICAgY3VyclJlcyA9IHJlc1trXTtcblxuICAgICAgICAgICAgICAgIGlmIChjdXJyQ3V0b2ZmICE9PSBtLnByZXZDdXRvZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJDdXRvZmYgPiBtLm55cXVpc3RSYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyQ3V0b2ZmID0gbS5ueXF1aXN0UmF0ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGYgPSBtLmYgPSAoY3VyckN1dG9mZiAvIG0ubnlxdWlzdFJhdGUpICogMS4xNjtcbiAgICAgICAgICAgICAgICAgICAgZlNxID0gbS5mU3EgPSBmICogZjtcbiAgICAgICAgICAgICAgICAgICAgZlNxU3EgPSBtLmZTcVNxID0gZlNxICogZlNxO1xuICAgICAgICAgICAgICAgICAgICBvbmVNaW51c0YgPSBtLm9uZU1pbnVzRiA9IDEgLSBmO1xuICAgICAgICAgICAgICAgICAgICBtLnByZXZSZXMgPSB1bmRlZmluZWQ7IC8vIEZsYWcgdGhlIG5lZWQgdG8gdXBkYXRlIGZiLlxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjdXJyUmVzICE9PSBtLnByZXZSZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJSZXMgPiA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyUmVzID0gNDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyUmVzIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyclJlcyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmYiA9IG0uZmIgPSBjdXJyUmVzICogKDEuMCAtIDAuMTUgKiBmU3EpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhbCA9IHNvdXJjZVtqXSAtIChtLm91dDQgKiBmYik7XG4gICAgICAgICAgICAgICAgdmFsICo9IDAuMzUwMTMgKiBmU3FTcTtcbiAgICAgICAgICAgICAgICBtLm91dDEgPSB2YWwgKyAwLjMgKiBtLmluMSArIG9uZU1pbnVzRiAqIG0ub3V0MTtcbiAgICAgICAgICAgICAgICBtLmluMSA9IHZhbDtcbiAgICAgICAgICAgICAgICBtLm91dDIgPSBtLm91dDEgKyAwLjMgKiBtLmluMiArIG9uZU1pbnVzRiAqIG0ub3V0MjtcbiAgICAgICAgICAgICAgICBtLmluMiA9IG0ub3V0MTtcbiAgICAgICAgICAgICAgICBtLm91dDMgPSBtLm91dDIgKyAwLjMgKiBtLmluMyArIG9uZU1pbnVzRiAqIG0ub3V0MztcbiAgICAgICAgICAgICAgICBtLmluMyA9IG0ub3V0MjtcbiAgICAgICAgICAgICAgICBtLm91dDQgPSBtLm91dDMgKyAwLjMgKiBtLmluNCArIG9uZU1pbnVzRiAqIG0ub3V0NDtcbiAgICAgICAgICAgICAgICBtLmluNCA9IG0ub3V0MztcbiAgICAgICAgICAgICAgICBvdXRbaV0gPSBtLm91dDQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG0udW5zY2FsZWRWYWx1ZSA9IG0ub3V0NDtcbiAgICAgICAgICAgIHRoYXQubXVsQWRkKG51bVNhbXBzKTtcbiAgICAgICAgICAgIG0udmFsdWUgPSBmbG9jay51Z2VuLmxhc3RPdXRwdXRWYWx1ZShudW1TYW1wcywgb3V0KTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0Lm9uSW5wdXRDaGFuZ2VkKCk7XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgIH07XG5cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsb2NrLnVnZW4uZmlsdGVyLm1vb2dcIiwge1xuICAgICAgICByYXRlOiBcImF1ZGlvXCIsXG4gICAgICAgIGlucHV0czoge1xuICAgICAgICAgICAgY3V0b2ZmOiAzMDAwLFxuICAgICAgICAgICAgcmVzb25hbmNlOiAzLjk5LFxuICAgICAgICAgICAgc291cmNlOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIHVnZW5PcHRpb25zOiB7XG4gICAgICAgICAgICBtb2RlbDoge1xuICAgICAgICAgICAgICAgIGluMTogMC4wLFxuICAgICAgICAgICAgICAgIGluMjogMC4wLFxuICAgICAgICAgICAgICAgIGluMzogMC4wLFxuICAgICAgICAgICAgICAgIGluNDogMC4wLFxuICAgICAgICAgICAgICAgIG91dDE6IDAuMCxcbiAgICAgICAgICAgICAgICBvdXQyOiAwLjAsXG4gICAgICAgICAgICAgICAgb3V0MzogMC4wLFxuICAgICAgICAgICAgICAgIG91dDQ6IDAuMCxcbiAgICAgICAgICAgICAgICBwcmV2Q3V0b2ZmOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgcHJldlJlc29uYW5jZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGY6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBmU3E6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBmU3FTcTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIG9uZU1pbnVzRjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGZiOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgdW5zY2FsZWRWYWx1ZTogMC4wLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAwLjBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdHJpZGVJbnB1dHM6IFtcInNvdXJjZVwiLCBcImN1dG9mZlwiLCBcInJlc29uYW5jZVwiXVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBmbG9jay51Z2VuLmRlbGF5ID0gZnVuY3Rpb24gKGlucHV0cywgb3V0cHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB0aGF0ID0gZmxvY2sudWdlbihpbnB1dHMsIG91dHB1dCwgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhhdC5nZW4gPSBmdW5jdGlvbiAobnVtU2FtcHMpIHtcbiAgICAgICAgICAgIHZhciBtID0gdGhhdC5tb2RlbCxcbiAgICAgICAgICAgICAgICBpbnB1dHMgPSB0aGF0LmlucHV0cyxcbiAgICAgICAgICAgICAgICBvdXQgPSB0aGF0Lm91dHB1dCxcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSBpbnB1dHMuc291cmNlLm91dHB1dCxcbiAgICAgICAgICAgICAgICB0aW1lID0gaW5wdXRzLnRpbWUub3V0cHV0WzBdLFxuICAgICAgICAgICAgICAgIGRlbGF5QnVmZmVyID0gdGhhdC5kZWxheUJ1ZmZlcixcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIHZhbDtcblxuICAgICAgICAgICAgaWYgKHRpbWUgIT09IG0udGltZSkge1xuICAgICAgICAgICAgICAgIG0udGltZSA9IHRpbWU7XG4gICAgICAgICAgICAgICAgbS5kZWxheVNhbXBzID0gdGltZSAqIHRoYXQubW9kZWwuc2FtcGxlUmF0ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bVNhbXBzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobS5wb3MgPj0gbS5kZWxheVNhbXBzKSB7XG4gICAgICAgICAgICAgICAgICAgIG0ucG9zID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0W2ldID0gdmFsID0gZGVsYXlCdWZmZXJbbS5wb3NdO1xuICAgICAgICAgICAgICAgIGRlbGF5QnVmZmVyW20ucG9zXSA9IHNvdXJjZVtpXTtcbiAgICAgICAgICAgICAgICBtLnBvcysrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtLnVuc2NhbGVkVmFsdWUgPSB2YWw7XG4gICAgICAgICAgICB0aGF0Lm11bEFkZChudW1TYW1wcyk7XG4gICAgICAgICAgICBtLnZhbHVlID0gZmxvY2sudWdlbi5sYXN0T3V0cHV0VmFsdWUobnVtU2FtcHMsIG91dCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5vbklucHV0Q2hhbmdlZCA9IGZ1bmN0aW9uIChpbnB1dE5hbWUpIHtcbiAgICAgICAgICAgIGZsb2NrLm9uTXVsQWRkSW5wdXRDaGFuZ2VkKHRoYXQpO1xuXG4gICAgICAgICAgICBpZiAoIWlucHV0TmFtZSB8fCBpbnB1dE5hbWUgPT09IFwibWF4VGltZVwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlbGF5QnVmZmVyTGVuZ3RoID0gdGhhdC5tb2RlbC5zYW1wbGVSYXRlICogdGhhdC5pbnB1dHMubWF4VGltZS5vdXRwdXRbMF07XG4gICAgICAgICAgICAgICAgdGhhdC5kZWxheUJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkoZGVsYXlCdWZmZXJMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQub25JbnB1dENoYW5nZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfTtcblxuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmxvY2sudWdlbi5kZWxheVwiLCB7XG4gICAgICAgIHJhdGU6IFwiYXVkaW9cIixcbiAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICBtYXhUaW1lOiAxLjAsXG4gICAgICAgICAgICB0aW1lOiAxLjAsXG4gICAgICAgICAgICBzb3VyY2U6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgdWdlbk9wdGlvbnM6IHtcbiAgICAgICAgICAgIG1vZGVsOiB7XG4gICAgICAgICAgICAgICAgcG9zOiAwLFxuICAgICAgICAgICAgICAgIHVuc2NhbGVkVmFsdWU6IDAuMCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogMC4wXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG4gICAgLy8gU2ltcGxlIG9wdGltaXNlZCBkZWxheSBmb3IgZXhhY3RseSAxIHNhbXBsZVxuICAgIGZsb2NrLnVnZW4uZGVsYXkxID0gZnVuY3Rpb24gKGlucHV0cywgb3V0cHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB0aGF0ID0gZmxvY2sudWdlbihpbnB1dHMsIG91dHB1dCwgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhhdC5nZW4gPSBmdW5jdGlvbiAobnVtU2FtcHMpIHtcbiAgICAgICAgICAgIHZhciBtID0gdGhhdC5tb2RlbCxcbiAgICAgICAgICAgICAgICBpbnB1dHMgPSB0aGF0LmlucHV0cyxcbiAgICAgICAgICAgICAgICBvdXQgPSB0aGF0Lm91dHB1dCxcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSBpbnB1dHMuc291cmNlLm91dHB1dCxcbiAgICAgICAgICAgICAgICBwcmV2VmFsID0gbS5wcmV2VmFsLFxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgdmFsO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtU2FtcHM7IGkrKykge1xuICAgICAgICAgICAgICAgIG91dFtpXSA9IHZhbCA9IHByZXZWYWw7XG4gICAgICAgICAgICAgICAgcHJldlZhbCA9IHNvdXJjZVtpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbS5wcmV2VmFsID0gcHJldlZhbDtcbiAgICAgICAgICAgIG0udW5zY2FsZWRWYWx1ZSA9IHZhbDtcbiAgICAgICAgICAgIHRoYXQubXVsQWRkKG51bVNhbXBzKTtcbiAgICAgICAgICAgIG0udmFsdWUgPSBmbG9jay51Z2VuLmxhc3RPdXRwdXRWYWx1ZShudW1TYW1wcywgb3V0KTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0Lm9uSW5wdXRDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZmxvY2sub25NdWxBZGRJbnB1dENoYW5nZWQodGhhdCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5vbklucHV0Q2hhbmdlZCgpO1xuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICB9O1xuXG4gICAgZmx1aWQuZGVmYXVsdHMoXCJmbG9jay51Z2VuLmRlbGF5MVwiLCB7XG4gICAgICAgIHJhdGU6IFwiYXVkaW9cIixcbiAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICBzb3VyY2U6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgdWdlbk9wdGlvbnM6IHtcbiAgICAgICAgICAgIG1vZGVsOiB7XG4gICAgICAgICAgICAgICAgcHJldlZhbDogMC4wLFxuICAgICAgICAgICAgICAgIHVuc2NhbGVkVmFsdWU6IDAuMCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogMC4wXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG4gICAgZmxvY2sudWdlbi5mcmVldmVyYiA9IGZ1bmN0aW9uIChpbnB1dHMsIG91dHB1dCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgdGhhdCA9IGZsb2NrLnVnZW4oaW5wdXRzLCBvdXRwdXQsIG9wdGlvbnMpO1xuICAgICAgICB0aGF0LnR1bmluZ3MgPSB0aGF0Lm9wdGlvbnMudHVuaW5ncztcbiAgICAgICAgdGhhdC5hbGxwYXNzVHVuaW5ncyA9IHRoYXQub3B0aW9ucy5hbGxwYXNzVHVuaW5ncztcblxuICAgICAgICB0aGF0LmdlbiA9IGZ1bmN0aW9uIChudW1TYW1wcykge1xuICAgICAgICAgICAgdmFyIG0gPSB0aGF0Lm1vZGVsLFxuICAgICAgICAgICAgICAgIGlucHV0cyA9IHRoYXQuaW5wdXRzLFxuICAgICAgICAgICAgICAgIG91dCA9IHRoYXQub3V0cHV0LFxuICAgICAgICAgICAgICAgIHNvdXJjZSA9IGlucHV0cy5zb3VyY2Uub3V0cHV0LFxuICAgICAgICAgICAgICAgIG1peCA9IGlucHV0cy5taXgub3V0cHV0WzBdLFxuICAgICAgICAgICAgICAgIGRyeSA9IDEgLSBtaXgsXG4gICAgICAgICAgICAgICAgcm9vbXNpemUgPSBpbnB1dHMucm9vbS5vdXRwdXRbMF0sXG4gICAgICAgICAgICAgICAgcm9vbV9zY2FsZWQgPSByb29tc2l6ZSAqIDAuMjggKyAwLjcsXG4gICAgICAgICAgICAgICAgZGFtcCA9IGlucHV0cy5kYW1wLm91dHB1dFswXSxcbiAgICAgICAgICAgICAgICBkYW1wMSA9IGRhbXAgKiAwLjQsXG4gICAgICAgICAgICAgICAgZGFtcDIgPSAxLjAgLSBkYW1wMSxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIGosXG4gICAgICAgICAgICAgICAgdmFsO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtU2FtcHM7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIHJlYWQgaW5wdXRzXG4gICAgICAgICAgICAgICAgdmFyIGlucCA9IHNvdXJjZVtpXTtcbiAgICAgICAgICAgICAgICB2YXIgaW5wX3NjYWxlZCA9IGlucCAqIDAuMDE1O1xuXG4gICAgICAgICAgICAgICAgLy8gcmVhZCBzYW1wbGVzIGZyb20gdGhlIGFsbHBhc3Nlc1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCB0aGF0LmJ1ZmZlcnNfYS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKyt0aGF0LmJ1ZmZlcmluZGljZXNfYVtqXSA9PT0gdGhhdC5hbGxwYXNzVHVuaW5nc1tqXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5idWZmZXJpbmRpY2VzX2Fbal0gPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoYXQucmVhZHNhbXBfYVtqXSA9IHRoYXQuYnVmZmVyc19hW2pdW3RoYXQuYnVmZmVyaW5kaWNlc19hW2pdXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBmb3JlYWNoIGNvbWIgYnVmZmVyLCB3ZSBwZXJmb3JtIHNhbWUgZmlsdGVyaW5nIChvbmx5IGJ1ZmZlcmxlbiBkaWZmZXJzKVxuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCB0aGF0LmJ1ZmZlcnNfYy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKyt0aGF0LmJ1ZmZlcmluZGljZXNfY1tqXSA9PT0gdGhhdC50dW5pbmdzW2pdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmJ1ZmZlcmluZGljZXNfY1tqXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ1ZklkeF9jID0gdGhhdC5idWZmZXJpbmRpY2VzX2Nbal0sXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkc2FtcF9jID0gdGhhdC5idWZmZXJzX2Nbal1bYnVmSWR4X2NdO1xuICAgICAgICAgICAgICAgICAgICB0aGF0LmZpbHRlcnhfY1tqXSA9IChkYW1wMiAqIHRoYXQuZmlsdGVyeV9jW2pdKSArIChkYW1wMSAqIHRoYXQuZmlsdGVyeF9jW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5idWZmZXJzX2Nbal1bYnVmSWR4X2NdID0gaW5wX3NjYWxlZCArIChyb29tX3NjYWxlZCAqIHRoYXQuZmlsdGVyeF9jW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5maWx0ZXJ5X2Nbal0gPSByZWFkc2FtcF9jO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGVhY2ggYWxscGFzcyBpcyBoYW5kbGVkIGluZGl2aWR1YWxseSxcbiAgICAgICAgICAgICAgICAvLyB3aXRoIGRpZmZlcmVudCBjYWxjdWxhdGlvbnMgbWFkZSBhbmQgc3RvcmVkIGludG8gdGhlIGRlbGF5bGluZXNcbiAgICAgICAgICAgICAgICB2YXIgZnRlbXA4ID0gKHRoYXQuZmlsdGVyeV9jWzZdICsgdGhhdC5maWx0ZXJ5X2NbN10pO1xuXG4gICAgICAgICAgICAgICAgdGhhdC5idWZmZXJzX2FbM11bdGhhdC5idWZmZXJpbmRpY2VzX2FbM11dID0gKCgoKDAuNSAqIHRoYXQuZmlsdGVyeF9hWzNdKSArIHRoYXQuZmlsdGVyeV9jWzBdKSArXG4gICAgICAgICAgICAgICAgICAgICh0aGF0LmZpbHRlcnlfY1sxXSArIHRoYXQuZmlsdGVyeV9jWzJdKSkgK1xuICAgICAgICAgICAgICAgICAgICAoKHRoYXQuZmlsdGVyeV9jWzNdICsgdGhhdC5maWx0ZXJ5X2NbNF0pICsgKHRoYXQuZmlsdGVyeV9jWzVdICsgZnRlbXA4KSkpO1xuICAgICAgICAgICAgICAgIHRoYXQuZmlsdGVyeF9hWzNdID0gdGhhdC5yZWFkc2FtcF9hWzNdO1xuICAgICAgICAgICAgICAgIHRoYXQuZmlsdGVyeV9hWzNdID0gKHRoYXQuZmlsdGVyeF9hWzNdIC0gKCgodGhhdC5maWx0ZXJ5X2NbMF0gKyB0aGF0LmZpbHRlcnlfY1sxXSkgK1xuICAgICAgICAgICAgICAgICAgICAodGhhdC5maWx0ZXJ5X2NbMl0gKyB0aGF0LmZpbHRlcnlfY1szXSkpICtcbiAgICAgICAgICAgICAgICAgICAgKCh0aGF0LmZpbHRlcnlfY1s0XSArIHRoYXQuZmlsdGVyeV9jWzVdKSArIGZ0ZW1wOCkpKTtcbiAgICAgICAgICAgICAgICB0aGF0LmJ1ZmZlcnNfYVsyXVt0aGF0LmJ1ZmZlcmluZGljZXNfYVsyXV0gPSAoKDAuNSAqIHRoYXQuZmlsdGVyeF9hWzJdKSArIHRoYXQuZmlsdGVyeV9hWzNdKTtcbiAgICAgICAgICAgICAgICB0aGF0LmZpbHRlcnhfYVsyXSA9IHRoYXQucmVhZHNhbXBfYVsyXTtcbiAgICAgICAgICAgICAgICB0aGF0LmZpbHRlcnlfYVsyXSA9ICh0aGF0LmZpbHRlcnhfYVsyXSAtIHRoYXQuZmlsdGVyeV9hWzNdKTtcblxuICAgICAgICAgICAgICAgIHRoYXQuYnVmZmVyc19hWzFdW3RoYXQuYnVmZmVyaW5kaWNlc19hWzFdXSA9ICgoMC41ICogdGhhdC5maWx0ZXJ4X2FbMV0pICsgdGhhdC5maWx0ZXJ5X2FbMl0pO1xuICAgICAgICAgICAgICAgIHRoYXQuZmlsdGVyeF9hWzFdID0gdGhhdC5yZWFkc2FtcF9hWzFdO1xuICAgICAgICAgICAgICAgIHRoYXQuZmlsdGVyeV9hWzFdID0gKHRoYXQuZmlsdGVyeF9hWzFdIC0gdGhhdC5maWx0ZXJ5X2FbMl0pO1xuXG4gICAgICAgICAgICAgICAgdGhhdC5idWZmZXJzX2FbMF1bdGhhdC5idWZmZXJpbmRpY2VzX2FbMF1dID0gKCgwLjUgKiB0aGF0LmZpbHRlcnhfYVswXSkgKyB0aGF0LmZpbHRlcnlfYVsxXSk7XG4gICAgICAgICAgICAgICAgdGhhdC5maWx0ZXJ4X2FbMF0gPSB0aGF0LnJlYWRzYW1wX2FbMF07XG4gICAgICAgICAgICAgICAgdGhhdC5maWx0ZXJ5X2FbMF0gPSAodGhhdC5maWx0ZXJ4X2FbMF0gLSB0aGF0LmZpbHRlcnlfYVsxXSk7XG4gICAgICAgICAgICAgICAgdmFsID0gKChkcnkgKiBpbnApICsgKG1peCAqIHRoYXQuZmlsdGVyeV9hWzBdKSk7XG4gICAgICAgICAgICAgICAgb3V0W2ldID0gdmFsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtLnVuc2NhbGVkVmFsdWUgPSB2YWw7XG4gICAgICAgICAgICB0aGF0Lm11bEFkZChudW1TYW1wcyk7XG4gICAgICAgICAgICBtLnZhbHVlID0gZmxvY2sudWdlbi5sYXN0T3V0cHV0VmFsdWUobnVtU2FtcHMsIG91dCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5pbml0RGVsYXlMaW5lcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIEluaXRpYWxpc2UgdGhlIGRlbGF5IGxpbmVzXG4gICAgICAgICAgICB0aGF0LmJ1ZmZlcnNfYyA9IG5ldyBBcnJheSg4KTtcbiAgICAgICAgICAgIHRoYXQuYnVmZmVyaW5kaWNlc19jID0gbmV3IEludDMyQXJyYXkoOCk7XG4gICAgICAgICAgICB0aGF0LmZpbHRlcnhfYyA9IG5ldyBGbG9hdDMyQXJyYXkoOCk7XG4gICAgICAgICAgICB0aGF0LmZpbHRlcnlfYyA9IG5ldyBGbG9hdDMyQXJyYXkoOCk7XG4gICAgICAgICAgICB2YXIgc3ByZWFkID0gdGhhdC5tb2RlbC5zcHJlYWQ7XG4gICAgICAgICAgICB2YXIgaSwgajtcbiAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IHRoYXQuYnVmZmVyc19jLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5idWZmZXJzX2NbaV0gPSBuZXcgRmxvYXQzMkFycmF5KHRoYXQudHVuaW5nc1tpXStzcHJlYWQpO1xuICAgICAgICAgICAgICAgIHRoYXQuYnVmZmVyaW5kaWNlc19jW2ldID0gMDtcbiAgICAgICAgICAgICAgICB0aGF0LmZpbHRlcnhfY1tpXSA9IDA7XG4gICAgICAgICAgICAgICAgdGhhdC5maWx0ZXJ5X2NbaV0gPSAwO1xuICAgICAgICAgICAgICAgIGZvcihqID0gMDsgaiA8IHRoYXQudHVuaW5nc1tpXStzcHJlYWQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB0aGF0LmJ1ZmZlcnNfY1tpXVtqXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhhdC5idWZmZXJzX2EgPSBuZXcgQXJyYXkoNCk7XG4gICAgICAgICAgICB0aGF0LmJ1ZmZlcmluZGljZXNfYSA9IG5ldyBJbnQzMkFycmF5KDQpO1xuICAgICAgICAgICAgdGhhdC5maWx0ZXJ4X2EgPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuICAgICAgICAgICAgdGhhdC5maWx0ZXJ5X2EgPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuICAgICAgICAgICAgLy8gXCJyZWFkc2FtcFwiIHZhcnMgYXJlIHRlbXBvcmFyeSB2YWx1ZXMgcmVhZCBiYWNrIGZyb20gdGhlIGRlbGF5IGxpbmVzLFxuICAgICAgICAgICAgLy8gbm90IHN0b3JlZCBidXQgb25seSB1c2VkIGluIHRoZSBnZW4gbG9vcFxuICAgICAgICAgICAgdGhhdC5yZWFkc2FtcF9hID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGF0LmJ1ZmZlcnNfYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoYXQuYnVmZmVyaW5kaWNlc19hW2ldID0gMDtcbiAgICAgICAgICAgICAgICB0aGF0LmZpbHRlcnhfYVtpXSA9IDA7XG4gICAgICAgICAgICAgICAgdGhhdC5maWx0ZXJ5X2FbaV0gPSAwO1xuICAgICAgICAgICAgICAgIHRoYXQucmVhZHNhbXBfYVtpXSA9IDA7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBpcyB0aGlzIHdoYXQgdGhlIHNwcmVhZCBpcyBtZWFudCB0byBkbz9cbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgdGhhdC5hbGxwYXNzVHVuaW5ncy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB0aGF0LmFsbHBhc3NUdW5pbmdzW2pdICs9IHNwcmVhZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhhdC5idWZmZXJzX2FbaV0gPSBuZXcgRmxvYXQzMkFycmF5KHRoYXQuYWxscGFzc1R1bmluZ3NbaV0pO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCB0aGF0LmFsbHBhc3NUdW5pbmdzW2ldOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5idWZmZXJzX2FbaV1bal0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0LmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0LmluaXREZWxheUxpbmVzKCk7XG4gICAgICAgICAgICB0aGF0Lm9uSW5wdXRDaGFuZ2VkKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5pbml0KCk7XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgIH07XG5cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsb2NrLnVnZW4uZnJlZXZlcmJcIiwge1xuICAgICAgICByYXRlOiBcImF1ZGlvXCIsXG4gICAgICAgIGlucHV0czoge1xuICAgICAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICAgICAgbWl4OiAwLjMzLFxuICAgICAgICAgICAgcm9vbTogMC41LFxuICAgICAgICAgICAgZGFtcDogMC41XG4gICAgICAgIH0sXG4gICAgICAgIHVnZW5PcHRpb25zOiB7XG4gICAgICAgICAgICBtb2RlbDoge1xuICAgICAgICAgICAgICAgIHNwcmVhZDogMCxcbiAgICAgICAgICAgICAgICB1bnNjYWxlZFZhbHVlOiAwLjAsXG4gICAgICAgICAgICAgICAgdmFsdWU6IDAuMFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgdHVuaW5nczogWzExMTYsIDExODgsIDEyNzcsIDEzNTYsIDE0MjIsIDE0OTEsIDE1NTcsIDE2MTddLFxuICAgICAgICAgICAgYWxscGFzc1R1bmluZ3M6IFs1NTYsIDQ0MSwgMzQxLCAyMjVdXG4gICAgICAgIH1cbiAgICB9KTtcblxuXG4gICAgLyoqXG4gICAgICogQSBzaW1wbGUgd2F2ZXNoYXBlci1iYXNlZCBkaXN0b3J0aW9uIGVmZmVjdC5cbiAgICAgKiBVc2VzIHRoZSBwb2x5bm9taWFsIHkgPSAoMy8yKSAqIHggLSAoMS8yKSAqIHheMy5cbiAgICAgKiBodHRwOi8vd3d3Lm11c2ljZHNwLm9yZy9zaG93b25lLnBocD9pZD0xMTRcbiAgICAgKlxuICAgICAqIElucHV0czpcbiAgICAgKiAgIC0gc291cmNlOiB0aGUgaW5wdXQgc2lnbmFsIHRvIGRpc3RvcnRcbiAgICAgKiAgIC0gZ2FpbjogdGhlIGdhaW4gZmFjdG9yIHRvIGFwcGx5IFsxLjAuLkluZmluaXR5XVxuICAgICAqL1xuICAgIGZsb2NrLnVnZW4uZGlzdG9ydGlvbiA9IGZ1bmN0aW9uIChpbnB1dHMsIG91dHB1dCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgdGhhdCA9IGZsb2NrLnVnZW4oaW5wdXRzLCBvdXRwdXQsIG9wdGlvbnMpO1xuXG4gICAgICAgIHRoYXQuZ2VuID0gZnVuY3Rpb24gKG51bVNhbXBzKSB7XG4gICAgICAgICAgICB2YXIgbSA9IHRoYXQubW9kZWwsXG4gICAgICAgICAgICAgICAgb3V0ID0gdGhhdC5vdXRwdXQsXG4gICAgICAgICAgICAgICAgc291cmNlID0gdGhhdC5pbnB1dHMuc291cmNlLm91dHB1dCxcbiAgICAgICAgICAgICAgICBzb3VyY2VJbmMgPSBtLnN0cmlkZXMuc291cmNlLFxuICAgICAgICAgICAgICAgIGdhaW4gPSB0aGF0LmlucHV0cy5nYWluLm91dHB1dCxcbiAgICAgICAgICAgICAgICBnYWluSW5jID0gbS5zdHJpZGVzLmdhaW4sXG4gICAgICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgICAgIGRpc3QsXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICBqLFxuICAgICAgICAgICAgICAgIGs7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IGogPSAgayA9IDA7IGkgPCBudW1TYW1wczsgaSsrLCBqICs9IHNvdXJjZUluYywgayArPSBnYWluSW5jKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gc291cmNlW2pdICogZ2FpbltrXTtcbiAgICAgICAgICAgICAgICBkaXN0ID0gMS41ICogdmFsIC0gMC41ICogdmFsICogdmFsICogdmFsO1xuICAgICAgICAgICAgICAgIG91dFtpXSA9IGRpc3Q7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG0udW5zY2FsZWRWYWx1ZSA9IGRpc3Q7XG4gICAgICAgICAgICB0aGF0Lm11bEFkZChudW1TYW1wcyk7XG4gICAgICAgICAgICBtLnZhbHVlID0gZmxvY2sudWdlbi5sYXN0T3V0cHV0VmFsdWUobnVtU2FtcHMsIG91dCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5vbklucHV0Q2hhbmdlZCgpO1xuXG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgIH07XG5cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsb2NrLnVnZW4uZGlzdG9ydGlvblwiLCB7XG4gICAgICAgIHJhdGU6IFwiYXVkaW9cIixcbiAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICBzb3VyY2U6IG51bGwsXG4gICAgICAgICAgICBnYWluOiAxLjBcbiAgICAgICAgfSxcbiAgICAgICAgdWdlbk9wdGlvbnM6IHtcbiAgICAgICAgICAgIHN0cmlkZUlucHV0czogW1wic291cmNlXCIsIFwiZ2FpblwiXVxuICAgICAgICB9XG4gICAgfSk7XG5cblxuICAgIC8qKlxuICAgICAqIEEgc2ltcGxlIHdhdmVzaGFwZXItYmFzZWQgZGlzdG9ydGlvbiBlZmZlY3QgYnkgQnJhbSBkZSBKb25nZS5cbiAgICAgKiBodHRwOi8vd3d3Lm11c2ljZHNwLm9yZy9zaG93b25lLnBocD9pZD00MVxuICAgICAqXG4gICAgICogSW5wdXRzOlxuICAgICAqICAgLSBzb3VyY2U6IHRoZSBpbnB1dCBzaWduYWxcbiAgICAgKiAgIC0gYW1vdW50OiBhIHZhbHVlIGJldHdlZW4gMSBhbmQgSW5maW5pdHkgdGhhdCByZXByZXNlbnRzIHRoZSBhbW91bnQgb2YgZGlzdG9ydGlvblxuICAgICAqICAgICAgICAgICAgIHRvIGFwcGx5LlxuICAgICAqL1xuICAgIGZsb2NrLnVnZW4uZGlzdG9ydGlvbi5kZUpvbmdlID0gZnVuY3Rpb24gKGlucHV0cywgb3V0cHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB0aGF0ID0gZmxvY2sudWdlbihpbnB1dHMsIG91dHB1dCwgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhhdC5nZW4gPSBmdW5jdGlvbiAobnVtU2FtcHMpIHtcbiAgICAgICAgICAgIHZhciBtID0gdGhhdC5tb2RlbCxcbiAgICAgICAgICAgICAgICBvdXQgPSB0aGF0Lm91dHB1dCxcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSB0aGF0LmlucHV0cy5zb3VyY2Uub3V0cHV0LFxuICAgICAgICAgICAgICAgIHNvdXJjZUluYyA9IG0uc3RyaWRlcy5zb3VyY2UsXG4gICAgICAgICAgICAgICAgYW1vdW50ID0gdGhhdC5pbnB1dHMuYW1vdW50Lm91dHB1dCxcbiAgICAgICAgICAgICAgICBhbW91bnRJbmMgPSBtLnN0cmlkZXMuYW1vdW50LFxuICAgICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgICAgYSxcbiAgICAgICAgICAgICAgICBhYnNYLFxuICAgICAgICAgICAgICAgIGRpc3QsXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICBqLFxuICAgICAgICAgICAgICAgIGs7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IGogPSBrID0gMDsgaSA8IG51bVNhbXBzOyBpKyssIGogKz0gc291cmNlSW5jLCBrICs9IGFtb3VudEluYykge1xuICAgICAgICAgICAgICAgIHggPSBzb3VyY2Vbal07XG4gICAgICAgICAgICAgICAgYSA9IGFtb3VudFtrXTtcbiAgICAgICAgICAgICAgICBhYnNYID0gTWF0aC5hYnMoeCk7XG4gICAgICAgICAgICAgICAgZGlzdCA9IHggKiAoYWJzWCArIGEpIC8gKCh4ICogeCkgKyAoYSAtIDEpICogYWJzWCArIDEpO1xuICAgICAgICAgICAgICAgIG91dFtpXSA9IGRpc3Q7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG0udW5zY2FsZWRWYWx1ZSA9IGRpc3Q7XG4gICAgICAgICAgICB0aGF0Lm11bEFkZChudW1TYW1wcyk7XG4gICAgICAgICAgICBtLnZhbHVlID0gZmxvY2sudWdlbi5sYXN0T3V0cHV0VmFsdWUobnVtU2FtcHMsIG91dCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5vbklucHV0Q2hhbmdlZCgpO1xuXG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgIH07XG5cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsb2NrLnVnZW4uZGlzdG9ydGlvbi5kZUpvbmdlXCIsIHtcbiAgICAgICAgcmF0ZTogXCJhdWRpb1wiLFxuICAgICAgICBpbnB1dHM6IHtcbiAgICAgICAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgICAgICAgIGFtb3VudDogMlxuICAgICAgICB9LFxuICAgICAgICB1Z2VuT3B0aW9uczoge1xuICAgICAgICAgICAgc3RyaWRlSW5wdXRzOiBbXCJzb3VyY2VcIiwgXCJhbW91bnRcIl1cbiAgICAgICAgfVxuICAgIH0pO1xuXG5cbiAgICAvKipcbiAgICAgKiBBIHNpbXBsZSB3YXZlc2hhcGVyLWJhc2VkIGRpc3RvcnRpb24gZWZmZWN0IGJ5IFBhcnRpY2UgVGFycmFiaWEgYW5kIEJyYW0gZGUgSm9uZy5cbiAgICAgKiBodHRwOi8vd3d3Lm11c2ljZHNwLm9yZy9zaG93b25lLnBocD9pZD00NlxuICAgICAqXG4gICAgICogSW5wdXRzOlxuICAgICAqICAgLSBzb3VyY2U6IHRoZSBpbnB1dCBzaWduYWxcbiAgICAgKiAgIC0gYW1vdW50OiBhIHZhbHVlIGJldHdlZW4gLTEgYW5kIDEgdGhhdCByZXByZXNlbnRzIHRoZSBhbW91bnQgb2YgZGlzdG9ydGlvblxuICAgICAqICAgICAgICAgICAgIHRvIGFwcGx5LlxuICAgICAqL1xuICAgIGZsb2NrLnVnZW4uZGlzdG9ydGlvbi50YXJyYWJpYURlSm9uZ2UgPSBmdW5jdGlvbiAoaW5wdXRzLCBvdXRwdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHRoYXQgPSBmbG9jay51Z2VuKGlucHV0cywgb3V0cHV0LCBvcHRpb25zKTtcblxuICAgICAgICB0aGF0LmdlbiA9IGZ1bmN0aW9uIChudW1TYW1wcykge1xuICAgICAgICAgICAgdmFyIG0gPSB0aGF0Lm1vZGVsLFxuICAgICAgICAgICAgICAgIG91dCA9IHRoYXQub3V0cHV0LFxuICAgICAgICAgICAgICAgIHNvdXJjZSA9IHRoYXQuaW5wdXRzLnNvdXJjZS5vdXRwdXQsXG4gICAgICAgICAgICAgICAgc291cmNlSW5jID0gbS5zdHJpZGVzLnNvdXJjZSxcbiAgICAgICAgICAgICAgICBhbW91bnQgPSB0aGF0LmlucHV0cy5hbW91bnQub3V0cHV0LFxuICAgICAgICAgICAgICAgIGFtb3VudEluYyA9IG0uc3RyaWRlcy5hbW91bnQsXG4gICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICBhLFxuICAgICAgICAgICAgICAgIGRpc3QsXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICBzSWR4LFxuICAgICAgICAgICAgICAgIGFJZHgsXG4gICAgICAgICAgICAgICAgaztcblxuICAgICAgICAgICAgZm9yIChpID0gc0lkeCA9IGFJZHggPSAwOyBpIDwgbnVtU2FtcHM7IGkrKywgc0lkeCArPSBzb3VyY2VJbmMsIGFJZHggKz0gYW1vdW50SW5jKSB7XG4gICAgICAgICAgICAgICAgeCA9IHNvdXJjZVtzSWR4XTtcbiAgICAgICAgICAgICAgICBhID0gYW1vdW50W2FJZHhdO1xuXG4gICAgICAgICAgICAgICAgLy8gRXhwZWN0cyBhbiBhbW91bnQgdmFsdWUgaW4gdGhlIHJhbmdlIG9mXG4gICAgICAgICAgICAgICAgLy8gLTEuMCB0byAxLjAsIGJ1dCBOYU5zIGFyZSBwcm9kdWNlZCB3aXRoIGV4YWN0IDEuMHMuXG4gICAgICAgICAgICAgICAgaWYgKGEgPj0gMS4wKSB7XG4gICAgICAgICAgICAgICAgICAgIGEgPSAwLjk5OTk5OTk5OTk5OTk5OTk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhIDwgLTEuMCkge1xuICAgICAgICAgICAgICAgICAgICBhID0gLTEuMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBrID0gMiAqIGEgLyAoMSAtIGEpO1xuICAgICAgICAgICAgICAgIGRpc3QgPSAoMSArIGspICogeCAvICgxICsgayAqIE1hdGguYWJzKHgpKTtcbiAgICAgICAgICAgICAgICBvdXRbaV0gPSBkaXN0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtLnVuc2NhbGVkVmFsdWUgPSBkaXN0O1xuICAgICAgICAgICAgdGhhdC5tdWxBZGQobnVtU2FtcHMpO1xuICAgICAgICAgICAgbS52YWx1ZSA9IGZsb2NrLnVnZW4ubGFzdE91dHB1dFZhbHVlKG51bVNhbXBzLCBvdXQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQub25JbnB1dENoYW5nZWQoKTtcblxuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICB9O1xuXG4gICAgZmx1aWQuZGVmYXVsdHMoXCJmbG9jay51Z2VuLmRpc3RvcnRpb24udGFycmFiaWFEZUpvbmdlXCIsIHtcbiAgICAgICAgcmF0ZTogXCJhdWRpb1wiLFxuICAgICAgICBpbnB1dHM6IHtcbiAgICAgICAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgICAgICAgIGFtb3VudDogMTBcbiAgICAgICAgfSxcbiAgICAgICAgdWdlbk9wdGlvbnM6IHtcbiAgICAgICAgICAgIHN0cmlkZUlucHV0czogW1wic291cmNlXCIsIFwiYW1vdW50XCJdXG4gICAgICAgIH1cbiAgICB9KTtcblxuXG4gICAgLyoqXG4gICAgICogV2F2ZXNoYXBlciBkaXN0b3J0aW9uIGJ5IExhdXJlbnQgZGUgU29yYXMuXG4gICAgICogaHR0cDovL3d3dy5tdXNpY2RzcC5vcmcvc2hvd29uZS5waHA/aWQ9ODZcbiAgICAgKlxuICAgICAqIElucHV0czpcbiAgICAgKiAgIC0gc291cmNlOiB0aGUgc2lnbmFsIHRvIGRpc3RvcnRcbiAgICAgKiAgIC0gZ2FpbjogdGhlIGdhaW4gZmFjdG9yIHRvIGFwcGx5IFsxLjAuLkluZmluaXR5XVxuICAgICAqL1xuICAgIGZsb2NrLnVnZW4uZGlzdG9ydGlvbi5nbG91YmlCb3VsZ2EgPSBmdW5jdGlvbiAoaW5wdXRzLCBvdXRwdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHRoYXQgPSBmbG9jay51Z2VuKGlucHV0cywgb3V0cHV0LCBvcHRpb25zKTtcblxuICAgICAgICB0aGF0LmdlbiA9IGZ1bmN0aW9uIChudW1TYW1wcykge1xuICAgICAgICAgICAgdmFyIG0gPSB0aGF0Lm1vZGVsLFxuICAgICAgICAgICAgICAgIG91dCA9IHRoYXQub3V0cHV0LFxuICAgICAgICAgICAgICAgIHNvdXJjZSA9IHRoYXQuaW5wdXRzLnNvdXJjZS5vdXRwdXQsXG4gICAgICAgICAgICAgICAgc291cmNlSW5jID0gbS5zdHJpZGVzLnNvdXJjZSxcbiAgICAgICAgICAgICAgICBnYWluID0gdGhhdC5pbnB1dHMuZ2Fpbi5vdXRwdXQsXG4gICAgICAgICAgICAgICAgZ2FpbkluYyA9IG0uc3RyaWRlcy5nYWluLFxuICAgICAgICAgICAgICAgIHZhbCxcbiAgICAgICAgICAgICAgICBkaXN0LFxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgaixcbiAgICAgICAgICAgICAgICBrLFxuICAgICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgICAgYSxcbiAgICAgICAgICAgICAgICBleHBYO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSBqID0gayA9IDA7IGkgPCBudW1TYW1wczsgaSsrLCBqICs9IHNvdXJjZUluYywgayArPSBnYWluSW5jKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gc291cmNlW2pdICogZ2FpbltrXTtcbiAgICAgICAgICAgICAgICB4ID0gdmFsICogMC42ODYzMDY7XG4gICAgICAgICAgICAgICAgYSA9IDEgKyBNYXRoLmV4cChNYXRoLnNxcnQoTWF0aC5hYnMoeCkpICogLTAuNzUpO1xuICAgICAgICAgICAgICAgIGV4cFggPSBNYXRoLmV4cCh4KTtcbiAgICAgICAgICAgICAgICBkaXN0ID0gKGV4cFggLSBNYXRoLmV4cCgteCAqIGEpKSAvIChleHBYICsgTWF0aC5leHAoLXgpKTtcbiAgICAgICAgICAgICAgICBvdXRbaV0gPSBkaXN0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtLnVuc2NhbGVkVmFsdWUgPSBkaXN0O1xuICAgICAgICAgICAgdGhhdC5tdWxBZGQobnVtU2FtcHMpO1xuICAgICAgICAgICAgbS52YWx1ZSA9IGZsb2NrLnVnZW4ubGFzdE91dHB1dFZhbHVlKG51bVNhbXBzLCBvdXQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQub25JbnB1dENoYW5nZWQoKTtcblxuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICB9O1xuXG4gICAgZmx1aWQuZGVmYXVsdHMoXCJmbG9jay51Z2VuLmRpc3RvcnRpb24uZ2xvdWJpQm91bGdhXCIsIHtcbiAgICAgICAgcmF0ZTogXCJhdWRpb1wiLFxuICAgICAgICBpbnB1dHM6IHtcbiAgICAgICAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgICAgICAgIGdhaW46IDEuMFxuICAgICAgICB9LFxuICAgICAgICB1Z2VuT3B0aW9uczoge1xuICAgICAgICAgICAgc3RyaWRlSW5wdXRzOiBbXCJzb3VyY2VcIiwgXCJnYWluXCJdXG4gICAgICAgIH1cbiAgICB9KTtcblxuXG4gICAgZmxvY2sudWdlbi5kZWNheSA9IGZ1bmN0aW9uIChpbnB1dHMsIG91dHB1dCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgdGhhdCA9IGZsb2NrLnVnZW4oaW5wdXRzLCBvdXRwdXQsIG9wdGlvbnMpO1xuXG4gICAgICAgIHRoYXQuZ2VuID0gZnVuY3Rpb24gKG51bVNhbXBzKSB7XG4gICAgICAgICAgICB2YXIgbSA9IHRoYXQubW9kZWwsXG4gICAgICAgICAgICAgICAgaW5wdXRzID0gdGhhdC5pbnB1dHMsXG4gICAgICAgICAgICAgICAgb3V0ID0gdGhhdC5vdXRwdXQsXG4gICAgICAgICAgICAgICAgc291cmNlID0gaW5wdXRzLnNvdXJjZS5vdXRwdXQsXG4gICAgICAgICAgICAgICAgdGltZSA9IGlucHV0cy50aW1lLm91dHB1dFswXSxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIHZhbDtcblxuICAgICAgICAgICAgaWYgKHRpbWUgIT09IG0udGltZSkge1xuICAgICAgICAgICAgICAgIG0udGltZSA9IHRpbWU7XG4gICAgICAgICAgICAgICAgbS5jb2VmZiA9IHRpbWUgPT09IDAuMCA/IDAuMCA6IE1hdGguZXhwKGZsb2NrLkxPRzAwMSAvICh0aW1lICogdGhhdC5tb2RlbC5zYW1wbGVSYXRlKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRPRE86IE9wdGltaXplIHRoaXMgY29uZGl0aW9uYWwuXG4gICAgICAgICAgICBpZiAobS5jb2VmZiA9PT0gMC4wKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bVNhbXBzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0W2ldID0gdmFsID0gc291cmNlW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bVNhbXBzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbS5sYXN0U2FtcCA9IHNvdXJjZVtpXSArIG0uY29lZmYgKiBtLmxhc3RTYW1wO1xuICAgICAgICAgICAgICAgICAgICBvdXRbaV0gPSB2YWwgPSBtLmxhc3RTYW1wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbS51bnNjYWxlZFZhbHVlID0gdmFsO1xuICAgICAgICAgICAgdGhhdC5tdWxBZGQobnVtU2FtcHMpO1xuICAgICAgICAgICAgbS52YWx1ZSA9IGZsb2NrLnVnZW4ubGFzdE91dHB1dFZhbHVlKG51bVNhbXBzLCBvdXQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQub25JbnB1dENoYW5nZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfTtcblxuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmxvY2sudWdlbi5kZWNheVwiLCB7XG4gICAgICAgIHJhdGU6IFwiYXVkaW9cIixcbiAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICBzb3VyY2U6IG51bGwsXG4gICAgICAgICAgICB0aW1lOiAxLjBcbiAgICAgICAgfSxcbiAgICAgICAgdWdlbk9wdGlvbnM6IHtcbiAgICAgICAgICAgIG1vZGVsOiB7XG4gICAgICAgICAgICAgICAgdGltZTogMCxcbiAgICAgICAgICAgICAgICBsYXN0U2FtcDogMCxcbiAgICAgICAgICAgICAgICBjb2VmZjogMCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogMC4wXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICogR3JhbnVsYXIgU3ludGhlc2lzIFVHZW5zICpcbiAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJzIGdyYWlucyBmcm9tIGFuIGF1ZGlvIGJ1ZmZlci5cbiAgICAgKlxuICAgICAqIElucHV0czpcbiAgICAgKiAgIC0gZHVyOiB0aGUgZHVyYXRpb24gb2YgZWFjaCBncmFpbiAoY29udHJvbCBvciBjb25zdGFudCByYXRlIG9ubHkpXG4gICAgICogICAtIHRyaWdnZXI6IGEgdHJpZ2dlciBzaWduYWwgdGhhdCwgd2hlbiBpdCBtb3ZlIHRvIGEgcG9zaXRpdmUgbnVtYmVyLCB3aWxsIHN0YXJ0IGEgZ3JhaW5cbiAgICAgKiAgIC0gYnVmZmVyOiBhIGJ1ZmZlckRlZiBvYmplY3QgZGVzY3JpYmluZyB0aGUgYnVmZmVyIHRvIGdyYW51bGF0ZVxuICAgICAqICAgLSBjZW50ZXJQb3M6IHRoZSBwb3N0aW9uIHdpdGhpbiB0aGUgc291bmQgYnVmZmVyIHdoZW4gdGhlIGdyYWluIHdpbGwgcmVhY2ggbWF4aW11bSBhbXBsaXR1ZGVcbiAgICAgKiAgIC0gYW1wOiB0aGUgcGVhayBhbXBsaXR1ZGUgb2YgdGhlIGdyYWluXG4gICAgICogICAtIHNwZWVkOiB0aGUgcmF0ZSBhdCB3aGljaCBncmFpbiBzYW1wbGVzIGFyZSBzZWxlY3RlZCBmcm9tIHRoZSBidWZmZXI7IDEuMCBpcyBub3JtYWwgc3BlZWQsIC0xLjAgaXMgYmFja3dhcmRzXG4gICAgICpcbiAgICAgKiBPcHRpb25zOlxuICAgICAqICAgLSBpbnRlcnBvbGF0aW9uOiBcImN1YmljXCIsIFwibGluZWFyXCIsIG9yIFwibm9uZVwiL3VuZGVmaW5lZFxuICAgICAqL1xuICAgIC8vIFRPRE86IFVuaXQgdGVzdHMuXG4gICAgZmxvY2sudWdlbi50cmlnZ2VyR3JhaW5zID0gZnVuY3Rpb24gKGlucHV0cywgb3V0cHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB0aGF0ID0gZmxvY2sudWdlbihpbnB1dHMsIG91dHB1dCwgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhhdC5nZW4gPSBmdW5jdGlvbiAobnVtU2FtcHMpIHtcbiAgICAgICAgICAgIHZhciBtID0gdGhhdC5tb2RlbCxcbiAgICAgICAgICAgICAgICBpbnB1dHMgPSB0aGF0LmlucHV0cyxcbiAgICAgICAgICAgICAgICBvdXQgPSB0aGF0Lm91dHB1dCxcbiAgICAgICAgICAgICAgICBjaGFuID0gaW5wdXRzLmNoYW5uZWwub3V0cHV0WzBdLFxuICAgICAgICAgICAgICAgIGJ1ZiA9IHRoYXQuYnVmZmVyLmRhdGEuY2hhbm5lbHNbY2hhbl0sXG4gICAgICAgICAgICAgICAgYnVmUmF0ZSA9IHRoYXQuYnVmZmVyLmZvcm1hdC5zYW1wbGVSYXRlLFxuICAgICAgICAgICAgICAgIGR1ciA9IGlucHV0cy5kdXIub3V0cHV0WzBdLFxuICAgICAgICAgICAgICAgIGFtcCA9IGlucHV0cy5hbXAub3V0cHV0LFxuICAgICAgICAgICAgICAgIGNlbnRlclBvcyA9IGlucHV0cy5jZW50ZXJQb3Mub3V0cHV0LFxuICAgICAgICAgICAgICAgIHRyaWdnZXIgPSBpbnB1dHMudHJpZ2dlci5vdXRwdXQsXG4gICAgICAgICAgICAgICAgc3BlZWQgPSBpbnB1dHMuc3BlZWQub3V0cHV0LFxuICAgICAgICAgICAgICAgIGdyYWluRW52ID0gdGhhdC5vcHRpb25zLmdyYWluRW52LFxuICAgICAgICAgICAgICAgIGxhc3RPdXRJZHggPSBudW1TYW1wcyAtIDEsXG4gICAgICAgICAgICAgICAgcG9zSWR4ID0gMCxcbiAgICAgICAgICAgICAgICB0cmlnSWR4ID0gMCxcbiAgICAgICAgICAgICAgICBhbXBJZHggPSAwLFxuICAgICAgICAgICAgICAgIHNwZWVkSWR4ID0gMCxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIGosXG4gICAgICAgICAgICAgICAgayxcbiAgICAgICAgICAgICAgICBncmFpbixcbiAgICAgICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgICAgICBzYW1wLFxuICAgICAgICAgICAgICAgIGVudjtcblxuICAgICAgICAgICAgLy8gVHJpZ2dlciBuZXcgZ3JhaW5zLlxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bVNhbXBzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodHJpZ2dlclt0cmlnSWR4XSA+IDAuMCAmJiBtLnByZXZUcmlnZ2VyIDw9IDAuMCAmJiBtLmFjdGl2ZUdyYWlucy5sZW5ndGggPCBtLm1heE51bUdyYWlucykge1xuICAgICAgICAgICAgICAgICAgICBncmFpbiA9IG0uZnJlZUdyYWlucy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgZ3JhaW4ubnVtU2FtcHMgPSBtLnNhbXBsZVJhdGUgKiBkdXI7XG4gICAgICAgICAgICAgICAgICAgIGdyYWluLmNlbnRlcklkeCA9IChncmFpbi5udW1TYW1wcyAvIDIpICogbS5zdGVwU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgZ3JhaW4uZW52U2NhbGUgPSB0aGF0Lm9wdGlvbnMuZ3JhaW5FbnYubGVuZ3RoIC8gZ3JhaW4ubnVtU2FtcHM7XG4gICAgICAgICAgICAgICAgICAgIGdyYWluLnNhbXBJZHggPSAwO1xuICAgICAgICAgICAgICAgICAgICBncmFpbi5hbXAgPSBhbXBbYW1wSWR4XTtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSAoY2VudGVyUG9zW3Bvc0lkeF0gKiBidWZSYXRlKSAtIGdyYWluLmNlbnRlcklkeDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgKz0gYnVmLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBncmFpbi5yZWFkUG9zID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIGdyYWluLndyaXRlUG9zID0gaTtcbiAgICAgICAgICAgICAgICAgICAgZ3JhaW4uc3BlZWQgPSBzcGVlZFtzcGVlZElkeF07XG4gICAgICAgICAgICAgICAgICAgIG0uYWN0aXZlR3JhaW5zLnB1c2goZ3JhaW4pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG0ucHJldlRyaWdnZXIgPSB0cmlnZ2VyW3RyaWdJZHhdO1xuICAgICAgICAgICAgICAgIG91dFtpXSA9IDAuMDtcblxuICAgICAgICAgICAgICAgIHBvc0lkeCArPSBtLnN0cmlkZXMuY2VudGVyUG9zO1xuICAgICAgICAgICAgICAgIHRyaWdJZHggKz0gbS5zdHJpZGVzLnRyaWdnZXI7XG4gICAgICAgICAgICAgICAgYW1wSWR4ICs9IG0uc3RyaWRlcy5hbXA7XG4gICAgICAgICAgICAgICAgc3BlZWRJZHggKz0gbS5zdHJpZGVzLnNwZWVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBPdXRwdXQgc2FtcGxlcyBmb3IgYWxsIGFjdGl2ZSBncmFpbnMuXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbS5hY3RpdmVHcmFpbnMubGVuZ3RoOykge1xuICAgICAgICAgICAgICAgIGdyYWluID0gbS5hY3RpdmVHcmFpbnNbal07XG4gICAgICAgICAgICAgICAgZm9yIChrID0gZ3JhaW4ud3JpdGVQb3M7IGsgPCBNYXRoLm1pbihrICsgKGdyYWluLm51bVNhbXBzIC0gZ3JhaW4uc2FtcElkeCksIG51bVNhbXBzKTsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIHNhbXAgPSB0aGF0LmludGVycG9sYXRlKGdyYWluLnJlYWRQb3MsIGJ1Zik7XG4gICAgICAgICAgICAgICAgICAgIGVudiA9IGZsb2NrLmludGVycG9sYXRlLmxpbmVhcihncmFpbi5zYW1wSWR4ICogZ3JhaW4uZW52U2NhbGUsIGdyYWluRW52KTtcbiAgICAgICAgICAgICAgICAgICAgb3V0W2tdICs9IHNhbXAgKiBlbnYgKiBncmFpbi5hbXA7XG4gICAgICAgICAgICAgICAgICAgIGdyYWluLnJlYWRQb3MgPSAoZ3JhaW4ucmVhZFBvcyArIChtLnN0ZXBTaXplICogZ3JhaW4uc3BlZWQpKSAlIGJ1Zi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGdyYWluLnNhbXBJZHgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGdyYWluLnNhbXBJZHggPj0gZ3JhaW4ubnVtU2FtcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgbS5mcmVlR3JhaW5zLnB1c2goZ3JhaW4pO1xuICAgICAgICAgICAgICAgICAgICBtLmFjdGl2ZUdyYWlucy5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgICAgICBncmFpbi53cml0ZVBvcyA9IGsgJSBudW1TYW1wcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG0udW5zY2FsZWRWYWx1ZSA9IG91dFtsYXN0T3V0SWR4XTtcbiAgICAgICAgICAgIHRoYXQubXVsQWRkKG51bVNhbXBzKTtcbiAgICAgICAgICAgIG0udmFsdWUgPSBvdXRbbGFzdE91dElkeF07XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5vbkJ1ZmZlclJlYWR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG0gPSB0aGF0Lm1vZGVsO1xuICAgICAgICAgICAgbS5zdGVwU2l6ZSA9IHRoYXQuYnVmZmVyLmZvcm1hdC5zYW1wbGVSYXRlIC8gbS5zYW1wbGVSYXRlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQub25JbnB1dENoYW5nZWQgPSBmdW5jdGlvbiAoaW5wdXROYW1lKSB7XG4gICAgICAgICAgICB0aGF0Lm9uQnVmZmVySW5wdXRDaGFuZ2VkKGlucHV0TmFtZSk7XG4gICAgICAgICAgICB0aGF0LmNhbGN1bGF0ZVN0cmlkZXMoKTtcbiAgICAgICAgICAgIGZsb2NrLm9uTXVsQWRkSW5wdXRDaGFuZ2VkKHRoYXQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQuYWxsb2NhdGVHcmFpbnMgPSBmdW5jdGlvbiAobnVtR3JhaW5zKSB7XG4gICAgICAgICAgICBudW1HcmFpbnMgPSBudW1HcmFpbnMgfHwgdGhhdC5tb2RlbC5tYXhOdW1HcmFpbnM7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtR3JhaW5zOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGF0Lm1vZGVsLmZyZWVHcmFpbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG51bVNhbXBzOiAwLFxuICAgICAgICAgICAgICAgICAgICBjZW50ZXJJZHg6IDAuMCxcbiAgICAgICAgICAgICAgICAgICAgZW52U2NhbGU6IDAuMCxcbiAgICAgICAgICAgICAgICAgICAgc2FtcElkeDogMCxcbiAgICAgICAgICAgICAgICAgICAgYW1wOiAwLjAsXG4gICAgICAgICAgICAgICAgICAgIHJlYWRQb3M6IDAuMCxcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVQb3M6IDAsXG4gICAgICAgICAgICAgICAgICAgIHNwZWVkOiAwLjBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0LmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmbG9jay51Z2VuLmJ1ZmZlcih0aGF0KTtcbiAgICAgICAgICAgIHRoYXQuYWxsb2NhdGVHcmFpbnMoKTtcbiAgICAgICAgICAgIHRoYXQuaW5pdEJ1ZmZlcigpO1xuICAgICAgICAgICAgdGhhdC5vbklucHV0Q2hhbmdlZCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQuaW5pdCgpO1xuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICB9O1xuXG4gICAgZmx1aWQuZGVmYXVsdHMoXCJmbG9jay51Z2VuLnRyaWdnZXJHcmFpbnNcIiwge1xuICAgICAgICByYXRlOiBcImF1ZGlvXCIsXG4gICAgICAgIGlucHV0czoge1xuICAgICAgICAgICAgY2VudGVyUG9zOiAwLFxuICAgICAgICAgICAgY2hhbm5lbDogMCxcbiAgICAgICAgICAgIGFtcDogMS4wLFxuICAgICAgICAgICAgZHVyOiAwLjEsXG4gICAgICAgICAgICBzcGVlZDogMS4wLFxuICAgICAgICAgICAgdHJpZ2dlcjogMC4wLFxuICAgICAgICAgICAgYnVmZmVyOiBudWxsLFxuICAgICAgICAgICAgbXVsOiBudWxsLFxuICAgICAgICAgICAgYWRkOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIHVnZW5PcHRpb25zOiB7XG4gICAgICAgICAgICBncmFpbkVudjogZmxvY2suZmlsbFRhYmxlKDgxOTIsIGZsb2NrLnRhYmxlR2VuZXJhdG9ycy5oYW5uKSxcbiAgICAgICAgICAgIG1vZGVsOiB7XG4gICAgICAgICAgICAgICAgdW5zY2FsZWRWYWx1ZTogMC4wLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAwLjAsXG4gICAgICAgICAgICAgICAgbWF4TnVtR3JhaW5zOiA1MTIsXG4gICAgICAgICAgICAgICAgYWN0aXZlR3JhaW5zOiBbXSxcbiAgICAgICAgICAgICAgICBmcmVlR3JhaW5zOiBbXSxcbiAgICAgICAgICAgICAgICBlbnY6IG51bGwsXG4gICAgICAgICAgICAgICAgc3RyaWRlczoge31cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdHJpZGVJbnB1dHM6IFtcbiAgICAgICAgICAgICAgICBcImNlbnRlclBvc1wiLFxuICAgICAgICAgICAgICAgIFwidHJpZ2dlclwiLFxuICAgICAgICAgICAgICAgIFwiYW1wXCIsXG4gICAgICAgICAgICAgICAgXCJzcGVlZFwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgaW50ZXJwb2xhdGlvbjogXCJjdWJpY1wiXG4gICAgICAgIH1cbiAgICB9KTtcblxuXG4gICAgLyoqXG4gICAgICogR3JhbnVsYXRlcyBhIHNvdXJjZSBzaWduYWwgdXNpbmcgYW4gaW50ZWdyYWwgZGVsYXkgbGluZS5cbiAgICAgKiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIGxpdmUgZ3JhbnVsYXRpb24uXG4gICAgICogQ29udHJpYnV0ZWQgYnkgTWF5YW5rIFNhbmdhbmVyaWEuXG4gICAgICpcbiAgICAgKiBJbnB1dHM6XG4gICAgICogICAtIGdyYWluRHVyOiB0aGUgZHVyYXRpb24gb2YgZWFjaCBncmFpbiAoY29udHJvbCBvciBjb25zdGFudCByYXRlIG9ubHkpXG4gICAgICogICAtIGRlbGF5RHVyOiB0aGUgZHVyYXRpb24gb2YgdGhlIGRlbGF5IGxpbmUgKGNvbnRyb2wgb3IgY29uc3RhbnQgcmF0ZSBvbmx5KVxuICAgICAqICAgLSBudW1HcmFpbnM6IHRoZSBudW1iZXIgb2YgZ3JhaW5zIHRvIGdlbmVyYXRlIChjb250cm9sIG9yIGNvbnN0YW50IHJhdGUgb25seSlcbiAgICAgKiAgIC0gbXVsOiBhbXBsaXR1ZGUgc2NhbGUgZmFjdG9yXG4gICAgICogICAtIGFkZDogYW1wbGlkZSBhZGRcbiAgICAgKi9cbiAgICAvLyBUT0RPOiBVbml0IHRlc3RzLlxuICAgIGZsb2NrLnVnZW4uZ3JhbnVsYXRvciA9IGZ1bmN0aW9uIChpbnB1dHMsIG91dHB1dCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgdGhhdCA9IGZsb2NrLnVnZW4oaW5wdXRzLCBvdXRwdXQsIG9wdGlvbnMpO1xuXG4gICAgICAgIHRoYXQuZ2VuID0gZnVuY3Rpb24gKG51bVNhbXBzKSB7XG4gICAgICAgICAgICB2YXIgbSA9IHRoYXQubW9kZWwsXG4gICAgICAgICAgICAgICAgbyA9IHRoYXQub3B0aW9ucyxcbiAgICAgICAgICAgICAgICBpbnB1dHMgPSB0aGF0LmlucHV0cyxcbiAgICAgICAgICAgICAgICBvdXQgPSB0aGF0Lm91dHB1dCxcbiAgICAgICAgICAgICAgICBkZWxheUxpbmUgPSB0aGF0LmRlbGF5TGluZSxcbiAgICAgICAgICAgICAgICBncmFpbkR1ciA9IGlucHV0cy5ncmFpbkR1ci5vdXRwdXRbMF0sXG4gICAgICAgICAgICAgICAgZGVsYXlEdXIgPSBpbnB1dHMuZGVsYXlEdXIub3V0cHV0WzBdLFxuICAgICAgICAgICAgICAgIG51bUdyYWlucyA9IGlucHV0cy5udW1HcmFpbnMub3V0cHV0WzBdLFxuICAgICAgICAgICAgICAgIHNvdXJjZSA9IGlucHV0cy5zb3VyY2Uub3V0cHV0LFxuICAgICAgICAgICAgICAgIG1heERlbGF5RHVyID0gby5tYXhEZWxheUR1cixcbiAgICAgICAgICAgICAgICBncmFpbkVudiA9IG8uZ3JhaW5FbnYsXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICBqLFxuICAgICAgICAgICAgICAgIHZhbCxcbiAgICAgICAgICAgICAgICBncmFpbklkeCxcbiAgICAgICAgICAgICAgICBkZWxheUxpbmVSZWFkSWR4LFxuICAgICAgICAgICAgICAgIHNhbXAsXG4gICAgICAgICAgICAgICAgd2luZG93UG9zLFxuICAgICAgICAgICAgICAgIGFtcDtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIGFuZCBjbGFtcCB0aGUgZGVsYXkgbGluZSBsZW5ndGguXG4gICAgICAgICAgICBpZiAobS5kZWxheUR1ciAhPT0gZGVsYXlEdXIpIHtcbiAgICAgICAgICAgICAgICBtLmRlbGF5RHVyID0gZGVsYXlEdXI7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGVsYXlEdXIgPiBtYXhEZWxheUR1cikge1xuICAgICAgICAgICAgICAgICAgICBkZWxheUR1ciA9IG1heERlbGF5RHVyO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG0uZGVsYXlMZW5ndGggPSAoZGVsYXlEdXIgKiBtLnNhbXBsZVJhdGUpIHwgMDtcbiAgICAgICAgICAgICAgICBtLndyaXRlUG9zID0gbS53cml0ZVBvcyAlIG0uZGVsYXlMZW5ndGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgZ3JhaW4gZHVyYXRpb24uXG4gICAgICAgICAgICBpZiAobS5ncmFpbkR1ciAhPT0gZ3JhaW5EdXIpIHtcbiAgICAgICAgICAgICAgICBtLmdyYWluRHVyID0gZ3JhaW5EdXI7XG4gICAgICAgICAgICAgICAgbS5ncmFpbkxlbmd0aCA9IChtLnNhbXBsZVJhdGUgKiBtLmdyYWluRHVyKSB8IDA7XG4gICAgICAgICAgICAgICAgbS5lbnZTY2FsZSA9IGdyYWluRW52Lmxlbmd0aCAvIG0uZ3JhaW5MZW5ndGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRPRE86IFRoaXMgaW1wbGVtZW50YXRpb24gd2lsbCBjYXVzZSBjdXJyZW50bHktc291bmRpbmcgZ3JhaW5zXG4gICAgICAgICAgICAvLyB0byBiZSBzdG9wcGVkIGltbWVkaWF0ZWx5LCByYXRoZXIgdGhhbiBiZWluZyBhbGxvd2VkIHRvIGZpbmlzaC5cbiAgICAgICAgICAgIG51bUdyYWlucyA9IG51bUdyYWlucyA+IG8ubWF4TnVtR3JhaW5zID8gby5tYXhOdW1HcmFpbnMgOiBNYXRoLnJvdW5kKG51bUdyYWlucyk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1TYW1wczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gV3JpdGUgaW50byB0aGUgZGVsYXkgbGluZSBhbmQgdXBkYXRlIHRoZSB3cml0ZSBwb3NpdGlvbi5cbiAgICAgICAgICAgICAgICBkZWxheUxpbmVbbS53cml0ZVBvc10gPSBzb3VyY2VbaV07XG4gICAgICAgICAgICAgICAgbS53cml0ZVBvcyA9ICsrbS53cml0ZVBvcyAlIG0uZGVsYXlMZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAvLyBDbGVhciB0aGUgcHJldmlvdXMgb3V0cHV0LlxuICAgICAgICAgICAgICAgIHZhbCA9IDA7XG5cbiAgICAgICAgICAgICAgICAvLyBOb3cgZmlsbCB3aXRoIGdyYWluc1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBudW1HcmFpbnM7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBncmFpbklkeCA9IG0uZ3JhaW5JZHhbal07XG4gICAgICAgICAgICAgICAgICAgIGRlbGF5TGluZVJlYWRJZHggPSBtLmRlbGF5TGluZUlkeFtqXTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBSYW5kb21pemUgdGhlIHJlc2V0IHBvc2l0aW9uIG9mIGZpbmlzaGVkIGdyYWlucy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGdyYWluSWR4ID4gbS5ncmFpbkxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JhaW5JZHggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsYXlMaW5lUmVhZElkeCA9IChNYXRoLnJhbmRvbSgpICogbS5kZWxheUxlbmd0aCkgfCAwO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc2FtcCA9IGRlbGF5TGluZVtkZWxheUxpbmVSZWFkSWR4XTtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93UG9zID0gZ3JhaW5JZHggKiBtLmVudlNjYWxlO1xuICAgICAgICAgICAgICAgICAgICBhbXAgPSBmbG9jay5pbnRlcnBvbGF0ZS5saW5lYXIod2luZG93UG9zLCBncmFpbkVudik7XG4gICAgICAgICAgICAgICAgICAgIHZhbCArPSBzYW1wICogYW1wO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBwb3NpdGlvbnMgaW4gdGhlIGRlbGF5IGxpbmUgYW5kIGdyYWluIGVudmVsb3BlIGFycmF5cyBmb3IgbmV4dCB0aW1lLlxuICAgICAgICAgICAgICAgICAgICBtLmRlbGF5TGluZUlkeFtqXSA9ICsrZGVsYXlMaW5lUmVhZElkeCAlIG0uZGVsYXlMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIG0uZ3JhaW5JZHhbal0gPSArK2dyYWluSWR4O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhbCA9IHZhbCAvIG51bUdyYWlucztcbiAgICAgICAgICAgICAgICBvdXRbaV0gPSB2YWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG0udW5zY2FsZWRWYWx1ZSA9IHZhbDtcbiAgICAgICAgICAgIHRoYXQubXVsQWRkKG51bVNhbXBzKTtcbiAgICAgICAgICAgIG0udmFsdWUgPSBmbG9jay51Z2VuLmxhc3RPdXRwdXRWYWx1ZShudW1TYW1wcywgb3V0KTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0LmluaXRHcmFpbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbSA9IHRoYXQubW9kZWw7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhhdC5vcHRpb25zLm1heE51bUdyYWluczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbS5ncmFpbklkeFtpXSA9IDA7XG4gICAgICAgICAgICAgICAgbS5kZWxheUxpbmVJZHhbaV0gPSBNYXRoLnJhbmRvbSgpICogbS5kZWxheUxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0LmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbSA9IHRoYXQubW9kZWwsXG4gICAgICAgICAgICAgICAgbyA9IHRoYXQub3B0aW9ucyxcbiAgICAgICAgICAgICAgICBkZWxheUxpbmVMZW4gPSAoby5tYXhEZWxheUR1ciAqIG0uc2FtcGxlUmF0ZSkgfCAwO1xuXG4gICAgICAgICAgICB0aGF0LmRlbGF5TGluZSA9IG5ldyBGbG9hdDMyQXJyYXkoZGVsYXlMaW5lTGVuKTtcbiAgICAgICAgICAgIG0uZGVsYXlMZW5ndGggPSBkZWxheUxpbmVMZW47XG4gICAgICAgICAgICBtLmRlbGF5TGluZUlkeCA9IG5ldyBVaW50MzJBcnJheShvLm1heE51bUdyYWlucyk7XG4gICAgICAgICAgICBtLmdyYWluSWR4ID0gbmV3IFVpbnQzMkFycmF5KG8ubWF4TnVtR3JhaW5zKTtcblxuICAgICAgICAgICAgdGhhdC5pbml0R3JhaW5zKCk7XG4gICAgICAgICAgICB0aGF0Lm9uSW5wdXRDaGFuZ2VkKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5pbml0KCk7XG5cbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfTtcblxuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmxvY2sudWdlbi5ncmFudWxhdG9yXCIsIHtcbiAgICAgICAgcmF0ZTogXCJhdWRpb1wiLFxuXG4gICAgICAgIGlucHV0czoge1xuICAgICAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICAgICAgZ3JhaW5EdXI6IDAuMSxcbiAgICAgICAgICAgIGRlbGF5RHVyOiAxLFxuICAgICAgICAgICAgbnVtR3JhaW5zOiA1LFxuICAgICAgICAgICAgbXVsOiBudWxsLFxuICAgICAgICAgICAgYWRkOiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgdWdlbk9wdGlvbnM6IHtcbiAgICAgICAgICAgIG1heE51bUdyYWluczogNTEyLFxuICAgICAgICAgICAgbWF4RGVsYXlEdXI6IDMwLFxuICAgICAgICAgICAgZ3JhaW5FbnY6IGZsb2NrLmZpbGxUYWJsZSg4MTkyLCBmbG9jay50YWJsZUdlbmVyYXRvcnMuc2luV2luZG93KSxcbiAgICAgICAgICAgIG1vZGVsOiB7XG4gICAgICAgICAgICAgICAgdW5zY2FsZWRWYWx1ZTogMC4wLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAwLjAsXG4gICAgICAgICAgICAgICAgZ3JhaW5MZW5ndGg6IDAsXG4gICAgICAgICAgICAgICAgd3JpdGVQb3M6IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG5cbiAgICAvLyBUT0RPOiBVbml0IHRlc3RzLlxuICAgIGZsb2NrLnVnZW4ucHJpbnQgPSBmdW5jdGlvbiAoaW5wdXQsIG91dHB1dCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgdGhhdCA9IGZsb2NrLnVnZW4oaW5wdXQsIG91dHB1dCwgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhhdC5nZW4gPSBmdW5jdGlvbiAobnVtU2FtcHMpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dHMgPSB0aGF0LmlucHV0cyxcbiAgICAgICAgICAgICAgICBvdXQgPSB0aGF0Lm91dHB1dCxcbiAgICAgICAgICAgICAgICBtID0gdGhhdC5tb2RlbCxcbiAgICAgICAgICAgICAgICBsYWJlbCA9IG0ubGFiZWwsXG4gICAgICAgICAgICAgICAgY2hhbiA9IGlucHV0cy5jaGFubmVsLFxuICAgICAgICAgICAgICAgIC8vIEJhc2ljIG11bHRpY2hhbm5lbCBzdXBwb3J0LiBUaGlzIHNob3VsZCBiZSBpbnByb3ZlZFxuICAgICAgICAgICAgICAgIC8vIGJ5IGZhY3RvcmluZyB0aGUgbXVsdGljaGFubmVsIGlucHV0IGNvZGUgb3V0IG9mIGZsb2NrLnVnZW4ub3V0LlxuICAgICAgICAgICAgICAgIHNvdXJjZSA9IGNoYW4gPyBpbnB1dHMuc291cmNlLm91dHB1dFtjaGFuLm91dHB1dFswXV0gOiBpbnB1dHMuc291cmNlLm91dHB1dCxcbiAgICAgICAgICAgICAgICB0cmlnID0gaW5wdXRzLnRyaWdnZXIub3V0cHV0WzBdLFxuICAgICAgICAgICAgICAgIGZyZXEgPSBpbnB1dHMuZnJlcS5vdXRwdXRbMF0sXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICBqLFxuICAgICAgICAgICAgICAgIHZhbDtcblxuICAgICAgICAgICAgaWYgKHRyaWcgPiAwLjAgJiYgbS5wcmV2VHJpZyA8PSAwLjApIHtcbiAgICAgICAgICAgICAgICBmbHVpZC5sb2coZmx1aWQubG9nTGV2ZWwuSU1QT1JUQU5ULCBsYWJlbCArIHNvdXJjZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtLmZyZXEgIT09IGZyZXEpIHtcbiAgICAgICAgICAgICAgICBtLnNhbXBJbnRlcnZhbCA9IE1hdGgucm91bmQobS5zYW1wbGVSYXRlIC8gZnJlcSk7XG4gICAgICAgICAgICAgICAgbS5mcmVxID0gZnJlcTtcbiAgICAgICAgICAgICAgICBtLmNvdW50ZXIgPSBtLnNhbXBJbnRlcnZhbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMCwgaiA9IDAgOyBpIDwgbnVtU2FtcHM7IGkrKywgaiArPSBtLnN0cmlkZXMuc291cmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG0uY291bnRlciA+PSBtLnNhbXBJbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgICAgICBmbHVpZC5sb2coZmx1aWQubG9nTGV2ZWwuSU1QT1JUQU5ULCBsYWJlbCArIHNvdXJjZVtqXSk7XG4gICAgICAgICAgICAgICAgICAgIG0uY291bnRlciA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG0uY291bnRlcisrO1xuICAgICAgICAgICAgICAgIG91dFtpXSA9IHZhbCA9IHNvdXJjZVtpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbS52YWx1ZSA9IG0udW5zY2FsZWRWYWx1ZSA9IHZhbDtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0LmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbyA9IHRoYXQub3B0aW9ucztcbiAgICAgICAgICAgIHRoYXQubW9kZWwubGFiZWwgPSBvLmxhYmVsID8gby5sYWJlbCArIFwiOiBcIiA6IFwiXCI7XG4gICAgICAgICAgICB0aGF0Lm9uSW5wdXRDaGFuZ2VkKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5pbml0KCk7XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgIH07XG5cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsb2NrLnVnZW4ucHJpbnRcIiwge1xuICAgICAgICByYXRlOiBcImF1ZGlvXCIsXG4gICAgICAgIGlucHV0czoge1xuICAgICAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICAgICAgdHJpZ2dlcjogMC4wLFxuICAgICAgICAgICAgZnJlcTogMS4wXG4gICAgICAgIH0sXG4gICAgICAgIHVnZW5PcHRpb25zOiB7XG4gICAgICAgICAgICBtb2RlbDoge1xuICAgICAgICAgICAgICAgIHVuc2NhbGVkVmFsdWU6IDAuMCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogMC4wLFxuICAgICAgICAgICAgICAgIGNvdW50ZXI6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdHJpZGVJbnB1dHM6IFtcInNvdXJjZVwiXVxuICAgICAgICB9XG4gICAgfSk7XG5cblxuICAgIGZsb2NrLnVnZW4uc2VxdWVuY2UgPSBmdW5jdGlvbiAoaW5wdXRzLCBvdXRwdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHRoYXQgPSBmbG9jay51Z2VuKGlucHV0cywgb3V0cHV0LCBvcHRpb25zKTtcblxuICAgICAgICB0aGF0LmdlbiA9IGZ1bmN0aW9uIChudW1TYW1wcykge1xuICAgICAgICAgICAgdmFyIGxpc3QgPSB0aGF0LmlucHV0cy5saXN0LFxuICAgICAgICAgICAgICAgIGlucHV0cyA9IHRoYXQuaW5wdXRzLFxuICAgICAgICAgICAgICAgIGZyZXEgPSBpbnB1dHMuZnJlcS5vdXRwdXQsXG4gICAgICAgICAgICAgICAgbG9vcCA9IGlucHV0cy5sb29wLm91dHB1dFswXSxcbiAgICAgICAgICAgICAgICBtID0gdGhhdC5tb2RlbCxcbiAgICAgICAgICAgICAgICBzY2FsZSA9IG0uc2NhbGUsXG4gICAgICAgICAgICAgICAgb3V0ID0gdGhhdC5vdXRwdXQsXG4gICAgICAgICAgICAgICAgc3RhcnQgPSBpbnB1dHMuc3RhcnQgPyBNYXRoLnJvdW5kKGlucHV0cy5zdGFydC5vdXRwdXRbMF0pIDogMCxcbiAgICAgICAgICAgICAgICBlbmQgPSBpbnB1dHMuZW5kID8gTWF0aC5yb3VuZChpbnB1dHMuZW5kLm91dHB1dFswXSkgOiBsaXN0Lmxlbmd0aCxcbiAgICAgICAgICAgICAgICBzdGFydEl0ZW0sXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICBqO1xuXG4gICAgICAgICAgICBpZiAobS51bnNjYWxlZFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzdGFydEl0ZW0gPSBsaXN0W3N0YXJ0XTtcbiAgICAgICAgICAgICAgICBtLnVuc2NhbGVkVmFsdWUgPSAoc3RhcnRJdGVtID09PSB1bmRlZmluZWQpID8gMC4wIDogc3RhcnRJdGVtO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobS5uZXh0SWR4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtLm5leHRJZHggPSBzdGFydDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBudW1TYW1wczsgaSsrLCBqICs9IG0uc3RyaWRlcy5mcmVxKSB7XG4gICAgICAgICAgICAgICAgaWYgKG0ubmV4dElkeCA+PSBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvb3AgPiAwLjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG0ubmV4dElkeCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0W2ldID0gbS51bnNjYWxlZFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvdXRbaV0gPSBtLnVuc2NhbGVkVmFsdWUgPSBsaXN0W20ubmV4dElkeF07XG4gICAgICAgICAgICAgICAgbS5waGFzZSArPSBmcmVxW2pdICogc2NhbGU7XG5cbiAgICAgICAgICAgICAgICBpZiAobS5waGFzZSA+PSAxLjApIHtcbiAgICAgICAgICAgICAgICAgICAgbS5waGFzZSA9IDAuMDtcbiAgICAgICAgICAgICAgICAgICAgbS5uZXh0SWR4Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGF0Lm11bEFkZChudW1TYW1wcyk7XG4gICAgICAgICAgICBtLnZhbHVlID0gZmxvY2sudWdlbi5sYXN0T3V0cHV0VmFsdWUobnVtU2FtcHMsIG91dCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5vbklucHV0Q2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQubW9kZWwuc2NhbGUgPSB0aGF0LnJhdGUgIT09IGZsb2NrLnJhdGVzLkRFTUFORCA/IHRoYXQubW9kZWwuc2FtcGxlRHVyIDogMTtcblxuICAgICAgICAgICAgaWYgKCF0aGF0LmlucHV0cy5saXN0KSB7XG4gICAgICAgICAgICAgICAgdGhhdC5pbnB1dHMubGlzdCA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGF0LmNhbGN1bGF0ZVN0cmlkZXMoKTtcbiAgICAgICAgICAgIGZsb2NrLm9uTXVsQWRkSW5wdXRDaGFuZ2VkKHRoYXQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQub25JbnB1dENoYW5nZWQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0LmluaXQoKTtcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfTtcblxuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmxvY2sudWdlbi5zZXF1ZW5jZVwiLCB7XG4gICAgICAgIHJhdGU6IFwiY29udHJvbFwiLFxuXG4gICAgICAgIGlucHV0czoge1xuICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICBmcmVxOiAxLjAsXG4gICAgICAgICAgICBsb29wOiAwLjAsXG4gICAgICAgICAgICBsaXN0OiBbXVxuICAgICAgICB9LFxuXG4gICAgICAgIHVnZW5PcHRpb25zOiB7XG4gICAgICAgICAgICBtb2RlbDoge1xuICAgICAgICAgICAgICAgIHVuc2NhbGVkVmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogMC4wLFxuICAgICAgICAgICAgICAgIHBoYXNlOiAwXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzdHJpZGVJbnB1dHM6IFtcImZyZXFcIl1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZmxvY2sudWdlbi5taWRpRnJlcSA9IGZ1bmN0aW9uIChpbnB1dHMsIG91dHB1dCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgdGhhdCA9IGZsb2NrLnVnZW4oaW5wdXRzLCBvdXRwdXQsIG9wdGlvbnMpO1xuXG4gICAgICAgIHRoYXQuZ2VuID0gZnVuY3Rpb24gKG51bVNhbXBzKSB7XG4gICAgICAgICAgICB2YXIgbSA9IHRoYXQubW9kZWwsXG4gICAgICAgICAgICAgICAgYTQgPSBtLmE0LFxuICAgICAgICAgICAgICAgIGE0RnJlcSA9IGE0LmZyZXEsXG4gICAgICAgICAgICAgICAgYTROb3RlTnVtID0gYTQubm90ZU51bSxcbiAgICAgICAgICAgICAgICBub3Rlc1Blck9jdGF2ZSA9IG0ubm90ZXNQZXJPY3RhdmUsXG4gICAgICAgICAgICAgICAgbm90ZU51bSA9IHRoYXQuaW5wdXRzLnNvdXJjZS5vdXRwdXQsXG4gICAgICAgICAgICAgICAgb3V0ID0gdGhhdC5vdXRwdXQsXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICBqLFxuICAgICAgICAgICAgICAgIHZhbDtcblxuICAgICAgICAgICAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBudW1TYW1wczsgaSsrLCBqICs9IG0uc3RyaWRlcy5zb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBvdXRbaV0gPSB2YWwgPSBmbG9jay5taWRpRnJlcShub3RlTnVtW2pdLCBhNEZyZXEsIGE0Tm90ZU51bSwgbm90ZXNQZXJPY3RhdmUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtLnVuc2NhbGVkVmFsdWUgPSB2YWw7XG4gICAgICAgICAgICB0aGF0Lm11bEFkZChudW1TYW1wcyk7XG4gICAgICAgICAgICBtLnZhbHVlID0gZmxvY2sudWdlbi5sYXN0T3V0cHV0VmFsdWUobnVtU2FtcHMsIG91dCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5tb2RlbC5vY3RhdmVTY2FsZSA9IDEgLyB0aGF0Lm1vZGVsLm5vdGVzUGVyT2N0YXZlO1xuICAgICAgICAgICAgdGhhdC5vbklucHV0Q2hhbmdlZCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQuaW5pdCgpO1xuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICB9O1xuXG4gICAgZmx1aWQuZGVmYXVsdHMoXCJmbG9jay51Z2VuLm1pZGlGcmVxXCIsIHtcbiAgICAgICAgcmF0ZTogXCJjb250cm9sXCIsXG4gICAgICAgIGlucHV0czoge1xuICAgICAgICAgICAgc291cmNlOiBudWxsIC8vIFRPRE86IFRoaXMgaW5wdXQgc2hvdWxkIGJlIG5hbWVkIFwibm90ZVwiXG4gICAgICAgIH0sXG4gICAgICAgIHVnZW5PcHRpb25zOiB7XG4gICAgICAgICAgICBtb2RlbDoge1xuICAgICAgICAgICAgICAgIHVuc2NhbGVkVmFsdWU6IDAuMCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogMC4wLFxuICAgICAgICAgICAgICAgIGE0OiB7XG4gICAgICAgICAgICAgICAgICAgIG5vdGVOdW06IDY5LFxuICAgICAgICAgICAgICAgICAgICBmcmVxOiA0NDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG5vdGVzUGVyT2N0YXZlOiAxMlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0cmlkZUlucHV0czogW1xuICAgICAgICAgICAgICAgIFwic291cmNlXCJcbiAgICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgIH0pO1xufSgpKTtcbjsvKlxuKiBGbG9ja2luZyBCYW5kbGltaXRlZCBVR2Vuc1xuKiBodHRwOi8vZ2l0aHViLmNvbS9jb2xpbmJkY2xhcmsvZmxvY2tpbmdcbipcbiogQ29weXJpZ2h0IDIwMTUsIENvbGluIENsYXJrXG4qIER1YWwgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBhbmQgR1BMIFZlcnNpb24gMiBsaWNlbnNlcy5cbiovXG5cbi8qZ2xvYmFsIHJlcXVpcmUqL1xuLypqc2hpbnQgd2hpdGU6IGZhbHNlLCBuZXdjYXA6IHRydWUsIHJlZ2V4cDogdHJ1ZSwgYnJvd3NlcjogdHJ1ZSxcbiAgICBmb3JpbjogZmFsc2UsIG5vbWVuOiB0cnVlLCBiaXR3aXNlOiBmYWxzZSwgbWF4ZXJyOiAxMDAsXG4gICAgaW5kZW50OiA0LCBwbHVzcGx1czogZmFsc2UsIGN1cmx5OiB0cnVlLCBlcWVxZXE6IHRydWUsXG4gICAgZnJlZXplOiB0cnVlLCBsYXRlZGVmOiB0cnVlLCBub2FyZzogdHJ1ZSwgbm9uZXc6IHRydWUsIHF1b3RtYXJrOiBkb3VibGUsIHVuZGVmOiB0cnVlLFxuICAgIHVudXNlZDogdHJ1ZSwgc3RyaWN0OiB0cnVlLCBhc2k6IGZhbHNlLCBib3NzOiBmYWxzZSwgZXZpbDogZmFsc2UsIGV4cHI6IGZhbHNlLFxuICAgIGZ1bmNzY29wZTogZmFsc2UqL1xuXG52YXIgZmx1aWQgPSBmbHVpZCB8fCByZXF1aXJlKFwiaW5mdXNpb25cIiksXG4gICAgZmxvY2sgPSBmbHVpZC5yZWdpc3Rlck5hbWVzcGFjZShcImZsb2NrXCIpO1xuXG4oZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZmxvY2suYmxpdCA9IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciB2YWwsXG4gICAgICAgICAgICB0O1xuXG4gICAgICAgIGlmIChwID49IDIuMCkge1xuICAgICAgICAgICAgdmFsID0gMC4wO1xuICAgICAgICB9IGVsc2UgaWYgKHAgPj0gMS4wKSB7XG4gICAgICAgICAgICB0ID0gMi4wIC0gcDtcbiAgICAgICAgICAgIHZhbCA9IDAuMTY2NjY2NjY2NjY2NjY2NjYgKiB0ICogdCAqIHQ7XG4gICAgICAgIH0gZWxzZSBpZiAocCA+PSAwLjApIHtcbiAgICAgICAgICAgIHQgPSBwICogcDtcbiAgICAgICAgICAgIHZhbCA9ICgwLjY2NjY2NjY2NjY2NjY2NjYgLSB0KSArICgwLjUgKiB0ICogcCk7XG4gICAgICAgIH0gZWxzZSBpZiAocCA+PSAtMS4wKSB7XG4gICAgICAgICAgICB0ID0gcCAqIHA7XG4gICAgICAgICAgICB2YWwgPSAoMC42NjY2NjY2NjY2NjY2NjY2IC0gdCkgLSAoMC41ICogdCAqIHApO1xuICAgICAgICB9IGVsc2UgaWYgKHAgPj0gLTIuMCkge1xuICAgICAgICAgICAgdCA9IDIgKyBwO1xuICAgICAgICAgICAgdmFsID0gMC4xNjY2NjY2NjY2NjY2NjY2NiAqIHQgKiB0ICogdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbCA9IDAuMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcblxuICAgIGZsb2NrLmJsaXQucGVyaW9kID0gZnVuY3Rpb24gKHNhbXBsZVJhdGUsIGZyZXEpIHtcbiAgICAgICAgdmFyIGQwID0gc2FtcGxlUmF0ZSAvIGZyZXE7XG4gICAgICAgIHJldHVybiBkMCA8IDEuMCA/IDEuMCA6IGQwO1xuICAgIH07XG5cbiAgICBmbG9jay5ibGl0LnVwZGF0ZVBlcmlvZFN0YXRlID0gZnVuY3Rpb24gKG0sIGZyZXEpIHtcbiAgICAgICAgbS5mcmVxID0gZnJlcSA8IDAuMDAwMDAxID8gMC4wMDAwMDEgOiBmcmVxO1xuICAgICAgICBtLmQwID0gZmxvY2suYmxpdC5wZXJpb2QobS5zYW1wbGVSYXRlLCBtLmZyZXEpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBIGJhbmQtbGltaXRlZCBpbXB1bHNlIHRyYWluLlxuICAgICAqXG4gICAgICogVGhpcyB1bml0IGdlbmVyYXRvciBpcyBiYXNlZCBvbiB0aGUgQkxJVC1GREYgbWV0aG9kIGRvY3VtZW50ZWQgaW46XG4gICAgICogXCJFZmZpY2llbnQgQW50aWFsaWFzaW5nIE9zY2lsbGF0b3IgQWxnb3JpdGhtcyBVc2luZyBMb3ctT3JkZXIgRnJhY3Rpb25hbCBEZWxheSBGaWx0ZXJzXCJcbiAgICAgKiBKdWhhbiBOYW0sIFZlc2EgVmFsaW1ha2ksIEpvbmF0aGFuIFMuIEFibGUsIGFuZCBKdWxpdXMgTy4gU21pdGhcbiAgICAgKiBpbiBJRUVFIFRyYW5zYWN0aW9ucyBvbiBBdWRpbywgU3BlZWNoLCBhbmQgTGFuZ3VhZ2UgUHJvY2Vzc2luZywgVm9sLiAxOCwgTm8uIDQsIE1heSAyMDEwLlxuICAgICAqXG4gICAgICogSW5wdXRzOlxuICAgICAqICAtIGZyZXE6IHRoZSBmcmVxdWVuY3kgb2YgdGhlIGltcHVsc2UgdHJhaW47XG4gICAgICogICAgICAgICAgdGhpcyBjYW4gb25seSBiZSBtb2R1bGF0ZWQgZXZlcnkgcGVyaW9kLFxuICAgICAqICAgICAgICAgIHNvIHRoZXJlIG1heSBiZSBhIGRlbGF5IGJlZm9yZSB0aGUgZnJlcXVlbmN5IGlzIHVwZGF0ZWQgYXQgbG93IGZyZXF1ZW5jaWVzXG4gICAgICogIC0gbXVsOiB0aGUgYW1wbGl0dWRlIG9mIHRoZSBpbXB1bHNlc1xuICAgICAqICAtIGFkZDogdGhlIGFtcGxpdHVkZSBvZmZzZXQgb2YgdGhlIGltcHVsc2VzXG4gICAgICovXG4gICAgZmxvY2sudWdlbi5ibGl0ID0gZnVuY3Rpb24gKGlucHV0cywgb3V0cHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB0aGF0ID0gZmxvY2sudWdlbihpbnB1dHMsIG91dHB1dCwgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhhdC5nZW4gPSBmdW5jdGlvbiAobnVtU2FtcHMpIHtcbiAgICAgICAgICAgIHZhciBtID0gdGhhdC5tb2RlbCxcbiAgICAgICAgICAgICAgICBvdXQgPSB0aGF0Lm91dHB1dCxcbiAgICAgICAgICAgICAgICBmcmVxID0gdGhhdC5pbnB1dHMuZnJlcS5vdXRwdXRbMF0sXG4gICAgICAgICAgICAgICAgcCA9IG0ucGhhc2UsXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICB2YWw7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1TYW1wczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcCAtPSAxLjA7XG4gICAgICAgICAgICAgICAgaWYgKHAgPCAtMi4wKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlJ3ZlIGhpdCB0aGUgZW5kIG9mIHRoZSBwZXJpb2QuXG4gICAgICAgICAgICAgICAgICAgIGZsb2NrLmJsaXQudXBkYXRlUGVyaW9kU3RhdGUobSwgZnJlcSk7XG4gICAgICAgICAgICAgICAgICAgIHAgKz0gbS5kMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YWwgPSBmbG9jay5ibGl0KHApO1xuICAgICAgICAgICAgICAgIG91dFtpXSA9IHZhbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbS5waGFzZSA9IHA7XG4gICAgICAgICAgICBtLnVuc2NhbGVkVmFsdWUgPSB2YWw7XG4gICAgICAgICAgICB0aGF0Lm11bEFkZChudW1TYW1wcyk7XG4gICAgICAgICAgICBtLnZhbHVlID0gZmxvY2sudWdlbi5sYXN0T3V0cHV0VmFsdWUobnVtU2FtcHMsIG91dCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5vbklucHV0Q2hhbmdlZCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQuaW5pdCgpO1xuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICB9O1xuXG4gICAgZmx1aWQuZGVmYXVsdHMoXCJmbG9jay51Z2VuLmJsaXRcIiwge1xuICAgICAgICByYXRlOiBcImF1ZGlvXCIsXG5cbiAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICBmcmVxOiA0NDAuMCxcbiAgICAgICAgICAgIG11bDogbnVsbCxcbiAgICAgICAgICAgIGFkZDogbnVsbFxuICAgICAgICB9LFxuXG4gICAgICAgIHVnZW5PcHRpb25zOiB7XG4gICAgICAgICAgICBtb2RlbDoge1xuICAgICAgICAgICAgICAgIHBoYXNlOiAtMi4wLFxuICAgICAgICAgICAgICAgIHVuc2NhbGVkVmFsdWU6IDAuMCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogMC4wXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIGJhbmQtbGltaXRlZCBzYXd0b290aCB3YXZlZnJvbS5cbiAgICAgKlxuICAgICAqIFRoaXMgdW5pdCBnZW5lcmF0b3IgaXMgYmFzZWQgb24gdGhlIEJMSVQtRkRGIG1ldGhvZCBkb2N1bWVudGVkIGluOlxuICAgICAqIFwiRWZmaWNpZW50IEFudGlhbGlhc2luZyBPc2NpbGxhdG9yIEFsZ29yaXRobXMgVXNpbmcgTG93LU9yZGVyIEZyYWN0aW9uYWwgRGVsYXkgRmlsdGVyc1wiXG4gICAgICogSnVoYW4gTmFtLCBWZXNhIFZhbGltYWtpLCBKb25hdGhhbiBTLiBBYmxlLCBhbmQgSnVsaXVzIE8uIFNtaXRoXG4gICAgICogaW4gSUVFRSBUcmFuc2FjdGlvbnMgb24gQXVkaW8sIFNwZWVjaCwgYW5kIExhbmd1YWdlIFByb2Nlc3NpbmcsIFZvbC4gMTgsIE5vLiA0LCBNYXkgMjAxMC5cbiAgICAgKlxuICAgICAqIFRoaXMgdW5pdCBnZW5lcmF0b3IgaXMgYmFzZWQgb24gYW4gYWxnb3JpdGhtIHRoYXQgaW50ZWdyYXRlcyBiYW5kbGltaXRlZCBpbXB1bHNlIHRyYWlucyxcbiAgICAgKiBhbmQgYXMgYSByZXN1bHQgY2FuIG9ubHkgY2hhbmdlIGZyZXF1ZW5jaWVzIGF0IHRoZSBlbmQgb2YgZWFjaCB3YXZlZm9ybSBwZXJpb2QuXG4gICAgICpcbiAgICAgKiBJbnB1dHM6XG4gICAgICogIC0gZnJlcTogdGhlIGZyZXF1ZW5jeSBvZiB0aGUgc2F3O1xuICAgICAqICAgICAgICAgIHRoaXMgY2FuIG9ubHkgYmUgbW9kdWxhdGVkIGV2ZXJ5IHBlcmlvZCxcbiAgICAgKiAgICAgICAgICBzbyB0aGVyZSBtYXkgYmUgYSBkZWxheSBiZWZvcmUgdGhlIGZyZXF1ZW5jeSBpcyB1cGRhdGVkIGF0IGxvdyBmcmVxdWVuY2llc1xuICAgICAqICAtIGxlYWtSYXRlOiB0aGUgbGVhayByYXRlIG9mIHRoZSBsZWFreSBpbnRlZ3JhdG9yIChiZXR3ZWVuID4wLjAgYW5kIDEuMClcbiAgICAgKiAgLSBtdWw6IHRoZSBhbXBsaXR1ZGUgb2YgdGhlIGltcHVsc2VzXG4gICAgICogIC0gYWRkOiB0aGUgYW1wbGl0dWRlIG9mZnNldCBvZiB0aGUgaW1wdWxzZXNcbiAgICAgKi9cbiAgICBmbG9jay51Z2VuLnNhdyA9IGZ1bmN0aW9uIChpbnB1dHMsIG91dHB1dCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgdGhhdCA9IGZsb2NrLnVnZW4oaW5wdXRzLCBvdXRwdXQsIG9wdGlvbnMpO1xuXG4gICAgICAgIHRoYXQuZ2VuID0gZnVuY3Rpb24gKG51bVNhbXBzKSB7XG4gICAgICAgICAgICB2YXIgbSA9IHRoYXQubW9kZWwsXG4gICAgICAgICAgICAgICAgb3V0ID0gdGhhdC5vdXRwdXQsXG4gICAgICAgICAgICAgICAgZnJlcSA9IHRoYXQuaW5wdXRzLmZyZXEub3V0cHV0WzBdLFxuICAgICAgICAgICAgICAgIGxlYWsgPSAxLjAgLSB0aGF0LmlucHV0cy5sZWFrUmF0ZS5vdXRwdXRbMF0sXG4gICAgICAgICAgICAgICAgcCA9IG0ucGhhc2UsXG4gICAgICAgICAgICAgICAgdW5zY2FsZWRWYWx1ZSA9IG0udW5zY2FsZWRWYWx1ZSxcbiAgICAgICAgICAgICAgICBpO1xuXG4gICAgICAgICAgICAvLyBUT0RPOiBUaGlzIGNhbiBiZSBtb3ZlZCB0byBpbml0KCkgd2hlblxuICAgICAgICAgICAgLy8gd2UgaGF2ZSB1Z2VuIGdyYXBoIHByaW1pbmcgaW1wbGVtZW50ZWQuXG4gICAgICAgICAgICBpZiAocCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZmxvY2sudWdlbi5zYXcudXBkYXRlUGVyaW9kU3RhdGUobSwgZnJlcSk7XG4gICAgICAgICAgICAgICAgcCA9IG0uZDAgLyAyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtU2FtcHM7IGkrKykge1xuICAgICAgICAgICAgICAgIHAgLT0gMS4wO1xuICAgICAgICAgICAgICAgIGlmIChwIDwgLTIuMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSd2ZSBoaXQgdGhlIGVuZCBvZiB0aGUgcGVyaW9kLlxuICAgICAgICAgICAgICAgICAgICBmbG9jay51Z2VuLnNhdy51cGRhdGVQZXJpb2RTdGF0ZShtLCBmcmVxKTtcbiAgICAgICAgICAgICAgICAgICAgcCArPSBtLmQwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFNhdyBpcyBCTElUIC0gZGNPZmZzZXQgKyAoMSAtIGxlYWtSYXRlKSAqIHByZXZWYWxcbiAgICAgICAgICAgICAgICBvdXRbaV0gPSB1bnNjYWxlZFZhbHVlID0gZmxvY2suYmxpdChwKSAtIG0uZGNPZmZzZXQgKyBsZWFrICogdW5zY2FsZWRWYWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbS5waGFzZSA9IHA7XG4gICAgICAgICAgICBtLnVuc2NhbGVkVmFsdWUgPSB1bnNjYWxlZFZhbHVlO1xuICAgICAgICAgICAgdGhhdC5tdWxBZGQobnVtU2FtcHMpO1xuICAgICAgICAgICAgbS52YWx1ZSA9IGZsb2NrLnVnZW4ubGFzdE91dHB1dFZhbHVlKG51bVNhbXBzLCBvdXQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQub25JbnB1dENoYW5nZWQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0LmluaXQoKTtcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfTtcblxuICAgIGZsb2NrLnVnZW4uc2F3LnVwZGF0ZVBlcmlvZFN0YXRlID0gZnVuY3Rpb24gKG0sIGZyZXEpIHtcbiAgICAgICAgZmxvY2suYmxpdC51cGRhdGVQZXJpb2RTdGF0ZShtLCBmcmVxKTtcbiAgICAgICAgbS5kY09mZnNldCA9IDEuMCAvIG0uZDA7IC8vIERDIG9mZnNldCBhdCBzdGVhZHkgc3RhdGUgaXMgMSAvIGQwLlxuICAgIH07XG5cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsb2NrLnVnZW4uc2F3XCIsIHtcbiAgICAgICAgcmF0ZTogXCJhdWRpb1wiLFxuXG4gICAgICAgIGlucHV0czoge1xuICAgICAgICAgICAgZnJlcTogNDQwLjAsXG4gICAgICAgICAgICBsZWFrUmF0ZTogMC4wMSxcbiAgICAgICAgICAgIG11bDogbnVsbCxcbiAgICAgICAgICAgIGFkZDogbnVsbFxuICAgICAgICB9LFxuXG4gICAgICAgIHVnZW5PcHRpb25zOiB7XG4gICAgICAgICAgICBtb2RlbDoge1xuICAgICAgICAgICAgICAgIHBoYXNlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgZGNPZmZzZXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB1bnNjYWxlZFZhbHVlOiAwLjAsXG4gICAgICAgICAgICAgICAgdmFsdWU6IDAuMFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBiYW5kLWxpbWl0ZWQgc3F1YXJlIHdhdmUuXG4gICAgICpcbiAgICAgKiBUaGlzIHVuaXQgZ2VuZXJhdG9yIGlzIGJhc2VkIG9uIHRoZSBCTElULUZERiBtZXRob2QgZG9jdW1lbnRlZCBpbjpcbiAgICAgKiBcIkVmZmljaWVudCBBbnRpYWxpYXNpbmcgT3NjaWxsYXRvciBBbGdvcml0aG1zIFVzaW5nIExvdy1PcmRlciBGcmFjdGlvbmFsIERlbGF5IEZpbHRlcnNcIlxuICAgICAqIEp1aGFuIE5hbSwgVmVzYSBWYWxpbWFraSwgSm9uYXRoYW4gUy4gQWJsZSwgYW5kIEp1bGl1cyBPLiBTbWl0aFxuICAgICAqIGluIElFRUUgVHJhbnNhY3Rpb25zIG9uIEF1ZGlvLCBTcGVlY2gsIGFuZCBMYW5ndWFnZSBQcm9jZXNzaW5nLCBWb2wuIDE4LCBOby4gNCwgTWF5IDIwMTAuXG4gICAgICpcbiAgICAgKiBUaGlzIHVuaXQgZ2VuZXJhdG9yIGlzIGJhc2VkIG9uIGFuIGFsZ29yaXRobSB0aGF0IGludGVncmF0ZXMgYmFuZGxpbWl0ZWQgaW1wdWxzZSB0cmFpbnMsXG4gICAgICogYW5kIGFzIGEgcmVzdWx0IGNhbiBvbmx5IGNoYW5nZSBmcmVxdWVuY2llcyBhdCB0aGUgZW5kIG9mIGVhY2ggd2F2ZWZvcm0gcGVyaW9kLlxuICAgICAqXG4gICAgICogSW5wdXRzOlxuICAgICAqICAtIGZyZXE6IHRoZSBmcmVxdWVuY3kgb2YgdGhlIHNxdWFyZTtcbiAgICAgKiAgICAgICAgICB0aGlzIGNhbiBvbmx5IGJlIG1vZHVsYXRlZCBldmVyeSBwZXJpb2QsXG4gICAgICogICAgICAgICAgc28gdGhlcmUgbWF5IGJlIGEgZGVsYXkgYmVmb3JlIHRoZSBmcmVxdWVuY3kgaXMgdXBkYXRlZCBhdCBsb3cgZnJlcXVlbmNpZXNcbiAgICAgKiAgLSBsZWFrUmF0ZTogdGhlIGxlYWsgcmF0ZSBvZiB0aGUgbGVha3kgaW50ZWdyYXRvciAoYmV0d2VlbiA+MC4wIGFuZCAxLjApXG4gICAgICogIC0gbXVsOiB0aGUgYW1wbGl0dWRlIG9mIHRoZSBpbXB1bHNlc1xuICAgICAqICAtIGFkZDogdGhlIGFtcGxpdHVkZSBvZmZzZXQgb2YgdGhlIGltcHVsc2VzXG4gICAgICovXG4gICAgZmxvY2sudWdlbi5zcXVhcmUgPSBmdW5jdGlvbiAoaW5wdXRzLCBvdXRwdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHRoYXQgPSBmbG9jay51Z2VuKGlucHV0cywgb3V0cHV0LCBvcHRpb25zKTtcblxuICAgICAgICB0aGF0LmdlbiA9IGZ1bmN0aW9uIChudW1TYW1wcykge1xuICAgICAgICAgICAgdmFyIG0gPSB0aGF0Lm1vZGVsLFxuICAgICAgICAgICAgICAgIG91dCA9IHRoYXQub3V0cHV0LFxuICAgICAgICAgICAgICAgIGZyZXEgPSB0aGF0LmlucHV0cy5mcmVxLm91dHB1dFswXSxcbiAgICAgICAgICAgICAgICBsZWFrID0gMS4wIC0gdGhhdC5pbnB1dHMubGVha1JhdGUub3V0cHV0WzBdLFxuICAgICAgICAgICAgICAgIHAgPSBtLnBoYXNlLFxuICAgICAgICAgICAgICAgIHVuc2NhbGVkVmFsdWUgPSBtLnVuc2NhbGVkVmFsdWUsXG4gICAgICAgICAgICAgICAgaTtcblxuICAgICAgICAgICAgLy8gVE9ETzogVGhpcyBjYW4gYmUgbW92ZWQgdG8gaW5pdCgpIHdoZW5cbiAgICAgICAgICAgIC8vIHdlIGhhdmUgdWdlbiBncmFwaCBwcmltaW5nIGltcGxlbWVudGVkLlxuICAgICAgICAgICAgaWYgKHAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGZsb2NrLnVnZW4uc3F1YXJlLnVwZGF0ZVBlcmlvZFN0YXRlKG0sIGZyZXEpO1xuICAgICAgICAgICAgICAgIHAgPSBtLnBoYXNlUmVzZXRWYWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bVNhbXBzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvdXRbaV0gPSB1bnNjYWxlZFZhbHVlID0gKGZsb2NrLmJsaXQocCkgKiBtLnNpZ24pICsgbGVhayAqIHVuc2NhbGVkVmFsdWU7XG5cbiAgICAgICAgICAgICAgICBpZiAocCA8IC0yLjApIHtcbiAgICAgICAgICAgICAgICAgICAgZmxvY2sudWdlbi5zcXVhcmUudXBkYXRlUGVyaW9kU3RhdGUobSwgZnJlcSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlJ3ZlIGhpdCB0aGUgZW5kIG9mIHRoZSBwZXJpb2QuXG4gICAgICAgICAgICAgICAgICAgIHAgKz0gbS5waGFzZVJlc2V0VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcCAtPSAxLjA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG0ucGhhc2UgPSBwO1xuICAgICAgICAgICAgbS51bnNjYWxlZFZhbHVlID0gdW5zY2FsZWRWYWx1ZTtcbiAgICAgICAgICAgIHRoYXQubXVsQWRkKG51bVNhbXBzKTtcbiAgICAgICAgICAgIG0udmFsdWUgPSBmbG9jay51Z2VuLmxhc3RPdXRwdXRWYWx1ZShudW1TYW1wcywgb3V0KTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0LmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0Lm9uSW5wdXRDaGFuZ2VkKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5pbml0KCk7XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgIH07XG5cbiAgICBmbG9jay51Z2VuLnNxdWFyZS51cGRhdGVQZXJpb2RTdGF0ZSA9IGZ1bmN0aW9uIChtLCBmcmVxKSB7XG4gICAgICAgIGZsb2NrLmJsaXQudXBkYXRlUGVyaW9kU3RhdGUobSwgZnJlcSk7XG4gICAgICAgIG0ucGhhc2VSZXNldFZhbHVlID0gbS5kMCAvIDI7XG4gICAgICAgIC8vIEZsaXAgdGhlIHNpZ24gb2YgdGhlIG91dHB1dC5cbiAgICAgICAgbS5zaWduICo9IC0xLjA7XG4gICAgfTtcblxuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmxvY2sudWdlbi5zcXVhcmVcIiwge1xuICAgICAgICByYXRlOiBcImF1ZGlvXCIsXG5cbiAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICBmcmVxOiA0NDAuMCxcbiAgICAgICAgICAgIGxlYWtSYXRlOiAwLjAxLFxuICAgICAgICAgICAgbXVsOiBudWxsLFxuICAgICAgICAgICAgYWRkOiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgdWdlbk9wdGlvbnM6IHtcbiAgICAgICAgICAgIG1vZGVsOiB7XG4gICAgICAgICAgICAgICAgcGhhc2U6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB1bnNjYWxlZFZhbHVlOiAwLjUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IDAuNSxcbiAgICAgICAgICAgICAgICBzaWduOiAxLjBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBiYW5kLWxpbWl0ZWQgdHJpYW5nbGUgd2F2ZS5cbiAgICAgKlxuICAgICAqIFRoaXMgdW5pdCBnZW5lcmF0b3IgaXMgYmFzZWQgb24gdGhlIEJMSVQtRkRGIG1ldGhvZCBkb2N1bWVudGVkIGluOlxuICAgICAqIFwiRWZmaWNpZW50IEFudGlhbGlhc2luZyBPc2NpbGxhdG9yIEFsZ29yaXRobXMgVXNpbmcgTG93LU9yZGVyIEZyYWN0aW9uYWwgRGVsYXkgRmlsdGVyc1wiXG4gICAgICogSnVoYW4gTmFtLCBWZXNhIFZhbGltYWtpLCBKb25hdGhhbiBTLiBBYmxlLCBhbmQgSnVsaXVzIE8uIFNtaXRoXG4gICAgICogaW4gSUVFRSBUcmFuc2FjdGlvbnMgb24gQXVkaW8sIFNwZWVjaCwgYW5kIExhbmd1YWdlIFByb2Nlc3NpbmcsIFZvbC4gMTgsIE5vLiA0LCBNYXkgMjAxMC5cbiAgICAgKlxuICAgICAqIFRoaXMgdW5pdCBnZW5lcmF0b3IgaXMgYmFzZWQgb24gYW4gYWxnb3JpdGhtIHRoYXQgaW50ZWdyYXRlcyBiYW5kbGltaXRlZCBpbXB1bHNlIHRyYWlucyxcbiAgICAgKiBhbmQgYXMgYSByZXN1bHQgY2FuIG9ubHkgY2hhbmdlIGZyZXF1ZW5jaWVzIGF0IHRoZSBlbmQgb2YgZWFjaCB3YXZlZm9ybSBwZXJpb2QuXG4gICAgICpcbiAgICAgKiBJdCB3aWxsIG5vdGljZWFibHkgZGlzdG9ydCBhdCBmcmVxdWVuY2llcyBhYm92ZSA2MDAwIEh6IHVubGVzcyB5b3UgYWRqdXN0IHRoZVxuICAgICAqIGxlYWtSYXRlIGFjY29yZGluZ2x5LlxuICAgICAqXG4gICAgICogSW5wdXRzOlxuICAgICAqICAtIGZyZXE6IHRoZSBmcmVxdWVuY3kgb2YgdGhlIHNxdWFyZTtcbiAgICAgKiAgICAgICAgICB0aGlzIGNhbiBvbmx5IGJlIG1vZHVsYXRlZCBldmVyeSBwZXJpb2QsXG4gICAgICogICAgICAgICAgc28gdGhlcmUgbWF5IGJlIGEgZGVsYXkgYmVmb3JlIHRoZSBmcmVxdWVuY3kgaXMgdXBkYXRlZCBhdCBsb3cgZnJlcXVlbmNpZXNcbiAgICAgKiAgLSBsZWFrUmF0ZTogdGhlIGxlYWsgcmF0ZSBvZiB0aGUgbGVha3kgaW50ZWdyYXRvciAoYmV0d2VlbiA+MC4wIGFuZCAxLjApXG4gICAgICogIC0gbXVsOiB0aGUgYW1wbGl0dWRlIG9mIHRoZSBpbXB1bHNlc1xuICAgICAqICAtIGFkZDogdGhlIGFtcGxpdHVkZSBvZmZzZXQgb2YgdGhlIGltcHVsc2VzXG4gICAgICovXG4gICAgZmxvY2sudWdlbi50cmkgPSBmdW5jdGlvbiAoaW5wdXRzLCBvdXRwdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHRoYXQgPSBmbG9jay51Z2VuKGlucHV0cywgb3V0cHV0LCBvcHRpb25zKTtcblxuICAgICAgICB0aGF0LmdlbiA9IGZ1bmN0aW9uIChudW1TYW1wcykge1xuICAgICAgICAgICAgdmFyIG0gPSB0aGF0Lm1vZGVsLFxuICAgICAgICAgICAgICAgIG91dCA9IHRoYXQub3V0cHV0LFxuICAgICAgICAgICAgICAgIGZyZXEgPSB0aGF0LmlucHV0cy5mcmVxLm91dHB1dFswXSxcbiAgICAgICAgICAgICAgICBsZWFrID0gMS4wIC0gdGhhdC5pbnB1dHMubGVha1JhdGUub3V0cHV0WzBdLFxuICAgICAgICAgICAgICAgIHAgPSBtLnBoYXNlLFxuICAgICAgICAgICAgICAgIHVuc2NhbGVkVmFsdWUgPSBtLnVuc2NhbGVkVmFsdWUsXG4gICAgICAgICAgICAgICAgc2Vjb25kUHJldlZhbCA9IG0uc2Vjb25kUHJldlZhbCxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIGZpcnN0SW50ZWdyYXRlLFxuICAgICAgICAgICAgICAgIHNlY29uZEludGVncmF0ZTtcblxuICAgICAgICAgICAgLy8gVE9ETzogVGhpcyBjYW4gYmUgbW92ZWQgdG8gaW5pdCgpIHdoZW5cbiAgICAgICAgICAgIC8vIHdlIGhhdmUgdWdlbiBncmFwaCBwcmltaW5nIGltcGxlbWVudGVkLlxuICAgICAgICAgICAgaWYgKHAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGZsb2NrLnVnZW4udHJpLnVwZGF0ZVBlcmlvZFN0YXRlKG0sIGZyZXEpO1xuICAgICAgICAgICAgICAgIHAgPSBtLmQwIC8gNDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bVNhbXBzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmaXJzdEludGVncmF0ZSA9IChmbG9jay5ibGl0KHApICogbS5zaWduKSArIGxlYWsgKiB1bnNjYWxlZFZhbHVlO1xuICAgICAgICAgICAgICAgIHVuc2NhbGVkVmFsdWUgPSBmaXJzdEludGVncmF0ZTtcbiAgICAgICAgICAgICAgICBzZWNvbmRJbnRlZ3JhdGUgPSBmaXJzdEludGVncmF0ZSArIGxlYWsgKiBzZWNvbmRQcmV2VmFsO1xuICAgICAgICAgICAgICAgIHNlY29uZFByZXZWYWwgPSBzZWNvbmRJbnRlZ3JhdGU7XG4gICAgICAgICAgICAgICAgb3V0W2ldID0gc2Vjb25kSW50ZWdyYXRlICogbS5hbXBTY2FsZTtcblxuICAgICAgICAgICAgICAgIHAgLT0gMS4wO1xuICAgICAgICAgICAgICAgIGlmIChwIDwgLTIuMCkge1xuICAgICAgICAgICAgICAgICAgICBmbG9jay51Z2VuLnRyaS51cGRhdGVQZXJpb2RTdGF0ZShtLCBmcmVxKTtcbiAgICAgICAgICAgICAgICAgICAgcCArPSBtLnBoYXNlUmVzZXRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG0ucGhhc2UgPSBwO1xuICAgICAgICAgICAgbS51bnNjYWxlZFZhbHVlID0gdW5zY2FsZWRWYWx1ZTtcbiAgICAgICAgICAgIG0uc2Vjb25kUHJldlZhbCA9IHNlY29uZFByZXZWYWw7XG4gICAgICAgICAgICB0aGF0Lm11bEFkZChudW1TYW1wcyk7XG4gICAgICAgICAgICBtLnZhbHVlID0gZmxvY2sudWdlbi5sYXN0T3V0cHV0VmFsdWUobnVtU2FtcHMsIG91dCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5vbklucHV0Q2hhbmdlZCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQuaW5pdCgpO1xuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICB9O1xuXG4gICAgZmxvY2sudWdlbi50cmkudXBkYXRlUGVyaW9kU3RhdGUgPSBmdW5jdGlvbiAobSwgZnJlcSkge1xuICAgICAgICBmbG9jay5ibGl0LnVwZGF0ZVBlcmlvZFN0YXRlKG0sIGZyZXEpO1xuICAgICAgICBtLnBoYXNlUmVzZXRWYWx1ZSA9IG0uZDAgLyAyO1xuICAgICAgICBtLmFtcFNjYWxlID0gMiAvIG0uZDA7XG4gICAgICAgIC8vIEZsaXAgdGhlIHNpZ24gb2YgdGhlIG91dHB1dC5cbiAgICAgICAgbS5zaWduICo9IC0xLjA7XG4gICAgfTtcblxuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmxvY2sudWdlbi50cmlcIiwge1xuICAgICAgICByYXRlOiBcImF1ZGlvXCIsXG5cbiAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICBmcmVxOiA0NDAuMCxcbiAgICAgICAgICAgIGxlYWtSYXRlOiAwLjAxLFxuICAgICAgICAgICAgbXVsOiBudWxsLFxuICAgICAgICAgICAgYWRkOiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgdWdlbk9wdGlvbnM6IHtcbiAgICAgICAgICAgIG1vZGVsOiB7XG4gICAgICAgICAgICAgICAgcGhhc2U6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogMC41LFxuICAgICAgICAgICAgICAgIHVuc2NhbGVkVmFsdWU6IDAuNSxcbiAgICAgICAgICAgICAgICBzZWNvbmRQcmV2VmFsOiAwLjAsXG4gICAgICAgICAgICAgICAgc2lnbjogMS4wLFxuICAgICAgICAgICAgICAgIGFtcFNjYWxlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgcGhhc2VSZXNldFZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufSgpKTtcbjsvKlxuKiBGbG9ja2luZyBFbnZlbG9wZXNcbiogaHR0cDovL2dpdGh1Yi5jb20vY29saW5iZGNsYXJrL2Zsb2NraW5nXG4qXG4qIENvcHlyaWdodCAyMDExLTIwMTQsIENvbGluIENsYXJrXG4qIER1YWwgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBhbmQgR1BMIFZlcnNpb24gMiBsaWNlbnNlcy5cbiovXG5cbi8qZ2xvYmFsIHJlcXVpcmUsIERTUCovXG4vKmpzaGludCB3aGl0ZTogZmFsc2UsIG5ld2NhcDogdHJ1ZSwgcmVnZXhwOiB0cnVlLCBicm93c2VyOiB0cnVlLFxuICAgIGZvcmluOiBmYWxzZSwgbm9tZW46IHRydWUsIGJpdHdpc2U6IGZhbHNlLCBtYXhlcnI6IDEwMCxcbiAgICBpbmRlbnQ6IDQsIHBsdXNwbHVzOiBmYWxzZSwgY3VybHk6IHRydWUsIGVxZXFlcTogdHJ1ZSxcbiAgICBmcmVlemU6IHRydWUsIGxhdGVkZWY6IHRydWUsIG5vYXJnOiB0cnVlLCBub25ldzogdHJ1ZSwgcXVvdG1hcms6IGRvdWJsZSwgdW5kZWY6IHRydWUsXG4gICAgdW51c2VkOiB0cnVlLCBzdHJpY3Q6IHRydWUsIGFzaTogZmFsc2UsIGJvc3M6IGZhbHNlLCBldmlsOiBmYWxzZSwgZXhwcjogZmFsc2UsXG4gICAgZnVuY3Njb3BlOiBmYWxzZSovXG5cbnZhciBmbHVpZCA9IGZsdWlkIHx8IHJlcXVpcmUoXCJpbmZ1c2lvblwiKSxcbiAgICBmbG9jayA9IGZsdWlkLnJlZ2lzdGVyTmFtZXNwYWNlKFwiZmxvY2tcIik7XG5cbihmdW5jdGlvbiAoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgJCA9IGZsdWlkLnJlZ2lzdGVyTmFtZXNwYWNlKFwialF1ZXJ5XCIpO1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKlxuICAgICAqIEVudmVsb3BlIENyZWF0b3JzICpcbiAgICAgKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgZmxvY2suZW52ZWxvcGUgPSB7fTtcblxuICAgIC8vIFVuc3VwcG9ydGVkIEFQSS5cbiAgICBmbG9jay5lbnZlbG9wZS5tYWtlQ3JlYXRvciA9IGZ1bmN0aW9uIChuYW1lLCBlbnZlbG9wZU9wdGlvbnNUcmFuc2Zvcm1lcikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0cyA9IGZsdWlkLmRlZmF1bHRzKG5hbWUpLFxuICAgICAgICAgICAgICAgIG1lcmdlZCA9ICQuZXh0ZW5kKHRydWUsIHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIHJldHVybiBlbnZlbG9wZU9wdGlvbnNUcmFuc2Zvcm1lcihtZXJnZWQpO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBVbnN1cHBvcnRlZCBBUEkuXG4gICAgZmxvY2suZW52ZWxvcGUucmVnaXN0ZXJDcmVhdG9ycyA9IGZ1bmN0aW9uIChpbk5hbWVzcGFjZSwgY3JlYXRvclNwZWNzKSB7XG4gICAgICAgIHZhciBwYXRoLCBjcmVhdG9yU3BlYztcblxuICAgICAgICBmb3IgKHZhciBwYXRoU3VmZml4IGluIGNyZWF0b3JTcGVjcykge1xuICAgICAgICAgICAgcGF0aCA9IGZsdWlkLnBhdGhVdGlsLmNvbXBvc2VQYXRoKGluTmFtZXNwYWNlLCBwYXRoU3VmZml4KTtcbiAgICAgICAgICAgIGNyZWF0b3JTcGVjID0gY3JlYXRvclNwZWNzW3BhdGhTdWZmaXhdO1xuXG4gICAgICAgICAgICBmbHVpZC5kZWZhdWx0cyhwYXRoLCBjcmVhdG9yU3BlYy5kZWZhdWx0cyk7XG4gICAgICAgICAgICBmbHVpZC5zZXRHbG9iYWxWYWx1ZShwYXRoLCBmbG9jay5lbnZlbG9wZS5tYWtlQ3JlYXRvcihwYXRoLCBjcmVhdG9yU3BlYy50cmFuc2Zvcm1lcikpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFVuc3VwcG9ydGVkIEFQSS5cbiAgICBmbG9jay5lbnZlbG9wZS5jcmVhdG9yU3BlY3MgPSB7XG4gICAgICAgIGxpbmU6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVyOiBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGxldmVsczogW28uc3RhcnQsIG8uZW5kXSxcbiAgICAgICAgICAgICAgICAgICAgdGltZXM6IFtvLmR1cmF0aW9uXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBkZWZhdWx0czoge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiAwLjAsXG4gICAgICAgICAgICAgICAgZW5kOiAxLjAsXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IDEuMFxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGxpbmVhcjoge1xuICAgICAgICAgICAgdHJhbnNmb3JtZXI6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWxzOiBbMCwgby5sZXZlbCwgby5sZXZlbCwgMF0sXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzOiBbby5hdHRhY2ssIG8uc3VzdGFpbiwgby5yZWxlYXNlXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBkZWZhdWx0czoge1xuICAgICAgICAgICAgICAgIGxldmVsOiAxLjAsXG4gICAgICAgICAgICAgICAgYXR0YWNrOiAwLjAxLFxuICAgICAgICAgICAgICAgIHN1c3RhaW46IDEuMCxcbiAgICAgICAgICAgICAgICByZWxlYXNlOiAxLjBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB0cmk6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVyOiBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGxldmVsczogWzAsIG8ubGV2ZWwsIDBdLFxuICAgICAgICAgICAgICAgICAgICB0aW1lczogW28uZHVyYXRpb24sIG8uZHVyYXRpb25dXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGRlZmF1bHRzOiB7XG4gICAgICAgICAgICAgICAgbGV2ZWw6IDEuMCxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogMS4wXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2luOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lcjogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBsZXZlbHM6IFswLCBvLmxldmVsLCAwXSxcbiAgICAgICAgICAgICAgICAgICAgdGltZXM6IFtvLmR1cmF0aW9uLCBvLmR1cmF0aW9uXSxcbiAgICAgICAgICAgICAgICAgICAgY3VydmU6IFwic2luXCJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgICAgICAgICBsZXZlbDogMS4wLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAxLjBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhc3I6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVyOiBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGxldmVsczogWzAsIG8uc3VzdGFpbiwgMF0sXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzOiBbby5hdHRhY2ssIG8ucmVsZWFzZV0sXG4gICAgICAgICAgICAgICAgICAgIHN1c3RhaW5Qb2ludDogMSxcbiAgICAgICAgICAgICAgICAgICAgY3VydmU6IC00LjBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgICAgICAgICBzdXN0YWluOiAxLjAsXG4gICAgICAgICAgICAgICAgYXR0YWNrOiAwLjAxLFxuICAgICAgICAgICAgICAgIHJlbGVhc2U6IDEuMFxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGRhZHNyOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lcjogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgICAgICB2YXIgbGV2ZWxzID0gWzAsIDAsIG8ucGVhaywgby5wZWFrICogby5zdXN0YWluLCAwXTtcbiAgICAgICAgICAgICAgICBEU1AuYWRkKGxldmVscywgbGV2ZWxzLCBvLmJpYXMpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWxzOiBsZXZlbHMsXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzOiBbby5kZWxheSwgby5hdHRhY2ssIG8uZGVjYXksIG8ucmVsZWFzZV0sXG4gICAgICAgICAgICAgICAgICAgIHN1c3RhaW5Qb2ludDogMyxcbiAgICAgICAgICAgICAgICAgICAgY3VydmU6IC00LjBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgICAgICAgICBkZWxheTogMC4xLFxuICAgICAgICAgICAgICAgIGF0dGFjazogMC4wMSxcbiAgICAgICAgICAgICAgICBkZWNheTogMC4zLFxuICAgICAgICAgICAgICAgIHN1c3RhaW46IDAuNSxcbiAgICAgICAgICAgICAgICByZWxlYXNlOiAxLjAsXG4gICAgICAgICAgICAgICAgcGVhazogMS4wLFxuICAgICAgICAgICAgICAgIGJpYXM6IDAuMFxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGFkc3I6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVyOiBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgICAgIHZhciBsZXZlbHMgPSBbMCwgby5wZWFrLCBvLnBlYWsgKiBvLnN1c3RhaW4sIDBdO1xuICAgICAgICAgICAgICAgIERTUC5hZGQobGV2ZWxzLCBsZXZlbHMsIG8uYmlhcyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBsZXZlbHM6IGxldmVscyxcbiAgICAgICAgICAgICAgICAgICAgdGltZXM6IFtvLmF0dGFjaywgby5kZWNheSwgby5yZWxlYXNlXSxcbiAgICAgICAgICAgICAgICAgICAgc3VzdGFpblBvaW50OiAyLFxuICAgICAgICAgICAgICAgICAgICBjdXJ2ZTogLTQuMFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBkZWZhdWx0czoge1xuICAgICAgICAgICAgICAgIGF0dGFjazogMC4wMSxcbiAgICAgICAgICAgICAgICBkZWNheTogMC4zLFxuICAgICAgICAgICAgICAgIHN1c3RhaW46IDAuNSxcbiAgICAgICAgICAgICAgICByZWxlYXNlOiAxLjAsXG4gICAgICAgICAgICAgICAgcGVhazogMS4wLFxuICAgICAgICAgICAgICAgIGJpYXM6IDAuMFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZsb2NrLmVudmVsb3BlLnJlZ2lzdGVyQ3JlYXRvcnMoXCJmbG9jay5lbnZlbG9wZVwiLCBmbG9jay5lbnZlbG9wZS5jcmVhdG9yU3BlY3MpO1xuXG4gICAgZmxvY2suZW52ZWxvcGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoZW52ZWxvcGUsIGZhaWxPbkVycm9yKSB7XG4gICAgICAgIHZhciBsZXZlbHMgPSBlbnZlbG9wZS5sZXZlbHMsXG4gICAgICAgICAgICByZXBvcnQgPSB7fTtcblxuICAgICAgICBpZiAoIWVudmVsb3BlLnRpbWVzKSB7XG4gICAgICAgICAgICByZXBvcnQudGltZXMgPSBcIkFuIGFycmF5IGNvbnRhaW5pbmcgYXQgbGVhc3Qgb25lIHRpbWUgdmFsdWUgbXVzdCBiZSBzcGVjaWZpZWQuXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoIWxldmVscyB8fCBsZXZlbHMubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgcmVwb3J0LmxldmVscyA9IFwiQW4gYXJyYXkgY29udGFpbmluZyBhdCBsZWFzdCB0d28gbGV2ZWxzIG11c3QgYmUgc3BlY2lmaWVkLlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmxvY2suZW52ZWxvcGUudmFsaWRhdGUudGltZXMoZW52ZWxvcGUudGltZXMsIGxldmVscywgcmVwb3J0KTtcbiAgICAgICAgICAgIGZsb2NrLmVudmVsb3BlLnZhbGlkYXRlLmxldmVscyhsZXZlbHMsIHJlcG9ydCk7XG4gICAgICAgICAgICBmbG9jay5lbnZlbG9wZS52YWxpZGF0ZS5jdXJ2ZXMoZW52ZWxvcGUuY3VydmUsIGxldmVscywgcmVwb3J0KTtcbiAgICAgICAgICAgIGZsb2NrLmVudmVsb3BlLnZhbGlkYXRlLnN1c3RhaW5Qb2ludChlbnZlbG9wZS5zdXN0YWluUG9pbnQsIGxldmVscywgcmVwb3J0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmYWlsT25FcnJvciAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGVycm9yUHJvcCBpbiByZXBvcnQpIHtcbiAgICAgICAgICAgICAgICBmbG9jay5mYWlsKHJlcG9ydFtlcnJvclByb3BdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXBvcnQ7XG4gICAgfTtcblxuICAgIGZsb2NrLmVudmVsb3BlLnZhbGlkYXRlLnRpbWVzID0gZnVuY3Rpb24gKHRpbWVzLCBsZXZlbHMsIHJlcG9ydCkge1xuICAgICAgICBpZiAodGltZXMubGVuZ3RoICE9PSBsZXZlbHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgcmVwb3J0LnRpbWVzID0gXCJUaGUgZW52ZWxvcGUgc3BlY2lmaWNhdGlvbiBzaG91bGQgcHJvdmlkZSBvbmUgZmV3ZXIgdGltZSB2YWx1ZSBcIiArXG4gICAgICAgICAgICAgICAgXCJ0aGFuIHRoZSBudW1iZXIgb2YgbGV2ZWwgdmFsdWVzLiB0aW1lczogXCIgKyB0aW1lcyArIFwiIGxldmVsczogXCIgKyBsZXZlbHM7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdGltZSA9IHRpbWVzW2ldO1xuXG4gICAgICAgICAgICBpZiAoaXNOYU4odGltZSkpIHtcbiAgICAgICAgICAgICAgICByZXBvcnQudGltZXMgPSBcIkEgTmFOIHRpbWUgdmFsdWUgd2FzIHNwZWNpZmllZCBhdCBpbmRleCBcIiArXG4gICAgICAgICAgICAgICAgICAgIGkgKyBcIi4gdGltZXM6IFwiICsgdGltZXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aW1lIDwgMCkge1xuICAgICAgICAgICAgICAgIHJlcG9ydC50aW1lcyA9IFwiQWxsIHRpbWVzIHNob3VsZCBiZSBwb3NpdGl2ZSB2YWx1ZXMuIHRpbWVzOiBcIiArIHRpbWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZsb2NrLmVudmVsb3BlLnZhbGlkYXRlLmxldmVscyA9IGZ1bmN0aW9uIChsZXZlbHMsIHJlcG9ydCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxldmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGlzTmFOKGxldmVsc1tpXSkpIHtcbiAgICAgICAgICAgICAgICByZXBvcnQubGV2ZWxzID0gXCJBIE5hTiBsZXZlbCB2YWx1ZSB3YXMgc3BlY2lmaWVkIGF0IGluZGV4IFwiICtcbiAgICAgICAgICAgICAgICAgICAgaSArIFwiLiBsZXZlbHM6IFwiICsgbGV2ZWxzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZsb2NrLmVudmVsb3BlLnZhbGlkYXRlLmN1cnZlcyA9IGZ1bmN0aW9uIChjdXJ2ZSwgbGV2ZWxzLCByZXBvcnQpIHtcbiAgICAgICAgaWYgKCFjdXJ2ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcG9ydDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmbG9jay5pc0l0ZXJhYmxlKGN1cnZlKSkge1xuICAgICAgICAgICAgaWYgKGN1cnZlLmxlbmd0aCAhPT0gbGV2ZWxzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICByZXBvcnQuY3VydmUgPSBcIldoZW4gY3VydmUgaXMgc3BlY2lmaWVkIGFzIGFuIGFycmF5LCBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwidGhlcmUgc2hvdWxkIGJlIG9uZSBmZXdlciBjdXJ2ZSB2YWx1ZSBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwidGhhbiB0aGUgbnVtYmVyIG9mIGxldmVsIHZhbHVlcy4gY3VydmU6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgY3VydmUgKyBcIiBsZXZlbHM6IFwiICsgbGV2ZWxzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmbHVpZC5lYWNoKGN1cnZlLCBmdW5jdGlvbiAoY3VydmVOYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmVHZW4gPSBmbG9jay5saW5lLmdlbmVyYXRvcihjdXJ2ZU5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICghbGluZUdlbikge1xuICAgICAgICAgICAgICAgICAgICByZXBvcnQuY3VydmUgPSBcIidcIiArIGN1cnZlTmFtZSArIFwiJyBpcyBub3QgYSB2YWxpZCBjdXJ2ZSB0eXBlLiBjdXJ2ZTogXCIgKyBjdXJ2ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsaW5lR2VuID0gZmxvY2subGluZS5nZW5lcmF0b3IoY3VydmUpO1xuICAgICAgICBpZiAoIWxpbmVHZW4pIHtcbiAgICAgICAgICAgIHJlcG9ydC5jdXJ2ZSA9IFwiJ1wiICsgY3VydmUgKyBcIicgaXMgbm90IGEgdmFsaWQgY3VydmUgdHlwZS5cIjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmbG9jay5lbnZlbG9wZS52YWxpZGF0ZS5zdXN0YWluUG9pbnQgPSBmdW5jdGlvbiAoc3VzdGFpblBvaW50LCBsZXZlbHMsIHJlcG9ydCkge1xuICAgICAgICBpZiAoc3VzdGFpblBvaW50IDwgMCB8fCBzdXN0YWluUG9pbnQgPj0gbGV2ZWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVwb3J0LnN1c3RhaW5Qb2ludCA9IFwiVGhlIHNwZWNpZmllZCBzdXN0YWluUG9pbnQgaW5kZXggaXMgb3V0IHJhbmdlIGZvciB0aGUgbGV2ZWxzIGFycmF5LiBcIiArXG4gICAgICAgICAgICAgICAgXCJzdXN0YWluUG9pbnQ6IFwiICsgc3VzdGFpblBvaW50ICsgXCIgbGV2ZWxzOiBcIiArIGxldmVscztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUYWtlcyBhbiBlbnZlbG9wZSBzcGVjaWZpY2F0aW9uIGFuZCBleHBhbmRzIGl0LFxuICAgICAqIHByb2R1Y2luZyBhbiBlbnZlbG9wZSBvYmplY3QuXG4gICAgICovXG4gICAgZmxvY2suZW52ZWxvcGUuZXhwYW5kID0gZnVuY3Rpb24gKGVudlNwZWMpIHtcbiAgICAgICAgdmFyIGVudmVsb3BlID0gdHlwZW9mIGVudlNwZWMgPT09IFwic3RyaW5nXCIgPyBmbHVpZC5pbnZva2VHbG9iYWxGdW5jdGlvbihlbnZTcGVjKSA6XG4gICAgICAgICAgICBlbnZTcGVjLnR5cGUgPyBmbHVpZC5pbnZva2VHbG9iYWxGdW5jdGlvbihlbnZTcGVjLnR5cGUsIFtlbnZTcGVjXSkgOiBlbnZTcGVjO1xuXG4gICAgICAgIC8vIENhdGNoIGEgY29tbW9uIG5hbWluZyBtaXN0YWtlIGFuZCBhbGlhcyBpdCB0byB0aGUgY29ycmVjdCBuYW1lLlxuICAgICAgICBpZiAoZW52ZWxvcGUuY3VydmVzICYmICFlbnZlbG9wZS5jdXJ2ZSkge1xuICAgICAgICAgICAgZW52ZWxvcGUuY3VydmUgPSBlbnZlbG9wZS5jdXJ2ZXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWZsb2NrLmlzSXRlcmFibGUoZW52ZWxvcGUuY3VydmUpKSB7XG4gICAgICAgICAgICB2YXIgbnVtQ3VydmVzID0gZW52ZWxvcGUubGV2ZWxzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBlbnZlbG9wZS5jdXJ2ZSA9IGZsb2NrLmdlbmVyYXRlKG5ldyBBcnJheShudW1DdXJ2ZXMpLCBlbnZlbG9wZS5jdXJ2ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmbG9jay5lbnZlbG9wZS52YWxpZGF0ZShlbnZlbG9wZSwgdHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIGVudmVsb3BlO1xuICAgIH07XG5cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICogTGluZSBHZW5lcmF0b3IgRnVuY3Rpb25zICpcbiAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIGZsb2NrLmxpbmUgPSB7XG4gICAgICAgIC8vIFRPRE86IFVuaXQgdGVzdHMhXG4gICAgICAgIC8vIGUuZy4gZmxvY2subGluZS5maWxsKFwibGluZWFyXCIsIG5ldyBGbG9hdDMyQXJyYXkoNjQpLCAwLCAxKTtcbiAgICAgICAgZmlsbDogZnVuY3Rpb24gKHR5cGUsIGJ1ZmZlciwgc3RhcnQsIGVuZCwgc3RhcnRJZHgsIGVuZElkeCkge1xuICAgICAgICAgICAgc3RhcnRJZHggPSBzdGFydElkeCA9PT0gdW5kZWZpbmVkID8gMCA6IHN0YXJ0SWR4O1xuICAgICAgICAgICAgZW5kSWR4ID0gZW5kSWR4ID09PSB1bmRlZmluZWQgPyBidWZmZXIubGVuZ3RoIDogZW5kSWR4O1xuXG4gICAgICAgICAgICB2YXIgbnVtU2FtcHMgPSBlbmRJZHggLSBzdGFydElkeCxcbiAgICAgICAgICAgICAgICBtID0gZmxvY2subGluZS5maWxsLm1vZGVsO1xuXG4gICAgICAgICAgICBtLnVuc2NhbGVkVmFsdWUgPSBzdGFydDtcbiAgICAgICAgICAgIG0uZGVzdGluYXRpb24gPSBlbmQ7XG4gICAgICAgICAgICBtLm51bVNlZ21lbnRTYW1wcyA9IG51bVNhbXBzIC0gMTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgbS5jdXJyZW50Q3VydmUgPSB0eXBlO1xuICAgICAgICAgICAgICAgIHR5cGUgPSBcImN1cnZlXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBnZW5lcmF0b3IgPSBmbG9jay5saW5lW3R5cGVdO1xuICAgICAgICAgICAgaWYgKCFnZW5lcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBmbG9jay5mYWlsKFwiTm8gbGluZSBnZW5lcmF0b3IgY291bGQgYmUgZm91bmQgZm9yIHR5cGUgXCIgKyB0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdlbmVyYXRvci5pbml0KG0pO1xuXG4gICAgICAgICAgICByZXR1cm4gZ2VuZXJhdG9yLmdlbihudW1TYW1wcywgc3RhcnRJZHgsIGJ1ZmZlciwgbSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2VuZXJhdG9yOiBmdW5jdGlvbiAoY3VydmUpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gdHlwZW9mIGN1cnZlO1xuXG4gICAgICAgICAgICByZXR1cm4gdHlwZSA9PT0gXCJzdHJpbmdcIiA/IGZsb2NrLmxpbmVbY3VydmVdIDpcbiAgICAgICAgICAgICAgICB0eXBlID09PSBcIm51bWJlclwiID8gZmxvY2subGluZS5jdXJ2ZSA6IGZsb2NrLmxpbmUubGluZWFyO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbnN0YW50OiB7XG4gICAgICAgICAgICBpbml0OiBmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgICAgIG0uc3RlcFNpemUgPSAwO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2VuOiBmdW5jdGlvbiAobnVtU2FtcHMsIGlkeCwgYnVmZmVyLCBtKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IG0udW5zY2FsZWRWYWx1ZTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gaWR4OyBpIDwgbnVtU2FtcHMgKyBpZHg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBidWZmZXJbaV0gPSB2YWw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzdGVwOiB7XG4gICAgICAgICAgICBpbml0OiBmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgICAgIG0uYXJyaXZlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2VuOiBmdW5jdGlvbiAobnVtU2FtcHMsIGlkeCwgYnVmZmVyLCBtKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGlkeDsgaSA8IG51bVNhbXBzICsgaWR4OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyW2ldID0gbS51bnNjYWxlZFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW0uYXJyaXZlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbS5hcnJpdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG0udW5zY2FsZWRWYWx1ZSA9IG0uZGVzdGluYXRpb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGxpbmVhcjoge1xuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgICAgICBtLnN0ZXBTaXplID0gKG0uZGVzdGluYXRpb24gLSBtLnVuc2NhbGVkVmFsdWUpIC8gbS5udW1TZWdtZW50U2FtcHM7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZW46IGZ1bmN0aW9uIChudW1TYW1wcywgaWR4LCBidWZmZXIsIG0pIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gbS51bnNjYWxlZFZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBzdGVwU2l6ZSA9IG0uc3RlcFNpemU7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gaWR4OyBpIDwgbnVtU2FtcHMgKyBpZHg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBidWZmZXJbaV0gPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgIHZhbCArPSBzdGVwU2l6ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtLnVuc2NhbGVkVmFsdWUgPSB2YWw7XG4gICAgICAgICAgICAgICAgbS5zdGVwU2l6ZSA9IHN0ZXBTaXplO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBleHBvbmVudGlhbDoge1xuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgICAgICBpZiAobS51bnNjYWxlZFZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG0udW5zY2FsZWRWYWx1ZSA9IDAuMDAwMDAwMDAwMDAwMDAwMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbS5zdGVwU2l6ZSA9IG0ubnVtU2VnbWVudFNhbXBzID09PSAwID8gMCA6XG4gICAgICAgICAgICAgICAgICAgIE1hdGgucG93KG0uZGVzdGluYXRpb24gLyBtLnVuc2NhbGVkVmFsdWUsIDEuMCAvIG0ubnVtU2VnbWVudFNhbXBzKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdlbjogZnVuY3Rpb24gKG51bVNhbXBzLCBpZHgsIGJ1ZmZlciwgbSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSBtLnVuc2NhbGVkVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHN0ZXBTaXplID0gbS5zdGVwU2l6ZTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBpZHg7IGkgPCBudW1TYW1wcyArIGlkeDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltpXSA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgdmFsICo9IHN0ZXBTaXplO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG0udW5zY2FsZWRWYWx1ZSA9IHZhbDtcbiAgICAgICAgICAgICAgICBtLnN0ZXBTaXplID0gc3RlcFNpemU7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGN1cnZlOiB7XG4gICAgICAgICAgICBpbml0OiBmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhtLmN1cnJlbnRDdXJ2ZSkgPCAwLjAwMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIGN1cnZlIHZhbHVlIHRoaXMgc21hbGwgbWlnaHQgYXMgd2VsbCBiZSBsaW5lYXIuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbG9jay5saW5lLmxpbmVhci5pbml0KG0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhMSA9IChtLmRlc3RpbmF0aW9uIC0gbS51bnNjYWxlZFZhbHVlKSAvICgxLjAgLSBNYXRoLmV4cChtLmN1cnJlbnRDdXJ2ZSkpO1xuICAgICAgICAgICAgICAgICAgICBtLmEyID0gbS51bnNjYWxlZFZhbHVlICsgYTE7XG4gICAgICAgICAgICAgICAgICAgIG0uYjEgPSBhMTtcbiAgICAgICAgICAgICAgICAgICAgbS5zdGVwU2l6ZSA9IE1hdGguZXhwKG0uY3VycmVudEN1cnZlIC8gbS5udW1TZWdtZW50U2FtcHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdlbjogZnVuY3Rpb24gKG51bVNhbXBzLCBpZHgsIGJ1ZmZlciwgbSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSBtLnVuc2NhbGVkVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGIxID0gbS5iMTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBpZHg7IGkgPCBudW1TYW1wcyArIGlkeDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltpXSA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgYjEgKj0gbS5zdGVwU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gbS5hMiAtIGIxO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG0udW5zY2FsZWRWYWx1ZSA9IHZhbDtcbiAgICAgICAgICAgICAgICBtLmIxID0gYjE7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNpbjoge1xuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgICAgICB2YXIgdyA9IE1hdGguUEkgLyBtLm51bVNlZ21lbnRTYW1wcztcbiAgICAgICAgICAgICAgICBtLmEyID0gKG0uZGVzdGluYXRpb24gKyBtLnVuc2NhbGVkVmFsdWUpICogMC41O1xuICAgICAgICAgICAgICAgIG0uYjEgPSAyLjAgKiBNYXRoLmNvcyh3KTtcbiAgICAgICAgICAgICAgICBtLnkxID0gKG0uZGVzdGluYXRpb24gLSBtLnVuc2NhbGVkVmFsdWUpICogMC41O1xuICAgICAgICAgICAgICAgIG0ueTIgPSBtLnkxICogTWF0aC5zaW4oZmxvY2suSEFMRlBJIC0gdyk7XG4gICAgICAgICAgICAgICAgbS51bnNjYWxlZFZhbHVlID0gbS5hMiAtIG0ueTE7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZW46IGZ1bmN0aW9uIChudW1TYW1wcywgaWR4LCBidWZmZXIsIG0pIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gbS51bnNjYWxlZFZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB5MSA9IG0ueTEsXG4gICAgICAgICAgICAgICAgICAgIHkyID0gbS55MixcbiAgICAgICAgICAgICAgICAgICAgeTA7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gaWR4OyBpIDwgbnVtU2FtcHMgKyBpZHg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBidWZmZXJbaV0gPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgIHkwID0gbS5iMSAqIHkxIC0geTI7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IG0uYTIgLSB5MDtcbiAgICAgICAgICAgICAgICAgICAgeTIgPSB5MTtcbiAgICAgICAgICAgICAgICAgICAgeTEgPSB5MDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtLnVuc2NhbGVkVmFsdWUgPSB2YWw7XG4gICAgICAgICAgICAgICAgbS55MSA9IHkxO1xuICAgICAgICAgICAgICAgIG0ueTIgPSB5MjtcblxuICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgd2Vsc2g6IHtcbiAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICAgICAgdmFyIHcgPSBmbG9jay5IQUxGUEkgLyBtLm51bVNlZ21lbnRTYW1wcyxcbiAgICAgICAgICAgICAgICAgICAgY29zVyA9IE1hdGguY29zKHcpO1xuXG4gICAgICAgICAgICAgICAgbS5iMSA9IDIuMCAqIGNvc1c7XG5cbiAgICAgICAgICAgICAgICBpZiAobS5kZXN0aW5hdGlvbiA+PSBtLnVuc2NhbGVkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbS5hMiA9IG0udW5zY2FsZWRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgbS55MSA9IDAuMDtcbiAgICAgICAgICAgICAgICAgICAgbS55MiA9IC1NYXRoLnNpbih3KSAqIChtLmRlc3RpbmF0aW9uIC0gbS51bnNjYWxlZFZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtLmEyID0gbS5kZXN0aW5hdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgbS55MSA9IG0udW5zY2FsZWRWYWx1ZSAtIG0uZGVzdGluYXRpb247XG4gICAgICAgICAgICAgICAgICAgIG0ueTIgPSBjb3NXICogKG0udW5zY2FsZWRWYWx1ZSAtIG0uZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG0udW5zY2FsZWRWYWx1ZSA9IG0uYTIgKyBtLnkxO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2VuOiBmdW5jdGlvbiAobnVtU2FtcHMsIGlkeCwgYnVmZmVyLCBtKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IG0udW5zY2FsZWRWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgeTEgPSBtLnkxLFxuICAgICAgICAgICAgICAgICAgICB5MiA9IG0ueTIsXG4gICAgICAgICAgICAgICAgICAgIHkwO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGlkeDsgaSA8IG51bVNhbXBzICsgaWR4OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyW2ldID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICB5MCA9IG0uYjEgKiB5MSAtIHkyO1xuICAgICAgICAgICAgICAgICAgICB5MiA9IHkxO1xuICAgICAgICAgICAgICAgICAgICB5MSA9IHkwO1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSBtLmEyICsgeTA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbS51bnNjYWxlZFZhbHVlID0gdmFsO1xuICAgICAgICAgICAgICAgIG0ueTEgPSB5MTtcbiAgICAgICAgICAgICAgICBtLnkyID0geTI7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNxdWFyZWQ6IHtcbiAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICAgICAgbS55MSA9IE1hdGguc3FydChtLnVuc2NhbGVkVmFsdWUpO1xuICAgICAgICAgICAgICAgIG0ueTIgPSBNYXRoLnNxcnQobS5kZXN0aW5hdGlvbik7XG4gICAgICAgICAgICAgICAgbS5zdGVwU2l6ZSA9IChtLnkyIC0gbS55MSkgLyBtLm51bVNlZ21lbnRTYW1wcztcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdlbjogZnVuY3Rpb24gKG51bVNhbXBzLCBpZHgsIGJ1ZmZlciwgbSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSBtLnVuc2NhbGVkVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHkxID0gbS55MTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBpZHg7IGkgPCBudW1TYW1wcyArIGlkeDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltpXSA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgeTEgKz0gbS5zdGVwU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0geTEgKiB5MTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtLnkxID0geTE7XG4gICAgICAgICAgICAgICAgbS51bnNjYWxlZFZhbHVlID0gdmFsO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBjdWJlZDoge1xuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgICAgICB2YXIgdGhpcmQgPSAwLjMzMzMzMzMzMzMzMzMzMzM7XG4gICAgICAgICAgICAgICAgbS55MSA9IE1hdGgucG93KG0udW5zY2FsZWRWYWx1ZSwgdGhpcmQpO1xuICAgICAgICAgICAgICAgIG0ueTIgPSBNYXRoLnBvdyhtLmRlc3RpbmF0aW9uLCB0aGlyZCk7XG4gICAgICAgICAgICAgICAgbS5zdGVwU2l6ZSA9IChtLnkyIC0gbS55MSkgLyBtLm51bVNlZ21lbnRTYW1wcztcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdlbjogZnVuY3Rpb24gKG51bVNhbXBzLCBpZHgsIGJ1ZmZlciwgbSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSBtLnVuc2NhbGVkVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHkxID0gbS55MTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBpZHg7IGkgPCBudW1TYW1wcyArIGlkeDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltpXSA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgeTEgKz0gbS5zdGVwU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0geTEgKiB5MSAqIHkxO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG0ueTEgPSB5MTtcbiAgICAgICAgICAgICAgICBtLnVuc2NhbGVkVmFsdWUgPSB2YWw7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFVuc3VwcG9ydGVkIEFQSS5cbiAgICBmbG9jay5saW5lLmZpbGwubW9kZWwgPSB7XG4gICAgICAgIHVuc2NhbGVkVmFsdWU6IDAuMCxcbiAgICAgICAgdmFsdWU6IDAuMCxcbiAgICAgICAgZGVzdGluYXRpb246IDEuMFxuICAgIH07XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAqIEVudmVsb3BlIFVuaXQgR2VuZXJhdG9ycyAqXG4gICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICBmbG9jay51Z2VuLmxpbmUgPSBmdW5jdGlvbiAoaW5wdXRzLCBvdXRwdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHRoYXQgPSBmbG9jay51Z2VuKGlucHV0cywgb3V0cHV0LCBvcHRpb25zKTtcblxuICAgICAgICB0aGF0LmdlbiA9IGZ1bmN0aW9uIChudW1TYW1wcykge1xuICAgICAgICAgICAgdmFyIG0gPSB0aGF0Lm1vZGVsLFxuICAgICAgICAgICAgICAgIHN0ZXBTaXplID0gbS5zdGVwU2l6ZSxcbiAgICAgICAgICAgICAgICBudW1TdGVwcyA9IG0ubnVtU3RlcHMsXG4gICAgICAgICAgICAgICAgbnVtTGV2ZWxWYWxzID0gbnVtU3RlcHMgPj0gbnVtU2FtcHMgPyBudW1TYW1wcyA6IG51bVN0ZXBzLFxuICAgICAgICAgICAgICAgIG51bUVuZFZhbHMgPSBudW1TYW1wcyAtIG51bUxldmVsVmFscyxcbiAgICAgICAgICAgICAgICBsZXZlbCA9IG0ubGV2ZWwsXG4gICAgICAgICAgICAgICAgb3V0ID0gdGhhdC5vdXRwdXQsXG4gICAgICAgICAgICAgICAgaTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bUxldmVsVmFsczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0W2ldID0gbGV2ZWw7XG4gICAgICAgICAgICAgICAgbnVtU3RlcHMtLTtcbiAgICAgICAgICAgICAgICBsZXZlbCArPSBzdGVwU2l6ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IGEgbW9yZSBlZmZpY2llbnQgZ2VuIGFsZ29yaXRobSB3aGVuIHRoZSBsaW5lIGhhcyBmaW5pc2hlZC5cbiAgICAgICAgICAgIGlmIChudW1FbmRWYWxzID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1FbmRWYWxzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0W2ldID0gbGV2ZWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUT0RPOiBcImxldmVsXCIgc2hvdWxkIGJlIGRlcHJlY2F0ZWQgaW4gZmF2b3VyIG9mIFwidW5zY2FsZWRWYWx1ZVwiXG4gICAgICAgICAgICBtLmxldmVsID0gbS51bnNjYWxlZFZhbHVlID0gbGV2ZWw7XG4gICAgICAgICAgICBtLm51bVN0ZXBzID0gbnVtU3RlcHM7XG4gICAgICAgICAgICB0aGF0Lm11bEFkZChudW1TYW1wcyk7XG4gICAgICAgICAgICBtLnZhbHVlID0gZmxvY2sudWdlbi5sYXN0T3V0cHV0VmFsdWUobnVtU2FtcHMsIG91dCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5vbklucHV0Q2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtID0gdGhhdC5tb2RlbDtcblxuICAgICAgICAgICAgLy8gQW55IGNoYW5nZSBpbiBpbnB1dCB2YWx1ZSB3aWxsIHJlc3RhcnQgdGhlIGxpbmUuXG4gICAgICAgICAgICBtLnN0YXJ0ID0gdGhhdC5pbnB1dHMuc3RhcnQub3V0cHV0WzBdO1xuICAgICAgICAgICAgbS5lbmQgPSB0aGF0LmlucHV0cy5lbmQub3V0cHV0WzBdO1xuICAgICAgICAgICAgbS5udW1TdGVwcyA9IE1hdGgucm91bmQodGhhdC5pbnB1dHMuZHVyYXRpb24ub3V0cHV0WzBdICogbS5zYW1wbGVSYXRlKTtcbiAgICAgICAgICAgIGlmIChtLm51bVN0ZXBzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbS5zdGVwU2l6ZSA9IDAuMDtcbiAgICAgICAgICAgICAgICBtLmxldmVsID0gbS5lbmQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG0uc3RlcFNpemUgPSAobS5lbmQgLSBtLnN0YXJ0KSAvIG0ubnVtU3RlcHM7XG4gICAgICAgICAgICAgICAgbS5sZXZlbCA9IG0uc3RhcnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZsb2NrLm9uTXVsQWRkSW5wdXRDaGFuZ2VkKHRoYXQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQub25JbnB1dENoYW5nZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfTtcblxuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmxvY2sudWdlbi5saW5lXCIsIHtcbiAgICAgICAgcmF0ZTogXCJjb250cm9sXCIsXG4gICAgICAgIGlucHV0czoge1xuICAgICAgICAgICAgc3RhcnQ6IDAuMCxcbiAgICAgICAgICAgIGVuZDogMS4wLFxuICAgICAgICAgICAgZHVyYXRpb246IDEuMCxcbiAgICAgICAgICAgIG11bDogbnVsbCxcbiAgICAgICAgICAgIGFkZDogbnVsbFxuICAgICAgICB9LFxuICAgICAgICB1Z2VuT3B0aW9uczoge1xuICAgICAgICAgICAgbW9kZWw6IHtcbiAgICAgICAgICAgICAgICBzdGFydDogMC4wLFxuICAgICAgICAgICAgICAgIGVuZDogMS4wLFxuICAgICAgICAgICAgICAgIG51bVN0ZXBzOiAwLFxuICAgICAgICAgICAgICAgIHN0ZXBTaXplOiAwLFxuICAgICAgICAgICAgICAgIGxldmVsOiAwLjAsXG4gICAgICAgICAgICAgICAgdW5zY2FsZWRWYWx1ZTogMC4wLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAwLjBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG5cbiAgICBmbG9jay51Z2VuLnhMaW5lID0gZnVuY3Rpb24gKGlucHV0cywgb3V0cHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB0aGF0ID0gZmxvY2sudWdlbihpbnB1dHMsIG91dHB1dCwgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhhdC5nZW4gPSBmdW5jdGlvbiAobnVtU2FtcHMpIHtcbiAgICAgICAgICAgIHZhciBtID0gdGhhdC5tb2RlbCxcbiAgICAgICAgICAgICAgICBtdWx0aXBsaWVyID0gbS5tdWx0aXBsaWVyLFxuICAgICAgICAgICAgICAgIG51bVN0ZXBzID0gbS5udW1TdGVwcyxcbiAgICAgICAgICAgICAgICBudW1MZXZlbFZhbHMgPSBudW1TdGVwcyA+PSBudW1TYW1wcyA/IG51bVNhbXBzIDogbnVtU3RlcHMsXG4gICAgICAgICAgICAgICAgbnVtRW5kVmFscyA9IG51bVNhbXBzIC0gbnVtTGV2ZWxWYWxzLFxuICAgICAgICAgICAgICAgIGxldmVsID0gbS5sZXZlbCxcbiAgICAgICAgICAgICAgICBvdXQgPSB0aGF0Lm91dHB1dCxcbiAgICAgICAgICAgICAgICBpO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtTGV2ZWxWYWxzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvdXRbaV0gPSBsZXZlbDtcbiAgICAgICAgICAgICAgICBudW1TdGVwcy0tO1xuICAgICAgICAgICAgICAgIGxldmVsICo9IG11bHRpcGxpZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRPRE86IEltcGxlbWVudCBhIG1vcmUgZWZmaWNpZW50IGdlbiBhbGdvcml0aG0gd2hlbiB0aGUgbGluZSBoYXMgZmluaXNoZWQuXG4gICAgICAgICAgICBpZiAobnVtRW5kVmFscyA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtRW5kVmFsczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dFtpXSA9IGxldmVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVE9ETzogXCJsZXZlbFwiIHNob3VsZCBiZSBkZXByZWNhdGVkIGluIGZhdm91ciBvZiBcInVuc2NhbGVkVmFsdWVcIlxuICAgICAgICAgICAgbS5sZXZlbCA9IG0udW5zY2FsZWRWYWx1ZSA9IGxldmVsO1xuICAgICAgICAgICAgbS5udW1TdGVwcyA9IG51bVN0ZXBzO1xuICAgICAgICAgICAgdGhhdC5tdWxBZGQobnVtU2FtcHMpO1xuICAgICAgICAgICAgbS52YWx1ZSA9IGZsb2NrLnVnZW4ubGFzdE91dHB1dFZhbHVlKG51bVNhbXBzLCBvdXQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQub25JbnB1dENoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbSA9IHRoYXQubW9kZWw7XG5cbiAgICAgICAgICAgIGZsb2NrLm9uTXVsQWRkSW5wdXRDaGFuZ2VkKHRoYXQpO1xuXG4gICAgICAgICAgICAvLyBBbnkgY2hhbmdlIGluIGlucHV0IHZhbHVlIHdpbGwgcmVzdGFydCB0aGUgbGluZS5cbiAgICAgICAgICAgIG0uc3RhcnQgPSB0aGF0LmlucHV0cy5zdGFydC5vdXRwdXRbMF07XG4gICAgICAgICAgICBpZiAobS5zdGFydCA9PT0gMC4wKSB7XG4gICAgICAgICAgICAgICAgbS5zdGFydCA9IDFlLTEwMTsgLy8gR3VhcmQgYWdhaW5zdCBkaXZpZGUgYnkgemVyby5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbS5lbmQgPSB0aGF0LmlucHV0cy5lbmQub3V0cHV0WzBdO1xuICAgICAgICAgICAgbS5udW1TdGVwcyA9IE1hdGgucm91bmQodGhhdC5pbnB1dHMuZHVyYXRpb24ub3V0cHV0WzBdICogbS5zYW1wbGVSYXRlKTtcbiAgICAgICAgICAgIG0ubXVsdGlwbGllciA9IE1hdGgucG93KG0uZW5kIC8gbS5zdGFydCwgMS4wIC8gbS5udW1TdGVwcyk7XG4gICAgICAgICAgICBtLmxldmVsID0gbS5zdGFydDtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0Lm9uSW5wdXRDaGFuZ2VkKCk7XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgIH07XG5cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsb2NrLnVnZW4ueExpbmVcIiwge1xuICAgICAgICByYXRlOiBcImNvbnRyb2xcIixcbiAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICBzdGFydDogMC4wLFxuICAgICAgICAgICAgZW5kOiAxLjAsXG4gICAgICAgICAgICBkdXJhdGlvbjogMS4wLFxuICAgICAgICAgICAgbXVsOiBudWxsLFxuICAgICAgICAgICAgYWRkOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIHVnZW5PcHRpb25zOiB7XG4gICAgICAgICAgICBtb2RlbDoge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiAwLjAsXG4gICAgICAgICAgICAgICAgZW5kOiAxLjAsXG4gICAgICAgICAgICAgICAgbnVtU3RlcHM6IDAsXG4gICAgICAgICAgICAgICAgbXVsdGlwbGllcjogMCxcbiAgICAgICAgICAgICAgICBsZXZlbDogMC4wLFxuICAgICAgICAgICAgICAgIHVuc2NhbGVkVmFsdWU6IDAuMCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogMC4wXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZsb2NrLnVnZW4uYXNyID0gZnVuY3Rpb24gKGlucHV0cywgb3V0cHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB0aGF0ID0gZmxvY2sudWdlbihpbnB1dHMsIG91dHB1dCwgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhhdC5nZW4gPSBmdW5jdGlvbiAobnVtU2FtcHMpIHtcbiAgICAgICAgICAgIHZhciBtID0gdGhhdC5tb2RlbCxcbiAgICAgICAgICAgICAgICBvdXQgPSB0aGF0Lm91dHB1dCxcbiAgICAgICAgICAgICAgICBwcmV2R2F0ZSA9IG0ucHJldmlvdXNHYXRlLFxuICAgICAgICAgICAgICAgIGdhdGUgPSB0aGF0LmlucHV0cy5nYXRlLm91dHB1dFswXSxcbiAgICAgICAgICAgICAgICBsZXZlbCA9IG0ubGV2ZWwsXG4gICAgICAgICAgICAgICAgc3RhZ2UgPSBtLnN0YWdlLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRTdGVwID0gc3RhZ2UuY3VycmVudFN0ZXAsXG4gICAgICAgICAgICAgICAgc3RlcEluYyA9IHN0YWdlLnN0ZXBJbmMsXG4gICAgICAgICAgICAgICAgbnVtU3RlcHMgPSBzdGFnZS5udW1TdGVwcyxcbiAgICAgICAgICAgICAgICB0YXJnZXRMZXZlbCA9IG0udGFyZ2V0TGV2ZWwsXG4gICAgICAgICAgICAgICAgc3RlcHNOZWVkUmVjYWxjID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgc3RhZ2VUaW1lLFxuICAgICAgICAgICAgICAgIGk7XG5cbiAgICAgICAgICAgIC8vIFJlY2FsY3VsYXRlIHRoZSBzdGVwIHN0YXRlIGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgICAgIGlmIChwcmV2R2F0ZSA8PSAwICYmIGdhdGUgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gU3RhcnRpbmcgYSBuZXcgYXR0YWNrIHN0YWdlLlxuICAgICAgICAgICAgICAgIHRhcmdldExldmVsID0gdGhhdC5pbnB1dHMuc3VzdGFpbi5vdXRwdXRbMF07XG4gICAgICAgICAgICAgICAgc3RhZ2VUaW1lID0gdGhhdC5pbnB1dHMuYXR0YWNrLm91dHB1dFswXTtcbiAgICAgICAgICAgICAgICBzdGVwc05lZWRSZWNhbGMgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChnYXRlIDw9IDAgJiYgY3VycmVudFN0ZXAgPj0gbnVtU3RlcHMpIHtcbiAgICAgICAgICAgICAgICAvLyBTdGFydGluZyBhIG5ldyByZWxlYXNlIHN0YWdlLlxuICAgICAgICAgICAgICAgIHRhcmdldExldmVsID0gdGhhdC5pbnB1dHMuc3RhcnQub3V0cHV0WzBdO1xuICAgICAgICAgICAgICAgIHN0YWdlVGltZSA9IHRoYXQuaW5wdXRzLnJlbGVhc2Uub3V0cHV0WzBdO1xuICAgICAgICAgICAgICAgIHN0ZXBzTmVlZFJlY2FsYyA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRPRE86IENhbiB3ZSBnZXQgcmlkIG9mIHRoaXMgZXh0cmEgYnJhbmNoIHdpdGhvdXQgaW50cm9kdWNpbmcgY29kZSBkdXBsaWNhdGlvbj9cbiAgICAgICAgICAgIGlmIChzdGVwc05lZWRSZWNhbGMpIHtcbiAgICAgICAgICAgICAgICBudW1TdGVwcyA9IE1hdGgucm91bmQoc3RhZ2VUaW1lICogbS5zYW1wbGVSYXRlKTtcbiAgICAgICAgICAgICAgICBzdGVwSW5jID0gKHRhcmdldExldmVsIC0gbGV2ZWwpIC8gbnVtU3RlcHM7XG4gICAgICAgICAgICAgICAgY3VycmVudFN0ZXAgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBPdXRwdXQgdGhlIHRoZSBlbnZlbG9wZSdzIHNhbXBsZSBkYXRhLlxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bVNhbXBzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvdXRbaV0gPSBsZXZlbDtcbiAgICAgICAgICAgICAgICBjdXJyZW50U3RlcCsrO1xuICAgICAgICAgICAgICAgIC8vIEhvbGQgdGhlIGxhc3QgdmFsdWUgaWYgdGhlIHN0YWdlIGlzIGNvbXBsZXRlLCBvdGhlcndpc2UgaW5jcmVtZW50LlxuICAgICAgICAgICAgICAgIGxldmVsID0gY3VycmVudFN0ZXAgPCBudW1TdGVwcyA/XG4gICAgICAgICAgICAgICAgICAgIGxldmVsICsgc3RlcEluYyA6IGN1cnJlbnRTdGVwID09PSBudW1TdGVwcyA/XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldExldmVsIDogbGV2ZWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN0b3JlIGluc3RhbmNlIHN0YXRlLlxuICAgICAgICAgICAgLy8gVE9ETzogXCJsZXZlbFwiIHNob3VsZCBiZSBkZXByZWNhdGVkIGluIGZhdm91ciBvZiBcInVuc2NhbGVkVmFsdWVcIlxuICAgICAgICAgICAgbS5sZXZlbCA9IG0udW5zY2FsZWRWYWx1ZSA9IGxldmVsO1xuICAgICAgICAgICAgbS50YXJnZXRMZXZlbCA9IHRhcmdldExldmVsO1xuICAgICAgICAgICAgbS5wcmV2aW91c0dhdGUgPSBnYXRlO1xuICAgICAgICAgICAgc3RhZ2UuY3VycmVudFN0ZXAgPSBjdXJyZW50U3RlcDtcbiAgICAgICAgICAgIHN0YWdlLnN0ZXBJbmMgPSBzdGVwSW5jO1xuICAgICAgICAgICAgc3RhZ2UubnVtU3RlcHMgPSBudW1TdGVwcztcblxuICAgICAgICAgICAgdGhhdC5tdWxBZGQobnVtU2FtcHMpO1xuICAgICAgICAgICAgbS52YWx1ZSA9IGZsb2NrLnVnZW4ubGFzdE91dHB1dFZhbHVlKG51bVNhbXBzLCBvdXQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtID0gdGhhdC5tb2RlbDtcbiAgICAgICAgICAgIG0ubGV2ZWwgPSBtLnVuc2NhbGVkVmFsdWUgPSB0aGF0LmlucHV0cy5zdGFydC5vdXRwdXRbMF07XG4gICAgICAgICAgICBtLnRhcmdldExldmVsID0gdGhhdC5pbnB1dHMuc3VzdGFpbi5vdXRwdXRbMF07XG5cbiAgICAgICAgICAgIHRoYXQub25JbnB1dENoYW5nZWQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0LmluaXQoKTtcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfTtcblxuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmxvY2sudWdlbi5hc3JcIiwge1xuICAgICAgICByYXRlOiBcImNvbnRyb2xcIixcbiAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICBzdGFydDogMC4wLFxuICAgICAgICAgICAgYXR0YWNrOiAwLjAxLFxuICAgICAgICAgICAgc3VzdGFpbjogMS4wLFxuICAgICAgICAgICAgcmVsZWFzZTogMS4wLFxuICAgICAgICAgICAgZ2F0ZTogMC4wLFxuICAgICAgICAgICAgbXVsOiBudWxsLFxuICAgICAgICAgICAgYWRkOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIHVnZW5PcHRpb25zOiB7XG4gICAgICAgICAgICBtb2RlbDoge1xuICAgICAgICAgICAgICAgIGxldmVsOiAwLjAsXG4gICAgICAgICAgICAgICAgdGFyZ2V0TGV2ZWw6IDAuMCxcbiAgICAgICAgICAgICAgICBwcmV2aW91c0dhdGU6IDAuMCxcbiAgICAgICAgICAgICAgICB1bnNjYWxlZFZhbHVlOiAwLjAsXG4gICAgICAgICAgICAgICAgdmFsdWU6IDAuMCxcbiAgICAgICAgICAgICAgICBzdGFnZToge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3RlcDogMCxcbiAgICAgICAgICAgICAgICAgICAgc3RlcEluYzogMCxcbiAgICAgICAgICAgICAgICAgICAgbnVtU3RlcHM6IDBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEluY2x1ZGVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgICAvLyBUaGUgbmFtZSBcImZsb2NrLnVnZW4uZW52LnNpbXBsZUFTUiBpcyBkZXByZWNhdGVkLlxuICAgIC8vIFBsZWFzZSB1c2UgZmxvY2sudWdlbi5hc3IgaW5zdGVhZC5cbiAgICAvLyBUaGlzIHdpbGwgYmUgcmVtb3ZlZCBiZWZvcmUgRmxvY2tpbmcgMS4wLlxuICAgIGZsb2NrLnVnZW4uZW52ID0ge307XG4gICAgZmxvY2sudWdlbi5lbnYuc2ltcGxlQVNSICA9IGZsb2NrLnVnZW4uYXNyO1xuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmxvY2sudWdlbi5lbnYuc2ltcGxlQVNSXCIsIGZsdWlkLmNvcHkoZmx1aWQuZGVmYXVsdHMoXCJmbG9jay51Z2VuLmFzclwiKSkpO1xuXG4gICAgZmxvY2sudWdlbi5lbnZHZW4gPSBmdW5jdGlvbiAoaW5wdXRzLCBvdXRwdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHRoYXQgPSBmbG9jay51Z2VuKGlucHV0cywgb3V0cHV0LCBvcHRpb25zKTtcblxuICAgICAgICB0aGF0LmtyR2VuID0gZnVuY3Rpb24gKG51bVNhbXBzKSB7XG4gICAgICAgICAgICB2YXIgbSA9IHRoYXQubW9kZWwsXG4gICAgICAgICAgICAgICAgb3V0ID0gdGhhdC5vdXRwdXQsXG4gICAgICAgICAgICAgICAgaW5wdXRzID0gdGhhdC5pbnB1dHMsXG4gICAgICAgICAgICAgICAgZ2F0ZSA9IGlucHV0cy5nYXRlLm91dHB1dFswXSxcbiAgICAgICAgICAgICAgICB0aW1lU2NhbGUgPSBpbnB1dHMudGltZVNjYWxlLm91dHB1dFswXSxcbiAgICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgICBzYW1wc1RvR2VuO1xuXG4gICAgICAgICAgICBmbG9jay51Z2VuLmVudkdlbi5jaGVja0dhdGUodGhhdCwgZ2F0ZSwgdGltZVNjYWxlKTtcblxuICAgICAgICAgICAgd2hpbGUgKGkgPCBudW1TYW1wcykge1xuICAgICAgICAgICAgICAgIHNhbXBzVG9HZW4gPSBNYXRoLm1pbihudW1TYW1wcyAtIGksIG0ubnVtU2VnbWVudFNhbXBzKTtcbiAgICAgICAgICAgICAgICB0aGF0LmxpbmVHZW4uZ2VuKHNhbXBzVG9HZW4sIGksIG91dCwgbSk7XG4gICAgICAgICAgICAgICAgaSArPSBzYW1wc1RvR2VuO1xuICAgICAgICAgICAgICAgIG0ubnVtU2VnbWVudFNhbXBzIC09IHNhbXBzVG9HZW47XG5cbiAgICAgICAgICAgICAgICBpZiAobS5udW1TZWdtZW50U2FtcHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZmxvY2sudWdlbi5lbnZHZW4ubmV4dFN0YWdlKHRoYXQsIHRpbWVTY2FsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGF0Lm11bEFkZChudW1TYW1wcyk7XG4gICAgICAgICAgICBtLnZhbHVlID0gZmxvY2sudWdlbi5sYXN0T3V0cHV0VmFsdWUobnVtU2FtcHMsIG91dCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5hckdlbiA9IGZ1bmN0aW9uIChudW1TYW1wcykge1xuICAgICAgICAgICAgdmFyIG0gPSB0aGF0Lm1vZGVsLFxuICAgICAgICAgICAgICAgIG91dCA9IHRoYXQub3V0cHV0LFxuICAgICAgICAgICAgICAgIGlucHV0cyA9IHRoYXQuaW5wdXRzLFxuICAgICAgICAgICAgICAgIGdhdGUgPSBpbnB1dHMuZ2F0ZS5vdXRwdXQsXG4gICAgICAgICAgICAgICAgdGltZVNjYWxlID0gaW5wdXRzLnRpbWVTY2FsZS5vdXRwdXRbMF0sXG4gICAgICAgICAgICAgICAgaTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bVNhbXBzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmbG9jay51Z2VuLmVudkdlbi5jaGVja0dhdGUodGhhdCwgZ2F0ZVtpXSwgdGltZVNjYWxlKTtcblxuICAgICAgICAgICAgICAgIHRoYXQubGluZUdlbi5nZW4oMSwgaSwgb3V0LCBtKTtcbiAgICAgICAgICAgICAgICBtLm51bVNlZ21lbnRTYW1wcy0tO1xuXG4gICAgICAgICAgICAgICAgaWYgKG0ubnVtU2VnbWVudFNhbXBzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsb2NrLnVnZW4uZW52R2VuLm5leHRTdGFnZSh0aGF0LCB0aW1lU2NhbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhhdC5tdWxBZGQobnVtU2FtcHMpO1xuICAgICAgICAgICAgbS52YWx1ZSA9IGZsb2NrLnVnZW4ubGFzdE91dHB1dFZhbHVlKG51bVNhbXBzLCBvdXQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQub25JbnB1dENoYW5nZWQgPSBmdW5jdGlvbiAoaW5wdXROYW1lKSB7XG4gICAgICAgICAgICBpZiAoIWlucHV0TmFtZSB8fCBpbnB1dE5hbWUgPT09IFwiZW52ZWxvcGVcIikge1xuICAgICAgICAgICAgICAgIHRoYXQuZW52ZWxvcGUgPSBmbG9jay51Z2VuLmVudkdlbi5pbml0RW52ZWxvcGUodGhhdCwgdGhhdC5pbnB1dHMuZW52ZWxvcGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWlucHV0TmFtZSB8fCBpbnB1dE5hbWUgPT09IFwiZ2F0ZVwiKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5nZW4gPSB0aGF0LmlucHV0cy5nYXRlLnJhdGUgPT09IGZsb2NrLnJhdGVzLkFVRElPID8gdGhhdC5hckdlbiA6IHRoYXQua3JHZW47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZsb2NrLm9uTXVsQWRkSW5wdXRDaGFuZ2VkKHRoYXQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQub25JbnB1dENoYW5nZWQoKTtcblxuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICB9O1xuXG4gICAgLy8gVW5zdXBwb3J0ZWQgQVBJLlxuICAgIGZsb2NrLnVnZW4uZW52R2VuLmluaXRFbnZlbG9wZSA9IGZ1bmN0aW9uICh0aGF0LCBlbnZTcGVjKSB7XG4gICAgICAgIHZhciBtID0gdGhhdC5tb2RlbCxcbiAgICAgICAgICAgIGVudmVsb3BlID0gZmxvY2suZW52ZWxvcGUuZXhwYW5kKGVudlNwZWMpO1xuXG4gICAgICAgIG0uc3RhZ2UgPSAwO1xuICAgICAgICBtLm51bVN0YWdlcyA9IGVudmVsb3BlLnRpbWVzLmxlbmd0aDtcbiAgICAgICAgdGhhdC5saW5lR2VuID0gZmxvY2subGluZS5jb25zdGFudDtcblxuICAgICAgICBmbG9jay51Z2VuLmVudkdlbi5saW5lR2VuRm9yU3RhZ2UodGhhdC5pbnB1dHMudGltZVNjYWxlLm91dHB1dFswXSwgZW52ZWxvcGUsIG0pO1xuICAgICAgICBtLnVuc2NhbGVkVmFsdWUgPSBlbnZlbG9wZS5sZXZlbHNbbS5zdGFnZV07XG5cbiAgICAgICAgcmV0dXJuIGVudmVsb3BlO1xuICAgIH07XG5cbiAgICAvLyBVbnN1cHBvcnRlZCBBUEkuXG4gICAgZmxvY2sudWdlbi5lbnZHZW4uY2hlY2tHYXRlID0gZnVuY3Rpb24gKHRoYXQsIGdhdGUsIHRpbWVTY2FsZSkge1xuICAgICAgICB2YXIgbSA9IHRoYXQubW9kZWwsXG4gICAgICAgICAgICBlbnZlbG9wZSA9IHRoYXQuZW52ZWxvcGU7XG5cbiAgICAgICAgaWYgKGdhdGUgIT09IG0ucHJldmlvdXNHYXRlKSB7XG4gICAgICAgICAgICBpZiAoZ2F0ZSA+IDAuMCAmJiBtLnByZXZpb3VzR2F0ZSA8PSAwLjApIHtcbiAgICAgICAgICAgICAgICAvLyBHYXRlIGhhcyBvcGVuZWQuXG4gICAgICAgICAgICAgICAgbS5zdGFnZSA9IDE7XG4gICAgICAgICAgICAgICAgdGhhdC5saW5lR2VuID0gZmxvY2sudWdlbi5lbnZHZW4ubGluZUdlbkZvclN0YWdlKHRpbWVTY2FsZSwgZW52ZWxvcGUsIG0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChnYXRlIDw9IDAuMCAmJiBtLnByZXZpb3VzR2F0ZSA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBHYXRlIGhhcyBjbG9zZWQuXG4gICAgICAgICAgICAgICAgbS5zdGFnZSA9IG0ubnVtU3RhZ2VzO1xuICAgICAgICAgICAgICAgIHRoYXQubGluZUdlbiA9IGZsb2NrLnVnZW4uZW52R2VuLmxpbmVHZW5Gb3JTdGFnZSh0aW1lU2NhbGUsIGVudmVsb3BlLCBtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtLnByZXZpb3VzR2F0ZSA9IGdhdGU7XG4gICAgfTtcblxuICAgIC8vIFVuc3VwcG9ydGVkIEFQSS5cbiAgICBmbG9jay51Z2VuLmVudkdlbi5uZXh0U3RhZ2UgPSBmdW5jdGlvbiAodGhhdCwgdGltZVNjYWxlKSB7XG4gICAgICAgIHZhciBtID0gdGhhdC5tb2RlbCxcbiAgICAgICAgICAgIGVudmVsb3BlID0gdGhhdC5lbnZlbG9wZTtcblxuICAgICAgICAvLyBXZSd2ZSBoaXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCB0cmFuc2l0aW9uLlxuICAgICAgICBpZiAobS5zdGFnZSA9PT0gZW52ZWxvcGUuc3VzdGFpblBvaW50KSB7XG4gICAgICAgICAgICAvLyBXZSdyZSBhdCB0aGUgc3VzdGFpbiBwb2ludC5cbiAgICAgICAgICAgIC8vIE91dHB1dCBhIGNvbnN0YW50IHZhbHVlLlxuICAgICAgICAgICAgdGhhdC5saW5lR2VuID0gZmxvY2subGluZS5jb25zdGFudDtcbiAgICAgICAgICAgIG0ubnVtU2VnbWVudFNhbXBzID0gSW5maW5pdHk7XG4gICAgICAgICAgICBtLmRlc3RpbmF0aW9uID0gbS51bnNjYWxlZFZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTW92ZSBvbiB0byB0aGUgbmV4dCBicmVha3BvaW50IHN0YWdlLlxuICAgICAgICAgICAgbS5zdGFnZSsrO1xuICAgICAgICAgICAgdGhhdC5saW5lR2VuID0gZmxvY2sudWdlbi5lbnZHZW4ubGluZUdlbkZvclN0YWdlKHRpbWVTY2FsZSwgZW52ZWxvcGUsIG0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFVuc3VwcG9ydGVkIEFQSS5cbiAgICBmbG9jay51Z2VuLmVudkdlbi5zZXR1cFN0YWdlID0gZnVuY3Rpb24gKHRpbWVTY2FsZSwgZW52ZWxvcGUsIG0pIHtcbiAgICAgICAgdmFyIGRlc3QgPSBlbnZlbG9wZS5sZXZlbHNbbS5zdGFnZV0sXG4gICAgICAgICAgICBkdXIsXG4gICAgICAgICAgICBkdXJTYW1wcztcblxuICAgICAgICBpZiAobS5zdGFnZSA9PT0gMCB8fCBtLnN0YWdlID4gbS5udW1TdGFnZXMpIHtcbiAgICAgICAgICAgIGR1clNhbXBzID0gSW5maW5pdHk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkdXIgPSBlbnZlbG9wZS50aW1lc1ttLnN0YWdlIC0gMV0gKiB0aW1lU2NhbGU7XG4gICAgICAgICAgICBkdXJTYW1wcyA9IE1hdGgubWF4KDEsIGR1ciAqIG0uc2FtcGxlUmF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBtLm51bVNlZ21lbnRTYW1wcyA9IGR1clNhbXBzO1xuICAgICAgICBtLmRlc3RpbmF0aW9uID0gZGVzdDtcbiAgICB9O1xuXG4gICAgLy8gVW5zdXBwb3J0ZWQgQVBJLlxuICAgIGZsb2NrLnVnZW4uZW52R2VuLmxpbmVHZW5Gb3JTdGFnZSA9IGZ1bmN0aW9uICh0aW1lU2NhbGUsIGVudmVsb3BlLCBtKSB7XG4gICAgICAgIHZhciBjdXJ2ZSA9IGVudmVsb3BlLmN1cnZlLFxuICAgICAgICAgICAgbGluZUdlbixcbiAgICAgICAgICAgIGN1cnZlVmFsdWU7XG5cbiAgICAgICAgaWYgKG0uc3RhZ2UgPT09IDAgfHwgbS5zdGFnZSA+IG0ubnVtU3RhZ2VzKSB7XG4gICAgICAgICAgICBsaW5lR2VuID0gZmxvY2subGluZS5jb25zdGFudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN1cnZlVmFsdWUgPSBjdXJ2ZVttLnN0YWdlIC0gMV07XG4gICAgICAgICAgICBtLmN1cnJlbnRDdXJ2ZSA9IGN1cnZlVmFsdWU7XG4gICAgICAgICAgICBsaW5lR2VuID0gZmxvY2subGluZS5nZW5lcmF0b3IoY3VydmVWYWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmbG9jay51Z2VuLmVudkdlbi5zZXR1cFN0YWdlKHRpbWVTY2FsZSwgZW52ZWxvcGUsIG0pO1xuICAgICAgICBsaW5lR2VuLmluaXQobSk7XG5cbiAgICAgICAgcmV0dXJuIGxpbmVHZW47XG4gICAgfTtcblxuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmxvY2sudWdlbi5lbnZHZW5cIiwge1xuICAgICAgICByYXRlOiBcImF1ZGlvXCIsXG5cbiAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICBlbnZlbG9wZTogXCJmbG9jay5lbnZlbG9wZS5hZHNyXCIsXG4gICAgICAgICAgICBnYXRlOiAwLjAsXG4gICAgICAgICAgICB0aW1lU2NhbGU6IDEuMCwgICAgIC8vIFRpbWVzY2FsZSBpcyBjb250cm9sLXJhdGUgKG9yIGxvd2VyKSBvbmx5LlxuICAgICAgICAgICAgbXVsOiBudWxsLCAgICAgICAgICAvLyBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gU0MncyBsZXZlbFNjYWxlIHBhcmFtZXRlci5cbiAgICAgICAgICAgIGFkZDogbnVsbCAgICAgICAgICAgLy8gQW5kIHRoaXMgdG8gU0MncyBsZXZlbEJpYXMuXG4gICAgICAgIH0sXG5cbiAgICAgICAgdWdlbk9wdGlvbnM6IHtcbiAgICAgICAgICAgIG1vZGVsOiB7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNHYXRlOiAwLjAsXG4gICAgICAgICAgICAgICAgc3RlcFNpemU6IDAuMCxcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbjogMC4wLFxuICAgICAgICAgICAgICAgIG51bVNlZ21lbnRTYW1wczogMS4wLFxuICAgICAgICAgICAgICAgIHVuc2NhbGVkVmFsdWU6IDAuMCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogMC4wLFxuICAgICAgICAgICAgICAgIHN0YWdlOiAwLjAsXG4gICAgICAgICAgICAgICAgbnVtU3RhZ2VzOiAwLjBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG59KCkpO1xuOy8qXG4qIEZsb2NraW5nIEJyb3dzZXItRGVwZW5kZW50IFVuaXQgR2VuZXJhdG9yc1xuKiBodHRwOi8vZ2l0aHViLmNvbS9jb2xpbmJkY2xhcmsvZmxvY2tpbmdcbipcbiogQ29weXJpZ2h0IDIwMTMtMjAxNCwgQ29saW4gQ2xhcmtcbiogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGFuZCBHUEwgVmVyc2lvbiAyIGxpY2Vuc2VzLlxuKi9cblxuLypnbG9iYWwgcmVxdWlyZSwgRmxvYXQzMkFycmF5LCB3aW5kb3cqL1xuLypqc2hpbnQgd2hpdGU6IGZhbHNlLCBuZXdjYXA6IHRydWUsIHJlZ2V4cDogdHJ1ZSwgYnJvd3NlcjogdHJ1ZSxcbiAgICBmb3JpbjogZmFsc2UsIG5vbWVuOiB0cnVlLCBiaXR3aXNlOiBmYWxzZSwgbWF4ZXJyOiAxMDAsXG4gICAgaW5kZW50OiA0LCBwbHVzcGx1czogZmFsc2UsIGN1cmx5OiB0cnVlLCBlcWVxZXE6IHRydWUsXG4gICAgZnJlZXplOiB0cnVlLCBsYXRlZGVmOiB0cnVlLCBub2FyZzogdHJ1ZSwgbm9uZXc6IHRydWUsIHF1b3RtYXJrOiBkb3VibGUsIHVuZGVmOiB0cnVlLFxuICAgIHVudXNlZDogdHJ1ZSwgc3RyaWN0OiB0cnVlLCBhc2k6IGZhbHNlLCBib3NzOiBmYWxzZSwgZXZpbDogZmFsc2UsIGV4cHI6IGZhbHNlLFxuICAgIGZ1bmNzY29wZTogZmFsc2UqL1xuXG52YXIgZmx1aWQgPSBmbHVpZCB8fCByZXF1aXJlKFwiaW5mdXNpb25cIiksXG4gICAgZmxvY2sgPSBmbHVpZC5yZWdpc3Rlck5hbWVzcGFjZShcImZsb2NrXCIpO1xuXG4oZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyICQgPSBmbHVpZC5yZWdpc3Rlck5hbWVzcGFjZShcImpRdWVyeVwiKTtcblxuICAgIGZsdWlkLnJlZ2lzdGVyTmFtZXNwYWNlKFwiZmxvY2sudWdlblwiKTtcblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgKiBCcm93c2VyLWRlcGVuZGVudCBVR2VucyAqXG4gICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIGZsb2NrLnVnZW4uc2NvcGUgPSBmdW5jdGlvbiAoaW5wdXRzLCBvdXRwdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHRoYXQgPSBmbG9jay51Z2VuKGlucHV0cywgb3V0cHV0LCBvcHRpb25zKTtcblxuICAgICAgICB0aGF0LmdlbiA9IGZ1bmN0aW9uIChudW1TYW1wcykge1xuICAgICAgICAgICAgdmFyIG0gPSB0aGF0Lm1vZGVsLFxuICAgICAgICAgICAgICAgIHNvdXJjZSA9IHRoYXQuaW5wdXRzLnNvdXJjZS5vdXRwdXQsXG4gICAgICAgICAgICAgICAgc3BmID0gbS5zcGYsXG4gICAgICAgICAgICAgICAgYnVmSWR4ID0gbS5idWZJZHgsXG4gICAgICAgICAgICAgICAgYnVmID0gbS5zY29wZS52YWx1ZXMsXG4gICAgICAgICAgICAgICAgaTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bVNhbXBzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBidWZbYnVmSWR4XSA9IHNvdXJjZVtpXTtcbiAgICAgICAgICAgICAgICBpZiAoYnVmSWR4IDwgc3BmKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZklkeCArPSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZklkeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuc2NvcGVWaWV3LnJlZnJlc2hWaWV3KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtLmJ1ZklkeCA9IGJ1ZklkeDtcbiAgICAgICAgICAgIG0udmFsdWUgPSBtLnVuc2NhbGVkVmFsdWUgPSBmbG9jay51Z2VuLmxhc3RPdXRwdXRWYWx1ZShudW1TYW1wcywgc291cmNlKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0Lm9uSW5wdXRDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gUGFzcyB0aGUgXCJzb3VyY2VcIiBpbnB1dCBkaXJlY3RseSBiYWNrIGFzIHRoZSBvdXRwdXQgZnJvbSB0aGlzIHVnZW4uXG4gICAgICAgICAgICB0aGF0Lm91dHB1dCA9IHRoYXQuaW5wdXRzLnNvdXJjZS5vdXRwdXQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5tb2RlbC5zcGYgPSBNYXRoLnJvdW5kKHRoYXQubW9kZWwuc2FtcGxlUmF0ZSAvIHRoYXQub3B0aW9ucy5mcHMpO1xuICAgICAgICAgICAgdGhhdC5tb2RlbC5idWZJZHggPSAwO1xuXG4gICAgICAgICAgICAvLyBTZXQgdXAgdGhlIHNjb3BlVmlldyB3aWRnZXQuXG4gICAgICAgICAgICB0aGF0Lm1vZGVsLnNjb3BlID0gdGhhdC5vcHRpb25zLnN0eWxlcztcbiAgICAgICAgICAgIHRoYXQubW9kZWwuc2NvcGUudmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh0aGF0Lm1vZGVsLnNwZik7XG4gICAgICAgICAgICB0aGF0LnNjb3BlVmlldyA9IGZsb2NrLnZpZXcuc2NvcGUodGhhdC5vcHRpb25zLmNhbnZhcywgdGhhdC5tb2RlbC5zY29wZSk7XG5cbiAgICAgICAgICAgIHRoYXQub25JbnB1dENoYW5nZWQoKTtcbiAgICAgICAgICAgIHRoYXQuc2NvcGVWaWV3LnJlZnJlc2hWaWV3KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5pbml0KCk7XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgIH07XG5cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsb2NrLnVnZW4uc2NvcGVcIiwge1xuICAgICAgICByYXRlOiBcImF1ZGlvXCIsXG4gICAgICAgIGlucHV0czoge1xuICAgICAgICAgICAgc291cmNlOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIHVnZW5PcHRpb25zOiB7XG4gICAgICAgICAgICBmcHM6IDYwLFxuICAgICAgICAgICAgc3R5bGVzOiB7XG4gICAgICAgICAgICAgICAgc3Ryb2tlQ29sb3I6IFwiIzc3Nzc3N1wiLFxuICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG4gICAgZmxvY2sudWdlbi5tb3VzZSA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogVHJhY2tzIHRoZSBtb3VzZSdzIHBvc2l0aW9uIGFsb25nIHRoZSBzcGVjaWZpZWQgYXhpcyB3aXRoaW4gdGhlIGJvdW5kYXJpZXMgdGhlIHdob2xlIHNjcmVlbi5cbiAgICAgKiBUaGlzIHVuaXQgZ2VuZXJhdG9yIHdpbGwgZ2VuZXJhdGUgYSBzaWduYWwgYmV0d2VlbiAwLjAgYW5kIDEuMCBiYXNlZCBvbiB0aGUgcG9zaXRpb24gb2YgdGhlIG1vdXNlO1xuICAgICAqIHVzZSB0aGUgbXVsIGFuZCBhZGQgaW5wdXRzIHRvIHNjYWxlIHRoaXMgdmFsdWUgdG8gYW4gYXBwcm9wcmlhdGUgY29udHJvbCBzaWduYWwuXG4gICAgICovXG4gICAgZmxvY2sudWdlbi5tb3VzZS5jdXJzb3IgPSBmdW5jdGlvbiAoaW5wdXRzLCBvdXRwdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHRoYXQgPSBmbG9jay51Z2VuKGlucHV0cywgb3V0cHV0LCBvcHRpb25zKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2VuZXJhdGVzIGEgY29udHJvbCByYXRlIHNpZ25hbCBiZXR3ZWVuIDAuMCBhbmQgMS4wIGJ5IHRyYWNraW5nIHRoZSBtb3VzZSdzIHBvc2l0aW9uIGFsb25nIHRoZSBzcGVjaWZpZWQgYXhpcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG51bVNhbXBzIHRoZSBudW1iZXIgb2Ygc2FtcGxlcyB0byBnZW5lcmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhhdC5leHBvbmVudGlhbEdlbiA9IGZ1bmN0aW9uIChudW1TYW1wcykge1xuICAgICAgICAgICAgdmFyIG0gPSB0aGF0Lm1vZGVsLFxuICAgICAgICAgICAgICAgIHZhbCA9IGZsb2NrLnVnZW4ubW91c2UuY3Vyc29yLm5vcm1hbGl6ZSh0aGF0LnRhcmdldCwgbSksXG4gICAgICAgICAgICAgICAgbW92aW5nQXZnID0gbS5tb3ZpbmdBdmcsXG4gICAgICAgICAgICAgICAgbGFnID0gdGhhdC5pbnB1dHMubGFnLm91dHB1dFswXSxcbiAgICAgICAgICAgICAgICBhZGQgPSB0aGF0LmlucHV0cy5hZGQub3V0cHV0WzBdLFxuICAgICAgICAgICAgICAgIG11bCA9IHRoYXQuaW5wdXRzLm11bC5vdXRwdXRbMF0sXG4gICAgICAgICAgICAgICAgbGFnQ29lZiA9IG0ubGFnQ29lZixcbiAgICAgICAgICAgICAgICBvdXQgPSB0aGF0Lm91dHB1dCxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIG1heDtcblxuICAgICAgICAgICAgaWYgKGxhZyAhPT0gbGFnQ29lZikge1xuICAgICAgICAgICAgICAgIGxhZ0NvZWYgPSBsYWcgPT09IDAgPyAwLjAgOiBNYXRoLmV4cChmbG9jay5MT0cwMDEgLyAobGFnICogbS5zYW1wbGVSYXRlKSk7XG4gICAgICAgICAgICAgICAgbS5sYWdDb2VmID0gbGFnQ29lZjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bVNhbXBzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBtYXggPSBtdWwgKyBhZGQ7XG4gICAgICAgICAgICAgICAgdmFsID0gTWF0aC5wb3cobWF4ICAvIGFkZCwgdmFsKSAqIGFkZDtcbiAgICAgICAgICAgICAgICBtb3ZpbmdBdmcgPSB2YWwgKyBsYWdDb2VmICogKG1vdmluZ0F2ZyAtIHZhbCk7IC8vIDEtcG9sZSBmaWx0ZXIgYXZlcmFnZXMgbW91c2UgdmFsdWVzLlxuICAgICAgICAgICAgICAgIG91dFtpXSA9IG1vdmluZ0F2ZztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbS5tb3ZpbmdBdmcgPSBtb3ZpbmdBdmc7XG4gICAgICAgICAgICBtLnZhbHVlID0gbS51bnNjYWxlZFZhbHVlID0gbW92aW5nQXZnO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQubGluZWFyR2VuID0gZnVuY3Rpb24gKG51bVNhbXBzKSB7XG4gICAgICAgICAgICB2YXIgbSA9IHRoYXQubW9kZWwsXG4gICAgICAgICAgICAgICAgdmFsID0gZmxvY2sudWdlbi5tb3VzZS5jdXJzb3Iubm9ybWFsaXplKHRoYXQudGFyZ2V0LCBtKSxcbiAgICAgICAgICAgICAgICBtb3ZpbmdBdmcgPSBtLm1vdmluZ0F2ZyxcbiAgICAgICAgICAgICAgICBsYWcgPSB0aGF0LmlucHV0cy5sYWcub3V0cHV0WzBdLFxuICAgICAgICAgICAgICAgIGFkZCA9IHRoYXQuaW5wdXRzLmFkZC5vdXRwdXRbMF0sXG4gICAgICAgICAgICAgICAgbXVsID0gdGhhdC5pbnB1dHMubXVsLm91dHB1dFswXSxcbiAgICAgICAgICAgICAgICBsYWdDb2VmID0gbS5sYWdDb2VmLFxuICAgICAgICAgICAgICAgIG91dCA9IHRoYXQub3V0cHV0LFxuICAgICAgICAgICAgICAgIGk7XG5cbiAgICAgICAgICAgIGlmIChsYWcgIT09IGxhZ0NvZWYpIHtcbiAgICAgICAgICAgICAgICBsYWdDb2VmID0gbGFnID09PSAwID8gMC4wIDogTWF0aC5leHAoZmxvY2suTE9HMDAxIC8gKGxhZyAqIG0uc2FtcGxlUmF0ZSkpO1xuICAgICAgICAgICAgICAgIG0ubGFnQ29lZiA9IGxhZ0NvZWY7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1TYW1wczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbW92aW5nQXZnID0gdmFsICsgbGFnQ29lZiAqIChtb3ZpbmdBdmcgLSB2YWwpO1xuICAgICAgICAgICAgICAgIG91dFtpXSA9IG1vdmluZ0F2ZyAqIG11bCArIGFkZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbS5tb3ZpbmdBdmcgPSBtLnVuc2NhbGVkVmFsdWUgPSBtb3ZpbmdBdmc7XG4gICAgICAgICAgICBtLnZhbHVlID0gZmxvY2sudWdlbi5sYXN0T3V0cHV0VmFsdWUobnVtU2FtcHMsIG91dCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5ub0ludGVycG9sYXRpb25HZW4gPSBmdW5jdGlvbiAobnVtU2FtcHMpIHtcbiAgICAgICAgICAgIHZhciBtID0gdGhhdC5tb2RlbCxcbiAgICAgICAgICAgICAgICBvdXQgPSB0aGF0Lm91dHB1dCxcbiAgICAgICAgICAgICAgICB2YWwgPSBmbG9jay51Z2VuLm1vdXNlLmN1cnNvci5ub3JtYWxpemUodGhhdC50YXJnZXQsIG0pLFxuICAgICAgICAgICAgICAgIGk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1TYW1wczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0W2ldID0gdmFsICogdGhhdC5pbnB1dHMubXVsLm91dHB1dFswXSArIHRoYXQuaW5wdXRzLmFkZC5vdXRwdXRbMF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG0udmFsdWUgPSBtLnVuc2NhbGVkVmFsdWUgPSBmbG9jay51Z2VuLmxhc3RPdXRwdXRWYWx1ZShudW1TYW1wcywgb3V0KTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0Lm1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgbSA9IHRoYXQubW9kZWw7XG4gICAgICAgICAgICBtLm1vdXNlUG9zaXRpb24gPSBlW20uZXZlbnRQcm9wXTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0Lm92ZXJMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQubW9kZWwuaXNXaXRoaW5UYXJnZXQgPSB0cnVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQub3V0TGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbSA9IHRoYXQubW9kZWw7XG4gICAgICAgICAgICBtLmlzV2l0aGluVGFyZ2V0ID0gZmFsc2U7XG4gICAgICAgICAgICBtLm1vdXNlUG9zaXRpb24gPSAwLjA7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5kb3duTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0Lm1vZGVsLmlzTW91c2VEb3duID0gdHJ1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0LnVwTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbSA9IHRoYXQubW9kZWw7XG4gICAgICAgICAgICBtLmlzTW91c2VEb3duID0gZmFsc2U7XG4gICAgICAgICAgICBtLm1vdXNlUG9zaXRpb24gPSAwO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQubW92ZVdoaWxlRG93bkxpc3RlbmVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmICh0aGF0Lm1vZGVsLmlzTW91c2VEb3duKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5tb3ZlTGlzdGVuZXIoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5iaW5kRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoYXQudGFyZ2V0LFxuICAgICAgICAgICAgICAgIG1vdmVMaXN0ZW5lciA9IHRoYXQubW92ZUxpc3RlbmVyO1xuXG4gICAgICAgICAgICBpZiAodGhhdC5vcHRpb25zLm9ubHlPbk1vdXNlRG93bikge1xuICAgICAgICAgICAgICAgIHRhcmdldC5tb3VzZWRvd24odGhhdC5kb3duTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIHRhcmdldC5tb3VzZXVwKHRoYXQudXBMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgbW92ZUxpc3RlbmVyID0gdGhhdC5tb3ZlV2hpbGVEb3duTGlzdGVuZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRhcmdldC5tb3VzZW92ZXIodGhhdC5vdmVyTGlzdGVuZXIpO1xuICAgICAgICAgICAgdGFyZ2V0Lm1vdXNlb3V0KHRoYXQub3V0TGlzdGVuZXIpO1xuICAgICAgICAgICAgdGFyZ2V0Lm1vdXNlbW92ZShtb3ZlTGlzdGVuZXIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQub25JbnB1dENoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmbG9jay5vbk11bEFkZElucHV0Q2hhbmdlZCh0aGF0KTtcblxuICAgICAgICAgICAgdmFyIGludGVycCA9IHRoYXQub3B0aW9ucy5pbnRlcnBvbGF0aW9uO1xuICAgICAgICAgICAgdGhhdC5nZW4gPSBpbnRlcnAgPT09IFwibm9uZVwiID8gdGhhdC5ub0ludGVycG9sYXRpb25HZW4gOlxuICAgICAgICAgICAgICAgIGludGVycCA9PT0gXCJleHBvbmVudGlhbFwiID8gdGhhdC5leHBvbmVudGlhbEdlbiA6IHRoYXQubGluZWFyR2VuO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtID0gdGhhdC5tb2RlbCxcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gdGhhdC5vcHRpb25zLFxuICAgICAgICAgICAgICAgIGF4aXMgPSBvcHRpb25zLmF4aXMsXG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gJChvcHRpb25zLnRhcmdldCB8fCB3aW5kb3cpO1xuXG4gICAgICAgICAgICBpZiAoYXhpcyA9PT0gXCJ4XCIgfHwgYXhpcyA9PT0gXCJ3aWR0aFwiIHx8IGF4aXMgPT09IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICAgICAgICAgICAgbS5ldmVudFByb3AgPSBcImNsaWVudFhcIjtcbiAgICAgICAgICAgICAgICBtLm9mZnNldFByb3AgPSBcImxlZnRcIjtcbiAgICAgICAgICAgICAgICBtLmRpbWVuc2lvbiA9IFwid2lkdGhcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbS5ldmVudFByb3AgPSBcImNsaWVudFlcIjtcbiAgICAgICAgICAgICAgICBtLm9mZnNldFByb3AgPSBcInRvcFwiO1xuICAgICAgICAgICAgICAgIG0uZGltZW5zaW9uID0gXCJoZWlnaHRcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhhdC50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgICAgICBtLm1vdXNlUG9zaXRpb24gPSAwO1xuICAgICAgICAgICAgbS5tb3ZpbmdBdmcgPSAwO1xuXG4gICAgICAgICAgICB0aGF0LmJpbmRFdmVudHMoKTtcbiAgICAgICAgICAgIHRoYXQub25JbnB1dENoYW5nZWQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0LmluaXQoKTtcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfTtcblxuICAgIGZsb2NrLnVnZW4ubW91c2UuY3Vyc29yLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uICh0YXJnZXQsIG0pIHtcbiAgICAgICAgaWYgKCFtLmlzV2l0aGluVGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gMC4wO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNpemUgPSB0YXJnZXRbbS5kaW1lbnNpb25dKCksXG4gICAgICAgICAgICBvZmZzZXQgPSB0YXJnZXQub2Zmc2V0KCksXG4gICAgICAgICAgICBwb3MgPSBtLm1vdXNlUG9zaXRpb247XG5cbiAgICAgICAgaWYgKG9mZnNldCkge1xuICAgICAgICAgICAgcG9zIC09IG9mZnNldFttLm9mZnNldFByb3BdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvcyAvIHNpemU7XG4gICAgfTtcblxuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmxvY2sudWdlbi5tb3VzZS5jdXJzb3JcIiwge1xuICAgICAgICByYXRlOiBcImNvbnRyb2xcIixcbiAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICBsYWc6IDAuNSxcbiAgICAgICAgICAgIGFkZDogMC4wLFxuICAgICAgICAgICAgbXVsOiAxLjBcbiAgICAgICAgfSxcblxuICAgICAgICB1Z2VuT3B0aW9uczoge1xuICAgICAgICAgICAgYXhpczogXCJ4XCIsXG4gICAgICAgICAgICBpbnRlcnBvbGF0aW9uOiBcImxpbmVhclwiLFxuICAgICAgICAgICAgbW9kZWw6IHtcbiAgICAgICAgICAgICAgICBtb3VzZVBvc2l0aW9uOiAwLFxuICAgICAgICAgICAgICAgIG1vdmluZ0F2ZzogMCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogMC4wXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG4gICAgZmxvY2sudWdlbi5tb3VzZS5jbGljayA9IGZ1bmN0aW9uIChpbnB1dHMsIG91dHB1dCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgdGhhdCA9IGZsb2NrLnVnZW4oaW5wdXRzLCBvdXRwdXQsIG9wdGlvbnMpO1xuXG4gICAgICAgIHRoYXQuZ2VuID0gZnVuY3Rpb24gKG51bVNhbXBzKSB7XG4gICAgICAgICAgICB2YXIgb3V0ID0gdGhhdC5vdXRwdXQsXG4gICAgICAgICAgICAgICAgbSA9IHRoYXQubW9kZWwsXG4gICAgICAgICAgICAgICAgaTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bVNhbXBzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvdXRbaV0gPSBtLnVuc2NhbGVkVmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoYXQubXVsQWRkKG51bVNhbXBzKTtcbiAgICAgICAgICAgIG0udmFsdWUgPSBmbG9jay51Z2VuLmxhc3RPdXRwdXRWYWx1ZShudW1TYW1wcywgb3V0KTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0Lm1vdXNlRG93bkxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5tb2RlbC51bnNjYWxlZFZhbHVlID0gMS4wO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQubW91c2VVcExpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5tb2RlbC51bnNjYWxlZFZhbHVlID0gMC4wO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtID0gdGhhdC5tb2RlbDtcbiAgICAgICAgICAgIG0udGFyZ2V0ID0gIXRoYXQub3B0aW9ucy50YXJnZXQgPyAkKHdpbmRvdykgOiAkKHRoYXQub3B0aW9ucy50YXJnZXQpO1xuXG4gICAgICAgICAgICBtLnRhcmdldC5tb3VzZWRvd24odGhhdC5tb3VzZURvd25MaXN0ZW5lcik7XG4gICAgICAgICAgICBtLnRhcmdldC5tb3VzZXVwKHRoYXQubW91c2VVcExpc3RlbmVyKTtcblxuICAgICAgICAgICAgdGhhdC5vbklucHV0Q2hhbmdlZCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoYXQub25JbnB1dENoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmbG9jay5vbk11bEFkZElucHV0Q2hhbmdlZCh0aGF0KTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0LmluaXQoKTtcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfTtcblxuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmxvY2sudWdlbi5tb3VzZS5jbGlja1wiLCB7XG4gICAgICAgIHJhdGU6IFwiY29udHJvbFwiXG4gICAgfSk7XG5cblxuICAgIGZsb2NrLnVnZW4ubWVkaWFJbiA9IGZ1bmN0aW9uIChpbnB1dHMsIG91dHB1dCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgdGhhdCA9IGZsb2NrLnVnZW4oaW5wdXRzLCBvdXRwdXQsIG9wdGlvbnMpO1xuXG4gICAgICAgIHRoYXQuZ2VuID0gZnVuY3Rpb24gKG51bVNhbXBzKSB7XG4gICAgICAgICAgICB2YXIgbSA9IHRoYXQubW9kZWwsXG4gICAgICAgICAgICAgICAgb3V0ID0gdGhhdC5vdXRwdXQsXG4gICAgICAgICAgICAgICAgYnVzID0gdGhhdC5idXMsXG4gICAgICAgICAgICAgICAgdmFsO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVNhbXBzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvdXRbaV0gPSB2YWwgPSBidXNbaV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG0udW5zY2FsZWRWYWx1ZSA9IHZhbDtcbiAgICAgICAgICAgIHRoYXQubXVsQWRkKG51bVNhbXBzKTtcbiAgICAgICAgICAgIG0udmFsdWUgPSBmbG9jay51Z2VuLmxhc3RPdXRwdXRWYWx1ZShudW1TYW1wcywgb3V0KTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0Lm9uSW5wdXRDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZmxvY2sub25NdWxBZGRJbnB1dENoYW5nZWQodGhhdCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGVudmlybyA9IGZsb2NrLmVudmlyby5zaGFyZWQsXG4gICAgICAgICAgICAgICAgbWVkaWFFbCA9ICQodGhhdC5vcHRpb25zLmVsZW1lbnQpLFxuICAgICAgICAgICAgICAgIC8vIFRPRE86IERpcmVjdCByZWZlcmVuY2UgdG8gdGhlIHNoYXJlZCBlbnZpcm9ubWVudC5cbiAgICAgICAgICAgICAgICBidXNOdW0gPSBlbnZpcm8uYXVkaW9TdHJhdGVneS5uYXRpdmVOb2RlTWFuYWdlci5jcmVhdGVNZWRpYUVsZW1lbnRJbnB1dChtZWRpYUVsWzBdKTtcblxuICAgICAgICAgICAgdGhhdC5idXMgPSB0aGF0Lm9wdGlvbnMuYXVkaW9TZXR0aW5ncy5idXNlc1tidXNOdW1dO1xuICAgICAgICAgICAgdGhhdC5vbklucHV0Q2hhbmdlZCgpO1xuXG4gICAgICAgICAgICAvLyBUT0RPOiBSZW1vdmUgdGhpcyB3YXJuaW5nIHdoZW4gU2FmYXJpIGFuZCBBbmRyb2lkXG4gICAgICAgICAgICAvLyBmaXggdGhlaXIgTWVkaWFFbGVtZW50QXVkaW9Tb3VyY2VOb2RlIGltcGxlbWVudGF0aW9ucy5cbiAgICAgICAgICAgIGlmIChmbG9jay5wbGF0Zm9ybS5icm93c2VyLnNhZmFyaSkge1xuICAgICAgICAgICAgICAgIGZsb2NrLmxvZy53YXJuKFwiTWVkaWFFbGVtZW50U291cmNlTm9kZSBkb2VzIG5vdCB3b3JrIG9uIFNhZmFyaS4gXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIkZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTg0NzQzIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJhbmQgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEyNTAzMVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZmxvY2sucGxhdGZvcm0uaXNBbmRyb2lkKSB7XG4gICAgICAgICAgICAgICAgZmxvY2subG9nLndhcm4oXCJNZWRpYUVsZW1lbnRTb3VyY2VOb2RlIGRvZXMgbm90IHdvcmsgb24gQW5kcm9pZC4gXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIkZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQxOTQ0NlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0LmluaXQoKTtcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfTtcblxuICAgIGZsdWlkLmRlZmF1bHRzKFwiZmxvY2sudWdlbi5tZWRpYUluXCIsIHtcbiAgICAgICAgcmF0ZTogXCJhdWRpb1wiLFxuICAgICAgICBpbnB1dHM6IHtcbiAgICAgICAgICAgIG11bDogbnVsbCxcbiAgICAgICAgICAgIGFkZDogbnVsbFxuICAgICAgICB9LFxuICAgICAgICB1Z2VuT3B0aW9uczoge1xuICAgICAgICAgICAgZWxlbWVudDogXCJhdWRpb1wiXG4gICAgICAgIH1cbiAgICB9KTtcbn0oKSk7XG47LyohXG4qIEZsb2NraW5nIC0gQ3JlYXRpdmUgYXVkaW8gc3ludGhlc2lzIGZvciB0aGUgV2ViIVxuKiBodHRwOi8vZ2l0aHViLmNvbS9jb2xpbmJkY2xhcmsvZmxvY2tpbmdcbipcbiogQ29weXJpZ2h0IDIwMTEtMjAxNCwgQ29saW4gQ2xhcmtcbiogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIG9yIEdQTCBWZXJzaW9uIDIgbGljZW5zZXMuXG4qL1xuXG4vKmdsb2JhbCByZXF1aXJlKi9cbi8qanNoaW50IHdoaXRlOiBmYWxzZSwgbmV3Y2FwOiB0cnVlLCByZWdleHA6IHRydWUsIGJyb3dzZXI6IHRydWUsXG4gICAgZm9yaW46IGZhbHNlLCBub21lbjogdHJ1ZSwgYml0d2lzZTogZmFsc2UsIG1heGVycjogMTAwLFxuICAgIGluZGVudDogNCwgcGx1c3BsdXM6IGZhbHNlLCBjdXJseTogdHJ1ZSwgZXFlcWVxOiB0cnVlLFxuICAgIGZyZWV6ZTogdHJ1ZSwgbGF0ZWRlZjogdHJ1ZSwgbm9hcmc6IHRydWUsIG5vbmV3OiB0cnVlLCBxdW90bWFyazogZG91YmxlLCB1bmRlZjogdHJ1ZSxcbiAgICB1bnVzZWQ6IHRydWUsIHN0cmljdDogdHJ1ZSwgYXNpOiBmYWxzZSwgYm9zczogZmFsc2UsIGV2aWw6IGZhbHNlLCBleHByOiBmYWxzZSxcbiAgICBmdW5jc2NvcGU6IGZhbHNlKi9cblxudmFyIGZsdWlkID0gZmx1aWQgfHwgcmVxdWlyZShcImluZnVzaW9uXCIpLFxuICAgIGZsb2NrID0gZmx1aWQucmVnaXN0ZXJOYW1lc3BhY2UoXCJmbG9ja1wiKTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBcbiAgICBmbHVpZC5yZWdpc3Rlck5hbWVzcGFjZShcImZsb2NrLnZpZXdcIik7XG4gICAgXG4gICAgLy8gVE9ETzogSW5mdXNpb25pemUuXG4gICAgZmxvY2sudmlldy5zY29wZSA9IGZ1bmN0aW9uIChjYW52YXMsIG1vZGVsKSB7XG4gICAgICAgIHZhciB0aGF0ID0ge1xuICAgICAgICAgICAgbW9kZWw6IG1vZGVsIHx8IHtcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IFtdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2FudmFzOiB0eXBlb2YgKGNhbnZhcykgPT09IFwic3RyaW5nXCIgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGNhbnZhcykgOiBjYW52YXNcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHRoYXQucmVmcmVzaFZpZXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhhdC5jdHgsXG4gICAgICAgICAgICAgICAgaCA9IHRoYXQubW9kZWwuaGVpZ2h0LFxuICAgICAgICAgICAgICAgIGhhbGZIID0gdGhhdC5tb2RlbC5oYWxmSGVpZ2h0LFxuICAgICAgICAgICAgICAgIHcgPSB0aGF0Lm1vZGVsLndpZHRoLFxuICAgICAgICAgICAgICAgIHZhbHMgPSB0aGF0Lm1vZGVsLnZhbHVlcyxcbiAgICAgICAgICAgICAgICBsZW4gPSB2YWxzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBzY2FsZVggPSB0aGF0Lm1vZGVsLnNjYWxlWCAqICh3IC8gbGVuKSwgLy8gVE9ETzogRG9lc24ndCBzdXBwb3J0IHNjYWxlIHZhbHVlcyA8IDEuMFxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICB5O1xuICAgICAgICBcbiAgICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgdywgaCk7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB4ID0gaSAqIHNjYWxlWDtcbiAgICAgICAgICAgICAgICB5ID0gdmFsc1tpXSAqIHRoYXQubW9kZWwuc2NhbGVZICogaGFsZkggKyBoYWxmSDtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgdGhhdC5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5jdHggPSB0aGF0LmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgICAgICB0aGF0LmN0eC5maWxsU3R5bGUgPSB0aGF0Lm1vZGVsLmZpbGwgfHwgdGhhdC5jdHguZmlsbFN0eWxlO1xuICAgICAgICAgICAgdGhhdC5jdHguc3Ryb2tlU3R5bGUgPSB0aGF0Lm1vZGVsLnN0cm9rZUNvbG9yIHx8IHRoYXQuY3R4LnN0cm9rZVN0eWxlO1xuICAgICAgICAgICAgdGhhdC5jdHgubGluZVdpZHRoID0gdGhhdC5tb2RlbC5zdHJva2VXaWR0aCB8fCB0aGF0LmN0eC5saW5lV2lkdGg7XG4gICAgICAgIFxuICAgICAgICAgICAgdGhhdC5tb2RlbC5taW4gPSB0aGF0Lm1vZGVsLm1pbiB8fCAtMS4wO1xuICAgICAgICAgICAgdGhhdC5tb2RlbC5tYXggPSB0aGF0Lm1vZGVsLm1heCB8fCAxLjA7XG4gICAgICAgICAgICB0aGF0Lm1vZGVsLmhlaWdodCA9IHRoYXQuY2FudmFzLmhlaWdodDtcbiAgICAgICAgICAgIHRoYXQubW9kZWwuaGFsZkhlaWdodCA9IHRoYXQubW9kZWwuaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgIHRoYXQubW9kZWwud2lkdGggPSB0aGF0LmNhbnZhcy53aWR0aDtcbiAgICAgICAgICAgIHRoYXQubW9kZWwuc2NhbGVYID0gdGhhdC5tb2RlbC5zY2FsZVggfHwgdGhhdC5tb2RlbC5zY2FsZSB8fCAxLjA7XG4gICAgICAgICAgICB0aGF0Lm1vZGVsLnNjYWxlWSA9IHRoYXQubW9kZWwuc2NhbGVZIHx8IHRoYXQubW9kZWwuc2NhbGUgfHwgMS4wO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGF0LnJlZnJlc2hWaWV3KCk7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICB0aGF0LmluaXQoKTtcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfTtcbiAgICBcbn0oKSk7XG47LypcbiAqIEZsb2NraW5nIE1JRElcbiAqIGh0dHA6Ly9naXRodWIuY29tL2NvbGluYmRjbGFyay9mbG9ja2luZ1xuICpcbiAqIENvcHlyaWdodCAyMDE0LCBDb2xpbiBDbGFya1xuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGFuZCBHUEwgVmVyc2lvbiAyIGxpY2Vuc2VzLlxuICovXG5cbi8qZ2xvYmFsIHJlcXVpcmUsIFByb21pc2UsIGNvbnNvbGUqL1xuLypqc2hpbnQgd2hpdGU6IGZhbHNlLCBuZXdjYXA6IHRydWUsIHJlZ2V4cDogdHJ1ZSwgYnJvd3NlcjogdHJ1ZSxcbiAgICBmb3JpbjogZmFsc2UsIG5vbWVuOiB0cnVlLCBiaXR3aXNlOiBmYWxzZSwgbWF4ZXJyOiAxMDAsXG4gICAgaW5kZW50OiA0LCBwbHVzcGx1czogZmFsc2UsIGN1cmx5OiB0cnVlLCBlcWVxZXE6IHRydWUsXG4gICAgZnJlZXplOiB0cnVlLCBsYXRlZGVmOiB0cnVlLCBub2FyZzogdHJ1ZSwgbm9uZXc6IHRydWUsIHF1b3RtYXJrOiBkb3VibGUsIHVuZGVmOiB0cnVlLFxuICAgIHVudXNlZDogdHJ1ZSwgc3RyaWN0OiB0cnVlLCBhc2k6IGZhbHNlLCBib3NzOiBmYWxzZSwgZXZpbDogZmFsc2UsIGV4cHI6IGZhbHNlLFxuICAgIGZ1bmNzY29wZTogZmFsc2UqL1xuXG52YXIgZmx1aWQgPSBmbHVpZCB8fCByZXF1aXJlKFwiaW5mdXNpb25cIiksXG4gICAgZmxvY2sgPSBmbHVpZC5yZWdpc3Rlck5hbWVzcGFjZShcImZsb2NrXCIpO1xuXG4oZnVuY3Rpb24gKCkge1xuXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBmbHVpZC5yZWdpc3Rlck5hbWVzcGFjZShcImZsb2NrLm1pZGlcIik7XG5cbiAgICBmbG9jay5taWRpLnJlcXVlc3RBY2Nlc3MgPSBmdW5jdGlvbiAoc3lzZXgsIG9uQWNjZXNzR3JhbnRlZCwgb25FcnJvcikge1xuICAgICAgICBpZiAoIW5hdmlnYXRvci5yZXF1ZXN0TUlESUFjY2Vzcykge1xuICAgICAgICAgICAgdmFyIG1zZyA9IFwiVGhlIFdlYiBNSURJIEFQSSBpcyBub3QgYXZhaWxhYmxlLiBZb3UgbWF5IG5lZWQgdG8gZW5hYmxlIGl0IGluIHlvdXIgYnJvd3NlcidzIHNldHRpbmdzLlwiO1xuICAgICAgICAgICAgZmx1aWQubG9nKGZsdWlkLmxvZ0xldmVsLldBUk4sIG1zZyk7XG4gICAgICAgICAgICBvbkVycm9yKG1zZyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcCA9IG5hdmlnYXRvci5yZXF1ZXN0TUlESUFjY2Vzcyh7XG4gICAgICAgICAgICBzeXNleDogc3lzZXhcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcC50aGVuKG9uQWNjZXNzR3JhbnRlZCwgb25FcnJvcik7XG4gICAgfTtcblxuICAgIGZsb2NrLm1pZGkuZ2V0UG9ydHMgPSBmdW5jdGlvbiAoYWNjZXNzKSB7XG4gICAgICAgIHZhciBwb3J0cyA9IHt9LFxuICAgICAgICAgICAgcG9ydENvbGxlY3RvciA9IHR5cGVvZiBhY2Nlc3MuaW5wdXRzID09PSBcImZ1bmN0aW9uXCIgP1xuICAgICAgICAgICAgICAgIGZsb2NrLm1pZGkuY29sbGVjdFBvcnRzTGVnYWN5IDogZmxvY2subWlkaS5jb2xsZWN0UG9ydHM7XG5cbiAgICAgICAgcG9ydENvbGxlY3RvcihcImlucHV0c1wiLCBhY2Nlc3MsIHBvcnRzKTtcbiAgICAgICAgcG9ydENvbGxlY3RvcihcIm91dHB1dHNcIiwgYWNjZXNzLCBwb3J0cyk7XG5cbiAgICAgICAgcmV0dXJuIHBvcnRzO1xuICAgIH07XG5cbiAgICBmbG9jay5taWRpLnJlcXVlc3RQb3J0cyA9IGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICBmdW5jdGlvbiB3cmFwcGVkU3VjY2VzcyAoYWNjZXNzKSB7XG4gICAgICAgICAgICB2YXIgcG9ydHMgPSBmbG9jay5taWRpLmdldFBvcnRzKGFjY2Vzcyk7XG4gICAgICAgICAgICBzdWNjZXNzKHBvcnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZsb2NrLm1pZGkucmVxdWVzdEFjY2VzcyhmYWxzZSwgd3JhcHBlZFN1Y2Nlc3MsIGVycm9yKTtcbiAgICB9O1xuXG4gICAgZmxvY2subWlkaS5jcmVhdGVQb3J0Vmlld3MgPSBmdW5jdGlvbiAocG9ydHNBcnJheSkge1xuICAgICAgICByZXR1cm4gZmx1aWQudHJhbnNmb3JtKHBvcnRzQXJyYXksIGZ1bmN0aW9uIChwb3J0KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlkOiBwb3J0LmlkLFxuICAgICAgICAgICAgICAgIG5hbWU6IHBvcnQubmFtZSxcbiAgICAgICAgICAgICAgICBtYW51ZmFjdHVyZXI6IHBvcnQubWFudWZhY3R1cmVyLFxuICAgICAgICAgICAgICAgIHN0YXRlOiBwb3J0LnN0YXRlLFxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb246IHBvcnQuY29ubmVjdGlvblxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZsb2NrLm1pZGkucHJldHR5UHJpbnRQb3J0cyA9IGZ1bmN0aW9uIChwb3J0cykge1xuICAgICAgICByZXR1cm4gZmx1aWQucHJldHR5UHJpbnRKU09OKHtcbiAgICAgICAgICAgIGlucHV0czogZmxvY2subWlkaS5jcmVhdGVQb3J0Vmlld3MocG9ydHMuaW5wdXRzKSxcbiAgICAgICAgICAgIG91dHB1dHM6IGZsb2NrLm1pZGkuY3JlYXRlUG9ydFZpZXdzKHBvcnRzLm91dHB1dHMpXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmbG9jay5taWRpLmxvZ1BvcnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBzdWNjZXNzIChwb3J0cykge1xuICAgICAgICAgICAgdmFyIHByaW50ZWQgPSBmbG9jay5taWRpLnByZXR0eVByaW50UG9ydHMocG9ydHMpO1xuICAgICAgICAgICAgY29uc29sZS5sb2cocHJpbnRlZCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBlcnJvciAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZmxvY2subWlkaS5yZXF1ZXN0UG9ydHMoc3VjY2VzcywgZXJyb3IpO1xuICAgIH07XG5cbiAgICBmbG9jay5taWRpLmNvbGxlY3RQb3J0cyA9IGZ1bmN0aW9uICh0eXBlLCBhY2Nlc3MsIHBvcnRzKSB7XG4gICAgICAgIHZhciBwb3J0c0ZvclR5cGUgPSBwb3J0c1t0eXBlXSA9IHBvcnRzW3R5cGVdIHx8IFtdLFxuICAgICAgICAgICAgaXRlcmF0b3IgPSBhY2Nlc3NbdHlwZV0udmFsdWVzKCk7XG5cbiAgICAgICAgLy8gVE9ETzogU3dpdGNoIHRvIEVTNiBmb3IuLm9mIHN5bnRheCB3aGVuIGl0J3Mgc2FmZSB0byBkbyBzb1xuICAgICAgICAvLyBhY3Jvc3MgYWxsIHN1cHBvcnRlZCBGbG9ja2luZyBlbnZpcm9ubWVudHNcbiAgICAgICAgLy8gKGkuZS4gd2hlbiBOb2RlLmpzIGFuZCBldmVudHVhbGx5IElFIHN1cHBvcnQgaXQpLlxuICAgICAgICB2YXIgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgd2hpbGUgKCFuZXh0LmRvbmUpIHtcbiAgICAgICAgICAgIHBvcnRzRm9yVHlwZS5wdXNoKG5leHQudmFsdWUpO1xuICAgICAgICAgICAgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb3J0cztcbiAgICB9O1xuXG4gICAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgd2hlbiB0aGUgbmV3IFdlYiBNSURJIEFQSSBtYWtlcyBpdFxuICAgIC8vIGludG8gdGhlIENocm9tZSByZWxlYXNlIGNoYW5uZWwuXG4gICAgZmxvY2subWlkaS5jb2xsZWN0UG9ydHNMZWdhY3kgPSBmdW5jdGlvbiAodHlwZSwgYWNjZXNzLCBwb3J0cykge1xuICAgICAgICBpZiAoYWNjZXNzW3R5cGVdKSB7XG4gICAgICAgICAgICBwb3J0c1t0eXBlXSA9IGFjY2Vzc1t0eXBlXSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvcnRzO1xuICAgIH07XG5cbiAgICBmbG9jay5taWRpLnJlYWQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgc3RhdHVzID0gZGF0YVswXSxcbiAgICAgICAgICAgIHR5cGUgPSBzdGF0dXMgPj4gNCxcbiAgICAgICAgICAgIGNoYW4gPSBzdGF0dXMgJiAweGYsXG4gICAgICAgICAgICBmbjtcblxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICBmbiA9IGZsb2NrLm1pZGkucmVhZC5ub3RlT2ZmO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgIGZuID0gZGF0YVsyXSA+IDAgPyBmbG9jay5taWRpLnJlYWQubm90ZU9uIDogZmxvY2subWlkaS5yZWFkLm5vdGVPZmY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgIGZuID0gZmxvY2subWlkaS5yZWFkLnBvbHlBZnRlcnRvdWNoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICBmbiA9IGZsb2NrLm1pZGkucmVhZC5jb250cm9sQ2hhbmdlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICBmbiA9IGZsb2NrLm1pZGkucmVhZC5wcm9ncmFtQ2hhbmdlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICBmbiA9IGZsb2NrLm1pZGkucmVhZC5jaGFubmVsQWZ0ZXJ0b3VjaDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgZm4gPSBmbG9jay5taWRpLnJlYWQucGl0Y2hiZW5kO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICBmbiA9IGZsb2NrLm1pZGkucmVhZC5zeXNleDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVjaWV2ZWQgYW4gdW5yZWNvZ25pemVkIE1JREkgbWVzc2FnZTogXCIgKyBkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmbihjaGFuLCBkYXRhKTtcbiAgICB9O1xuXG4gICAgZmxvY2subWlkaS5yZWFkLm5vdGUgPSBmdW5jdGlvbiAodHlwZSwgY2hhbiwgZGF0YSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIGNoYW46IGNoYW4sXG4gICAgICAgICAgICBub3RlOiBkYXRhWzFdLFxuICAgICAgICAgICAgdmVsb2NpdHk6IGRhdGFbMl1cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgZmxvY2subWlkaS5yZWFkLm5vdGVPbiA9IGZ1bmN0aW9uIChjaGFuLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiBmbG9jay5taWRpLnJlYWQubm90ZShcIm5vdGVPblwiLCBjaGFuLCBkYXRhKTtcbiAgICB9O1xuXG4gICAgZmxvY2subWlkaS5yZWFkLm5vdGVPZmYgPSBmdW5jdGlvbiAoY2hhbiwgZGF0YSkge1xuICAgICAgICByZXR1cm4gZmxvY2subWlkaS5yZWFkLm5vdGUoXCJub3RlT2ZmXCIsIGNoYW4sIGRhdGEpO1xuICAgIH07XG5cbiAgICBmbG9jay5taWRpLnJlYWQucG9seUFmdGVydG91Y2ggPSBmdW5jdGlvbiAoY2hhbiwgZGF0YSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJhZnRlcnRvdWNoXCIsXG4gICAgICAgICAgICBjaGFuOiBjaGFuLFxuICAgICAgICAgICAgbm90ZTogZGF0YVsxXSxcbiAgICAgICAgICAgIHByZXNzdXJlOiBkYXRhWzJdXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIGZsb2NrLm1pZGkucmVhZC5jb250cm9sQ2hhbmdlID0gZnVuY3Rpb24gKGNoYW4sIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiY29udHJvbFwiLFxuICAgICAgICAgICAgY2hhbjogY2hhbixcbiAgICAgICAgICAgIG51bWJlcjogZGF0YVsxXSxcbiAgICAgICAgICAgIHZhbHVlOiBkYXRhWzJdXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIGZsb2NrLm1pZGkucmVhZC5wcm9ncmFtQ2hhbmdlID0gZnVuY3Rpb24gKGNoYW4sIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwicHJvZ3JhbVwiLFxuICAgICAgICAgICAgY2hhbjogY2hhbixcbiAgICAgICAgICAgIHByb2dyYW06IGRhdGFbMV1cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgZmxvY2subWlkaS5yZWFkLmNoYW5uZWxBZnRlcnRvdWNoID0gZnVuY3Rpb24gKGNoYW4sIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiYWZ0ZXJ0b3VjaFwiLFxuICAgICAgICAgICAgY2hhbjogY2hhbixcbiAgICAgICAgICAgIHByZXNzdXJlOiBkYXRhWzFdXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIGZsb2NrLm1pZGkucmVhZC5waXRjaGJlbmQgPSBmdW5jdGlvbiAoY2hhbiwgZGF0YSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJwaXRjaGJlbmRcIixcbiAgICAgICAgICAgIGNoYW46IGNoYW4sXG4gICAgICAgICAgICB2YWx1ZTogKGRhdGFbMV0gPDwgNykgfCBkYXRhWzJdXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIGZsb2NrLm1pZGkucmVhZC5zeXNleCA9IGZ1bmN0aW9uIChjaGFuLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcInN5c3RlbVwiLFxuICAgICAgICAgICAgY2hhbjogY2hhbixcbiAgICAgICAgICAgIGRhdGE6IGRhdGEuc3ViYXJyYXkoMSlcbiAgICAgICAgfTtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIHRoZSBvdmVyYWxsIFdlYiBNSURJIHN5c3RlbSxcbiAgICAgKiBpbmNsdWRpbmcgcmVmZXJlbmNlcyB0byBhbGwgdGhlIGF2YWlsYWJsZSBNSURJIHBvcnRzXG4gICAgICogYW5kIHRoZSBNSURJQWNjZXNzIG9iamVjdC5cbiAgICAgKi9cbiAgICBmbHVpZC5kZWZhdWx0cyhcImZsb2NrLm1pZGkuc3lzdGVtXCIsIHtcbiAgICAgICAgZ3JhZGVOYW1lczogW1wiZmx1aWQuZXZlbnRlZENvbXBvbmVudFwiLCBcImF1dG9Jbml0XCJdLFxuXG4gICAgICAgIHN5c2V4OiBmYWxzZSxcblxuICAgICAgICBtZW1iZXJzOiB7XG4gICAgICAgICAgICBhY2Nlc3M6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHBvcnRzOiB1bmRlZmluZWRcbiAgICAgICAgfSxcblxuICAgICAgICBpbnZva2Vyczoge1xuICAgICAgICAgICAgcmVxdWVzdEFjY2Vzczoge1xuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcImZsb2NrLm1pZGkucmVxdWVzdEFjY2Vzc1wiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICAgICAgXCJ7dGhhdH0ub3B0aW9ucy5zeXNleFwiLFxuICAgICAgICAgICAgICAgICAgICBcInt0aGF0fS5ldmVudHMub25BY2Nlc3NHcmFudGVkLmZpcmVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ7dGhhdH0uZXZlbnRzLm9uQWNjZXNzRXJyb3IuZmlyZVwiXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcmVmcmVzaFBvcnRzOiB7XG4gICAgICAgICAgICAgICAgZnVuY05hbWU6IFwiZmxvY2subWlkaS5zeXN0ZW0ucmVmcmVzaFBvcnRzXCIsXG4gICAgICAgICAgICAgICAgYXJnczogW1wie3RoYXR9XCIsIFwie3RoYXR9LmFjY2Vzc1wiXVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGV2ZW50czoge1xuICAgICAgICAgICAgb25BY2Nlc3NHcmFudGVkOiBudWxsLFxuICAgICAgICAgICAgb25BY2Nlc3NFcnJvcjogbnVsbCxcbiAgICAgICAgICAgIG9uUmVhZHk6IG51bGxcbiAgICAgICAgfSxcblxuICAgICAgICBsaXN0ZW5lcnM6IHtcbiAgICAgICAgICAgIG9uQ3JlYXRlOiB7XG4gICAgICAgICAgICAgICAgZnVuYzogXCJ7dGhhdH0ucmVxdWVzdEFjY2Vzc1wiXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBvbkFjY2Vzc0dyYW50ZWQ6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcImZsb2NrLm1pZGkuc3lzdGVtLnNldEFjY2Vzc1wiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXCJ7dGhhdH1cIiwgXCJ7YXJndW1lbnRzfS4wXCJdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmM6IFwie3RoYXR9LnJlZnJlc2hQb3J0c1wiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmM6IFwie3RoYXR9LmV2ZW50cy5vblJlYWR5LmZpcmVcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogXCJ7dGhhdH0ucG9ydHNcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG5cbiAgICAgICAgICAgIG9uQWNjZXNzRXJyb3I6IHtcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJmbHVpZC5sb2dcIixcbiAgICAgICAgICAgICAgICBhcmdzOiBbZmx1aWQubG9nTGV2ZWwuV0FSTiwgXCJNSURJIEFjY2VzcyBFcnJvcjogXCIsIFwie2FyZ3VtZW50c30uMFwiXVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBmbG9jay5taWRpLnN5c3RlbS5zZXRBY2Nlc3MgPSBmdW5jdGlvbiAodGhhdCwgYWNjZXNzKSB7XG4gICAgICAgIHRoYXQuYWNjZXNzID0gYWNjZXNzO1xuICAgIH07XG5cbiAgICBmbG9jay5taWRpLnN5c3RlbS5yZWZyZXNoUG9ydHMgPSBmdW5jdGlvbiAodGhhdCwgYWNjZXNzKSB7XG4gICAgICAgIHRoYXQucG9ydHMgPSBmbG9jay5taWRpLmdldFBvcnRzKGFjY2Vzcyk7XG4gICAgfTtcblxuXG4gICAgLypcbiAgICAgKiBBIE1JREkgQ29ubmVjdGlvbiByZXByZXNlbnRzIGEgY29ubmVjdGlvbiBiZXR3ZWVuIGFuIGFyYml0cmFyeSBzZXQgb2ZcbiAgICAgKiBpbnB1dCBhbmQgb3V0cHV0IHBvcnRzIGFjcm9zcyBvbmUgb3IgbW9yZSBNSURJIGRldmljZXMgY29ubmVjdGVkIHRvIHRoZSBzeXN0ZW0uXG4gICAgICovXG4gICAgLy8gVE9ETzogSGFuZGxlIHBvcnQgZGlzY29ubmVjdGlvbiBldmVudHMuXG4gICAgZmx1aWQuZGVmYXVsdHMoXCJmbG9jay5taWRpLmNvbm5lY3Rpb25cIiwge1xuICAgICAgICBncmFkZU5hbWVzOiBbXCJmbHVpZC5ldmVudGVkQ29tcG9uZW50XCIsIFwiYXV0b0luaXRcIl0sXG5cbiAgICAgICAgb3BlbkltbWVkaWF0ZWx5OiBmYWxzZSxcblxuICAgICAgICBzeXNleDogZmFsc2UsXG5cbiAgICAgICAgZGlzdHJpYnV0ZU9wdGlvbnM6IHtcbiAgICAgICAgICAgIHNvdXJjZTogXCJ7dGhhdH0ub3B0aW9ucy5zeXNleFwiLFxuICAgICAgICAgICAgdGFyZ2V0OiBcInt0aGF0ID4gc3lzdGVtfS5vcHRpb25zLnN5c2V4XCJcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBTdXBwb3J0ZWQgUG9ydFNwZWMgZm9ybWF0czpcbiAgICAgICAgLy8gIC0gTnVtYmVyOiB0aGUgaW5kZXggb2YgdGhlIGlucHV0IGFuZCBvdXRwdXQgcG9ydCB0byB1c2UgKHRoaXMgaXMgdGhlIGRlZmF1bHQpXG4gICAgICAgIC8vICAtIHsgbWFudWZhY3R1cmVyOiBcImFrYWlcIiwgbmFtZTogXCJMUEQ4XCJ9XG4gICAgICAgIC8vICAtIHsgaW5wdXQ6IE51bWJlciwgb3V0cHV0OiBOdW1iZXJ9XG4gICAgICAgIC8vICAtIHsgaW5wdXQ6IHsgbWFudWZhY3R1cmVyOiBcImFrYWlcIiwgbmFtZTogXCJMUEQ4XCJ9LCBvdXRwdXQ6IHttYW51ZmFjdHVyZXI6IFwia29yZ1wiLCBuYW1lOiBcIm91dHB1dFwifX1cbiAgICAgICAgcG9ydHM6IDAsXG5cbiAgICAgICAgaW52b2tlcnM6IHtcbiAgICAgICAgICAgIHNlbmQ6IHtcbiAgICAgICAgICAgICAgICBmdW5jOiBcInt0aGF0fS5ldmVudHMub25TZW5kTWVzc2FnZS5maXJlXCJcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG9wZW46IHtcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJmbG9jay5taWRpLmNvbm5lY3Rpb24uYmluZFwiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICAgICAgXCJ7c3lzdGVtfS5wb3J0c1wiLFxuICAgICAgICAgICAgICAgICAgICBcInt0aGF0fS5vcHRpb25zLnBvcnRzXCIsXG4gICAgICAgICAgICAgICAgICAgIFwie3RoYXR9LmV2ZW50cy5vblJlYWR5LmZpcmVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ7dGhhdH0uZXZlbnRzLnJhdy5maXJlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwie3RoYXR9LmV2ZW50cy5vblNlbmRNZXNzYWdlXCJcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBjbG9zZToge1xuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcImZsb2NrLm1pZGkuY29ubmVjdGlvbi5jbG9zZVwiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICAgICAgXCJ7c3lzdGVtfS5wb3J0c1wiLFxuICAgICAgICAgICAgICAgICAgICBcInt0aGF0fS5ldmVudHMucmF3LmZpcmVcIlxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBjb21wb25lbnRzOiB7XG4gICAgICAgICAgICBzeXN0ZW06IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZsb2NrLm1pZGkuc3lzdGVtXCIsXG4gICAgICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICBldmVudHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uUmVhZHk6IFwie2Nvbm5lY3Rpb259LmV2ZW50cy5vblBvcnRzQXZhaWxhYmxlXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBldmVudHM6IHtcbiAgICAgICAgICAgIG9uUG9ydHNBdmFpbGFibGU6IG51bGwsIC8vXCJ7c3lzdGVtfS5ldmVudHMub25SZWFkeVwiLFxuICAgICAgICAgICAgb25SZWFkeTogbnVsbCxcbiAgICAgICAgICAgIG9uRXJyb3I6IG51bGwsXG4gICAgICAgICAgICBvblNlbmRNZXNzYWdlOiBudWxsLFxuXG4gICAgICAgICAgICByYXc6IG51bGwsXG4gICAgICAgICAgICBtZXNzYWdlOiBudWxsLFxuICAgICAgICAgICAgbm90ZTogbnVsbCxcbiAgICAgICAgICAgIG5vdGVPbjogbnVsbCxcbiAgICAgICAgICAgIG5vdGVPZmY6IG51bGwsXG4gICAgICAgICAgICBjb250cm9sOiBudWxsLFxuICAgICAgICAgICAgcHJvZ3JhbTogbnVsbCxcbiAgICAgICAgICAgIGFmdGVydG91Y2g6IG51bGwsXG4gICAgICAgICAgICBwaXRjaGJlbmQ6IG51bGxcbiAgICAgICAgfSxcblxuICAgICAgICBsaXN0ZW5lcnM6IHtcbiAgICAgICAgICAgIG9uUG9ydHNBdmFpbGFibGU6IHtcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJmbG9jay5taWRpLmNvbm5lY3Rpb24uYXV0b09wZW5cIixcbiAgICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgICAgIFwie2Nvbm5lY3Rpb259Lm9wdGlvbnMub3BlbkltbWVkaWF0ZWx5XCIsIFwie2Nvbm5lY3Rpb259Lm9wZW5cIlxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG9uRXJyb3I6IHtcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJmbHVpZC5sb2dcIixcbiAgICAgICAgICAgICAgICBhcmdzOiBbZmx1aWQubG9nTGV2ZWwuV0FSTiwgXCJ7YXJndW1lbnRzfS4wXCJdXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICByYXc6IHtcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJmbG9jay5taWRpLmNvbm5lY3Rpb24uZmlyZUV2ZW50XCIsXG4gICAgICAgICAgICAgICAgYXJnczogW1wie2FyZ3VtZW50c30uMFwiLCBcInt0aGF0fS5ldmVudHNcIl1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZmxvY2subWlkaS5jb25uZWN0aW9uLmF1dG9PcGVuID0gZnVuY3Rpb24gKG9wZW5JbW1lZGlhdGVseSwgb3BlbkZuKSB7XG4gICAgICAgIGlmIChvcGVuSW1tZWRpYXRlbHkpIHtcbiAgICAgICAgICAgIG9wZW5GbigpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZsb2NrLm1pZGkuZmluZFBvcnRzID0gZnVuY3Rpb24gKHBvcnRzLCBwb3J0U3BlY3MpIHtcbiAgICAgICAgcG9ydFNwZWNzID0gZmx1aWQubWFrZUFycmF5KHBvcnRTcGVjcyk7XG5cbiAgICAgICAgdmFyIG1hdGNoZXMgPSBbXTtcblxuICAgICAgICBmbHVpZC5lYWNoKHBvcnRTcGVjcywgZnVuY3Rpb24gKHBvcnRTcGVjKSB7XG4gICAgICAgICAgICB2YXIgcG9ydEZpbmRlciA9IGZsb2NrLm1pZGkuZmluZFBvcnRzLnBvcnRGaW5kZXIocG9ydFNwZWMpLFxuICAgICAgICAgICAgICAgIG1hdGNoZXNGb3JTcGVjID0gcG9ydEZpbmRlcihwb3J0cyk7XG5cbiAgICAgICAgICAgIG1hdGNoZXMgPSBtYXRjaGVzLmNvbmNhdChtYXRjaGVzRm9yU3BlYyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgIH07XG5cbiAgICBmbG9jay5taWRpLmZpbmRQb3J0cy5wb3J0RmluZGVyID0gZnVuY3Rpb24gKHBvcnRTcGVjKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcG9ydFNwZWMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBmbG9jay5taWRpLmZpbmRQb3J0cy5ieUluZGV4KHBvcnRTcGVjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcG9ydFNwZWMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHBvcnRTcGVjID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IHBvcnRTcGVjXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvcnRTcGVjLmlkKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHBvcnRzKSB7XG4gICAgICAgICAgICAgICAgcG9ydHMuZmluZChmbG9jay5taWRpLmZpbmRQb3J0cy5pZE1hdGNoZXIocG9ydFNwZWMuaWQpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWF0Y2hlciA9IHBvcnRTcGVjLm1hbnVmYWN0dXJlciAmJiBwb3J0U3BlYy5uYW1lID9cbiAgICAgICAgICAgIGZsb2NrLm1pZGkuZmluZFBvcnRzLmJvdGhNYXRjaGVyKHBvcnRTcGVjLm1hbnVmYWN0dXJlciwgcG9ydFNwZWMubmFtZSkgOlxuICAgICAgICAgICAgcG9ydFNwZWMubWFudWZhY3R1cmVyID8gZmxvY2subWlkaS5maW5kUG9ydHMubWFudWZhY3R1cmVyTWF0Y2hlcihwb3J0U3BlYy5tYW51ZmFjdHVyZXIpIDpcbiAgICAgICAgICAgIGZsb2NrLm1pZGkuZmluZFBvcnRzLm5hbWVNYXRjaGVyKHBvcnRTcGVjLm5hbWUpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocG9ydHMpIHtcbiAgICAgICAgICAgIHJldHVybiBwb3J0cy5maWx0ZXIobWF0Y2hlcik7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIGZsb2NrLm1pZGkuZmluZFBvcnRzLmJ5SW5kZXggPSBmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocG9ydHMpIHtcbiAgICAgICAgICAgIHZhciBwb3J0ID0gcG9ydHNbaWR4XTtcbiAgICAgICAgICAgIHJldHVybiBwb3J0ID8gW3BvcnRdIDogW107XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIGZsb2NrLm1pZGkuZmluZFBvcnRzLmxvd2VyQ2FzZUNvbnRhaW5zTWF0Y2hlciA9IGZ1bmN0aW9uIChtYXRjaFNwZWMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHZhciBpc01hdGNoO1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBtYXRjaFNwZWMpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2JqVmFsID0gb2JqW3Byb3BdO1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaFZhbCA9IG1hdGNoU3BlY1twcm9wXTtcblxuICAgICAgICAgICAgICAgIGlzTWF0Y2ggPSAobWF0Y2hWYWwgPT09IFwiKlwiKSA/IHRydWUgOlxuICAgICAgICAgICAgICAgICAgICBvYmpWYWwgJiYgKG9ialZhbC50b0xvd2VyQ2FzZSgpLmluZGV4T2YobWF0Y2hWYWwudG9Mb3dlckNhc2UoKSkgPiAtMSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWlzTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaXNNYXRjaDtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgZmxvY2subWlkaS5maW5kUG9ydHMuaWRNYXRjaGVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocG9ydCkge1xuICAgICAgICAgICAgcmV0dXJuIHBvcnQuaWQgPT09IGlkO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBmbG9jay5taWRpLmZpbmRQb3J0cy5ib3RoTWF0Y2hlciA9IGZ1bmN0aW9uIChtYW51LCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBmbG9jay5taWRpLmZpbmRQb3J0cy5sb3dlckNhc2VDb250YWluc01hdGNoZXIoe1xuICAgICAgICAgICAgbWFudWZhY3R1cmVyOiBtYW51LFxuICAgICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZmxvY2subWlkaS5maW5kUG9ydHMubWFudWZhY3R1cmVyTWF0Y2hlciA9IGZ1bmN0aW9uIChtYW51KSB7XG4gICAgICAgIHJldHVybiBmbG9jay5taWRpLmZpbmRQb3J0cy5sb3dlckNhc2VDb250YWluc01hdGNoZXIoe1xuICAgICAgICAgICAgbWFudWZhY3R1cmVyOiBtYW51XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmbG9jay5taWRpLmZpbmRQb3J0cy5uYW1lTWF0Y2hlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBmbG9jay5taWRpLmZpbmRQb3J0cy5sb3dlckNhc2VDb250YWluc01hdGNoZXIoe1xuICAgICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZmxvY2subWlkaS5maW5kUG9ydHMuZWFjaFBvcnRPZlR5cGUgPSBmdW5jdGlvbiAocG9ydCwgdHlwZSwgZm4pIHtcbiAgICAgICAgdmFyIHBvcnRzID0gZmx1aWQubWFrZUFycmF5KHBvcnQpO1xuICAgICAgICBmbHVpZC5lYWNoKHBvcnRzLCBmdW5jdGlvbiAocG9ydCkge1xuICAgICAgICAgICAgaWYgKHBvcnQudHlwZSA9PT0gdHlwZSkge1xuICAgICAgICAgICAgICAgIGZuKHBvcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZmxvY2subWlkaS5jb25uZWN0aW9uLm9wZW5Qb3J0ID0gZnVuY3Rpb24gKHBvcnQsIG9wZW5Qcm9taXNlcykge1xuICAgICAgICAvLyBSZW1vdmUgdGhpcyBjb25kaXRpb25hbCB3aGVuIENocm9tZSA0MyBoYXMgYmVlbiByZWxlYXNlZC5cbiAgICAgICAgaWYgKHBvcnQub3Blbikge1xuICAgICAgICAgICAgdmFyIHAgPSBwb3J0Lm9wZW4oKTtcbiAgICAgICAgICAgIG9wZW5Qcm9taXNlcy5wdXNoKHApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9wZW5Qcm9taXNlcztcbiAgICB9O1xuXG4gICAgZmxvY2subWlkaS5jb25uZWN0aW9uLmxpc3RlbiA9IGZ1bmN0aW9uIChwb3J0LCBvblJhdywgb3BlblByb21pc2VzKSB7XG4gICAgICAgIGZsb2NrLm1pZGkuZmluZFBvcnRzLmVhY2hQb3J0T2ZUeXBlKHBvcnQsIFwiaW5wdXRcIiwgZnVuY3Rpb24gKHBvcnQpIHtcbiAgICAgICAgICAgIGZsb2NrLm1pZGkuY29ubmVjdGlvbi5vcGVuUG9ydChwb3J0LCBvcGVuUHJvbWlzZXMpO1xuICAgICAgICAgICAgcG9ydC5hZGRFdmVudExpc3RlbmVyKFwibWlkaW1lc3NhZ2VcIiwgb25SYXcsIGZhbHNlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG9wZW5Qcm9taXNlcztcbiAgICB9O1xuXG4gICAgZmxvY2subWlkaS5jb25uZWN0aW9uLnN0b3BMaXN0ZW5pbmcgPSBmdW5jdGlvbiAocG9ydCwgb25SYXcpIHtcbiAgICAgICAgZmxvY2subWlkaS5maW5kUG9ydHMuZWFjaFBvcnRPZlR5cGUocG9ydCwgXCJpbnB1dFwiLCBmdW5jdGlvbiAocG9ydCkge1xuICAgICAgICAgICAgcG9ydC5jbG9zZSgpO1xuICAgICAgICAgICAgcG9ydC5yZW1vdmVFdmVudExpc3RlbmVyKFwibWlkaW1lc3NhZ2VcIiwgb25SYXcsIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZsb2NrLm1pZGkuY29ubmVjdGlvbi5iaW5kU2VuZGVyID0gZnVuY3Rpb24gKHBvcnQsIG9uU2VuZE1lc3NhZ2UsIG9wZW5Qcm9taXNlcykge1xuICAgICAgICB2YXIgcG9ydHMgPSBmbHVpZC5tYWtlQXJyYXkocG9ydCk7XG5cbiAgICAgICAgZmx1aWQuZWFjaChwb3J0cywgZnVuY3Rpb24gKHBvcnQpIHtcbiAgICAgICAgICAgIGZsb2NrLm1pZGkuY29ubmVjdGlvbi5vcGVuUG9ydChwb3J0LCBvcGVuUHJvbWlzZXMpO1xuICAgICAgICAgICAgb25TZW5kTWVzc2FnZS5hZGRMaXN0ZW5lcihwb3J0LnNlbmQuYmluZChwb3J0KSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBvcGVuUHJvbWlzZXM7XG4gICAgfTtcblxuICAgIGZsb2NrLm1pZGkuY29ubmVjdGlvbi5maXJlUmVhZHkgPSBmdW5jdGlvbiAob3BlblByb21pc2VzLCBvblJlYWR5KSB7XG4gICAgICAgIGlmICghb3BlblByb21pc2VzIHx8IG9wZW5Qcm9taXNlcy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBQcm9taXNlLmFsbChvcGVuUHJvbWlzZXMpLnRoZW4ob25SZWFkeSk7XG4gICAgfTtcblxuICAgIGZsb2NrLm1pZGkuY29ubmVjdGlvbi5iaW5kID0gZnVuY3Rpb24gKHBvcnRzLCBwb3J0U3BlYywgb25SZWFkeSwgb25SYXcsIG9uU2VuZE1lc3NhZ2UpIHtcbiAgICAgICAgcG9ydFNwZWMgPSBmbG9jay5taWRpLmNvbm5lY3Rpb24uZXhwYW5kUG9ydFNwZWMocG9ydFNwZWMpO1xuXG4gICAgICAgIHZhciBpbnB1dCA9IGZsb2NrLm1pZGkuZmluZFBvcnRzKHBvcnRzLmlucHV0cywgcG9ydFNwZWMuaW5wdXQpLFxuICAgICAgICAgICAgb3V0cHV0ID0gZmxvY2subWlkaS5maW5kUG9ydHMocG9ydHMub3V0cHV0cywgcG9ydFNwZWMub3V0cHV0KSxcbiAgICAgICAgICAgIG9wZW5Qcm9taXNlcyA9IFtdO1xuXG4gICAgICAgIGlmIChpbnB1dCAmJiBpbnB1dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmbG9jay5taWRpLmNvbm5lY3Rpb24ubGlzdGVuKGlucHV0LCBvblJhdywgb3BlblByb21pc2VzKTtcbiAgICAgICAgfSBlbHNlIGlmIChwb3J0U3BlYy5pbnB1dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmbG9jay5taWRpLmNvbm5lY3Rpb24ubG9nTm9NYXRjaGVkUG9ydHMoXCJpbnB1dFwiLCBwb3J0U3BlYyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3V0cHV0ICYmIG91dHB1dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmbG9jay5taWRpLmNvbm5lY3Rpb24uYmluZFNlbmRlcihvdXRwdXQsIG9uU2VuZE1lc3NhZ2UsIG9wZW5Qcm9taXNlcyk7XG4gICAgICAgIH0gZWxzZSBpZiAocG9ydFNwZWMub3V0cHV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZsb2NrLm1pZGkuY29ubmVjdGlvbi5sb2dOb01hdGNoZWRQb3J0cyhcIm91dHB1dFwiLCBwb3J0U3BlYyk7XG4gICAgICAgIH1cblxuICAgICAgICBmbG9jay5taWRpLmNvbm5lY3Rpb24uZmlyZVJlYWR5KG9wZW5Qcm9taXNlcywgb25SZWFkeSk7XG4gICAgfTtcblxuICAgIGZsb2NrLm1pZGkuY29ubmVjdGlvbi5jbG9zZSA9IGZ1bmN0aW9uIChwb3J0cywgb25SYXcpIHtcbiAgICAgICAgZmxvY2subWlkaS5jb25uZWN0aW9uLnN0b3BMaXN0ZW5pbmcocG9ydHMuaW5wdXRzLCBvblJhdyk7XG4gICAgICAgIC8vIFRPRE86IENvbWUgdXAgd2l0aCBzb21lIHNjaGVtZSBmb3IgdW5iaW5kaW5nIHBvcnQgc2VuZGVyc1xuICAgICAgICAvLyBzaW5jZSB0aGV5IHVzZSBGdW5jdGlvbi5iaW5kKCkuXG4gICAgfTtcblxuICAgIGZsb2NrLm1pZGkuY29ubmVjdGlvbi5sb2dOb01hdGNoZWRQb3J0cyA9IGZ1bmN0aW9uICh0eXBlLCBwb3J0U3BlYykge1xuICAgICAgICBmbHVpZC5sb2coZmx1aWQubG9nTGV2ZWwuV0FSTixcbiAgICAgICAgICAgIFwiTm8gbWF0Y2hpbmcgXCIgKyB0eXBlICsgXCIgcG9ydHMgd2VyZSBmb3VuZCBmb3IgcG9ydCBzcGVjaWZpY2F0aW9uOiBcIiwgcG9ydFNwZWNbdHlwZV0pO1xuICAgIH07XG5cbiAgICBmbG9jay5taWRpLmNvbm5lY3Rpb24uZXhwYW5kUG9ydFNwZWMgPSBmdW5jdGlvbiAocG9ydFNwZWMpIHtcbiAgICAgICAgaWYgKHBvcnRTcGVjLmlucHV0ICE9PSB1bmRlZmluZWQgfHwgcG9ydFNwZWMub3V0cHV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBwb3J0U3BlYztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBleHBhbmRlZCA9IHtcbiAgICAgICAgICAgIGlucHV0OiB7fSxcbiAgICAgICAgICAgIG91dHB1dDoge31cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodHlwZW9mIHBvcnRTcGVjID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBleHBhbmRlZC5pbnB1dCA9IGV4cGFuZGVkLm91dHB1dCA9IHBvcnRTcGVjO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmxvY2subWlkaS5jb25uZWN0aW9uLmV4cGFuZFBvcnRTcGVjUHJvcGVydHkoXCJtYW51ZmFjdHVyZXJcIiwgcG9ydFNwZWMsIGV4cGFuZGVkKTtcbiAgICAgICAgICAgIGZsb2NrLm1pZGkuY29ubmVjdGlvbi5leHBhbmRQb3J0U3BlY1Byb3BlcnR5KFwibmFtZVwiLCBwb3J0U3BlYywgZXhwYW5kZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cGFuZGVkO1xuICAgIH07XG5cbiAgICBmbG9jay5taWRpLmNvbm5lY3Rpb24uZXhwYW5kUG9ydFNwZWNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wTmFtZSwgcG9ydFNwZWMsIGV4cGFuZGVkKSB7XG4gICAgICAgIGV4cGFuZGVkLmlucHV0W3Byb3BOYW1lXSA9IGV4cGFuZGVkLm91dHB1dFtwcm9wTmFtZV0gPSBwb3J0U3BlY1twcm9wTmFtZV07XG4gICAgICAgIHJldHVybiBleHBhbmRlZDtcbiAgICB9O1xuXG4gICAgZmxvY2subWlkaS5jb25uZWN0aW9uLmZpcmVFdmVudCA9IGZ1bmN0aW9uIChtaWRpRXZlbnQsIGV2ZW50cykge1xuICAgICAgICB2YXIgbW9kZWwgPSBmbG9jay5taWRpLnJlYWQobWlkaUV2ZW50LmRhdGEpLFxuICAgICAgICAgICAgZXZlbnRGb3JUeXBlID0gbW9kZWwudHlwZSA/IGV2ZW50c1ttb2RlbC50eXBlXSA6IHVuZGVmaW5lZDtcblxuICAgICAgICBldmVudHMubWVzc2FnZS5maXJlKG1vZGVsKTtcblxuICAgICAgICAvLyBUT0RPOiBSZW1vdmUgdGhpcyBzcGVjaWFsLWNhc2luZyBvZiBub3RlT24vbm90ZU9mZiBldmVudHMgaW50byBub3RlIGV2ZW50cy5cbiAgICAgICAgaWYgKG1vZGVsLnR5cGUgPT09IFwibm90ZU9uXCIgfHwgbW9kZWwudHlwZSA9PT0gXCJub3RlT2ZmXCIpIHtcbiAgICAgICAgICAgIGV2ZW50cy5ub3RlLmZpcmUobW9kZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50Rm9yVHlwZSkge1xuICAgICAgICAgICAgZXZlbnRGb3JUeXBlLmZpcmUobW9kZWwpO1xuICAgICAgICB9XG4gICAgfTtcblxufSgpKTtcbjtcbiAgICB3aW5kb3cuZmx1aWQgPSBmbHVpZDtcblxuICAgIHJldHVybiBmbG9jaztcbn0pKTtcbiIsInZhciBjb3JlID0gcmVxdWlyZSgnLi9saWIvY29yZScpO1xuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvYXN5bmMnKTtcbmV4cG9ydHMuY29yZSA9IGNvcmU7XG5leHBvcnRzLmlzQ29yZSA9IGZ1bmN0aW9uICh4KSB7IHJldHVybiBjb3JlW3hdIH07XG5leHBvcnRzLnN5bmMgPSByZXF1aXJlKCcuL2xpYi9zeW5jJyk7XG4iLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4vY29yZScpO1xudmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xudmFyIGNhbGxlciA9IHJlcXVpcmUoJy4vY2FsbGVyLmpzJyk7XG52YXIgbm9kZU1vZHVsZXNQYXRocyA9IHJlcXVpcmUoJy4vbm9kZS1tb2R1bGVzLXBhdGhzLmpzJyk7XG52YXIgc3BsaXRSZSA9IHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgPyAvW1xcL1xcXFxdLyA6IC9cXC8vO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlc29sdmUgKHgsIG9wdHMsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNiID0gb3B0cztcbiAgICAgICAgb3B0cyA9IHt9O1xuICAgIH1cbiAgICBpZiAoIW9wdHMpIG9wdHMgPSB7fTtcbiAgICBpZiAodHlwZW9mIHggIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNiKG5ldyBFcnJvcigncGF0aCBtdXN0IGJlIGEgc3RyaW5nJykpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgdmFyIGlzRmlsZSA9IG9wdHMuaXNGaWxlIHx8IGZ1bmN0aW9uIChmaWxlLCBjYikge1xuICAgICAgICBmcy5zdGF0KGZpbGUsIGZ1bmN0aW9uIChlcnIsIHN0YXQpIHtcbiAgICAgICAgICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgPT09ICdFTk9FTlQnKSBjYihudWxsLCBmYWxzZSlcbiAgICAgICAgICAgIGVsc2UgaWYgKGVycikgY2IoZXJyKVxuICAgICAgICAgICAgZWxzZSBjYihudWxsLCBzdGF0LmlzRmlsZSgpIHx8IHN0YXQuaXNGSUZPKCkpXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdmFyIHJlYWRGaWxlID0gb3B0cy5yZWFkRmlsZSB8fCBmcy5yZWFkRmlsZTtcbiAgICBcbiAgICB2YXIgZXh0ZW5zaW9ucyA9IG9wdHMuZXh0ZW5zaW9ucyB8fCBbICcuanMnIF07XG4gICAgdmFyIHkgPSBvcHRzLmJhc2VkaXIgfHwgcGF0aC5kaXJuYW1lKGNhbGxlcigpKTtcbiAgICBcbiAgICBvcHRzLnBhdGhzID0gb3B0cy5wYXRocyB8fCBbXTtcbiAgICBcbiAgICBpZiAoL14oPzpcXC5cXC4/KD86XFwvfCQpfFxcL3woW0EtWmEtel06KT9bXFxcXFxcL10pLy50ZXN0KHgpKSB7XG4gICAgICAgIHZhciByZXMgPSBwYXRoLnJlc29sdmUoeSwgeCk7XG4gICAgICAgIGlmICh4ID09PSAnLi4nKSByZXMgKz0gJy8nO1xuICAgICAgICBpZiAoL1xcLyQvLnRlc3QoeCkgJiYgcmVzID09PSB5KSB7XG4gICAgICAgICAgICBsb2FkQXNEaXJlY3RvcnkocmVzLCBvcHRzLnBhY2thZ2UsIG9uZmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBsb2FkQXNGaWxlKHJlcywgb3B0cy5wYWNrYWdlLCBvbmZpbGUpO1xuICAgIH1cbiAgICBlbHNlIGxvYWROb2RlTW9kdWxlcyh4LCB5LCBmdW5jdGlvbiAoZXJyLCBuLCBwa2cpIHtcbiAgICAgICAgaWYgKGVycikgY2IoZXJyKVxuICAgICAgICBlbHNlIGlmIChuKSBjYihudWxsLCBuLCBwa2cpXG4gICAgICAgIGVsc2UgaWYgKGNvcmVbeF0pIHJldHVybiBjYihudWxsLCB4KTtcbiAgICAgICAgZWxzZSBjYihuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiICsgeCArIFwiJyBmcm9tICdcIiArIHkgKyBcIidcIikpXG4gICAgfSk7XG4gICAgXG4gICAgZnVuY3Rpb24gb25maWxlIChlcnIsIG0sIHBrZykge1xuICAgICAgICBpZiAoZXJyKSBjYihlcnIpXG4gICAgICAgIGVsc2UgaWYgKG0pIGNiKG51bGwsIG0sIHBrZylcbiAgICAgICAgZWxzZSBsb2FkQXNEaXJlY3RvcnkocmVzLCBmdW5jdGlvbiAoZXJyLCBkLCBwa2cpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIGNiKGVycilcbiAgICAgICAgICAgIGVsc2UgaWYgKGQpIGNiKG51bGwsIGQsIHBrZylcbiAgICAgICAgICAgIGVsc2UgY2IobmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIHggKyBcIicgZnJvbSAnXCIgKyB5ICsgXCInXCIpKVxuICAgICAgICB9KVxuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiBsb2FkQXNGaWxlICh4LCBwa2csIGNiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGtnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYiA9IHBrZztcbiAgICAgICAgICAgIHBrZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIGV4dHMgPSBbJyddLmNvbmNhdChleHRlbnNpb25zKTtcbiAgICAgICAgbG9hZChleHRzLCB4LCBwa2cpXG5cdFx0XG5cdFx0ZnVuY3Rpb24gbG9hZCAoZXh0cywgeCwgcGtnKSB7XG4gICAgICAgICAgICBpZiAoZXh0cy5sZW5ndGggPT09IDApIHJldHVybiBjYihudWxsLCB1bmRlZmluZWQsIHBrZyk7XG4gICAgICAgICAgICB2YXIgZmlsZSA9IHggKyBleHRzWzBdO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAocGtnKSBvbnBrZyhudWxsLCBwa2cpXG4gICAgICAgICAgICBlbHNlIGxvYWRwa2cocGF0aC5kaXJuYW1lKGZpbGUpLCBvbnBrZyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGZ1bmN0aW9uIG9ucGtnIChlcnIsIHBrZ18sIGRpcikge1xuICAgICAgICAgICAgICAgIHBrZyA9IHBrZ187XG4gICAgICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgICAgICAgICAgICBpZiAoZGlyICYmIHBrZyAmJiBvcHRzLnBhdGhGaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJmaWxlID0gcGF0aC5yZWxhdGl2ZShkaXIsIGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVsID0gcmZpbGUuc2xpY2UoMCwgcmZpbGUubGVuZ3RoIC0gZXh0c1swXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IG9wdHMucGF0aEZpbHRlcihwa2csIHgsIHJlbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyKSByZXR1cm4gbG9hZChcbiAgICAgICAgICAgICAgICAgICAgICAgIFsnJ10uY29uY2F0KGV4dGVuc2lvbnMuc2xpY2UoKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLnJlc29sdmUoZGlyLCByKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBrZ1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpc0ZpbGUoZmlsZSwgb25leCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBvbmV4IChlcnIsIGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikgY2IoZXJyKVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFleCkgbG9hZChleHRzLnNsaWNlKDEpLCB4LCBwa2cpXG4gICAgICAgICAgICAgICAgZWxzZSBjYihudWxsLCBmaWxlLCBwa2cpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gbG9hZHBrZyAoZGlyLCBjYikge1xuICAgICAgICBpZiAoZGlyID09PSAnJyB8fCBkaXIgPT09ICcvJykgcmV0dXJuIGNiKG51bGwpO1xuICAgICAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyAmJiAvXlxcdzpbXFxcXFxcL10qJC8udGVzdChkaXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gY2IobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKC9bXFxcXFxcL11ub2RlX21vZHVsZXNbXFxcXFxcL10qJC8udGVzdChkaXIpKSByZXR1cm4gY2IobnVsbCk7XG4gICAgICAgIFxuICAgICAgICB2YXIgcGtnZmlsZSA9IHBhdGguam9pbihkaXIsICdwYWNrYWdlLmpzb24nKTtcbiAgICAgICAgaXNGaWxlKHBrZ2ZpbGUsIGZ1bmN0aW9uIChlcnIsIGV4KSB7XG4gICAgICAgICAgICAvLyBvbiBlcnIsIGV4IGlzIGZhbHNlXG4gICAgICAgICAgICBpZiAoIWV4KSByZXR1cm4gbG9hZHBrZyhcbiAgICAgICAgICAgICAgICBwYXRoLmRpcm5hbWUoZGlyKSwgY2JcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJlYWRGaWxlKHBrZ2ZpbGUsIGZ1bmN0aW9uIChlcnIsIGJvZHkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSBjYihlcnIpO1xuICAgICAgICAgICAgICAgIHRyeSB7IHZhciBwa2cgPSBKU09OLnBhcnNlKGJvZHkpIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChwa2cgJiYgb3B0cy5wYWNrYWdlRmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHBrZyA9IG9wdHMucGFja2FnZUZpbHRlcihwa2csIHBrZ2ZpbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYihudWxsLCBwa2csIGRpcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIGxvYWRBc0RpcmVjdG9yeSAoeCwgZnBrZywgY2IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmcGtnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYiA9IGZwa2c7XG4gICAgICAgICAgICBmcGtnID0gb3B0cy5wYWNrYWdlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB2YXIgcGtnZmlsZSA9IHBhdGguam9pbih4LCAnL3BhY2thZ2UuanNvbicpO1xuICAgICAgICBpc0ZpbGUocGtnZmlsZSwgZnVuY3Rpb24gKGVyciwgZXgpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuICAgICAgICAgICAgaWYgKCFleCkgcmV0dXJuIGxvYWRBc0ZpbGUocGF0aC5qb2luKHgsICcvaW5kZXgnKSwgZnBrZywgY2IpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZWFkRmlsZShwa2dmaWxlLCBmdW5jdGlvbiAoZXJyLCBib2R5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBrZyA9IEpTT04ucGFyc2UoYm9keSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHt9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKG9wdHMucGFja2FnZUZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICBwa2cgPSBvcHRzLnBhY2thZ2VGaWx0ZXIocGtnLCBwa2dmaWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKHBrZy5tYWluKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwa2cubWFpbiA9PT0gJy4nIHx8IHBrZy5tYWluID09PSAnLi8nKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBrZy5tYWluID0gJ2luZGV4J1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxvYWRBc0ZpbGUocGF0aC5yZXNvbHZlKHgsIHBrZy5tYWluKSwgcGtnLCBmdW5jdGlvbiAoZXJyLCBtLCBwa2cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG0pIHJldHVybiBjYihudWxsLCBtLCBwa2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwa2cpIHJldHVybiBsb2FkQXNGaWxlKHBhdGguam9pbih4LCAnL2luZGV4JyksIHBrZywgY2IpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGlyID0gcGF0aC5yZXNvbHZlKHgsIHBrZy5tYWluKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRBc0RpcmVjdG9yeShkaXIsIHBrZywgZnVuY3Rpb24gKGVyciwgbiwgcGtnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4pIHJldHVybiBjYihudWxsLCBuLCBwa2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRBc0ZpbGUocGF0aC5qb2luKHgsICcvaW5kZXgnKSwgcGtnLCBjYik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgbG9hZEFzRmlsZShwYXRoLmpvaW4oeCwgJy9pbmRleCcpLCBwa2csIGNiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gbG9hZE5vZGVNb2R1bGVzICh4LCBzdGFydCwgY2IpIHtcbiAgICAgICAgKGZ1bmN0aW9uIHByb2Nlc3MgKGRpcnMpIHtcbiAgICAgICAgICAgIGlmIChkaXJzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGNiKG51bGwsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB2YXIgZGlyID0gZGlyc1swXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGZpbGUgPSBwYXRoLmpvaW4oZGlyLCAnLycsIHgpO1xuICAgICAgICAgICAgbG9hZEFzRmlsZShmaWxlLCB1bmRlZmluZWQsIG9uZmlsZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGZ1bmN0aW9uIG9uZmlsZSAoZXJyLCBtLCBwa2cpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcbiAgICAgICAgICAgICAgICBpZiAobSkgcmV0dXJuIGNiKG51bGwsIG0sIHBrZyk7XG4gICAgICAgICAgICAgICAgbG9hZEFzRGlyZWN0b3J5KHBhdGguam9pbihkaXIsICcvJywgeCksIHVuZGVmaW5lZCwgb25kaXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBmdW5jdGlvbiBvbmRpciAoZXJyLCBuLCBwa2cpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcbiAgICAgICAgICAgICAgICBpZiAobikgcmV0dXJuIGNiKG51bGwsIG4sIHBrZyk7XG4gICAgICAgICAgICAgICAgcHJvY2VzcyhkaXJzLnNsaWNlKDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkobm9kZU1vZHVsZXNQYXRocyhzdGFydCwgb3B0cykpO1xuICAgIH1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBzZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC93aWtpL0phdmFTY3JpcHRTdGFja1RyYWNlQXBpXG4gICAgdmFyIG9yaWdQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlO1xuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gZnVuY3Rpb24gKF8sIHN0YWNrKSB7IHJldHVybiBzdGFjayB9O1xuICAgIHZhciBzdGFjayA9IChuZXcgRXJyb3IoKSkuc3RhY2s7XG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBvcmlnUHJlcGFyZVN0YWNrVHJhY2U7XG4gICAgcmV0dXJuIHN0YWNrWzJdLmdldEZpbGVOYW1lKCk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHM9W1xuICAgIFwiYXNzZXJ0XCIsXG4gICAgXCJidWZmZXJfaWVlZTc1NFwiLFxuICAgIFwiYnVmZmVyXCIsXG4gICAgXCJjaGlsZF9wcm9jZXNzXCIsXG4gICAgXCJjbHVzdGVyXCIsXG4gICAgXCJjb25zb2xlXCIsXG4gICAgXCJjb25zdGFudHNcIixcbiAgICBcImNyeXB0b1wiLFxuICAgIFwiX2RlYnVnZ2VyXCIsXG4gICAgXCJkZ3JhbVwiLFxuICAgIFwiZG5zXCIsXG4gICAgXCJkb21haW5cIixcbiAgICBcImV2ZW50c1wiLFxuICAgIFwiZnJlZWxpc3RcIixcbiAgICBcImZzXCIsXG4gICAgXCJodHRwXCIsXG4gICAgXCJodHRwc1wiLFxuICAgIFwiX2xpbmtsaXN0XCIsXG4gICAgXCJtb2R1bGVcIixcbiAgICBcIm5ldFwiLFxuICAgIFwib3NcIixcbiAgICBcInBhdGhcIixcbiAgICBcInB1bnljb2RlXCIsXG4gICAgXCJxdWVyeXN0cmluZ1wiLFxuICAgIFwicmVhZGxpbmVcIixcbiAgICBcInJlcGxcIixcbiAgICBcInN0cmVhbVwiLFxuICAgIFwic3RyaW5nX2RlY29kZXJcIixcbiAgICBcInN5c1wiLFxuICAgIFwidGltZXJzXCIsXG4gICAgXCJ0bHNcIixcbiAgICBcInR0eVwiLFxuICAgIFwidXJsXCIsXG4gICAgXCJ1dGlsXCIsXG4gICAgXCJ2bVwiLFxuICAgIFwiemxpYlwiXG5dXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29yZS5qc29uJykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHgpIHtcbiAgICBhY2NbeF0gPSB0cnVlO1xuICAgIHJldHVybiBhY2M7XG59LCB7fSk7XG4iLCJ2YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RhcnQsIG9wdHMpIHtcbiAgICB2YXIgbW9kdWxlcyA9IG9wdHMubW9kdWxlRGlyZWN0b3J5XG4gICAgICAgID8gW10uY29uY2F0KG9wdHMubW9kdWxlRGlyZWN0b3J5KVxuICAgICAgICA6IFsnbm9kZV9tb2R1bGVzJ11cbiAgICA7XG4gICAgdmFyIHByZWZpeCA9ICcvJztcbiAgICBpZiAoL14oW0EtWmEtel06KS8udGVzdChzdGFydCkpIHtcbiAgICAgICAgcHJlZml4ID0gJyc7XG4gICAgfSBlbHNlIGlmICgvXlxcXFxcXFxcLy50ZXN0KHN0YXJ0KSkge1xuICAgICAgICBwcmVmaXggPSAnXFxcXFxcXFwnO1xuICAgIH1cbiAgICB2YXIgc3BsaXRSZSA9IHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgPyAvW1xcL1xcXFxdLyA6IC9cXC8rLztcblxuICAgIC8vIGVuc3VyZSB0aGF0IGBzdGFydGAgaXMgYW4gYWJzb2x1dGUgcGF0aCBhdCB0aGlzIHBvaW50LFxuICAgIC8vIHJlc29sdmluZyBhZ2FpbnQgdGhlIHByb2Nlc3MnIGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnlcbiAgICBzdGFydCA9IHBhdGgucmVzb2x2ZShzdGFydCk7XG5cbiAgICB2YXIgcGFydHMgPSBzdGFydC5zcGxpdChzcGxpdFJlKTtcblxuICAgIHZhciBkaXJzID0gW107XG4gICAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmIChtb2R1bGVzLmluZGV4T2YocGFydHNbaV0pICE9PSAtMSkgY29udGludWU7XG4gICAgICAgIGRpcnMgPSBkaXJzLmNvbmNhdChtb2R1bGVzLm1hcChmdW5jdGlvbihtb2R1bGVfZGlyKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJlZml4ICsgcGF0aC5qb2luKFxuICAgICAgICAgICAgICAgIHBhdGguam9pbi5hcHBseShwYXRoLCBwYXJ0cy5zbGljZSgwLCBpICsgMSkpLFxuICAgICAgICAgICAgICAgIG1vZHVsZV9kaXJcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpe1xuICAgICAgICBkaXJzW2RpcnMubGVuZ3RoLTFdID0gZGlyc1tkaXJzLmxlbmd0aC0xXS5yZXBsYWNlKFwiOlwiLCBcIjpcXFxcXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZGlycy5jb25jYXQob3B0cy5wYXRocyk7XG59XG4iLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4vY29yZScpO1xudmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xudmFyIGNhbGxlciA9IHJlcXVpcmUoJy4vY2FsbGVyLmpzJyk7XG52YXIgbm9kZU1vZHVsZXNQYXRocyA9IHJlcXVpcmUoJy4vbm9kZS1tb2R1bGVzLXBhdGhzLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHgsIG9wdHMpIHtcbiAgICBpZiAoIW9wdHMpIG9wdHMgPSB7fTtcbiAgICB2YXIgaXNGaWxlID0gb3B0cy5pc0ZpbGUgfHwgZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgICAgdHJ5IHsgdmFyIHN0YXQgPSBmcy5zdGF0U3luYyhmaWxlKSB9XG4gICAgICAgIGNhdGNoIChlcnIpIHsgaWYgKGVyciAmJiBlcnIuY29kZSA9PT0gJ0VOT0VOVCcpIHJldHVybiBmYWxzZSB9XG4gICAgICAgIHJldHVybiBzdGF0LmlzRmlsZSgpIHx8IHN0YXQuaXNGSUZPKCk7XG4gICAgfTtcbiAgICB2YXIgcmVhZEZpbGVTeW5jID0gb3B0cy5yZWFkRmlsZVN5bmMgfHwgZnMucmVhZEZpbGVTeW5jO1xuICAgIFxuICAgIHZhciBleHRlbnNpb25zID0gb3B0cy5leHRlbnNpb25zIHx8IFsgJy5qcycgXTtcbiAgICB2YXIgeSA9IG9wdHMuYmFzZWRpciB8fCBwYXRoLmRpcm5hbWUoY2FsbGVyKCkpO1xuXG4gICAgb3B0cy5wYXRocyA9IG9wdHMucGF0aHMgfHwgW107XG5cbiAgICBpZiAoL14oPzpcXC5cXC4/KD86XFwvfCQpfFxcL3woW0EtWmEtel06KT9bXFxcXFxcL10pLy50ZXN0KHgpKSB7XG4gICAgICAgIHZhciByZXMgPSBwYXRoLnJlc29sdmUoeSwgeCk7XG4gICAgICAgIGlmICh4ID09PSAnLi4nKSByZXMgKz0gJy8nO1xuICAgICAgICB2YXIgbSA9IGxvYWRBc0ZpbGVTeW5jKHJlcykgfHwgbG9hZEFzRGlyZWN0b3J5U3luYyhyZXMpO1xuICAgICAgICBpZiAobSkgcmV0dXJuIG07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG4gPSBsb2FkTm9kZU1vZHVsZXNTeW5jKHgsIHkpO1xuICAgICAgICBpZiAobikgcmV0dXJuIG47XG4gICAgfVxuICAgIFxuICAgIGlmIChjb3JlW3hdKSByZXR1cm4geDtcbiAgICBcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiICsgeCArIFwiJyBmcm9tICdcIiArIHkgKyBcIidcIik7XG4gICAgXG4gICAgZnVuY3Rpb24gbG9hZEFzRmlsZVN5bmMgKHgpIHtcbiAgICAgICAgaWYgKGlzRmlsZSh4KSkge1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXh0ZW5zaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGZpbGUgPSB4ICsgZXh0ZW5zaW9uc1tpXTtcbiAgICAgICAgICAgIGlmIChpc0ZpbGUoZmlsZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiBsb2FkQXNEaXJlY3RvcnlTeW5jICh4KSB7XG4gICAgICAgIHZhciBwa2dmaWxlID0gcGF0aC5qb2luKHgsICcvcGFja2FnZS5qc29uJyk7XG4gICAgICAgIGlmIChpc0ZpbGUocGtnZmlsZSkpIHtcbiAgICAgICAgICAgIHZhciBib2R5ID0gcmVhZEZpbGVTeW5jKHBrZ2ZpbGUsICd1dGY4Jyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBwa2cgPSBKU09OLnBhcnNlKGJvZHkpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRzLnBhY2thZ2VGaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcGtnID0gb3B0cy5wYWNrYWdlRmlsdGVyKHBrZywgeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChwa2cubWFpbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbSA9IGxvYWRBc0ZpbGVTeW5jKHBhdGgucmVzb2x2ZSh4LCBwa2cubWFpbikpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobSkgcmV0dXJuIG07XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gbG9hZEFzRGlyZWN0b3J5U3luYyhwYXRoLnJlc29sdmUoeCwgcGtnLm1haW4pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4pIHJldHVybiBuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHt9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBsb2FkQXNGaWxlU3luYyhwYXRoLmpvaW4oIHgsICcvaW5kZXgnKSk7XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIGxvYWROb2RlTW9kdWxlc1N5bmMgKHgsIHN0YXJ0KSB7XG4gICAgICAgIHZhciBkaXJzID0gbm9kZU1vZHVsZXNQYXRocyhzdGFydCwgb3B0cyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGRpciA9IGRpcnNbaV07XG4gICAgICAgICAgICB2YXIgbSA9IGxvYWRBc0ZpbGVTeW5jKHBhdGguam9pbiggZGlyLCAnLycsIHgpKTtcbiAgICAgICAgICAgIGlmIChtKSByZXR1cm4gbTtcbiAgICAgICAgICAgIHZhciBuID0gbG9hZEFzRGlyZWN0b3J5U3luYyhwYXRoLmpvaW4oIGRpciwgJy8nLCB4ICkpO1xuICAgICAgICAgICAgaWYgKG4pIHJldHVybiBuO1xuICAgICAgICB9XG4gICAgfVxufTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMiBPQ0FEIFVuaXZlcnNpdHksIEFudHJhbmlnIEJhc21hblxuXG5MaWNlbnNlZCB1bmRlciB0aGUgRWR1Y2F0aW9uYWwgQ29tbXVuaXR5IExpY2Vuc2UgKEVDTCksIFZlcnNpb24gMi4wIG9yIHRoZSBOZXdcbkJTRCBsaWNlbnNlLiBZb3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggb25lIHRoZXNlXG5MaWNlbnNlcy5cblxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBFQ0wgMi4wIExpY2Vuc2UgYW5kIEJTRCBMaWNlbnNlIGF0XG5odHRwczovL2dpdGh1Yi5jb20vZmx1aWQtcHJvamVjdC9pbmZ1c2lvbi9yYXcvbWFzdGVyL0luZnVzaW9uLUxJQ0VOU0UudHh0XG4qL1xuLyoganNoaW50IG5vZGU6IHRydWUgKi9cbi8qIGdsb2JhbCBnbG9iYWwgKi9cblxuKGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciBmcyA9IHJlcXVpcmUoXCJmc1wiKSxcbiAgICAgICAgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpLFxuICAgICAgICB2bSA9IHJlcXVpcmUoXCJ2bVwiKSxcbiAgICAgICAgcmVzb2x2ZSA9IHJlcXVpcmUoXCJyZXNvbHZlXCIpO1xuXG4gICAgdmFyIG1vZHVsZUJhc2VEaXIgPSBwYXRoLnJlc29sdmUoX19kaXJuYW1lLCBcIi4uLy4uXCIpO1xuXG4gICAgLyoqIEltcGxlbWVudGF0aW9uIGZvciBGTFVJRC01ODIyIHRvIGF2b2lkIHJlcXVpcmVtZW50IGZvciBkZWR1cGUtaW5mdXNpb24gKiovXG5cbiAgICB2YXIgdXBJbmZ1c2lvbjtcblxuICAgIHRyeSB7XG4gICAgICAgIHZhciB1cFBhdGggPSBwYXRoLnJlc29sdmUobW9kdWxlQmFzZURpciwgXCIuLi8uLi8uLlwiKTtcbiAgICAgICAgdmFyIHVwSW5mdXNpb25QYXRoID0gcmVzb2x2ZS5zeW5jKFwiaW5mdXNpb25cIiwge1xuICAgICAgICAgICAgYmFzZWRpcjogdXBQYXRoXG4gICAgICAgIH0pO1xuICAgICAgICB1cEluZnVzaW9uID0gcmVxdWlyZSh1cEluZnVzaW9uUGF0aCk7XG4gICAgfSBjYXRjaCAoZSkge31cblxuICAgIGlmICh1cEluZnVzaW9uKSB7XG4gICAgICAgIHVwSW5mdXNpb24ubG9nKFwiUmVzb2x2ZWQgaW5mdXNpb24gZnJvbSBwYXRoIFwiICsgX19kaXJuYW1lICsgXCIgdG8gXCIgKyB1cEluZnVzaW9uLm1vZHVsZS5tb2R1bGVzLmluZnVzaW9uLmJhc2VEaXIpO1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHVwSW5mdXNpb247XG4gICAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkluZnVzaW9uIGF0IHBhdGggXCIgKyBtb2R1bGVCYXNlRGlyICsgXCIgaXMgYXQgdG9wIGxldmVsIFwiKTtcbiAgICB9XG5cbiAgICB2YXIgZ2V0QmFzZURpciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fZGlybmFtZTtcbiAgICB9O1xuXG4gICAgdmFyIGJ1aWxkUGF0aCA9IGZ1bmN0aW9uIChwYXRoU2VnKSB7XG4gICAgICAgIHJldHVybiBwYXRoLmpvaW4oZ2V0QmFzZURpcigpLCBwYXRoU2VnKTtcbiAgICB9O1xuICAgIFxuICAgIC8vIFJlcG9ydCBvZiBleHBlcmltZW50cyBwZXJmb3JtZWQgd2l0aCBub2RlLmpzIGdsb2JhbHMgZG9uZSBvbiAxLzkvMTQgLSB3aGF0IHdlIG1pZ2h0IGxpa2UgdG8gd3JpdGUgYXQgdGhpcyBwb2ludCBpcyBcbiAgICAvLyBmbHVpZDoge2dsb2JhbDogR0xPQkFMfTsgLSB0aGlzIFwibmVhcmx5XCIgd29ya3MgYnV0IHVuZm9ydHVuYXRlbHkgdGhlIHByb2Nlc3Mgb2YgdHJhbnNwb3J0aW5nIHRoZSBcInBhbi1nbG9iYWxcIiBvYmplY3RcbiAgICAvLyBhY3Jvc3MgdGhlIHNhbmRib3ggaW5pdGlhbGl6YXRpb24gYm91bmRhcnkgZW5kcyB1cCBzaHJlZGRpbmcgaXQuIFdlIGVuZCB1cCB3aXRoIGEgc2l0dWF0aW9uIHdoZXJlIGluIHRoaXMgZmlsZSwgXG4gICAgLy8gZmx1aWQuZ2xvYmFsLmZsdWlkID09PSBmbHVpZCAtIGJ1dCBmcm9tIHdpdGhpbiBGbHVpZC5qcywgZmx1aWQuZ2xvYmFsLmZsdWlkID09PSB1bmRlZmluZWQuIG5vZGUuanMgZG9jcyBvbiBzYW5kYm94aW5nIFxuICAgIC8vIGRvIHJlcG9ydCB0aGF0IHRoZSByZXN1bHRzIGNhbiBiZSBmcmFnaWxlIGFuZCB2ZXJzaW9uIHVuc3RhYmxlLiBIb3dldmVyLCB3ZSBuZWVkIHRvIGNvbnRpbnVlIHdpdGggc2FuZGJveGluZyBiZWNhdXNlIG9mXG4gICAgLy8gdGhlIGRlbGljYXRlIGV4cGVjdGF0aW9ucywgZm9yIGV4YW1wbGUsIG9uIHZpc2libGUgZ2xvYmFscyBjYXVzZWQgYnkgUVVuaXQncyBzbmlmZmluZyBjb2RlLiAgXG4gICAgLy8gRXhwZXJpbWVudCBwZXJmb3JtZWQgd2l0aCBub2RlLmpzIDAuOC42IG9uIFdpbmRvd3MuIFxuICAgIC8vIFdlIGFjaGlldmUgYSBsb3Qgb2Ygd2hhdCB3ZSBtaWdodCB3YW50IHZpYSBcImdsb2JhbC5mbHVpZCA9IGZsdWlkXCIgYmVsb3cuIEhvd2V2ZXIsIG90aGVyIHRvcC1sZXZlbCBuYW1lcyBjb25zdHJ1Y3RlZCBcbiAgICAvLyB2aWEgZmx1aWQucmVnaXN0ZXJOYW1lc3BhY2Ugd2lsbCBub3QgYmUgZXhwb3J0ZWQgdXAgdG8gdGhlIHBhbi1nbG9iYWwuIFxuXG4gICAgdmFyIGNvbnRleHQgPSB2bS5jcmVhdGVDb250ZXh0KHtcbiAgICAgICAgY29uc29sZTogY29uc29sZSxcbiAgICAgICAgc2V0VGltZW91dDogc2V0VGltZW91dCxcbiAgICAgICAgY2xlYXJUaW1lb3V0OiBjbGVhclRpbWVvdXQsXG4gICAgICAgIHNldEludGVydmFsOiBzZXRJbnRlcnZhbCxcbiAgICAgICAgY2xlYXJJbnRlcnZhbDogY2xlYXJJbnRlcnZhbFxuICAgIH0pO1xuXG4gICAgY29udGV4dC53aW5kb3cgPSBjb250ZXh0O1xuXG4gICAgLyoqIExvYWQgYSBzdGFuZGFyZCwgbm9uLXJlcXVpcmUtYXdhcmUgRmx1aWQgZnJhbWV3b3JrIGZpbGUgaW50byB0aGUgRmx1aWQgY29udGV4dCwgZ2l2ZW4gYSBmaWxlbmFtZVxuICAgICAqIHJlbGF0aXZlIHRvIHRoaXMgZGlyZWN0b3J5IChzcmMvbW9kdWxlKSAqKi9cblxuICAgIHZhciBsb2FkSW5Db250ZXh0ID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgdmFyIGZ1bGxwYXRoID0gYnVpbGRQYXRoKHBhdGgpO1xuICAgICAgICB2YXIgZGF0YSA9IGZzLnJlYWRGaWxlU3luYyhmdWxscGF0aCk7XG4gICAgICAgIHZtLnJ1bkluQ29udGV4dChkYXRhLCBjb250ZXh0LCBmdWxscGF0aCk7XG4gICAgfTtcblxuICAgIHZhciBsb2FkSW5jbHVkZXMgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICB2YXIgaW5jbHVkZXMgPSByZXF1aXJlKGJ1aWxkUGF0aChwYXRoKSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5jbHVkZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGxvYWRJbkNvbnRleHQoaW5jbHVkZXNbaV0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGxvYWRJbmNsdWRlcyhcImluY2x1ZGVzLmpzb25cIik7XG5cbiAgICB2YXIgZmx1aWQgPSBjb250ZXh0LmZsdWlkO1xuICAgIC8vIEZMVUlELTQ5MTM6IFFVbml0IGNhbGxzIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyIG9uIGxvYWQuIFdlIG5lZWQgdG8gYWRkXG4gICAgLy8gaXQgdG8gdGhlIGNvbnRleHQgaXQgd2lsbCBiZSBsb2FkZWQgaW4uXG4gICAgY29udGV4dC5hZGRFdmVudExpc3RlbmVyID0gZmx1aWQuaWRlbnRpdHk7XG4gICAgXG4gICAgLy8gQXMgd2VsbCBhcyBmb3IgZWZmaWNpZW5jeSwgaXQncyB1c2VmdWwgdG8gY3VzdG9taXNlIHRoaXMgYmVjYXVzZSBhbiB1bmNhdWdodFxuICAgIC8vIGV4Y2VwdGlvbiBmaXJlZCBmcm9tIGEgYSBzZXRUaW1lb3V0IGhhbmRsZXIgaW4gbm9kZS5qcyB3aWxsIHByZXZlbnQgYW55IFxuICAgIC8vIGZ1cnRoZXIgZnJvbSBiZWluZyBzZXJ2aWNlZCwgd2hpY2ggaW1wZWRlcyB0ZXN0aW5nIHRoZXNlIGhhbmRsZXJzXG4gICAgZmx1aWQuaW52b2tlTGF0ZXIgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmMpO1xuICAgIH07XG4gICAgXG4gICAgZmx1aWQubG9nT2JqZWN0UmVuZGVyQ2hhcnMgPSAxMDI0O1xuICAgIFxuICAgIGZsdWlkLm9uVW5jYXVnaHRFeGNlcHRpb24gPSBmbHVpZC5tYWtlRXZlbnRGaXJlcih7XG4gICAgICAgIG5hbWU6IFwiR2xvYmFsIHVuY2F1Z2h0IGV4Y2VwdGlvbiBoYW5kbGVyXCJcbiAgICB9KTtcbiAgICBcbiAgICAvLyBUaGlzIHJlZ2lzdHJ5IG9mIHByaW9yaXRpZXMgd2lsbCBiZSByZW1vdmVkIG9uY2UgdGhlIGltcGxlbWVudGF0aW9uIG9mIEZMVUlELTU1MDYgaXMgY29tcGxldGVcbiAgICBmbHVpZC5oYW5kbGVyUHJpb3JpdGllcyA9IHtcbiAgICAgICAgdW5jYXVnaHRFeGNlcHRpb246IHtcbiAgICAgICAgICAgIGxvZzogMTAwLCAvLyBoaWdoIHByaW9yaXR5IC0gZG8gYWxsIGxvZ2dpbmcgZmlyc3RcbiAgICAgICAgICAgIGZhaWw6IFwibGFzdFwiXG4gICAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIHByb2Nlc3Mub24oXCJ1bmNhdWdodEV4Y2VwdGlvblwiLCBmdW5jdGlvbiBvblVuY2F1Z2h0RXhjZXB0aW9uIChlcnIpIHtcbiAgICAgICAgZmx1aWQub25VbmNhdWdodEV4Y2VwdGlvbi5maXJlKGVycik7XG4gICAgfSk7XG4gICAgXG4gICAgZmx1aWQubG9nVW5jYXVnaHRFeGNlcHRpb24gPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gXCJGQVRBTCBFUlJPUjogVW5jYXVnaHQgZXhjZXB0aW9uOiBcIiArIGVyci5tZXNzYWdlO1xuICAgICAgICBmbHVpZC5sb2coZmx1aWQubG9nTGV2ZWwuRkFUQUwsIG1lc3NhZ2UpO1xuICAgICAgICBjb25zb2xlLmxvZyhlcnIuc3RhY2spO1xuICAgIH07XG4gICAgXG4gICAgZmx1aWQub25VbmNhdWdodEV4Y2VwdGlvbi5hZGRMaXN0ZW5lcihmbHVpZC5sb2dVbmNhdWdodEV4Y2VwdGlvbiwgXCJsb2dcIiwgbnVsbCxcbiAgICAgICAgZmx1aWQuaGFuZGxlclByaW9yaXRpZXMudW5jYXVnaHRFeGNlcHRpb24ubG9nKTtcbiAgICAgIFxuICAgIC8vIENvbnZlcnQgYW4gYXJndW1lbnQgaW50ZW5kZWQgZm9yIGNvbnNvbGUubG9nIGluIHRoZSBub2RlIGVudmlyb25tZW50IHRvIGEgcmVhZGFibGUgZm9ybSAodGhlXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gb2YgdXRpbC5pbnNwZWN0IGNlbnNvcnMgYXQgZGVwdGggMSlcbiAgICBmbHVpZC5yZW5kZXJMb2dnaW5nQXJnID0gZnVuY3Rpb24gKGFyZykge1xuICAgICAgICB2YXIgdG9nbyA9IGFyZyAmJiBmbHVpZC5pc1ByaW1pdGl2ZShhcmcpID8gYXJnIDogZmx1aWQucHJldHR5UHJpbnRKU09OKGFyZyk7XG4gICAgICAgIGlmICh0eXBlb2YodG9nbykgPT09IFwic3RyaW5nXCIgJiYgdG9nby5sZW5ndGggPiBmbHVpZC5sb2dPYmplY3RSZW5kZXJDaGFycykge1xuICAgICAgICAgICAgdG9nbyA9IHRvZ28uc3Vic3RyaW5nKDAsIGZsdWlkLmxvZ09iamVjdFJlbmRlckNoYXJzKSArIFwiIC4uLi4gW291dHB1dCBzdXBwcmVzc2VkIGF0IFwiICsgZmx1aWQubG9nT2JqZWN0UmVuZGVyQ2hhcnMgKyBcIiBjaGFycyAtIGZvciBtb3JlIG91dHB1dCwgaW5jcmVhc2UgZmx1aWQubG9nT2JqZWN0UmVuZGVyQ2hhcnNdXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvZ287XG4gICAgfTtcbiAgICBcbiAgICAvLyBNb25rZXktcGF0Y2ggdGhlIGJ1aWx0LWluIGZsdWlkLmRvTG9nIHV0aWxpdHkgdG8gaW1wcm92ZSBpdHMgYmVoYXZpb3VyIHdpdGhpbiBub2RlLmpzIC0gc2VlIEZMVUlELTU0NzVcbiAgICBmbHVpZC5kb0xvZyA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgIGFyZ3MgPSBmbHVpZC50cmFuc2Zvcm0oYXJncywgZmx1aWQucmVuZGVyTG9nZ2luZ0FyZyk7XG4gICAgICAgIGNvbnNvbGUubG9nKGFyZ3Muam9pbihcIlwiKSk7XG4gICAgfTtcblxuICAgIGZsdWlkLmxvYWRJbkNvbnRleHQgPSBsb2FkSW5Db250ZXh0O1xuICAgIGZsdWlkLmxvYWRJbmNsdWRlcyA9IGxvYWRJbmNsdWRlcztcblxuICAgIC8qKiBMb2FkIGEgbm9kZS1hd2FyZSBKYXZhU2NyaXB0IGZpbGUgdXNpbmcgZWl0aGVyIGEgc3VwcGxpZWQgb3IgdGhlIG5hdGl2ZVxuICAgICAgKiBGbHVpZCByZXF1aXJlIGZ1bmN0aW9uLiBUaGUgbW9kdWxlIG5hbWUgbWF5IHN0YXJ0IHdpdGggYSBtb2R1bGUgcmVmZXJlbmNlXG4gICAgICAqIG9mIHRoZSBmb3JtICR7bW9kdWxlLW5hbWV9IHRvIGluZGljYXRlIGEgYmFzZSByZWZlcmVuY2UgaW50byBhbiBhbHJlYWR5XG4gICAgICAqIGxvYWRlZCBtb2R1bGUgdGhhdCB3YXMgcHJldmlvdXNseSByZWdpc3RlcmVkIHVzaW5nIGZsdWlkLm1vZHVsZS5yZWdpc3Rlci5cbiAgICAgICogSWYgdGhlIDxjb2RlPm5hbWVzcGFjZTwvY29kZT4gYXJndW1lbnQgaXMgc3VwcGxpZWQsIHRoZSBtb2R1bGUncyBleHBvcnRcbiAgICAgICogb2JqZWN0IHdpbGwgYmUgd3JpdHRlbiB0byB0aGF0IHBhdGggaW4gdGhlIGdsb2JhbCBGbHVpZCBuYW1lc3BhY2UgKi9cblxuICAgIGZsdWlkLnJlcXVpcmUgPSBmdW5jdGlvbiAobW9kdWxlTmFtZSwgZm9yZWlnblJlcXVpcmUsIG5hbWVzcGFjZSkge1xuICAgICAgICBmb3JlaWduUmVxdWlyZSA9IGZvcmVpZ25SZXF1aXJlIHx8IHJlcXVpcmU7XG4gICAgICAgIHZhciByZXNvbHZlZCA9IGZsdWlkLm1vZHVsZS5yZXNvbHZlUGF0aChtb2R1bGVOYW1lKTtcbiAgICAgICAgdmFyIG1vZHVsZSA9IGZvcmVpZ25SZXF1aXJlKHJlc29sdmVkKTtcbiAgICAgICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgICAgICAgZmx1aWQuc2V0R2xvYmFsVmFsdWUobmFtZXNwYWNlLCBtb2R1bGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2R1bGU7XG4gICAgfTtcblxuICAgIC8qKiBQcm9kdWNlIGEgbG9hZGVyIG9iamVjdCBleHBvc2luZyBhIFwicmVxdWlyZVwiIG9iamVjdCB3aGljaCB3aWxsIGF1dG9tYXRpY2FsbHlcbiAgICAgKiBwcmVmaXggdGhlIHN1cHBsaWVkIGRpcmVjdG9yeSBuYW1lIHRvIGFueSByZXF1ZXN0ZWQgbW9kdWxlcyBiZWZvcmUgZm9yd2FyZGluZ1xuICAgICAqIHRoZSBvcGVyYXRpb24gdG8gZmx1aWQucmVxdWlyZVxuICAgICAqL1xuXG4gICAgZmx1aWQuZ2V0TG9hZGVyID0gZnVuY3Rpb24gKGRpck5hbWUsIGZvcmVpZ25SZXF1aXJlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXF1aXJlOiBmdW5jdGlvbiAobW9kdWxlTmFtZSwgbmFtZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vZHVsZU5hbWUuaW5kZXhPZihcIi9cIikgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGVOYW1lID0gZGlyTmFtZSArIFwiL1wiICsgbW9kdWxlTmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZsdWlkLnJlcXVpcmUobW9kdWxlTmFtZSwgZm9yZWlnblJlcXVpcmUsIG5hbWVzcGFjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldCB1cCB0ZXN0aW5nIGVudmlyb25tZW50IHdpdGgganFVbml0IGFuZCBJb0MgVGVzdCBVdGlscyBpbiBub2RlLlxuICAgICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBsb2FkIGV2ZXJ5dGhpbmcgbmVjZXNzYXJ5IGZvciBydW5uaW5nIG5vZGUganFVbml0LlxuICAgICAqL1xuICAgIGZsdWlkLmxvYWRUZXN0aW5nU3VwcG9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZmx1aWQubG9hZEluY2x1ZGVzKFwiZGV2SW5jbHVkZXMuanNvblwiKTtcbiAgICB9O1xuICAgIFxuICAgIGlmIChnbG9iYWwuZmx1aWQpIHtcbiAgICAgICAgdmFyIG9sZFBhdGggPSBnbG9iYWwuZmx1aWQubW9kdWxlLm1vZHVsZXMuaW5mdXNpb24uYmFzZURpcjtcbiAgICAgICAgZmx1aWQuZmFpbChcIkVycm9yIGxvYWRpbmcgaW5mdXNpb24gLSBpbmZ1c2lvbiBoYXMgYWxyZWFkeSBiZWVuIGxvYWRlZCBmcm9tIHRoZSBwYXRoIFxcblxcdFwiICsgcGF0aC5yZXNvbHZlKG9sZFBhdGgpICtcbiAgICAgICAgICAgIFwiXFxuIC0gcGxlYXNlIGRlbGV0ZSB0aGUgZHVwbGljYXRlIGNvcHkgd2hpY2ggaXMgZm91bmQgYXQgXFxuXFx0XCIgKyBwYXRoLnJlc29sdmUoX19kaXJuYW1lKSArXG4gICAgICAgICAgICBcIlxcbiBUaGlzIGNhbiBiZSBkb25lIGF1dG9tYXRpY2FsbHkgYnkgcnVubmluZyB0aGUgdGFzayBcXFwiZ3J1bnQgZGVkdXBlLWluZnVzaW9uXFxcIlwiKTtcbiAgICB9XG4gICAgXG4gICAgZmx1aWQubW9kdWxlLnJlZ2lzdGVyKFwiaW5mdXNpb25cIiwgbW9kdWxlQmFzZURpciwgcmVxdWlyZSk7XG4gICAgXG4gICAgLy8gRXhwb3J0IHRoZSBmbHVpZCBvYmplY3QgaW50byB0aGUgcGFuLW1vZHVsZSBub2RlLmpzIGdsb2JhbCBvYmplY3RcbiAgICBnbG9iYWwuZmx1aWQgPSBmbHVpZDtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gZmx1aWQ7XG5cbn0pKCk7IiwiLyohXG4gKiBqUXVlcnkgSmF2YVNjcmlwdCBMaWJyYXJ5IHYzLjEuMVxuICogaHR0cHM6Ly9qcXVlcnkuY29tL1xuICpcbiAqIEluY2x1ZGVzIFNpenpsZS5qc1xuICogaHR0cHM6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE2LTA5LTIyVDIyOjMwWlxuICovXG4oIGZ1bmN0aW9uKCBnbG9iYWwsIGZhY3RvcnkgKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0aWYgKCB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIEZvciBDb21tb25KUyBhbmQgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgd2hlcmUgYSBwcm9wZXIgYHdpbmRvd2Bcblx0XHQvLyBpcyBwcmVzZW50LCBleGVjdXRlIHRoZSBmYWN0b3J5IGFuZCBnZXQgalF1ZXJ5LlxuXHRcdC8vIEZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3QgaGF2ZSBhIGB3aW5kb3dgIHdpdGggYSBgZG9jdW1lbnRgXG5cdFx0Ly8gKHN1Y2ggYXMgTm9kZS5qcyksIGV4cG9zZSBhIGZhY3RvcnkgYXMgbW9kdWxlLmV4cG9ydHMuXG5cdFx0Ly8gVGhpcyBhY2NlbnR1YXRlcyB0aGUgbmVlZCBmb3IgdGhlIGNyZWF0aW9uIG9mIGEgcmVhbCBgd2luZG93YC5cblx0XHQvLyBlLmcuIHZhciBqUXVlcnkgPSByZXF1aXJlKFwianF1ZXJ5XCIpKHdpbmRvdyk7XG5cdFx0Ly8gU2VlIHRpY2tldCAjMTQ1NDkgZm9yIG1vcmUgaW5mby5cblx0XHRtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5kb2N1bWVudCA/XG5cdFx0XHRmYWN0b3J5KCBnbG9iYWwsIHRydWUgKSA6XG5cdFx0XHRmdW5jdGlvbiggdyApIHtcblx0XHRcdFx0aWYgKCAhdy5kb2N1bWVudCApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwialF1ZXJ5IHJlcXVpcmVzIGEgd2luZG93IHdpdGggYSBkb2N1bWVudFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhY3RvcnkoIHcgKTtcblx0XHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0ZmFjdG9yeSggZ2xvYmFsICk7XG5cdH1cblxuLy8gUGFzcyB0aGlzIGlmIHdpbmRvdyBpcyBub3QgZGVmaW5lZCB5ZXRcbn0gKSggdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uKCB3aW5kb3csIG5vR2xvYmFsICkge1xuXG4vLyBFZGdlIDw9IDEyIC0gMTMrLCBGaXJlZm94IDw9MTggLSA0NSssIElFIDEwIC0gMTEsIFNhZmFyaSA1LjEgLSA5KywgaU9TIDYgLSA5LjFcbi8vIHRocm93IGV4Y2VwdGlvbnMgd2hlbiBub24tc3RyaWN0IGNvZGUgKGUuZy4sIEFTUC5ORVQgNC41KSBhY2Nlc3NlcyBzdHJpY3QgbW9kZVxuLy8gYXJndW1lbnRzLmNhbGxlZS5jYWxsZXIgKHRyYWMtMTMzMzUpLiBCdXQgYXMgb2YgalF1ZXJ5IDMuMCAoMjAxNiksIHN0cmljdCBtb2RlIHNob3VsZCBiZSBjb21tb25cbi8vIGVub3VnaCB0aGF0IGFsbCBzdWNoIGF0dGVtcHRzIGFyZSBndWFyZGVkIGluIGEgdHJ5IGJsb2NrLlxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBhcnIgPSBbXTtcblxudmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuXG52YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG5cbnZhciBzbGljZSA9IGFyci5zbGljZTtcblxudmFyIGNvbmNhdCA9IGFyci5jb25jYXQ7XG5cbnZhciBwdXNoID0gYXJyLnB1c2g7XG5cbnZhciBpbmRleE9mID0gYXJyLmluZGV4T2Y7XG5cbnZhciBjbGFzczJ0eXBlID0ge307XG5cbnZhciB0b1N0cmluZyA9IGNsYXNzMnR5cGUudG9TdHJpbmc7XG5cbnZhciBoYXNPd24gPSBjbGFzczJ0eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgZm5Ub1N0cmluZyA9IGhhc093bi50b1N0cmluZztcblxudmFyIE9iamVjdEZ1bmN0aW9uU3RyaW5nID0gZm5Ub1N0cmluZy5jYWxsKCBPYmplY3QgKTtcblxudmFyIHN1cHBvcnQgPSB7fTtcblxuXG5cblx0ZnVuY3Rpb24gRE9NRXZhbCggY29kZSwgZG9jICkge1xuXHRcdGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcblxuXHRcdHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudCggXCJzY3JpcHRcIiApO1xuXG5cdFx0c2NyaXB0LnRleHQgPSBjb2RlO1xuXHRcdGRvYy5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHQgKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBzY3JpcHQgKTtcblx0fVxuLyogZ2xvYmFsIFN5bWJvbCAqL1xuLy8gRGVmaW5pbmcgdGhpcyBnbG9iYWwgaW4gLmVzbGludHJjLmpzb24gd291bGQgY3JlYXRlIGEgZGFuZ2VyIG9mIHVzaW5nIHRoZSBnbG9iYWxcbi8vIHVuZ3VhcmRlZCBpbiBhbm90aGVyIHBsYWNlLCBpdCBzZWVtcyBzYWZlciB0byBkZWZpbmUgZ2xvYmFsIG9ubHkgZm9yIHRoaXMgbW9kdWxlXG5cblxuXG52YXJcblx0dmVyc2lvbiA9IFwiMy4xLjFcIixcblxuXHQvLyBEZWZpbmUgYSBsb2NhbCBjb3B5IG9mIGpRdWVyeVxuXHRqUXVlcnkgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cblx0XHQvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcblx0XHQvLyBOZWVkIGluaXQgaWYgalF1ZXJ5IGlzIGNhbGxlZCAoanVzdCBhbGxvdyBlcnJvciB0byBiZSB0aHJvd24gaWYgbm90IGluY2x1ZGVkKVxuXHRcdHJldHVybiBuZXcgalF1ZXJ5LmZuLmluaXQoIHNlbGVjdG9yLCBjb250ZXh0ICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5XG5cdC8vIE1ha2Ugc3VyZSB3ZSB0cmltIEJPTSBhbmQgTkJTUFxuXHRydHJpbSA9IC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZyxcblxuXHQvLyBNYXRjaGVzIGRhc2hlZCBzdHJpbmcgZm9yIGNhbWVsaXppbmdcblx0cm1zUHJlZml4ID0gL14tbXMtLyxcblx0cmRhc2hBbHBoYSA9IC8tKFthLXpdKS9nLFxuXG5cdC8vIFVzZWQgYnkgalF1ZXJ5LmNhbWVsQ2FzZSBhcyBjYWxsYmFjayB0byByZXBsYWNlKClcblx0ZmNhbWVsQ2FzZSA9IGZ1bmN0aW9uKCBhbGwsIGxldHRlciApIHtcblx0XHRyZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XG5cdH07XG5cbmpRdWVyeS5mbiA9IGpRdWVyeS5wcm90b3R5cGUgPSB7XG5cblx0Ly8gVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBqUXVlcnkgYmVpbmcgdXNlZFxuXHRqcXVlcnk6IHZlcnNpb24sXG5cblx0Y29uc3RydWN0b3I6IGpRdWVyeSxcblxuXHQvLyBUaGUgZGVmYXVsdCBsZW5ndGggb2YgYSBqUXVlcnkgb2JqZWN0IGlzIDBcblx0bGVuZ3RoOiAwLFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG5cdH0sXG5cblx0Ly8gR2V0IHRoZSBOdGggZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldCBPUlxuXHQvLyBHZXQgdGhlIHdob2xlIG1hdGNoZWQgZWxlbWVudCBzZXQgYXMgYSBjbGVhbiBhcnJheVxuXHRnZXQ6IGZ1bmN0aW9uKCBudW0gKSB7XG5cblx0XHQvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBpbiBhIGNsZWFuIGFycmF5XG5cdFx0aWYgKCBudW0gPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIGp1c3QgdGhlIG9uZSBlbGVtZW50IGZyb20gdGhlIHNldFxuXHRcdHJldHVybiBudW0gPCAwID8gdGhpc1sgbnVtICsgdGhpcy5sZW5ndGggXSA6IHRoaXNbIG51bSBdO1xuXHR9LFxuXG5cdC8vIFRha2UgYW4gYXJyYXkgb2YgZWxlbWVudHMgYW5kIHB1c2ggaXQgb250byB0aGUgc3RhY2tcblx0Ly8gKHJldHVybmluZyB0aGUgbmV3IG1hdGNoZWQgZWxlbWVudCBzZXQpXG5cdHB1c2hTdGFjazogZnVuY3Rpb24oIGVsZW1zICkge1xuXG5cdFx0Ly8gQnVpbGQgYSBuZXcgalF1ZXJ5IG1hdGNoZWQgZWxlbWVudCBzZXRcblx0XHR2YXIgcmV0ID0galF1ZXJ5Lm1lcmdlKCB0aGlzLmNvbnN0cnVjdG9yKCksIGVsZW1zICk7XG5cblx0XHQvLyBBZGQgdGhlIG9sZCBvYmplY3Qgb250byB0aGUgc3RhY2sgKGFzIGEgcmVmZXJlbmNlKVxuXHRcdHJldC5wcmV2T2JqZWN0ID0gdGhpcztcblxuXHRcdC8vIFJldHVybiB0aGUgbmV3bHktZm9ybWVkIGVsZW1lbnQgc2V0XG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHQvLyBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgc2V0LlxuXHRlYWNoOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5lYWNoKCB0aGlzLCBjYWxsYmFjayApO1xuXHR9LFxuXG5cdG1hcDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5Lm1hcCggdGhpcywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gY2FsbGJhY2suY2FsbCggZWxlbSwgaSwgZWxlbSApO1xuXHRcdH0gKSApO1xuXHR9LFxuXG5cdHNsaWNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHNsaWNlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSApO1xuXHR9LFxuXG5cdGZpcnN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggMCApO1xuXHR9LFxuXG5cdGxhc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAtMSApO1xuXHR9LFxuXG5cdGVxOiBmdW5jdGlvbiggaSApIHtcblx0XHR2YXIgbGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRqID0gK2kgKyAoIGkgPCAwID8gbGVuIDogMCApO1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggaiA+PSAwICYmIGogPCBsZW4gPyBbIHRoaXNbIGogXSBdIDogW10gKTtcblx0fSxcblxuXHRlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnByZXZPYmplY3QgfHwgdGhpcy5jb25zdHJ1Y3RvcigpO1xuXHR9LFxuXG5cdC8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cblx0Ly8gQmVoYXZlcyBsaWtlIGFuIEFycmF5J3MgbWV0aG9kLCBub3QgbGlrZSBhIGpRdWVyeSBtZXRob2QuXG5cdHB1c2g6IHB1c2gsXG5cdHNvcnQ6IGFyci5zb3J0LFxuXHRzcGxpY2U6IGFyci5zcGxpY2Vcbn07XG5cbmpRdWVyeS5leHRlbmQgPSBqUXVlcnkuZm4uZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG5cdHZhciBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZSxcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIDAgXSB8fCB7fSxcblx0XHRpID0gMSxcblx0XHRsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdGRlZXAgPSBmYWxzZTtcblxuXHQvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG5cdGlmICggdHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0ZGVlcCA9IHRhcmdldDtcblxuXHRcdC8vIFNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIGkgXSB8fCB7fTtcblx0XHRpKys7XG5cdH1cblxuXHQvLyBIYW5kbGUgY2FzZSB3aGVuIHRhcmdldCBpcyBhIHN0cmluZyBvciBzb21ldGhpbmcgKHBvc3NpYmxlIGluIGRlZXAgY29weSlcblx0aWYgKCB0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiICYmICFqUXVlcnkuaXNGdW5jdGlvbiggdGFyZ2V0ICkgKSB7XG5cdFx0dGFyZ2V0ID0ge307XG5cdH1cblxuXHQvLyBFeHRlbmQgalF1ZXJ5IGl0c2VsZiBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcblx0aWYgKCBpID09PSBsZW5ndGggKSB7XG5cdFx0dGFyZ2V0ID0gdGhpcztcblx0XHRpLS07XG5cdH1cblxuXHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblxuXHRcdC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcblx0XHRpZiAoICggb3B0aW9ucyA9IGFyZ3VtZW50c1sgaSBdICkgIT0gbnVsbCApIHtcblxuXHRcdFx0Ly8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuXHRcdFx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRzcmMgPSB0YXJnZXRbIG5hbWUgXTtcblx0XHRcdFx0Y29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG5cdFx0XHRcdGlmICggdGFyZ2V0ID09PSBjb3B5ICkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXG5cdFx0XHRcdGlmICggZGVlcCAmJiBjb3B5ICYmICggalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvcHkgKSB8fFxuXHRcdFx0XHRcdCggY29weUlzQXJyYXkgPSBqUXVlcnkuaXNBcnJheSggY29weSApICkgKSApIHtcblxuXHRcdFx0XHRcdGlmICggY29weUlzQXJyYXkgKSB7XG5cdFx0XHRcdFx0XHRjb3B5SXNBcnJheSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzQXJyYXkoIHNyYyApID8gc3JjIDogW107XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHNyYyApID8gc3JjIDoge307XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApO1xuXG5cdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0fSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0gY29weTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gVW5pcXVlIGZvciBlYWNoIGNvcHkgb2YgalF1ZXJ5IG9uIHRoZSBwYWdlXG5cdGV4cGFuZG86IFwialF1ZXJ5XCIgKyAoIHZlcnNpb24gKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xcRC9nLCBcIlwiICksXG5cblx0Ly8gQXNzdW1lIGpRdWVyeSBpcyByZWFkeSB3aXRob3V0IHRoZSByZWFkeSBtb2R1bGVcblx0aXNSZWFkeTogdHJ1ZSxcblxuXHRlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXHR9LFxuXG5cdG5vb3A6IGZ1bmN0aW9uKCkge30sXG5cblx0aXNGdW5jdGlvbjogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRyZXR1cm4galF1ZXJ5LnR5cGUoIG9iaiApID09PSBcImZ1bmN0aW9uXCI7XG5cdH0sXG5cblx0aXNBcnJheTogQXJyYXkuaXNBcnJheSxcblxuXHRpc1dpbmRvdzogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRyZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmoud2luZG93O1xuXHR9LFxuXG5cdGlzTnVtZXJpYzogZnVuY3Rpb24oIG9iaiApIHtcblxuXHRcdC8vIEFzIG9mIGpRdWVyeSAzLjAsIGlzTnVtZXJpYyBpcyBsaW1pdGVkIHRvXG5cdFx0Ly8gc3RyaW5ncyBhbmQgbnVtYmVycyAocHJpbWl0aXZlcyBvciBvYmplY3RzKVxuXHRcdC8vIHRoYXQgY2FuIGJlIGNvZXJjZWQgdG8gZmluaXRlIG51bWJlcnMgKGdoLTI2NjIpXG5cdFx0dmFyIHR5cGUgPSBqUXVlcnkudHlwZSggb2JqICk7XG5cdFx0cmV0dXJuICggdHlwZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlID09PSBcInN0cmluZ1wiICkgJiZcblxuXHRcdFx0Ly8gcGFyc2VGbG9hdCBOYU5zIG51bWVyaWMtY2FzdCBmYWxzZSBwb3NpdGl2ZXMgKFwiXCIpXG5cdFx0XHQvLyAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcIjB4Li4uXCIpXG5cdFx0XHQvLyBzdWJ0cmFjdGlvbiBmb3JjZXMgaW5maW5pdGllcyB0byBOYU5cblx0XHRcdCFpc05hTiggb2JqIC0gcGFyc2VGbG9hdCggb2JqICkgKTtcblx0fSxcblxuXHRpc1BsYWluT2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBwcm90bywgQ3RvcjtcblxuXHRcdC8vIERldGVjdCBvYnZpb3VzIG5lZ2F0aXZlc1xuXHRcdC8vIFVzZSB0b1N0cmluZyBpbnN0ZWFkIG9mIGpRdWVyeS50eXBlIHRvIGNhdGNoIGhvc3Qgb2JqZWN0c1xuXHRcdGlmICggIW9iaiB8fCB0b1N0cmluZy5jYWxsKCBvYmogKSAhPT0gXCJbb2JqZWN0IE9iamVjdF1cIiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRwcm90byA9IGdldFByb3RvKCBvYmogKTtcblxuXHRcdC8vIE9iamVjdHMgd2l0aCBubyBwcm90b3R5cGUgKGUuZy4sIGBPYmplY3QuY3JlYXRlKCBudWxsIClgKSBhcmUgcGxhaW5cblx0XHRpZiAoICFwcm90byApIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIE9iamVjdHMgd2l0aCBwcm90b3R5cGUgYXJlIHBsYWluIGlmZiB0aGV5IHdlcmUgY29uc3RydWN0ZWQgYnkgYSBnbG9iYWwgT2JqZWN0IGZ1bmN0aW9uXG5cdFx0Q3RvciA9IGhhc093bi5jYWxsKCBwcm90bywgXCJjb25zdHJ1Y3RvclwiICkgJiYgcHJvdG8uY29uc3RydWN0b3I7XG5cdFx0cmV0dXJuIHR5cGVvZiBDdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgZm5Ub1N0cmluZy5jYWxsKCBDdG9yICkgPT09IE9iamVjdEZ1bmN0aW9uU3RyaW5nO1xuXHR9LFxuXG5cdGlzRW1wdHlPYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cblx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZXNsaW50L2VzbGludC9pc3N1ZXMvNjEyNVxuXHRcdHZhciBuYW1lO1xuXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdHR5cGU6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0aWYgKCBvYmogPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiBvYmogKyBcIlwiO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD0yLjMgb25seSAoZnVuY3Rpb25pc2ggUmVnRXhwKVxuXHRcdHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiA/XG5cdFx0XHRjbGFzczJ0eXBlWyB0b1N0cmluZy5jYWxsKCBvYmogKSBdIHx8IFwib2JqZWN0XCIgOlxuXHRcdFx0dHlwZW9mIG9iajtcblx0fSxcblxuXHQvLyBFdmFsdWF0ZXMgYSBzY3JpcHQgaW4gYSBnbG9iYWwgY29udGV4dFxuXHRnbG9iYWxFdmFsOiBmdW5jdGlvbiggY29kZSApIHtcblx0XHRET01FdmFsKCBjb2RlICk7XG5cdH0sXG5cblx0Ly8gQ29udmVydCBkYXNoZWQgdG8gY2FtZWxDYXNlOyB1c2VkIGJ5IHRoZSBjc3MgYW5kIGRhdGEgbW9kdWxlc1xuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDEzXG5cdC8vIE1pY3Jvc29mdCBmb3Jnb3QgdG8gaHVtcCB0aGVpciB2ZW5kb3IgcHJlZml4ICgjOTU3Milcblx0Y2FtZWxDYXNlOiBmdW5jdGlvbiggc3RyaW5nICkge1xuXHRcdHJldHVybiBzdHJpbmcucmVwbGFjZSggcm1zUHJlZml4LCBcIm1zLVwiICkucmVwbGFjZSggcmRhc2hBbHBoYSwgZmNhbWVsQ2FzZSApO1xuXHR9LFxuXG5cdG5vZGVOYW1lOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0fSxcblxuXHRlYWNoOiBmdW5jdGlvbiggb2JqLCBjYWxsYmFjayApIHtcblx0XHR2YXIgbGVuZ3RoLCBpID0gMDtcblxuXHRcdGlmICggaXNBcnJheUxpa2UoIG9iaiApICkge1xuXHRcdFx0bGVuZ3RoID0gb2JqLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIG9iaiApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gb2JqO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seVxuXHR0cmltOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRyZXR1cm4gdGV4dCA9PSBudWxsID9cblx0XHRcdFwiXCIgOlxuXHRcdFx0KCB0ZXh0ICsgXCJcIiApLnJlcGxhY2UoIHJ0cmltLCBcIlwiICk7XG5cdH0sXG5cblx0Ly8gcmVzdWx0cyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYWtlQXJyYXk6IGZ1bmN0aW9uKCBhcnIsIHJlc3VsdHMgKSB7XG5cdFx0dmFyIHJldCA9IHJlc3VsdHMgfHwgW107XG5cblx0XHRpZiAoIGFyciAhPSBudWxsICkge1xuXHRcdFx0aWYgKCBpc0FycmF5TGlrZSggT2JqZWN0KCBhcnIgKSApICkge1xuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHJldCxcblx0XHRcdFx0XHR0eXBlb2YgYXJyID09PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRbIGFyciBdIDogYXJyXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmNhbGwoIHJldCwgYXJyICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHRpbkFycmF5OiBmdW5jdGlvbiggZWxlbSwgYXJyLCBpICkge1xuXHRcdHJldHVybiBhcnIgPT0gbnVsbCA/IC0xIDogaW5kZXhPZi5jYWxsKCBhcnIsIGVsZW0sIGkgKTtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRtZXJnZTogZnVuY3Rpb24oIGZpcnN0LCBzZWNvbmQgKSB7XG5cdFx0dmFyIGxlbiA9ICtzZWNvbmQubGVuZ3RoLFxuXHRcdFx0aiA9IDAsXG5cdFx0XHRpID0gZmlyc3QubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRmaXJzdFsgaSsrIF0gPSBzZWNvbmRbIGogXTtcblx0XHR9XG5cblx0XHRmaXJzdC5sZW5ndGggPSBpO1xuXG5cdFx0cmV0dXJuIGZpcnN0O1xuXHR9LFxuXG5cdGdyZXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGludmVydCApIHtcblx0XHR2YXIgY2FsbGJhY2tJbnZlcnNlLFxuXHRcdFx0bWF0Y2hlcyA9IFtdLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGgsXG5cdFx0XHRjYWxsYmFja0V4cGVjdCA9ICFpbnZlcnQ7XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgb25seSBzYXZpbmcgdGhlIGl0ZW1zXG5cdFx0Ly8gdGhhdCBwYXNzIHRoZSB2YWxpZGF0b3IgZnVuY3Rpb25cblx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdGNhbGxiYWNrSW52ZXJzZSA9ICFjYWxsYmFjayggZWxlbXNbIGkgXSwgaSApO1xuXHRcdFx0aWYgKCBjYWxsYmFja0ludmVyc2UgIT09IGNhbGxiYWNrRXhwZWN0ICkge1xuXHRcdFx0XHRtYXRjaGVzLnB1c2goIGVsZW1zWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbWF0Y2hlcztcblx0fSxcblxuXHQvLyBhcmcgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBhcmcgKSB7XG5cdFx0dmFyIGxlbmd0aCwgdmFsdWUsXG5cdFx0XHRpID0gMCxcblx0XHRcdHJldCA9IFtdO1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIHRyYW5zbGF0aW5nIGVhY2ggb2YgdGhlIGl0ZW1zIHRvIHRoZWlyIG5ldyB2YWx1ZXNcblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBlbGVtcyApICkge1xuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gR28gdGhyb3VnaCBldmVyeSBrZXkgb24gdGhlIG9iamVjdCxcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBlbGVtcyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRcdHJldHVybiBjb25jYXQuYXBwbHkoIFtdLCByZXQgKTtcblx0fSxcblxuXHQvLyBBIGdsb2JhbCBHVUlEIGNvdW50ZXIgZm9yIG9iamVjdHNcblx0Z3VpZDogMSxcblxuXHQvLyBCaW5kIGEgZnVuY3Rpb24gdG8gYSBjb250ZXh0LCBvcHRpb25hbGx5IHBhcnRpYWxseSBhcHBseWluZyBhbnlcblx0Ly8gYXJndW1lbnRzLlxuXHRwcm94eTogZnVuY3Rpb24oIGZuLCBjb250ZXh0ICkge1xuXHRcdHZhciB0bXAsIGFyZ3MsIHByb3h5O1xuXG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHRtcCA9IGZuWyBjb250ZXh0IF07XG5cdFx0XHRjb250ZXh0ID0gZm47XG5cdFx0XHRmbiA9IHRtcDtcblx0XHR9XG5cblx0XHQvLyBRdWljayBjaGVjayB0byBkZXRlcm1pbmUgaWYgdGFyZ2V0IGlzIGNhbGxhYmxlLCBpbiB0aGUgc3BlY1xuXHRcdC8vIHRoaXMgdGhyb3dzIGEgVHlwZUVycm9yLCBidXQgd2Ugd2lsbCBqdXN0IHJldHVybiB1bmRlZmluZWQuXG5cdFx0aWYgKCAhalF1ZXJ5LmlzRnVuY3Rpb24oIGZuICkgKSB7XG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFNpbXVsYXRlZCBiaW5kXG5cdFx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMiApO1xuXHRcdHByb3h5ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gZm4uYXBwbHkoIGNvbnRleHQgfHwgdGhpcywgYXJncy5jb25jYXQoIHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApICkgKTtcblx0XHR9O1xuXG5cdFx0Ly8gU2V0IHRoZSBndWlkIG9mIHVuaXF1ZSBoYW5kbGVyIHRvIHRoZSBzYW1lIG9mIG9yaWdpbmFsIGhhbmRsZXIsIHNvIGl0IGNhbiBiZSByZW1vdmVkXG5cdFx0cHJveHkuZ3VpZCA9IGZuLmd1aWQgPSBmbi5ndWlkIHx8IGpRdWVyeS5ndWlkKys7XG5cblx0XHRyZXR1cm4gcHJveHk7XG5cdH0sXG5cblx0bm93OiBEYXRlLm5vdyxcblxuXHQvLyBqUXVlcnkuc3VwcG9ydCBpcyBub3QgdXNlZCBpbiBDb3JlIGJ1dCBvdGhlciBwcm9qZWN0cyBhdHRhY2ggdGhlaXJcblx0Ly8gcHJvcGVydGllcyB0byBpdCBzbyBpdCBuZWVkcyB0byBleGlzdC5cblx0c3VwcG9ydDogc3VwcG9ydFxufSApO1xuXG5pZiAoIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0alF1ZXJ5LmZuWyBTeW1ib2wuaXRlcmF0b3IgXSA9IGFyclsgU3ltYm9sLml0ZXJhdG9yIF07XG59XG5cbi8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxualF1ZXJ5LmVhY2goIFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdCBFcnJvciBTeW1ib2xcIi5zcGxpdCggXCIgXCIgKSxcbmZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRjbGFzczJ0eXBlWyBcIltvYmplY3QgXCIgKyBuYW1lICsgXCJdXCIgXSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbn0gKTtcblxuZnVuY3Rpb24gaXNBcnJheUxpa2UoIG9iaiApIHtcblxuXHQvLyBTdXBwb3J0OiByZWFsIGlPUyA4LjIgb25seSAobm90IHJlcHJvZHVjaWJsZSBpbiBzaW11bGF0b3IpXG5cdC8vIGBpbmAgY2hlY2sgdXNlZCB0byBwcmV2ZW50IEpJVCBlcnJvciAoZ2gtMjE0NSlcblx0Ly8gaGFzT3duIGlzbid0IHVzZWQgaGVyZSBkdWUgdG8gZmFsc2UgbmVnYXRpdmVzXG5cdC8vIHJlZ2FyZGluZyBOb2RlbGlzdCBsZW5ndGggaW4gSUVcblx0dmFyIGxlbmd0aCA9ICEhb2JqICYmIFwibGVuZ3RoXCIgaW4gb2JqICYmIG9iai5sZW5ndGgsXG5cdFx0dHlwZSA9IGpRdWVyeS50eXBlKCBvYmogKTtcblxuXHRpZiAoIHR5cGUgPT09IFwiZnVuY3Rpb25cIiB8fCBqUXVlcnkuaXNXaW5kb3coIG9iaiApICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJldHVybiB0eXBlID09PSBcImFycmF5XCIgfHwgbGVuZ3RoID09PSAwIHx8XG5cdFx0dHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBsZW5ndGggPiAwICYmICggbGVuZ3RoIC0gMSApIGluIG9iajtcbn1cbnZhciBTaXp6bGUgPVxuLyohXG4gKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZSB2Mi4zLjNcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE2LTA4LTA4XG4gKi9cbihmdW5jdGlvbiggd2luZG93ICkge1xuXG52YXIgaSxcblx0c3VwcG9ydCxcblx0RXhwcixcblx0Z2V0VGV4dCxcblx0aXNYTUwsXG5cdHRva2VuaXplLFxuXHRjb21waWxlLFxuXHRzZWxlY3QsXG5cdG91dGVybW9zdENvbnRleHQsXG5cdHNvcnRJbnB1dCxcblx0aGFzRHVwbGljYXRlLFxuXG5cdC8vIExvY2FsIGRvY3VtZW50IHZhcnNcblx0c2V0RG9jdW1lbnQsXG5cdGRvY3VtZW50LFxuXHRkb2NFbGVtLFxuXHRkb2N1bWVudElzSFRNTCxcblx0cmJ1Z2d5UVNBLFxuXHRyYnVnZ3lNYXRjaGVzLFxuXHRtYXRjaGVzLFxuXHRjb250YWlucyxcblxuXHQvLyBJbnN0YW5jZS1zcGVjaWZpYyBkYXRhXG5cdGV4cGFuZG8gPSBcInNpenpsZVwiICsgMSAqIG5ldyBEYXRlKCksXG5cdHByZWZlcnJlZERvYyA9IHdpbmRvdy5kb2N1bWVudCxcblx0ZGlycnVucyA9IDAsXG5cdGRvbmUgPSAwLFxuXHRjbGFzc0NhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0dG9rZW5DYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdGNvbXBpbGVyQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRzb3J0T3JkZXIgPSBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gMDtcblx0fSxcblxuXHQvLyBJbnN0YW5jZSBtZXRob2RzXG5cdGhhc093biA9ICh7fSkuaGFzT3duUHJvcGVydHksXG5cdGFyciA9IFtdLFxuXHRwb3AgPSBhcnIucG9wLFxuXHRwdXNoX25hdGl2ZSA9IGFyci5wdXNoLFxuXHRwdXNoID0gYXJyLnB1c2gsXG5cdHNsaWNlID0gYXJyLnNsaWNlLFxuXHQvLyBVc2UgYSBzdHJpcHBlZC1kb3duIGluZGV4T2YgYXMgaXQncyBmYXN0ZXIgdGhhbiBuYXRpdmVcblx0Ly8gaHR0cHM6Ly9qc3BlcmYuY29tL3Rob3ItaW5kZXhvZi12cy1mb3IvNVxuXHRpbmRleE9mID0gZnVuY3Rpb24oIGxpc3QsIGVsZW0gKSB7XG5cdFx0dmFyIGkgPSAwLFxuXHRcdFx0bGVuID0gbGlzdC5sZW5ndGg7XG5cdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRpZiAoIGxpc3RbaV0gPT09IGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gLTE7XG5cdH0sXG5cblx0Ym9vbGVhbnMgPSBcImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXCIsXG5cblx0Ly8gUmVndWxhciBleHByZXNzaW9uc1xuXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzLyN3aGl0ZXNwYWNlXG5cdHdoaXRlc3BhY2UgPSBcIltcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdXCIsXG5cblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI3ZhbHVlLWRlZi1pZGVudGlmaWVyXG5cdGlkZW50aWZpZXIgPSBcIig/OlxcXFxcXFxcLnxbXFxcXHctXXxbXlxcMC1cXFxceGEwXSkrXCIsXG5cblx0Ly8gQXR0cmlidXRlIHNlbGVjdG9yczogaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXG5cdGF0dHJpYnV0ZXMgPSBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFwiICsgaWRlbnRpZmllciArIFwiKSg/OlwiICsgd2hpdGVzcGFjZSArXG5cdFx0Ly8gT3BlcmF0b3IgKGNhcHR1cmUgMilcblx0XHRcIiooWypeJHwhfl0/PSlcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIFwiQXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIENTUyBpZGVudGlmaWVycyBbY2FwdHVyZSA1XSBvciBzdHJpbmdzIFtjYXB0dXJlIDMgb3IgY2FwdHVyZSA0XVwiXG5cdFx0XCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArIGlkZW50aWZpZXIgKyBcIikpfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFwiKlxcXFxdXCIsXG5cblx0cHNldWRvcyA9IFwiOihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcXFxcKChcIiArXG5cdFx0Ly8gVG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygc2VsZWN0b3JzIG5lZWRpbmcgdG9rZW5pemUgaW4gdGhlIHByZUZpbHRlciwgcHJlZmVyIGFyZ3VtZW50czpcblx0XHQvLyAxLiBxdW90ZWQgKGNhcHR1cmUgMzsgY2FwdHVyZSA0IG9yIGNhcHR1cmUgNSlcblx0XHRcIignKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCIpfFwiICtcblx0XHQvLyAyLiBzaW1wbGUgKGNhcHR1cmUgNilcblx0XHRcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIiArIGF0dHJpYnV0ZXMgKyBcIikqKXxcIiArXG5cdFx0Ly8gMy4gYW55dGhpbmcgZWxzZSAoY2FwdHVyZSAyKVxuXHRcdFwiLipcIiArXG5cdFx0XCIpXFxcXCl8KVwiLFxuXG5cdC8vIExlYWRpbmcgYW5kIG5vbi1lc2NhcGVkIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGNhcHR1cmluZyBzb21lIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMgcHJlY2VkaW5nIHRoZSBsYXR0ZXJcblx0cndoaXRlc3BhY2UgPSBuZXcgUmVnRXhwKCB3aGl0ZXNwYWNlICsgXCIrXCIsIFwiZ1wiICksXG5cdHJ0cmltID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIrfCgoPzpefFteXFxcXFxcXFxdKSg/OlxcXFxcXFxcLikqKVwiICsgd2hpdGVzcGFjZSArIFwiKyRcIiwgXCJnXCIgKSxcblxuXHRyY29tbWEgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiosXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblx0cmNvbWJpbmF0b3JzID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFs+K35dfFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cblx0cmF0dHJpYnV0ZVF1b3RlcyA9IG5ldyBSZWdFeHAoIFwiPVwiICsgd2hpdGVzcGFjZSArIFwiKihbXlxcXFxdJ1xcXCJdKj8pXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXF1cIiwgXCJnXCIgKSxcblxuXHRycHNldWRvID0gbmV3IFJlZ0V4cCggcHNldWRvcyApLFxuXHRyaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoIFwiXlwiICsgaWRlbnRpZmllciArIFwiJFwiICksXG5cblx0bWF0Y2hFeHByID0ge1xuXHRcdFwiSURcIjogbmV3IFJlZ0V4cCggXCJeIyhcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiQ0xBU1NcIjogbmV3IFJlZ0V4cCggXCJeXFxcXC4oXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRcIlRBR1wiOiBuZXcgUmVnRXhwKCBcIl4oXCIgKyBpZGVudGlmaWVyICsgXCJ8WypdKVwiICksXG5cdFx0XCJBVFRSXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgYXR0cmlidXRlcyApLFxuXHRcdFwiUFNFVURPXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgcHNldWRvcyApLFxuXHRcdFwiQ0hJTERcIjogbmV3IFJlZ0V4cCggXCJeOihvbmx5fGZpcnN0fGxhc3R8bnRofG50aC1sYXN0KS0oY2hpbGR8b2YtdHlwZSkoPzpcXFxcKFwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXGQqKW58KVwiICsgd2hpdGVzcGFjZSArIFwiKig/OihbKy1dfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKFxcXFxkKyl8KSlcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpXCIsIFwiaVwiICksXG5cdFx0XCJib29sXCI6IG5ldyBSZWdFeHAoIFwiXig/OlwiICsgYm9vbGVhbnMgKyBcIikkXCIsIFwiaVwiICksXG5cdFx0Ly8gRm9yIHVzZSBpbiBsaWJyYXJpZXMgaW1wbGVtZW50aW5nIC5pcygpXG5cdFx0Ly8gV2UgdXNlIHRoaXMgZm9yIFBPUyBtYXRjaGluZyBpbiBgc2VsZWN0YFxuXHRcdFwibmVlZHNDb250ZXh0XCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXChcIiArXG5cdFx0XHR3aGl0ZXNwYWNlICsgXCIqKCg/Oi1cXFxcZCk/XFxcXGQqKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfCkoPz1bXi1dfCQpXCIsIFwiaVwiIClcblx0fSxcblxuXHRyaW5wdXRzID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmhlYWRlciA9IC9eaFxcZCQvaSxcblxuXHRybmF0aXZlID0gL15bXntdK1xce1xccypcXFtuYXRpdmUgXFx3LyxcblxuXHQvLyBFYXNpbHktcGFyc2VhYmxlL3JldHJpZXZhYmxlIElEIG9yIFRBRyBvciBDTEFTUyBzZWxlY3RvcnNcblx0cnF1aWNrRXhwciA9IC9eKD86IyhbXFx3LV0rKXwoXFx3Kyl8XFwuKFtcXHctXSspKSQvLFxuXG5cdHJzaWJsaW5nID0gL1srfl0vLFxuXG5cdC8vIENTUyBlc2NhcGVzXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCNlc2NhcGVkLWNoYXJhY3RlcnNcblx0cnVuZXNjYXBlID0gbmV3IFJlZ0V4cCggXCJcXFxcXFxcXChbXFxcXGRhLWZdezEsNn1cIiArIHdoaXRlc3BhY2UgKyBcIj98KFwiICsgd2hpdGVzcGFjZSArIFwiKXwuKVwiLCBcImlnXCIgKSxcblx0ZnVuZXNjYXBlID0gZnVuY3Rpb24oIF8sIGVzY2FwZWQsIGVzY2FwZWRXaGl0ZXNwYWNlICkge1xuXHRcdHZhciBoaWdoID0gXCIweFwiICsgZXNjYXBlZCAtIDB4MTAwMDA7XG5cdFx0Ly8gTmFOIG1lYW5zIG5vbi1jb2RlcG9pbnRcblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94PDI0XG5cdFx0Ly8gV29ya2Fyb3VuZCBlcnJvbmVvdXMgbnVtZXJpYyBpbnRlcnByZXRhdGlvbiBvZiArXCIweFwiXG5cdFx0cmV0dXJuIGhpZ2ggIT09IGhpZ2ggfHwgZXNjYXBlZFdoaXRlc3BhY2UgP1xuXHRcdFx0ZXNjYXBlZCA6XG5cdFx0XHRoaWdoIDwgMCA/XG5cdFx0XHRcdC8vIEJNUCBjb2RlcG9pbnRcblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCArIDB4MTAwMDAgKSA6XG5cdFx0XHRcdC8vIFN1cHBsZW1lbnRhbCBQbGFuZSBjb2RlcG9pbnQgKHN1cnJvZ2F0ZSBwYWlyKVxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoID4+IDEwIHwgMHhEODAwLCBoaWdoICYgMHgzRkYgfCAweERDMDAgKTtcblx0fSxcblxuXHQvLyBDU1Mgc3RyaW5nL2lkZW50aWZpZXIgc2VyaWFsaXphdGlvblxuXHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI2NvbW1vbi1zZXJpYWxpemluZy1pZGlvbXNcblx0cmNzc2VzY2FwZSA9IC8oW1xcMC1cXHgxZlxceDdmXXxeLT9cXGQpfF4tJHxbXlxcMC1cXHgxZlxceDdmLVxcdUZGRkZcXHctXS9nLFxuXHRmY3NzZXNjYXBlID0gZnVuY3Rpb24oIGNoLCBhc0NvZGVQb2ludCApIHtcblx0XHRpZiAoIGFzQ29kZVBvaW50ICkge1xuXG5cdFx0XHQvLyBVKzAwMDAgTlVMTCBiZWNvbWVzIFUrRkZGRCBSRVBMQUNFTUVOVCBDSEFSQUNURVJcblx0XHRcdGlmICggY2ggPT09IFwiXFwwXCIgKSB7XG5cdFx0XHRcdHJldHVybiBcIlxcdUZGRkRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udHJvbCBjaGFyYWN0ZXJzIGFuZCAoZGVwZW5kZW50IHVwb24gcG9zaXRpb24pIG51bWJlcnMgZ2V0IGVzY2FwZWQgYXMgY29kZSBwb2ludHNcblx0XHRcdHJldHVybiBjaC5zbGljZSggMCwgLTEgKSArIFwiXFxcXFwiICsgY2guY2hhckNvZGVBdCggY2gubGVuZ3RoIC0gMSApLnRvU3RyaW5nKCAxNiApICsgXCIgXCI7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXIgcG90ZW50aWFsbHktc3BlY2lhbCBBU0NJSSBjaGFyYWN0ZXJzIGdldCBiYWNrc2xhc2gtZXNjYXBlZFxuXHRcdHJldHVybiBcIlxcXFxcIiArIGNoO1xuXHR9LFxuXG5cdC8vIFVzZWQgZm9yIGlmcmFtZXNcblx0Ly8gU2VlIHNldERvY3VtZW50KClcblx0Ly8gUmVtb3ZpbmcgdGhlIGZ1bmN0aW9uIHdyYXBwZXIgY2F1c2VzIGEgXCJQZXJtaXNzaW9uIERlbmllZFwiXG5cdC8vIGVycm9yIGluIElFXG5cdHVubG9hZEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcblx0XHRzZXREb2N1bWVudCgpO1xuXHR9LFxuXG5cdGRpc2FibGVkQW5jZXN0b3IgPSBhZGRDb21iaW5hdG9yKFxuXHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IHRydWUgJiYgKFwiZm9ybVwiIGluIGVsZW0gfHwgXCJsYWJlbFwiIGluIGVsZW0pO1xuXHRcdH0sXG5cdFx0eyBkaXI6IFwicGFyZW50Tm9kZVwiLCBuZXh0OiBcImxlZ2VuZFwiIH1cblx0KTtcblxuLy8gT3B0aW1pemUgZm9yIHB1c2guYXBwbHkoIF8sIE5vZGVMaXN0IClcbnRyeSB7XG5cdHB1c2guYXBwbHkoXG5cdFx0KGFyciA9IHNsaWNlLmNhbGwoIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzICkpLFxuXHRcdHByZWZlcnJlZERvYy5jaGlsZE5vZGVzXG5cdCk7XG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4wXG5cdC8vIERldGVjdCBzaWxlbnRseSBmYWlsaW5nIHB1c2guYXBwbHlcblx0YXJyWyBwcmVmZXJyZWREb2MuY2hpbGROb2Rlcy5sZW5ndGggXS5ub2RlVHlwZTtcbn0gY2F0Y2ggKCBlICkge1xuXHRwdXNoID0geyBhcHBseTogYXJyLmxlbmd0aCA/XG5cblx0XHQvLyBMZXZlcmFnZSBzbGljZSBpZiBwb3NzaWJsZVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHB1c2hfbmF0aXZlLmFwcGx5KCB0YXJnZXQsIHNsaWNlLmNhbGwoZWxzKSApO1xuXHRcdH0gOlxuXG5cdFx0Ly8gU3VwcG9ydDogSUU8OVxuXHRcdC8vIE90aGVyd2lzZSBhcHBlbmQgZGlyZWN0bHlcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHR2YXIgaiA9IHRhcmdldC5sZW5ndGgsXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0Ly8gQ2FuJ3QgdHJ1c3QgTm9kZUxpc3QubGVuZ3RoXG5cdFx0XHR3aGlsZSAoICh0YXJnZXRbaisrXSA9IGVsc1tpKytdKSApIHt9XG5cdFx0XHR0YXJnZXQubGVuZ3RoID0gaiAtIDE7XG5cdFx0fVxuXHR9O1xufVxuXG5mdW5jdGlvbiBTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgbSwgaSwgZWxlbSwgbmlkLCBtYXRjaCwgZ3JvdXBzLCBuZXdTZWxlY3Rvcixcblx0XHRuZXdDb250ZXh0ID0gY29udGV4dCAmJiBjb250ZXh0Lm93bmVyRG9jdW1lbnQsXG5cblx0XHQvLyBub2RlVHlwZSBkZWZhdWx0cyB0byA5LCBzaW5jZSBjb250ZXh0IGRlZmF1bHRzIHRvIGRvY3VtZW50XG5cdFx0bm9kZVR5cGUgPSBjb250ZXh0ID8gY29udGV4dC5ub2RlVHlwZSA6IDk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gUmV0dXJuIGVhcmx5IGZyb20gY2FsbHMgd2l0aCBpbnZhbGlkIHNlbGVjdG9yIG9yIGNvbnRleHRcblx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgfHwgIXNlbGVjdG9yIHx8XG5cdFx0bm9kZVR5cGUgIT09IDEgJiYgbm9kZVR5cGUgIT09IDkgJiYgbm9kZVR5cGUgIT09IDExICkge1xuXG5cdFx0cmV0dXJuIHJlc3VsdHM7XG5cdH1cblxuXHQvLyBUcnkgdG8gc2hvcnRjdXQgZmluZCBvcGVyYXRpb25zIChhcyBvcHBvc2VkIHRvIGZpbHRlcnMpIGluIEhUTUwgZG9jdW1lbnRzXG5cdGlmICggIXNlZWQgKSB7XG5cblx0XHRpZiAoICggY29udGV4dCA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogcHJlZmVycmVkRG9jICkgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0XHR9XG5cdFx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cblx0XHRpZiAoIGRvY3VtZW50SXNIVE1MICkge1xuXG5cdFx0XHQvLyBJZiB0aGUgc2VsZWN0b3IgaXMgc3VmZmljaWVudGx5IHNpbXBsZSwgdHJ5IHVzaW5nIGEgXCJnZXQqQnkqXCIgRE9NIG1ldGhvZFxuXHRcdFx0Ly8gKGV4Y2VwdGluZyBEb2N1bWVudEZyYWdtZW50IGNvbnRleHQsIHdoZXJlIHRoZSBtZXRob2RzIGRvbid0IGV4aXN0KVxuXHRcdFx0aWYgKCBub2RlVHlwZSAhPT0gMTEgJiYgKG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApKSApIHtcblxuXHRcdFx0XHQvLyBJRCBzZWxlY3RvclxuXHRcdFx0XHRpZiAoIChtID0gbWF0Y2hbMV0pICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9jdW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdGlmICggbm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApKSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuXHRcdFx0XHRcdFx0XHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuXHRcdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRcdGlmICggZWxlbS5pZCA9PT0gbSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBFbGVtZW50IGNvbnRleHRcblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuXHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdGlmICggbmV3Q29udGV4dCAmJiAoZWxlbSA9IG5ld0NvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgJiZcblx0XHRcdFx0XHRcdFx0Y29udGFpbnMoIGNvbnRleHQsIGVsZW0gKSAmJlxuXHRcdFx0XHRcdFx0XHRlbGVtLmlkID09PSBtICkge1xuXG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHlwZSBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFsyXSApIHtcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBzZWxlY3RvciApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdFx0Ly8gQ2xhc3Mgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggKG0gPSBtYXRjaFszXSkgJiYgc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmXG5cdFx0XHRcdFx0Y29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICkge1xuXG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBtICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUYWtlIGFkdmFudGFnZSBvZiBxdWVyeVNlbGVjdG9yQWxsXG5cdFx0XHRpZiAoIHN1cHBvcnQucXNhICYmXG5cdFx0XHRcdCFjb21waWxlckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF0gJiZcblx0XHRcdFx0KCFyYnVnZ3lRU0EgfHwgIXJidWdneVFTQS50ZXN0KCBzZWxlY3RvciApKSApIHtcblxuXHRcdFx0XHRpZiAoIG5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRcdG5ld0NvbnRleHQgPSBjb250ZXh0O1xuXHRcdFx0XHRcdG5ld1NlbGVjdG9yID0gc2VsZWN0b3I7XG5cblx0XHRcdFx0Ly8gcVNBIGxvb2tzIG91dHNpZGUgRWxlbWVudCBjb250ZXh0LCB3aGljaCBpcyBub3Qgd2hhdCB3ZSB3YW50XG5cdFx0XHRcdC8vIFRoYW5rcyB0byBBbmRyZXcgRHVwb250IGZvciB0aGlzIHdvcmthcm91bmQgdGVjaG5pcXVlXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OFxuXHRcdFx0XHQvLyBFeGNsdWRlIG9iamVjdCBlbGVtZW50c1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBjb250ZXh0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdFx0XHQvLyBDYXB0dXJlIHRoZSBjb250ZXh0IElELCBzZXR0aW5nIGl0IGZpcnN0IGlmIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdGlmICggKG5pZCA9IGNvbnRleHQuZ2V0QXR0cmlidXRlKCBcImlkXCIgKSkgKSB7XG5cdFx0XHRcdFx0XHRuaWQgPSBuaWQucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb250ZXh0LnNldEF0dHJpYnV0ZSggXCJpZFwiLCAobmlkID0gZXhwYW5kbykgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmVmaXggZXZlcnkgc2VsZWN0b3IgaW4gdGhlIGxpc3Rcblx0XHRcdFx0XHRncm91cHMgPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHRcdFx0XHRpID0gZ3JvdXBzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGdyb3Vwc1tpXSA9IFwiI1wiICsgbmlkICsgXCIgXCIgKyB0b1NlbGVjdG9yKCBncm91cHNbaV0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bmV3U2VsZWN0b3IgPSBncm91cHMuam9pbiggXCIsXCIgKTtcblxuXHRcdFx0XHRcdC8vIEV4cGFuZCBjb250ZXh0IGZvciBzaWJsaW5nIHNlbGVjdG9yc1xuXHRcdFx0XHRcdG5ld0NvbnRleHQgPSByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fFxuXHRcdFx0XHRcdFx0Y29udGV4dDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggbmV3U2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsXG5cdFx0XHRcdFx0XHRcdG5ld0NvbnRleHQucXVlcnlTZWxlY3RvckFsbCggbmV3U2VsZWN0b3IgKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKCBxc2FFcnJvciApIHtcblx0XHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdFx0aWYgKCBuaWQgPT09IGV4cGFuZG8gKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRleHQucmVtb3ZlQXR0cmlidXRlKCBcImlkXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBBbGwgb3RoZXJzXG5cdHJldHVybiBzZWxlY3QoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApO1xufVxuXG4vKipcbiAqIENyZWF0ZSBrZXktdmFsdWUgY2FjaGVzIG9mIGxpbWl0ZWQgc2l6ZVxuICogQHJldHVybnMge2Z1bmN0aW9uKHN0cmluZywgb2JqZWN0KX0gUmV0dXJucyB0aGUgT2JqZWN0IGRhdGEgYWZ0ZXIgc3RvcmluZyBpdCBvbiBpdHNlbGYgd2l0aFxuICpcdHByb3BlcnR5IG5hbWUgdGhlIChzcGFjZS1zdWZmaXhlZCkgc3RyaW5nIGFuZCAoaWYgdGhlIGNhY2hlIGlzIGxhcmdlciB0aGFuIEV4cHIuY2FjaGVMZW5ndGgpXG4gKlx0ZGVsZXRpbmcgdGhlIG9sZGVzdCBlbnRyeVxuICovXG5mdW5jdGlvbiBjcmVhdGVDYWNoZSgpIHtcblx0dmFyIGtleXMgPSBbXTtcblxuXHRmdW5jdGlvbiBjYWNoZSgga2V5LCB2YWx1ZSApIHtcblx0XHQvLyBVc2UgKGtleSArIFwiIFwiKSB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBuYXRpdmUgcHJvdG90eXBlIHByb3BlcnRpZXMgKHNlZSBJc3N1ZSAjMTU3KVxuXHRcdGlmICgga2V5cy5wdXNoKCBrZXkgKyBcIiBcIiApID4gRXhwci5jYWNoZUxlbmd0aCApIHtcblx0XHRcdC8vIE9ubHkga2VlcCB0aGUgbW9zdCByZWNlbnQgZW50cmllc1xuXHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXlzLnNoaWZ0KCkgXTtcblx0XHR9XG5cdFx0cmV0dXJuIChjYWNoZVsga2V5ICsgXCIgXCIgXSA9IHZhbHVlKTtcblx0fVxuXHRyZXR1cm4gY2FjaGU7XG59XG5cbi8qKlxuICogTWFyayBhIGZ1bmN0aW9uIGZvciBzcGVjaWFsIHVzZSBieSBTaXp6bGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBtYXJrXG4gKi9cbmZ1bmN0aW9uIG1hcmtGdW5jdGlvbiggZm4gKSB7XG5cdGZuWyBleHBhbmRvIF0gPSB0cnVlO1xuXHRyZXR1cm4gZm47XG59XG5cbi8qKlxuICogU3VwcG9ydCB0ZXN0aW5nIHVzaW5nIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFBhc3NlZCB0aGUgY3JlYXRlZCBlbGVtZW50IGFuZCByZXR1cm5zIGEgYm9vbGVhbiByZXN1bHRcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0KCBmbiApIHtcblx0dmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZpZWxkc2V0XCIpO1xuXG5cdHRyeSB7XG5cdFx0cmV0dXJuICEhZm4oIGVsICk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0gZmluYWxseSB7XG5cdFx0Ly8gUmVtb3ZlIGZyb20gaXRzIHBhcmVudCBieSBkZWZhdWx0XG5cdFx0aWYgKCBlbC5wYXJlbnROb2RlICkge1xuXHRcdFx0ZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggZWwgKTtcblx0XHR9XG5cdFx0Ly8gcmVsZWFzZSBtZW1vcnkgaW4gSUVcblx0XHRlbCA9IG51bGw7XG5cdH1cbn1cblxuLyoqXG4gKiBBZGRzIHRoZSBzYW1lIGhhbmRsZXIgZm9yIGFsbCBvZiB0aGUgc3BlY2lmaWVkIGF0dHJzXG4gKiBAcGFyYW0ge1N0cmluZ30gYXR0cnMgUGlwZS1zZXBhcmF0ZWQgbGlzdCBvZiBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIFRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGFwcGxpZWRcbiAqL1xuZnVuY3Rpb24gYWRkSGFuZGxlKCBhdHRycywgaGFuZGxlciApIHtcblx0dmFyIGFyciA9IGF0dHJzLnNwbGl0KFwifFwiKSxcblx0XHRpID0gYXJyLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRFeHByLmF0dHJIYW5kbGVbIGFycltpXSBdID0gaGFuZGxlcjtcblx0fVxufVxuXG4vKipcbiAqIENoZWNrcyBkb2N1bWVudCBvcmRlciBvZiB0d28gc2libGluZ3NcbiAqIEBwYXJhbSB7RWxlbWVudH0gYVxuICogQHBhcmFtIHtFbGVtZW50fSBiXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBSZXR1cm5zIGxlc3MgdGhhbiAwIGlmIGEgcHJlY2VkZXMgYiwgZ3JlYXRlciB0aGFuIDAgaWYgYSBmb2xsb3dzIGJcbiAqL1xuZnVuY3Rpb24gc2libGluZ0NoZWNrKCBhLCBiICkge1xuXHR2YXIgY3VyID0gYiAmJiBhLFxuXHRcdGRpZmYgPSBjdXIgJiYgYS5ub2RlVHlwZSA9PT0gMSAmJiBiLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRhLnNvdXJjZUluZGV4IC0gYi5zb3VyY2VJbmRleDtcblxuXHQvLyBVc2UgSUUgc291cmNlSW5kZXggaWYgYXZhaWxhYmxlIG9uIGJvdGggbm9kZXNcblx0aWYgKCBkaWZmICkge1xuXHRcdHJldHVybiBkaWZmO1xuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgYiBmb2xsb3dzIGFcblx0aWYgKCBjdXIgKSB7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLm5leHRTaWJsaW5nKSApIHtcblx0XHRcdGlmICggY3VyID09PSBiICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGEgPyAxIDogLTE7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBpbnB1dCB0eXBlc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5wdXRQc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGJ1dHRvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJ1dHRvblBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiAobmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCIpICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIDplbmFibGVkLzpkaXNhYmxlZFxuICogQHBhcmFtIHtCb29sZWFufSBkaXNhYmxlZCB0cnVlIGZvciA6ZGlzYWJsZWQ7IGZhbHNlIGZvciA6ZW5hYmxlZFxuICovXG5mdW5jdGlvbiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZGlzYWJsZWQgKSB7XG5cblx0Ly8gS25vd24gOmRpc2FibGVkIGZhbHNlIHBvc2l0aXZlczogZmllbGRzZXRbZGlzYWJsZWRdID4gbGVnZW5kOm50aC1vZi10eXBlKG4rMikgOmNhbi1kaXNhYmxlXG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIE9ubHkgY2VydGFpbiBlbGVtZW50cyBjYW4gbWF0Y2ggOmVuYWJsZWQgb3IgOmRpc2FibGVkXG5cdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZW5hYmxlZFxuXHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWRpc2FibGVkXG5cdFx0aWYgKCBcImZvcm1cIiBpbiBlbGVtICkge1xuXG5cdFx0XHQvLyBDaGVjayBmb3IgaW5oZXJpdGVkIGRpc2FibGVkbmVzcyBvbiByZWxldmFudCBub24tZGlzYWJsZWQgZWxlbWVudHM6XG5cdFx0XHQvLyAqIGxpc3RlZCBmb3JtLWFzc29jaWF0ZWQgZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBmaWVsZHNldFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NhdGVnb3J5LWxpc3RlZFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtZmUtZGlzYWJsZWRcblx0XHRcdC8vICogb3B0aW9uIGVsZW1lbnRzIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjb25jZXB0LW9wdGlvbi1kaXNhYmxlZFxuXHRcdFx0Ly8gQWxsIHN1Y2ggZWxlbWVudHMgaGF2ZSBhIFwiZm9ybVwiIHByb3BlcnR5LlxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgJiYgZWxlbS5kaXNhYmxlZCA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0Ly8gT3B0aW9uIGVsZW1lbnRzIGRlZmVyIHRvIGEgcGFyZW50IG9wdGdyb3VwIGlmIHByZXNlbnRcblx0XHRcdFx0aWYgKCBcImxhYmVsXCIgaW4gZWxlbSApIHtcblx0XHRcdFx0XHRpZiAoIFwibGFiZWxcIiBpbiBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5wYXJlbnROb2RlLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDYgLSAxMVxuXHRcdFx0XHQvLyBVc2UgdGhlIGlzRGlzYWJsZWQgc2hvcnRjdXQgcHJvcGVydHkgdG8gY2hlY2sgZm9yIGRpc2FibGVkIGZpZWxkc2V0IGFuY2VzdG9yc1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5pc0Rpc2FibGVkID09PSBkaXNhYmxlZCB8fFxuXG5cdFx0XHRcdFx0Ly8gV2hlcmUgdGhlcmUgaXMgbm8gaXNEaXNhYmxlZCwgY2hlY2sgbWFudWFsbHlcblx0XHRcdFx0XHQvKiBqc2hpbnQgLVcwMTggKi9cblx0XHRcdFx0XHRlbGVtLmlzRGlzYWJsZWQgIT09ICFkaXNhYmxlZCAmJlxuXHRcdFx0XHRcdFx0ZGlzYWJsZWRBbmNlc3RvciggZWxlbSApID09PSBkaXNhYmxlZDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXG5cdFx0Ly8gVHJ5IHRvIHdpbm5vdyBvdXQgZWxlbWVudHMgdGhhdCBjYW4ndCBiZSBkaXNhYmxlZCBiZWZvcmUgdHJ1c3RpbmcgdGhlIGRpc2FibGVkIHByb3BlcnR5LlxuXHRcdC8vIFNvbWUgdmljdGltcyBnZXQgY2F1Z2h0IGluIG91ciBuZXQgKGxhYmVsLCBsZWdlbmQsIG1lbnUsIHRyYWNrKSwgYnV0IGl0IHNob3VsZG4ndFxuXHRcdC8vIGV2ZW4gZXhpc3Qgb24gdGhlbSwgbGV0IGFsb25lIGhhdmUgYSBib29sZWFuIHZhbHVlLlxuXHRcdH0gZWxzZSBpZiAoIFwibGFiZWxcIiBpbiBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdH1cblxuXHRcdC8vIFJlbWFpbmluZyBlbGVtZW50cyBhcmUgbmVpdGhlciA6ZW5hYmxlZCBub3IgOmRpc2FibGVkXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgcG9zaXRpb25hbHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZuICkge1xuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBhcmd1bWVudCApIHtcblx0XHRhcmd1bWVudCA9ICthcmd1bWVudDtcblx0XHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0dmFyIGosXG5cdFx0XHRcdG1hdGNoSW5kZXhlcyA9IGZuKCBbXSwgc2VlZC5sZW5ndGgsIGFyZ3VtZW50ICksXG5cdFx0XHRcdGkgPSBtYXRjaEluZGV4ZXMubGVuZ3RoO1xuXG5cdFx0XHQvLyBNYXRjaCBlbGVtZW50cyBmb3VuZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4ZXNcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIHNlZWRbIChqID0gbWF0Y2hJbmRleGVzW2ldKSBdICkge1xuXHRcdFx0XHRcdHNlZWRbal0gPSAhKG1hdGNoZXNbal0gPSBzZWVkW2pdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgYSBub2RlIGZvciB2YWxpZGl0eSBhcyBhIFNpenpsZSBjb250ZXh0XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0PX0gY29udGV4dFxuICogQHJldHVybnMge0VsZW1lbnR8T2JqZWN0fEJvb2xlYW59IFRoZSBpbnB1dCBub2RlIGlmIGFjY2VwdGFibGUsIG90aGVyd2lzZSBhIGZhbHN5IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRlc3RDb250ZXh0KCBjb250ZXh0ICkge1xuXHRyZXR1cm4gY29udGV4dCAmJiB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb250ZXh0O1xufVxuXG4vLyBFeHBvc2Ugc3VwcG9ydCB2YXJzIGZvciBjb252ZW5pZW5jZVxuc3VwcG9ydCA9IFNpenpsZS5zdXBwb3J0ID0ge307XG5cbi8qKlxuICogRGV0ZWN0cyBYTUwgbm9kZXNcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IGVsZW0gQW4gZWxlbWVudCBvciBhIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZmYgZWxlbSBpcyBhIG5vbi1IVE1MIFhNTCBub2RlXG4gKi9cbmlzWE1MID0gU2l6emxlLmlzWE1MID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdC8vIGRvY3VtZW50RWxlbWVudCBpcyB2ZXJpZmllZCBmb3IgY2FzZXMgd2hlcmUgaXQgZG9lc24ndCB5ZXQgZXhpc3Rcblx0Ly8gKHN1Y2ggYXMgbG9hZGluZyBpZnJhbWVzIGluIElFIC0gIzQ4MzMpXG5cdHZhciBkb2N1bWVudEVsZW1lbnQgPSBlbGVtICYmIChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSkuZG9jdW1lbnRFbGVtZW50O1xuXHRyZXR1cm4gZG9jdW1lbnRFbGVtZW50ID8gZG9jdW1lbnRFbGVtZW50Lm5vZGVOYW1lICE9PSBcIkhUTUxcIiA6IGZhbHNlO1xufTtcblxuLyoqXG4gKiBTZXRzIGRvY3VtZW50LXJlbGF0ZWQgdmFyaWFibGVzIG9uY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IFtkb2NdIEFuIGVsZW1lbnQgb3IgZG9jdW1lbnQgb2JqZWN0IHRvIHVzZSB0byBzZXQgdGhlIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKi9cbnNldERvY3VtZW50ID0gU2l6emxlLnNldERvY3VtZW50ID0gZnVuY3Rpb24oIG5vZGUgKSB7XG5cdHZhciBoYXNDb21wYXJlLCBzdWJXaW5kb3csXG5cdFx0ZG9jID0gbm9kZSA/IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlIDogcHJlZmVycmVkRG9jO1xuXG5cdC8vIFJldHVybiBlYXJseSBpZiBkb2MgaXMgaW52YWxpZCBvciBhbHJlYWR5IHNlbGVjdGVkXG5cdGlmICggZG9jID09PSBkb2N1bWVudCB8fCBkb2Mubm9kZVR5cGUgIT09IDkgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQgKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50O1xuXHR9XG5cblx0Ly8gVXBkYXRlIGdsb2JhbCB2YXJpYWJsZXNcblx0ZG9jdW1lbnQgPSBkb2M7XG5cdGRvY0VsZW0gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cdGRvY3VtZW50SXNIVE1MID0gIWlzWE1MKCBkb2N1bWVudCApO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDktMTEsIEVkZ2Vcblx0Ly8gQWNjZXNzaW5nIGlmcmFtZSBkb2N1bWVudHMgYWZ0ZXIgdW5sb2FkIHRocm93cyBcInBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3JzIChqUXVlcnkgIzEzOTM2KVxuXHRpZiAoIHByZWZlcnJlZERvYyAhPT0gZG9jdW1lbnQgJiZcblx0XHQoc3ViV2luZG93ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcpICYmIHN1YldpbmRvdy50b3AgIT09IHN1YldpbmRvdyApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDExLCBFZGdlXG5cdFx0aWYgKCBzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcInVubG9hZFwiLCB1bmxvYWRIYW5kbGVyLCBmYWxzZSApO1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDEwIG9ubHlcblx0XHR9IGVsc2UgaWYgKCBzdWJXaW5kb3cuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRzdWJXaW5kb3cuYXR0YWNoRXZlbnQoIFwib251bmxvYWRcIiwgdW5sb2FkSGFuZGxlciApO1xuXHRcdH1cblx0fVxuXG5cdC8qIEF0dHJpYnV0ZXNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFN1cHBvcnQ6IElFPDhcblx0Ly8gVmVyaWZ5IHRoYXQgZ2V0QXR0cmlidXRlIHJlYWxseSByZXR1cm5zIGF0dHJpYnV0ZXMgYW5kIG5vdCBwcm9wZXJ0aWVzXG5cdC8vIChleGNlcHRpbmcgSUU4IGJvb2xlYW5zKVxuXHRzdXBwb3J0LmF0dHJpYnV0ZXMgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGVsLmNsYXNzTmFtZSA9IFwiaVwiO1xuXHRcdHJldHVybiAhZWwuZ2V0QXR0cmlidXRlKFwiY2xhc3NOYW1lXCIpO1xuXHR9KTtcblxuXHQvKiBnZXRFbGVtZW50KHMpQnkqXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikgcmV0dXJucyBvbmx5IGVsZW1lbnRzXG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGVsLmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVDb21tZW50KFwiXCIpICk7XG5cdFx0cmV0dXJuICFlbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBTdXBwb3J0OiBJRTw5XG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDEwXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRCeUlkIHJldHVybnMgZWxlbWVudHMgYnkgbmFtZVxuXHQvLyBUaGUgYnJva2VuIGdldEVsZW1lbnRCeUlkIG1ldGhvZHMgZG9uJ3QgcGljayB1cCBwcm9ncmFtbWF0aWNhbGx5LXNldCBuYW1lcyxcblx0Ly8gc28gdXNlIGEgcm91bmRhYm91dCBnZXRFbGVtZW50c0J5TmFtZSB0ZXN0XG5cdHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pZCA9IGV4cGFuZG87XG5cdFx0cmV0dXJuICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSB8fCAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoIGV4cGFuZG8gKS5sZW5ndGg7XG5cdH0pO1xuXG5cdC8vIElEIGZpbHRlciBhbmQgZmluZFxuXHRpZiAoIHN1cHBvcnQuZ2V0QnlJZCApIHtcblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZShcImlkXCIpID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0RXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cdFx0XHRcdHJldHVybiBlbGVtID8gWyBlbGVtIF0gOiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdEV4cHIuZmlsdGVyW1wiSURcIl0gPSAgZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlTm9kZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuXHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRyZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA2IC0gNyBvbmx5XG5cdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgaXMgbm90IHJlbGlhYmxlIGFzIGEgZmluZCBzaG9ydGN1dFxuXHRcdEV4cHIuZmluZFtcIklEXCJdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIG5vZGUsIGksIGVsZW1zLFxuXHRcdFx0XHRcdGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXG5cdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdC8vIFZlcmlmeSB0aGUgaWQgYXR0cmlidXRlXG5cdFx0XHRcdFx0bm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBbIGVsZW0gXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBGYWxsIGJhY2sgb24gZ2V0RWxlbWVudHNCeU5hbWVcblx0XHRcdFx0XHRlbGVtcyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeU5hbWUoIGlkICk7XG5cdFx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1zW2krK10pICkge1xuXHRcdFx0XHRcdFx0bm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRcdFx0aWYgKCBub2RlICYmIG5vZGUudmFsdWUgPT09IGlkICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gWyBlbGVtIF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHQvLyBUYWdcblx0RXhwci5maW5kW1wiVEFHXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA/XG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRG9jdW1lbnRGcmFnbWVudCBub2RlcyBkb24ndCBoYXZlIGdFQlROXG5cdFx0XHR9IGVsc2UgaWYgKCBzdXBwb3J0LnFzYSApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnICk7XG5cdFx0XHR9XG5cdFx0fSA6XG5cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdHRtcCA9IFtdLFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0Ly8gQnkgaGFwcHkgY29pbmNpZGVuY2UsIGEgKGJyb2tlbikgZ0VCVE4gYXBwZWFycyBvbiBEb2N1bWVudEZyYWdtZW50IG5vZGVzIHRvb1xuXHRcdFx0XHRyZXN1bHRzID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIEZpbHRlciBvdXQgcG9zc2libGUgY29tbWVudHNcblx0XHRcdGlmICggdGFnID09PSBcIipcIiApIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0dG1wLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdG1wO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0fTtcblxuXHQvLyBDbGFzc1xuXHRFeHByLmZpbmRbXCJDTEFTU1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBmdW5jdGlvbiggY2xhc3NOYW1lLCBjb250ZXh0ICkge1xuXHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIGNsYXNzTmFtZSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiBRU0EvbWF0Y2hlc1NlbGVjdG9yXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBRU0EgYW5kIG1hdGNoZXNTZWxlY3RvciBzdXBwb3J0XG5cblx0Ly8gbWF0Y2hlc1NlbGVjdG9yKDphY3RpdmUpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChJRTkvT3BlcmEgMTEuNSlcblx0cmJ1Z2d5TWF0Y2hlcyA9IFtdO1xuXG5cdC8vIHFTYSg6Zm9jdXMpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChDaHJvbWUgMjEpXG5cdC8vIFdlIGFsbG93IHRoaXMgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBJRTgvOSB0aGF0IHRocm93cyBhbiBlcnJvclxuXHQvLyB3aGVuZXZlciBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgaXMgYWNjZXNzZWQgb24gYW4gaWZyYW1lXG5cdC8vIFNvLCB3ZSBhbGxvdyA6Zm9jdXMgdG8gcGFzcyB0aHJvdWdoIFFTQSBhbGwgdGhlIHRpbWUgdG8gYXZvaWQgdGhlIElFIGVycm9yXG5cdC8vIFNlZSBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzNzhcblx0cmJ1Z2d5UVNBID0gW107XG5cblx0aWYgKCAoc3VwcG9ydC5xc2EgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwgKSkgKSB7XG5cdFx0Ly8gQnVpbGQgUVNBIHJlZ2V4XG5cdFx0Ly8gUmVnZXggc3RyYXRlZ3kgYWRvcHRlZCBmcm9tIERpZWdvIFBlcmluaVxuXHRcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHQvLyBTZWxlY3QgaXMgc2V0IHRvIGVtcHR5IHN0cmluZyBvbiBwdXJwb3NlXG5cdFx0XHQvLyBUaGlzIGlzIHRvIHRlc3QgSUUncyB0cmVhdG1lbnQgb2Ygbm90IGV4cGxpY2l0bHlcblx0XHRcdC8vIHNldHRpbmcgYSBib29sZWFuIGNvbnRlbnQgYXR0cmlidXRlLFxuXHRcdFx0Ly8gc2luY2UgaXRzIHByZXNlbmNlIHNob3VsZCBiZSBlbm91Z2hcblx0XHRcdC8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjM1OVxuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pbm5lckhUTUwgPSBcIjxhIGlkPSdcIiArIGV4cGFuZG8gKyBcIic+PC9hPlwiICtcblx0XHRcdFx0XCI8c2VsZWN0IGlkPSdcIiArIGV4cGFuZG8gKyBcIi1cXHJcXFxcJyBtc2FsbG93Y2FwdHVyZT0nJz5cIiArXG5cdFx0XHRcdFwiPG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD5cIjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4LCBPcGVyYSAxMS0xMi4xNlxuXHRcdFx0Ly8gTm90aGluZyBzaG91bGQgYmUgc2VsZWN0ZWQgd2hlbiBlbXB0eSBzdHJpbmdzIGZvbGxvdyBePSBvciAkPSBvciAqPVxuXHRcdFx0Ly8gVGhlIHRlc3QgYXR0cmlidXRlIG11c3QgYmUgdW5rbm93biBpbiBPcGVyYSBidXQgXCJzYWZlXCIgZm9yIFdpblJUXG5cdFx0XHQvLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2hoNDY1Mzg4LmFzcHgjYXR0cmlidXRlX3NlY3Rpb25cblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIlttc2FsbG93Y2FwdHVyZV49JyddXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiWypeJF09XCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86Jyd8XFxcIlxcXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBCb29sZWFuIGF0dHJpYnV0ZXMgYW5kIFwidmFsdWVcIiBhcmUgbm90IHRyZWF0ZWQgY29ycmVjdGx5XG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW3NlbGVjdGVkXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86dmFsdWV8XCIgKyBib29sZWFucyArIFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZTwyOSwgQW5kcm9pZDw0LjQsIFNhZmFyaTw3LjArLCBpT1M8Ny4wKywgUGhhbnRvbUpTPDEuOS44K1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJbaWR+PVwiICsgZXhwYW5kbyArIFwiLV1cIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCJ+PVwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gV2Via2l0L09wZXJhIC0gOmNoZWNrZWQgc2hvdWxkIHJldHVybiBzZWxlY3RlZCBvcHRpb24gZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbChcIjpjaGVja2VkXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCI6Y2hlY2tlZFwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrLCBpT1MgOCtcblx0XHRcdC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzY4NTFcblx0XHRcdC8vIEluLXBhZ2UgYHNlbGVjdG9yI2lkIHNpYmxpbmctY29tYmluYXRvciBzZWxlY3RvcmAgZmFpbHNcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiYSNcIiArIGV4cGFuZG8gKyBcIisqXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiLiMuK1srfl1cIik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0ZWwuaW5uZXJIVE1MID0gXCI8YSBocmVmPScnIGRpc2FibGVkPSdkaXNhYmxlZCc+PC9hPlwiICtcblx0XHRcdFx0XCI8c2VsZWN0IGRpc2FibGVkPSdkaXNhYmxlZCc+PG9wdGlvbi8+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFdpbmRvd3MgOCBOYXRpdmUgQXBwc1xuXHRcdFx0Ly8gVGhlIHR5cGUgYW5kIG5hbWUgYXR0cmlidXRlcyBhcmUgcmVzdHJpY3RlZCBkdXJpbmcgLmlubmVySFRNTCBhc3NpZ25tZW50XG5cdFx0XHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG5cdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcImhpZGRlblwiICk7XG5cdFx0XHRlbC5hcHBlbmRDaGlsZCggaW5wdXQgKS5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcIkRcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEVuZm9yY2UgY2FzZS1zZW5zaXRpdml0eSBvZiBuYW1lIGF0dHJpYnV0ZVxuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW25hbWU9ZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJuYW1lXCIgKyB3aGl0ZXNwYWNlICsgXCIqWypeJHwhfl0/PVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZGIDMuNSAtIDplbmFibGVkLzpkaXNhYmxlZCBhbmQgaGlkZGVuIGVsZW1lbnRzIChoaWRkZW4gZWxlbWVudHMgYXJlIHN0aWxsIGVuYWJsZWQpXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmVuYWJsZWRcIikubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0XHRcdC8vIElFJ3MgOmRpc2FibGVkIHNlbGVjdG9yIGRvZXMgbm90IHBpY2sgdXAgdGhlIGNoaWxkcmVuIG9mIGRpc2FibGVkIGZpZWxkc2V0c1xuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5kaXNhYmxlZCA9IHRydWU7XG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZGlzYWJsZWRcIikubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9wZXJhIDEwLTExIGRvZXMgbm90IHRocm93IG9uIHBvc3QtY29tbWEgaW52YWxpZCBwc2V1ZG9zXG5cdFx0XHRlbC5xdWVyeVNlbGVjdG9yQWxsKFwiKiw6eFwiKTtcblx0XHRcdHJidWdneVFTQS5wdXNoKFwiLC4qOlwiKTtcblx0XHR9KTtcblx0fVxuXG5cdGlmICggKHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yID0gcm5hdGl2ZS50ZXN0KCAobWF0Y2hlcyA9IGRvY0VsZW0ubWF0Y2hlcyB8fFxuXHRcdGRvY0VsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm9NYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1zTWF0Y2hlc1NlbGVjdG9yKSApKSApIHtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHQvLyBDaGVjayB0byBzZWUgaWYgaXQncyBwb3NzaWJsZSB0byBkbyBtYXRjaGVzU2VsZWN0b3Jcblx0XHRcdC8vIG9uIGEgZGlzY29ubmVjdGVkIG5vZGUgKElFIDkpXG5cdFx0XHRzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoID0gbWF0Y2hlcy5jYWxsKCBlbCwgXCIqXCIgKTtcblxuXHRcdFx0Ly8gVGhpcyBzaG91bGQgZmFpbCB3aXRoIGFuIGV4Y2VwdGlvblxuXHRcdFx0Ly8gR2Vja28gZG9lcyBub3QgZXJyb3IsIHJldHVybnMgZmFsc2UgaW5zdGVhZFxuXHRcdFx0bWF0Y2hlcy5jYWxsKCBlbCwgXCJbcyE9JyddOnhcIiApO1xuXHRcdFx0cmJ1Z2d5TWF0Y2hlcy5wdXNoKCBcIiE9XCIsIHBzZXVkb3MgKTtcblx0XHR9KTtcblx0fVxuXG5cdHJidWdneVFTQSA9IHJidWdneVFTQS5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5UVNBLmpvaW4oXCJ8XCIpICk7XG5cdHJidWdneU1hdGNoZXMgPSByYnVnZ3lNYXRjaGVzLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lNYXRjaGVzLmpvaW4oXCJ8XCIpICk7XG5cblx0LyogQ29udGFpbnNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXHRoYXNDb21wYXJlID0gcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICk7XG5cblx0Ly8gRWxlbWVudCBjb250YWlucyBhbm90aGVyXG5cdC8vIFB1cnBvc2VmdWxseSBzZWxmLWV4Y2x1c2l2ZVxuXHQvLyBBcyBpbiwgYW4gZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0c2VsZlxuXHRjb250YWlucyA9IGhhc0NvbXBhcmUgfHwgcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbnRhaW5zICkgP1xuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0dmFyIGFkb3duID0gYS5ub2RlVHlwZSA9PT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcblx0XHRcdFx0YnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XG5cdFx0XHRyZXR1cm4gYSA9PT0gYnVwIHx8ICEhKCBidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIChcblx0XHRcdFx0YWRvd24uY29udGFpbnMgP1xuXHRcdFx0XHRcdGFkb3duLmNvbnRhaW5zKCBidXAgKSA6XG5cdFx0XHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAmJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBidXAgKSAmIDE2XG5cdFx0XHQpKTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdGlmICggYiApIHtcblx0XHRcdFx0d2hpbGUgKCAoYiA9IGIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBiID09PSBhICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHQvKiBTb3J0aW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBEb2N1bWVudCBvcmRlciBzb3J0aW5nXG5cdHNvcnRPcmRlciA9IGhhc0NvbXBhcmUgP1xuXHRmdW5jdGlvbiggYSwgYiApIHtcblxuXHRcdC8vIEZsYWcgZm9yIGR1cGxpY2F0ZSByZW1vdmFsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdC8vIFNvcnQgb24gbWV0aG9kIGV4aXN0ZW5jZSBpZiBvbmx5IG9uZSBpbnB1dCBoYXMgY29tcGFyZURvY3VtZW50UG9zaXRpb25cblx0XHR2YXIgY29tcGFyZSA9ICFhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIC0gIWIuY29tcGFyZURvY3VtZW50UG9zaXRpb247XG5cdFx0aWYgKCBjb21wYXJlICkge1xuXHRcdFx0cmV0dXJuIGNvbXBhcmU7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIHBvc2l0aW9uIGlmIGJvdGggaW5wdXRzIGJlbG9uZyB0byB0aGUgc2FtZSBkb2N1bWVudFxuXHRcdGNvbXBhcmUgPSAoIGEub3duZXJEb2N1bWVudCB8fCBhICkgPT09ICggYi5vd25lckRvY3VtZW50IHx8IGIgKSA/XG5cdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBiICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugd2Uga25vdyB0aGV5IGFyZSBkaXNjb25uZWN0ZWRcblx0XHRcdDE7XG5cblx0XHQvLyBEaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRpZiAoIGNvbXBhcmUgJiAxIHx8XG5cdFx0XHQoIXN1cHBvcnQuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGEgKSA9PT0gY29tcGFyZSkgKSB7XG5cblx0XHRcdC8vIENob29zZSB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGlzIHJlbGF0ZWQgdG8gb3VyIHByZWZlcnJlZCBkb2N1bWVudFxuXHRcdFx0aWYgKCBhID09PSBkb2N1bWVudCB8fCBhLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGEpICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGIgPT09IGRvY3VtZW50IHx8IGIub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYikgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWludGFpbiBvcmlnaW5hbCBvcmRlclxuXHRcdFx0cmV0dXJuIHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29tcGFyZSAmIDQgPyAtMSA6IDE7XG5cdH0gOlxuXHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHQvLyBFeGl0IGVhcmx5IGlmIHRoZSBub2RlcyBhcmUgaWRlbnRpY2FsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGF1cCA9IGEucGFyZW50Tm9kZSxcblx0XHRcdGJ1cCA9IGIucGFyZW50Tm9kZSxcblx0XHRcdGFwID0gWyBhIF0sXG5cdFx0XHRicCA9IFsgYiBdO1xuXG5cdFx0Ly8gUGFyZW50bGVzcyBub2RlcyBhcmUgZWl0aGVyIGRvY3VtZW50cyBvciBkaXNjb25uZWN0ZWRcblx0XHRpZiAoICFhdXAgfHwgIWJ1cCApIHtcblx0XHRcdHJldHVybiBhID09PSBkb2N1bWVudCA/IC0xIDpcblx0XHRcdFx0YiA9PT0gZG9jdW1lbnQgPyAxIDpcblx0XHRcdFx0YXVwID8gLTEgOlxuXHRcdFx0XHRidXAgPyAxIDpcblx0XHRcdFx0c29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXG5cdFx0Ly8gSWYgdGhlIG5vZGVzIGFyZSBzaWJsaW5ncywgd2UgY2FuIGRvIGEgcXVpY2sgY2hlY2tcblx0XHR9IGVsc2UgaWYgKCBhdXAgPT09IGJ1cCApIHtcblx0XHRcdHJldHVybiBzaWJsaW5nQ2hlY2soIGEsIGIgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2Ugd2UgbmVlZCBmdWxsIGxpc3RzIG9mIHRoZWlyIGFuY2VzdG9ycyBmb3IgY29tcGFyaXNvblxuXHRcdGN1ciA9IGE7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YXAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXHRcdGN1ciA9IGI7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YnAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2FsayBkb3duIHRoZSB0cmVlIGxvb2tpbmcgZm9yIGEgZGlzY3JlcGFuY3lcblx0XHR3aGlsZSAoIGFwW2ldID09PSBicFtpXSApIHtcblx0XHRcdGkrKztcblx0XHR9XG5cblx0XHRyZXR1cm4gaSA/XG5cdFx0XHQvLyBEbyBhIHNpYmxpbmcgY2hlY2sgaWYgdGhlIG5vZGVzIGhhdmUgYSBjb21tb24gYW5jZXN0b3Jcblx0XHRcdHNpYmxpbmdDaGVjayggYXBbaV0sIGJwW2ldICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugbm9kZXMgaW4gb3VyIGRvY3VtZW50IHNvcnQgZmlyc3Rcblx0XHRcdGFwW2ldID09PSBwcmVmZXJyZWREb2MgPyAtMSA6XG5cdFx0XHRicFtpXSA9PT0gcHJlZmVycmVkRG9jID8gMSA6XG5cdFx0XHQwO1xuXHR9O1xuXG5cdHJldHVybiBkb2N1bWVudDtcbn07XG5cblNpenpsZS5tYXRjaGVzID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1lbnRzICkge1xuXHRyZXR1cm4gU2l6emxlKCBleHByLCBudWxsLCBudWxsLCBlbGVtZW50cyApO1xufTtcblxuU2l6emxlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKCBlbGVtLCBleHByICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHQvLyBNYWtlIHN1cmUgdGhhdCBhdHRyaWJ1dGUgc2VsZWN0b3JzIGFyZSBxdW90ZWRcblx0ZXhwciA9IGV4cHIucmVwbGFjZSggcmF0dHJpYnV0ZVF1b3RlcywgXCI9JyQxJ11cIiApO1xuXG5cdGlmICggc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgJiYgZG9jdW1lbnRJc0hUTUwgJiZcblx0XHQhY29tcGlsZXJDYWNoZVsgZXhwciArIFwiIFwiIF0gJiZcblx0XHQoICFyYnVnZ3lNYXRjaGVzIHx8ICFyYnVnZ3lNYXRjaGVzLnRlc3QoIGV4cHIgKSApICYmXG5cdFx0KCAhcmJ1Z2d5UVNBICAgICB8fCAhcmJ1Z2d5UVNBLnRlc3QoIGV4cHIgKSApICkge1xuXG5cdFx0dHJ5IHtcblx0XHRcdHZhciByZXQgPSBtYXRjaGVzLmNhbGwoIGVsZW0sIGV4cHIgKTtcblxuXHRcdFx0Ly8gSUUgOSdzIG1hdGNoZXNTZWxlY3RvciByZXR1cm5zIGZhbHNlIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdFx0aWYgKCByZXQgfHwgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCB8fFxuXHRcdFx0XHRcdC8vIEFzIHdlbGwsIGRpc2Nvbm5lY3RlZCBub2RlcyBhcmUgc2FpZCB0byBiZSBpbiBhIGRvY3VtZW50XG5cdFx0XHRcdFx0Ly8gZnJhZ21lbnQgaW4gSUUgOVxuXHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQgJiYgZWxlbS5kb2N1bWVudC5ub2RlVHlwZSAhPT0gMTEgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZSkge31cblx0fVxuXG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIGRvY3VtZW50LCBudWxsLCBbIGVsZW0gXSApLmxlbmd0aCA+IDA7XG59O1xuXG5TaXp6bGUuY29udGFpbnMgPSBmdW5jdGlvbiggY29udGV4dCwgZWxlbSApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHR9XG5cdHJldHVybiBjb250YWlucyggY29udGV4dCwgZWxlbSApO1xufTtcblxuU2l6emxlLmF0dHIgPSBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0dmFyIGZuID0gRXhwci5hdHRySGFuZGxlWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSxcblx0XHQvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoalF1ZXJ5ICMxMzgwNylcblx0XHR2YWwgPSBmbiAmJiBoYXNPd24uY2FsbCggRXhwci5hdHRySGFuZGxlLCBuYW1lLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRmbiggZWxlbSwgbmFtZSwgIWRvY3VtZW50SXNIVE1MICkgOlxuXHRcdFx0dW5kZWZpbmVkO1xuXG5cdHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCA/XG5cdFx0dmFsIDpcblx0XHRzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWRvY3VtZW50SXNIVE1MID9cblx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICkgOlxuXHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShuYW1lKSkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG59O1xuXG5TaXp6bGUuZXNjYXBlID0gZnVuY3Rpb24oIHNlbCApIHtcblx0cmV0dXJuIChzZWwgKyBcIlwiKS5yZXBsYWNlKCByY3NzZXNjYXBlLCBmY3NzZXNjYXBlICk7XG59O1xuXG5TaXp6bGUuZXJyb3IgPSBmdW5jdGlvbiggbXNnICkge1xuXHR0aHJvdyBuZXcgRXJyb3IoIFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIgKyBtc2cgKTtcbn07XG5cbi8qKlxuICogRG9jdW1lbnQgc29ydGluZyBhbmQgcmVtb3ZpbmcgZHVwbGljYXRlc1xuICogQHBhcmFtIHtBcnJheUxpa2V9IHJlc3VsdHNcbiAqL1xuU2l6emxlLnVuaXF1ZVNvcnQgPSBmdW5jdGlvbiggcmVzdWx0cyApIHtcblx0dmFyIGVsZW0sXG5cdFx0ZHVwbGljYXRlcyA9IFtdLFxuXHRcdGogPSAwLFxuXHRcdGkgPSAwO1xuXG5cdC8vIFVubGVzcyB3ZSAqa25vdyogd2UgY2FuIGRldGVjdCBkdXBsaWNhdGVzLCBhc3N1bWUgdGhlaXIgcHJlc2VuY2Vcblx0aGFzRHVwbGljYXRlID0gIXN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcztcblx0c29ydElucHV0ID0gIXN1cHBvcnQuc29ydFN0YWJsZSAmJiByZXN1bHRzLnNsaWNlKCAwICk7XG5cdHJlc3VsdHMuc29ydCggc29ydE9yZGVyICk7XG5cblx0aWYgKCBoYXNEdXBsaWNhdGUgKSB7XG5cdFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XG5cdFx0XHRpZiAoIGVsZW0gPT09IHJlc3VsdHNbIGkgXSApIHtcblx0XHRcdFx0aiA9IGR1cGxpY2F0ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdHJlc3VsdHMuc3BsaWNlKCBkdXBsaWNhdGVzWyBqIF0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDbGVhciBpbnB1dCBhZnRlciBzb3J0aW5nIHRvIHJlbGVhc2Ugb2JqZWN0c1xuXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvcHVsbC8yMjVcblx0c29ydElucHV0ID0gbnVsbDtcblxuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmV0cmlldmluZyB0aGUgdGV4dCB2YWx1ZSBvZiBhbiBhcnJheSBvZiBET00gbm9kZXNcbiAqIEBwYXJhbSB7QXJyYXl8RWxlbWVudH0gZWxlbVxuICovXG5nZXRUZXh0ID0gU2l6emxlLmdldFRleHQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0dmFyIG5vZGUsXG5cdFx0cmV0ID0gXCJcIixcblx0XHRpID0gMCxcblx0XHRub2RlVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0aWYgKCAhbm9kZVR5cGUgKSB7XG5cdFx0Ly8gSWYgbm8gbm9kZVR5cGUsIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXlcblx0XHR3aGlsZSAoIChub2RlID0gZWxlbVtpKytdKSApIHtcblx0XHRcdC8vIERvIG5vdCB0cmF2ZXJzZSBjb21tZW50IG5vZGVzXG5cdFx0XHRyZXQgKz0gZ2V0VGV4dCggbm9kZSApO1xuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDEgfHwgbm9kZVR5cGUgPT09IDkgfHwgbm9kZVR5cGUgPT09IDExICkge1xuXHRcdC8vIFVzZSB0ZXh0Q29udGVudCBmb3IgZWxlbWVudHNcblx0XHQvLyBpbm5lclRleHQgdXNhZ2UgcmVtb3ZlZCBmb3IgY29uc2lzdGVuY3kgb2YgbmV3IGxpbmVzIChqUXVlcnkgIzExMTUzKVxuXHRcdGlmICggdHlwZW9mIGVsZW0udGV4dENvbnRlbnQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS50ZXh0Q29udGVudDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gVHJhdmVyc2UgaXRzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0cmV0ICs9IGdldFRleHQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAzIHx8IG5vZGVUeXBlID09PSA0ICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVWYWx1ZTtcblx0fVxuXHQvLyBEbyBub3QgaW5jbHVkZSBjb21tZW50IG9yIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gbm9kZXNcblxuXHRyZXR1cm4gcmV0O1xufTtcblxuRXhwciA9IFNpenpsZS5zZWxlY3RvcnMgPSB7XG5cblx0Ly8gQ2FuIGJlIGFkanVzdGVkIGJ5IHRoZSB1c2VyXG5cdGNhY2hlTGVuZ3RoOiA1MCxcblxuXHRjcmVhdGVQc2V1ZG86IG1hcmtGdW5jdGlvbixcblxuXHRtYXRjaDogbWF0Y2hFeHByLFxuXG5cdGF0dHJIYW5kbGU6IHt9LFxuXG5cdGZpbmQ6IHt9LFxuXG5cdHJlbGF0aXZlOiB7XG5cdFx0XCI+XCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIiBcIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiIH0sXG5cdFx0XCIrXCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiflwiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiB9XG5cdH0sXG5cblx0cHJlRmlsdGVyOiB7XG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdG1hdGNoWzFdID0gbWF0Y2hbMV0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0Ly8gTW92ZSB0aGUgZ2l2ZW4gdmFsdWUgdG8gbWF0Y2hbM10gd2hldGhlciBxdW90ZWQgb3IgdW5xdW90ZWRcblx0XHRcdG1hdGNoWzNdID0gKCBtYXRjaFszXSB8fCBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiICkucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsyXSA9PT0gXCJ+PVwiICkge1xuXHRcdFx0XHRtYXRjaFszXSA9IFwiIFwiICsgbWF0Y2hbM10gKyBcIiBcIjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCA0ICk7XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0LyogbWF0Y2hlcyBmcm9tIG1hdGNoRXhwcltcIkNISUxEXCJdXG5cdFx0XHRcdDEgdHlwZSAob25seXxudGh8Li4uKVxuXHRcdFx0XHQyIHdoYXQgKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdDMgYXJndW1lbnQgKGV2ZW58b2RkfFxcZCp8XFxkKm4oWystXVxcZCspP3wuLi4pXG5cdFx0XHRcdDQgeG4tY29tcG9uZW50IG9mIHhuK3kgYXJndW1lbnQgKFsrLV0/XFxkKm58KVxuXHRcdFx0XHQ1IHNpZ24gb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDYgeCBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NyBzaWduIG9mIHktY29tcG9uZW50XG5cdFx0XHRcdDggeSBvZiB5LWNvbXBvbmVudFxuXHRcdFx0Ki9cblx0XHRcdG1hdGNoWzFdID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsxXS5zbGljZSggMCwgMyApID09PSBcIm50aFwiICkge1xuXHRcdFx0XHQvLyBudGgtKiByZXF1aXJlcyBhcmd1bWVudFxuXHRcdFx0XHRpZiAoICFtYXRjaFszXSApIHtcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBudW1lcmljIHggYW5kIHkgcGFyYW1ldGVycyBmb3IgRXhwci5maWx0ZXIuQ0hJTERcblx0XHRcdFx0Ly8gcmVtZW1iZXIgdGhhdCBmYWxzZS90cnVlIGNhc3QgcmVzcGVjdGl2ZWx5IHRvIDAvMVxuXHRcdFx0XHRtYXRjaFs0XSA9ICsoIG1hdGNoWzRdID8gbWF0Y2hbNV0gKyAobWF0Y2hbNl0gfHwgMSkgOiAyICogKCBtYXRjaFszXSA9PT0gXCJldmVuXCIgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIgKSApO1xuXHRcdFx0XHRtYXRjaFs1XSA9ICsoICggbWF0Y2hbN10gKyBtYXRjaFs4XSApIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICk7XG5cblx0XHRcdC8vIG90aGVyIHR5cGVzIHByb2hpYml0IGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHR2YXIgZXhjZXNzLFxuXHRcdFx0XHR1bnF1b3RlZCA9ICFtYXRjaFs2XSAmJiBtYXRjaFsyXTtcblxuXHRcdFx0aWYgKCBtYXRjaEV4cHJbXCJDSElMRFwiXS50ZXN0KCBtYXRjaFswXSApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWNjZXB0IHF1b3RlZCBhcmd1bWVudHMgYXMtaXNcblx0XHRcdGlmICggbWF0Y2hbM10gKSB7XG5cdFx0XHRcdG1hdGNoWzJdID0gbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIjtcblxuXHRcdFx0Ly8gU3RyaXAgZXhjZXNzIGNoYXJhY3RlcnMgZnJvbSB1bnF1b3RlZCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIHVucXVvdGVkICYmIHJwc2V1ZG8udGVzdCggdW5xdW90ZWQgKSAmJlxuXHRcdFx0XHQvLyBHZXQgZXhjZXNzIGZyb20gdG9rZW5pemUgKHJlY3Vyc2l2ZWx5KVxuXHRcdFx0XHQoZXhjZXNzID0gdG9rZW5pemUoIHVucXVvdGVkLCB0cnVlICkpICYmXG5cdFx0XHRcdC8vIGFkdmFuY2UgdG8gdGhlIG5leHQgY2xvc2luZyBwYXJlbnRoZXNpc1xuXHRcdFx0XHQoZXhjZXNzID0gdW5xdW90ZWQuaW5kZXhPZiggXCIpXCIsIHVucXVvdGVkLmxlbmd0aCAtIGV4Y2VzcyApIC0gdW5xdW90ZWQubGVuZ3RoKSApIHtcblxuXHRcdFx0XHQvLyBleGNlc3MgaXMgYSBuZWdhdGl2ZSBpbmRleFxuXHRcdFx0XHRtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdFx0bWF0Y2hbMl0gPSB1bnF1b3RlZC5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVybiBvbmx5IGNhcHR1cmVzIG5lZWRlZCBieSB0aGUgcHNldWRvIGZpbHRlciBtZXRob2QgKHR5cGUgYW5kIGFyZ3VtZW50KVxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCAzICk7XG5cdFx0fVxuXHR9LFxuXG5cdGZpbHRlcjoge1xuXG5cdFx0XCJUQUdcIjogZnVuY3Rpb24oIG5vZGVOYW1lU2VsZWN0b3IgKSB7XG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBub2RlTmFtZVNlbGVjdG9yLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBub2RlTmFtZVNlbGVjdG9yID09PSBcIipcIiA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbm9kZU5hbWU7XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0xBU1NcIjogZnVuY3Rpb24oIGNsYXNzTmFtZSApIHtcblx0XHRcdHZhciBwYXR0ZXJuID0gY2xhc3NDYWNoZVsgY2xhc3NOYW1lICsgXCIgXCIgXTtcblxuXHRcdFx0cmV0dXJuIHBhdHRlcm4gfHxcblx0XHRcdFx0KHBhdHRlcm4gPSBuZXcgUmVnRXhwKCBcIihefFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgY2xhc3NOYW1lICsgXCIoXCIgKyB3aGl0ZXNwYWNlICsgXCJ8JClcIiApKSAmJlxuXHRcdFx0XHRjbGFzc0NhY2hlKCBjbGFzc05hbWUsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBwYXR0ZXJuLnRlc3QoIHR5cGVvZiBlbGVtLmNsYXNzTmFtZSA9PT0gXCJzdHJpbmdcIiAmJiBlbGVtLmNsYXNzTmFtZSB8fCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiICk7XG5cdFx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG5hbWUsIG9wZXJhdG9yLCBjaGVjayApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IFNpenpsZS5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHRcdFx0aWYgKCByZXN1bHQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiIT1cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFvcGVyYXRvciApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlc3VsdCArPSBcIlwiO1xuXG5cdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCI9XCIgPyByZXN1bHQgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIhPVwiID8gcmVzdWx0ICE9PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiXj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID09PSAwIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIqPVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiJD1cIiA/IGNoZWNrICYmIHJlc3VsdC5zbGljZSggLWNoZWNrLmxlbmd0aCApID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifj1cIiA/ICggXCIgXCIgKyByZXN1bHQucmVwbGFjZSggcndoaXRlc3BhY2UsIFwiIFwiICkgKyBcIiBcIiApLmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifD1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgfHwgcmVzdWx0LnNsaWNlKCAwLCBjaGVjay5sZW5ndGggKyAxICkgPT09IGNoZWNrICsgXCItXCIgOlxuXHRcdFx0XHRcdGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggdHlwZSwgd2hhdCwgYXJndW1lbnQsIGZpcnN0LCBsYXN0ICkge1xuXHRcdFx0dmFyIHNpbXBsZSA9IHR5cGUuc2xpY2UoIDAsIDMgKSAhPT0gXCJudGhcIixcblx0XHRcdFx0Zm9yd2FyZCA9IHR5cGUuc2xpY2UoIC00ICkgIT09IFwibGFzdFwiLFxuXHRcdFx0XHRvZlR5cGUgPSB3aGF0ID09PSBcIm9mLXR5cGVcIjtcblxuXHRcdFx0cmV0dXJuIGZpcnN0ID09PSAxICYmIGxhc3QgPT09IDAgP1xuXG5cdFx0XHRcdC8vIFNob3J0Y3V0IGZvciA6bnRoLSoobilcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuICEhZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0XHR9IDpcblxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBjYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsIG5vZGUsIG5vZGVJbmRleCwgc3RhcnQsXG5cdFx0XHRcdFx0XHRkaXIgPSBzaW1wbGUgIT09IGZvcndhcmQgPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiLFxuXHRcdFx0XHRcdFx0cGFyZW50ID0gZWxlbS5wYXJlbnROb2RlLFxuXHRcdFx0XHRcdFx0bmFtZSA9IG9mVHlwZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRcdFx0XHR1c2VDYWNoZSA9ICF4bWwgJiYgIW9mVHlwZSxcblx0XHRcdFx0XHRcdGRpZmYgPSBmYWxzZTtcblxuXHRcdFx0XHRcdGlmICggcGFyZW50ICkge1xuXG5cdFx0XHRcdFx0XHQvLyA6KGZpcnN0fGxhc3R8b25seSktKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdFx0XHRpZiAoIHNpbXBsZSApIHtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCBkaXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9IG5vZGVbIGRpciBdKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdC8vIFJldmVyc2UgZGlyZWN0aW9uIGZvciA6b25seS0qIChpZiB3ZSBoYXZlbid0IHlldCBkb25lIHNvKVxuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0ID0gZGlyID0gdHlwZSA9PT0gXCJvbmx5XCIgJiYgIXN0YXJ0ICYmIFwibmV4dFNpYmxpbmdcIjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0c3RhcnQgPSBbIGZvcndhcmQgPyBwYXJlbnQuZmlyc3RDaGlsZCA6IHBhcmVudC5sYXN0Q2hpbGQgXTtcblxuXHRcdFx0XHRcdFx0Ly8gbm9uLXhtbCA6bnRoLWNoaWxkKC4uLikgc3RvcmVzIGNhY2hlIGRhdGEgb24gYHBhcmVudGBcblx0XHRcdFx0XHRcdGlmICggZm9yd2FyZCAmJiB1c2VDYWNoZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTZWVrIGBlbGVtYCBmcm9tIGEgcHJldmlvdXNseS1jYWNoZWQgaW5kZXhcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBwYXJlbnQ7XG5cdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXggJiYgY2FjaGVbIDIgXTtcblx0XHRcdFx0XHRcdFx0bm9kZSA9IG5vZGVJbmRleCAmJiBwYXJlbnQuY2hpbGROb2Rlc1sgbm9kZUluZGV4IF07XG5cblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEZhbGxiYWNrIHRvIHNlZWtpbmcgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBXaGVuIGZvdW5kLCBjYWNoZSBpbmRleGVzIG9uIGBwYXJlbnRgIGFuZCBicmVha1xuXHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiArK2RpZmYgJiYgbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIG5vZGVJbmRleCwgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFVzZSBwcmV2aW91c2x5LWNhY2hlZCBlbGVtZW50IGluZGV4IGlmIGF2YWlsYWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbTtcblx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXg7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvLyB4bWwgOm50aC1jaGlsZCguLi4pXG5cdFx0XHRcdFx0XHRcdC8vIG9yIDpudGgtbGFzdC1jaGlsZCguLi4pIG9yIDpudGgoLWxhc3QpPy1vZi10eXBlKC4uLilcblx0XHRcdFx0XHRcdFx0aWYgKCBkaWZmID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBVc2UgdGhlIHNhbWUgbG9vcCBhcyBhYm92ZSB0byBzZWVrIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQrK2RpZmYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gQ2FjaGUgdGhlIGluZGV4IG9mIGVhY2ggZW5jb3VudGVyZWQgZWxlbWVudFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBJbmNvcnBvcmF0ZSB0aGUgb2Zmc2V0LCB0aGVuIGNoZWNrIGFnYWluc3QgY3ljbGUgc2l6ZVxuXHRcdFx0XHRcdFx0ZGlmZiAtPSBsYXN0O1xuXHRcdFx0XHRcdFx0cmV0dXJuIGRpZmYgPT09IGZpcnN0IHx8ICggZGlmZiAlIGZpcnN0ID09PSAwICYmIGRpZmYgLyBmaXJzdCA+PSAwICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggcHNldWRvLCBhcmd1bWVudCApIHtcblx0XHRcdC8vIHBzZXVkby1jbGFzcyBuYW1lcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZVxuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNwc2V1ZG8tY2xhc3Nlc1xuXHRcdFx0Ly8gUHJpb3JpdGl6ZSBieSBjYXNlIHNlbnNpdGl2aXR5IGluIGNhc2UgY3VzdG9tIHBzZXVkb3MgYXJlIGFkZGVkIHdpdGggdXBwZXJjYXNlIGxldHRlcnNcblx0XHRcdC8vIFJlbWVtYmVyIHRoYXQgc2V0RmlsdGVycyBpbmhlcml0cyBmcm9tIHBzZXVkb3Ncblx0XHRcdHZhciBhcmdzLFxuXHRcdFx0XHRmbiA9IEV4cHIucHNldWRvc1sgcHNldWRvIF0gfHwgRXhwci5zZXRGaWx0ZXJzWyBwc2V1ZG8udG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIgKyBwc2V1ZG8gKTtcblxuXHRcdFx0Ly8gVGhlIHVzZXIgbWF5IHVzZSBjcmVhdGVQc2V1ZG8gdG8gaW5kaWNhdGUgdGhhdFxuXHRcdFx0Ly8gYXJndW1lbnRzIGFyZSBuZWVkZWQgdG8gY3JlYXRlIHRoZSBmaWx0ZXIgZnVuY3Rpb25cblx0XHRcdC8vIGp1c3QgYXMgU2l6emxlIGRvZXNcblx0XHRcdGlmICggZm5bIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0cmV0dXJuIGZuKCBhcmd1bWVudCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBCdXQgbWFpbnRhaW4gc3VwcG9ydCBmb3Igb2xkIHNpZ25hdHVyZXNcblx0XHRcdGlmICggZm4ubGVuZ3RoID4gMSApIHtcblx0XHRcdFx0YXJncyA9IFsgcHNldWRvLCBwc2V1ZG8sIFwiXCIsIGFyZ3VtZW50IF07XG5cdFx0XHRcdHJldHVybiBFeHByLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoIHBzZXVkby50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdFx0XHRcdHZhciBpZHgsXG5cdFx0XHRcdFx0XHRcdG1hdGNoZWQgPSBmbiggc2VlZCwgYXJndW1lbnQgKSxcblx0XHRcdFx0XHRcdFx0aSA9IG1hdGNoZWQubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlkeCA9IGluZGV4T2YoIHNlZWQsIG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdFx0c2VlZFsgaWR4IF0gPSAhKCBtYXRjaGVzWyBpZHggXSA9IG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KSA6XG5cdFx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZm4oIGVsZW0sIDAsIGFyZ3MgKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZm47XG5cdFx0fVxuXHR9LFxuXG5cdHBzZXVkb3M6IHtcblx0XHQvLyBQb3RlbnRpYWxseSBjb21wbGV4IHBzZXVkb3Ncblx0XHRcIm5vdFwiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0Ly8gVHJpbSB0aGUgc2VsZWN0b3IgcGFzc2VkIHRvIGNvbXBpbGVcblx0XHRcdC8vIHRvIGF2b2lkIHRyZWF0aW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nXG5cdFx0XHQvLyBzcGFjZXMgYXMgY29tYmluYXRvcnNcblx0XHRcdHZhciBpbnB1dCA9IFtdLFxuXHRcdFx0XHRyZXN1bHRzID0gW10sXG5cdFx0XHRcdG1hdGNoZXIgPSBjb21waWxlKCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICkgKTtcblxuXHRcdFx0cmV0dXJuIG1hdGNoZXJbIGV4cGFuZG8gXSA/XG5cdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcywgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHRcdFx0dW5tYXRjaGVkID0gbWF0Y2hlciggc2VlZCwgbnVsbCwgeG1sLCBbXSApLFxuXHRcdFx0XHRcdFx0aSA9IHNlZWQubGVuZ3RoO1xuXG5cdFx0XHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgdW5tYXRjaGVkIGJ5IGBtYXRjaGVyYFxuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdHNlZWRbaV0gPSAhKG1hdGNoZXNbaV0gPSBlbGVtKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pIDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHRpbnB1dFswXSA9IGVsZW07XG5cdFx0XHRcdFx0bWF0Y2hlciggaW5wdXQsIG51bGwsIHhtbCwgcmVzdWx0cyApO1xuXHRcdFx0XHRcdC8vIERvbid0IGtlZXAgdGhlIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRcdFx0aW5wdXRbMF0gPSBudWxsO1xuXHRcdFx0XHRcdHJldHVybiAhcmVzdWx0cy5wb3AoKTtcblx0XHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdFwiaGFzXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBTaXp6bGUoIHNlbGVjdG9yLCBlbGVtICkubGVuZ3RoID4gMDtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImNvbnRhaW5zXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0udGV4dENvbnRlbnQgfHwgZWxlbS5pbm5lclRleHQgfHwgZ2V0VGV4dCggZWxlbSApICkuaW5kZXhPZiggdGV4dCApID4gLTE7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0Ly8gXCJXaGV0aGVyIGFuIGVsZW1lbnQgaXMgcmVwcmVzZW50ZWQgYnkgYSA6bGFuZygpIHNlbGVjdG9yXG5cdFx0Ly8gaXMgYmFzZWQgc29sZWx5IG9uIHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWVcblx0XHQvLyBiZWluZyBlcXVhbCB0byB0aGUgaWRlbnRpZmllciBDLFxuXHRcdC8vIG9yIGJlZ2lubmluZyB3aXRoIHRoZSBpZGVudGlmaWVyIEMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgXCItXCIuXG5cdFx0Ly8gVGhlIG1hdGNoaW5nIG9mIEMgYWdhaW5zdCB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlIGlzIHBlcmZvcm1lZCBjYXNlLWluc2Vuc2l0aXZlbHkuXG5cdFx0Ly8gVGhlIGlkZW50aWZpZXIgQyBkb2VzIG5vdCBoYXZlIHRvIGJlIGEgdmFsaWQgbGFuZ3VhZ2UgbmFtZS5cIlxuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jbGFuZy1wc2V1ZG9cblx0XHRcImxhbmdcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggbGFuZyApIHtcblx0XHRcdC8vIGxhbmcgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcblx0XHRcdGlmICggIXJpZGVudGlmaWVyLnRlc3QobGFuZyB8fCBcIlwiKSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIGxhbmc6IFwiICsgbGFuZyApO1xuXHRcdFx0fVxuXHRcdFx0bGFuZyA9IGxhbmcucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgZWxlbUxhbmc7XG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtTGFuZyA9IGRvY3VtZW50SXNIVE1MID9cblx0XHRcdFx0XHRcdGVsZW0ubGFuZyA6XG5cdFx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZShcInhtbDpsYW5nXCIpIHx8IGVsZW0uZ2V0QXR0cmlidXRlKFwibGFuZ1wiKSkgKSB7XG5cblx0XHRcdFx0XHRcdGVsZW1MYW5nID0gZWxlbUxhbmcudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtTGFuZyA9PT0gbGFuZyB8fCBlbGVtTGFuZy5pbmRleE9mKCBsYW5nICsgXCItXCIgKSA9PT0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gd2hpbGUgKCAoZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSkgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0Ly8gTWlzY2VsbGFuZW91c1xuXHRcdFwidGFyZ2V0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGhhc2ggPSB3aW5kb3cubG9jYXRpb24gJiYgd2luZG93LmxvY2F0aW9uLmhhc2g7XG5cdFx0XHRyZXR1cm4gaGFzaCAmJiBoYXNoLnNsaWNlKCAxICkgPT09IGVsZW0uaWQ7XG5cdFx0fSxcblxuXHRcdFwicm9vdFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2NFbGVtO1xuXHRcdH0sXG5cblx0XHRcImZvY3VzXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgKCFkb2N1bWVudC5oYXNGb2N1cyB8fCBkb2N1bWVudC5oYXNGb2N1cygpKSAmJiAhIShlbGVtLnR5cGUgfHwgZWxlbS5ocmVmIHx8IH5lbGVtLnRhYkluZGV4KTtcblx0XHR9LFxuXG5cdFx0Ly8gQm9vbGVhbiBwcm9wZXJ0aWVzXG5cdFx0XCJlbmFibGVkXCI6IGNyZWF0ZURpc2FibGVkUHNldWRvKCBmYWxzZSApLFxuXHRcdFwiZGlzYWJsZWRcIjogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIHRydWUgKSxcblxuXHRcdFwiY2hlY2tlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIEluIENTUzMsIDpjaGVja2VkIHNob3VsZCByZXR1cm4gYm90aCBjaGVja2VkIGFuZCBzZWxlY3RlZCBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiAobm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiAhIWVsZW0uY2hlY2tlZCkgfHwgKG5vZGVOYW1lID09PSBcIm9wdGlvblwiICYmICEhZWxlbS5zZWxlY3RlZCk7XG5cdFx0fSxcblxuXHRcdFwic2VsZWN0ZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBBY2Nlc3NpbmcgdGhpcyBwcm9wZXJ0eSBtYWtlcyBzZWxlY3RlZC1ieS1kZWZhdWx0XG5cdFx0XHQvLyBvcHRpb25zIGluIFNhZmFyaSB3b3JrIHByb3Blcmx5XG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZWxlbS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xuXHRcdH0sXG5cblx0XHQvLyBDb250ZW50c1xuXHRcdFwiZW1wdHlcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2VtcHR5LXBzZXVkb1xuXHRcdFx0Ly8gOmVtcHR5IGlzIG5lZ2F0ZWQgYnkgZWxlbWVudCAoMSkgb3IgY29udGVudCBub2RlcyAodGV4dDogMzsgY2RhdGE6IDQ7IGVudGl0eSByZWY6IDUpLFxuXHRcdFx0Ly8gICBidXQgbm90IGJ5IG90aGVycyAoY29tbWVudDogODsgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbjogNzsgZXRjLilcblx0XHRcdC8vIG5vZGVUeXBlIDwgNiB3b3JrcyBiZWNhdXNlIGF0dHJpYnV0ZXMgKDIpIGRvIG5vdCBhcHBlYXIgYXMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPCA2ICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdFwicGFyZW50XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICFFeHByLnBzZXVkb3NbXCJlbXB0eVwiXSggZWxlbSApO1xuXHRcdH0sXG5cblx0XHQvLyBFbGVtZW50L2lucHV0IHR5cGVzXG5cdFx0XCJoZWFkZXJcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmhlYWRlci50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiaW5wdXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmlucHV0cy50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiYnV0dG9uXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gXCJidXR0b25cIiB8fCBuYW1lID09PSBcImJ1dHRvblwiO1xuXHRcdH0sXG5cblx0XHRcInRleHRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgYXR0cjtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiAmJlxuXHRcdFx0XHRlbGVtLnR5cGUgPT09IFwidGV4dFwiICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUU8OFxuXHRcdFx0XHQvLyBOZXcgSFRNTDUgYXR0cmlidXRlIHZhbHVlcyAoZS5nLiwgXCJzZWFyY2hcIikgYXBwZWFyIHdpdGggZWxlbS50eXBlID09PSBcInRleHRcIlxuXHRcdFx0XHQoIChhdHRyID0gZWxlbS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpKSA9PSBudWxsIHx8IGF0dHIudG9Mb3dlckNhc2UoKSA9PT0gXCJ0ZXh0XCIgKTtcblx0XHR9LFxuXG5cdFx0Ly8gUG9zaXRpb24taW4tY29sbGVjdGlvblxuXHRcdFwiZmlyc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBbIDAgXTtcblx0XHR9KSxcblxuXHRcdFwibGFzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHJldHVybiBbIGxlbmd0aCAtIDEgXTtcblx0XHR9KSxcblxuXHRcdFwiZXFcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0cmV0dXJuIFsgYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudCBdO1xuXHRcdH0pLFxuXG5cdFx0XCJldmVuXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJvZGRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDE7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImx0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgLS1pID49IDA7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwiZ3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyArK2kgPCBsZW5ndGg7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KVxuXHR9XG59O1xuXG5FeHByLnBzZXVkb3NbXCJudGhcIl0gPSBFeHByLnBzZXVkb3NbXCJlcVwiXTtcblxuLy8gQWRkIGJ1dHRvbi9pbnB1dCB0eXBlIHBzZXVkb3NcbmZvciAoIGkgaW4geyByYWRpbzogdHJ1ZSwgY2hlY2tib3g6IHRydWUsIGZpbGU6IHRydWUsIHBhc3N3b3JkOiB0cnVlLCBpbWFnZTogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUlucHV0UHNldWRvKCBpICk7XG59XG5mb3IgKCBpIGluIHsgc3VibWl0OiB0cnVlLCByZXNldDogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUJ1dHRvblBzZXVkbyggaSApO1xufVxuXG4vLyBFYXN5IEFQSSBmb3IgY3JlYXRpbmcgbmV3IHNldEZpbHRlcnNcbmZ1bmN0aW9uIHNldEZpbHRlcnMoKSB7fVxuc2V0RmlsdGVycy5wcm90b3R5cGUgPSBFeHByLmZpbHRlcnMgPSBFeHByLnBzZXVkb3M7XG5FeHByLnNldEZpbHRlcnMgPSBuZXcgc2V0RmlsdGVycygpO1xuXG50b2tlbml6ZSA9IFNpenpsZS50b2tlbml6ZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgcGFyc2VPbmx5ICkge1xuXHR2YXIgbWF0Y2hlZCwgbWF0Y2gsIHRva2VucywgdHlwZSxcblx0XHRzb0ZhciwgZ3JvdXBzLCBwcmVGaWx0ZXJzLFxuXHRcdGNhY2hlZCA9IHRva2VuQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoIGNhY2hlZCApIHtcblx0XHRyZXR1cm4gcGFyc2VPbmx5ID8gMCA6IGNhY2hlZC5zbGljZSggMCApO1xuXHR9XG5cblx0c29GYXIgPSBzZWxlY3Rvcjtcblx0Z3JvdXBzID0gW107XG5cdHByZUZpbHRlcnMgPSBFeHByLnByZUZpbHRlcjtcblxuXHR3aGlsZSAoIHNvRmFyICkge1xuXG5cdFx0Ly8gQ29tbWEgYW5kIGZpcnN0IHJ1blxuXHRcdGlmICggIW1hdGNoZWQgfHwgKG1hdGNoID0gcmNvbW1hLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0aWYgKCBtYXRjaCApIHtcblx0XHRcdFx0Ly8gRG9uJ3QgY29uc3VtZSB0cmFpbGluZyBjb21tYXMgYXMgdmFsaWRcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hbMF0ubGVuZ3RoICkgfHwgc29GYXI7XG5cdFx0XHR9XG5cdFx0XHRncm91cHMucHVzaCggKHRva2VucyA9IFtdKSApO1xuXHRcdH1cblxuXHRcdG1hdGNoZWQgPSBmYWxzZTtcblxuXHRcdC8vIENvbWJpbmF0b3JzXG5cdFx0aWYgKCAobWF0Y2ggPSByY29tYmluYXRvcnMuZXhlYyggc29GYXIgKSkgKSB7XG5cdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdC8vIENhc3QgZGVzY2VuZGFudCBjb21iaW5hdG9ycyB0byBzcGFjZVxuXHRcdFx0XHR0eXBlOiBtYXRjaFswXS5yZXBsYWNlKCBydHJpbSwgXCIgXCIgKVxuXHRcdFx0fSk7XG5cdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZpbHRlcnNcblx0XHRmb3IgKCB0eXBlIGluIEV4cHIuZmlsdGVyICkge1xuXHRcdFx0aWYgKCAobWF0Y2ggPSBtYXRjaEV4cHJbIHR5cGUgXS5leGVjKCBzb0ZhciApKSAmJiAoIXByZUZpbHRlcnNbIHR5cGUgXSB8fFxuXHRcdFx0XHQobWF0Y2ggPSBwcmVGaWx0ZXJzWyB0eXBlIF0oIG1hdGNoICkpKSApIHtcblx0XHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRcdG1hdGNoZXM6IG1hdGNoXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggIW1hdGNoZWQgKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgaW52YWxpZCBleGNlc3Ncblx0Ly8gaWYgd2UncmUganVzdCBwYXJzaW5nXG5cdC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3Igb3IgcmV0dXJuIHRva2Vuc1xuXHRyZXR1cm4gcGFyc2VPbmx5ID9cblx0XHRzb0Zhci5sZW5ndGggOlxuXHRcdHNvRmFyID9cblx0XHRcdFNpenpsZS5lcnJvciggc2VsZWN0b3IgKSA6XG5cdFx0XHQvLyBDYWNoZSB0aGUgdG9rZW5zXG5cdFx0XHR0b2tlbkNhY2hlKCBzZWxlY3RvciwgZ3JvdXBzICkuc2xpY2UoIDAgKTtcbn07XG5cbmZ1bmN0aW9uIHRvU2VsZWN0b3IoIHRva2VucyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0c2VsZWN0b3IgPSBcIlwiO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRzZWxlY3RvciArPSB0b2tlbnNbaV0udmFsdWU7XG5cdH1cblx0cmV0dXJuIHNlbGVjdG9yO1xufVxuXG5mdW5jdGlvbiBhZGRDb21iaW5hdG9yKCBtYXRjaGVyLCBjb21iaW5hdG9yLCBiYXNlICkge1xuXHR2YXIgZGlyID0gY29tYmluYXRvci5kaXIsXG5cdFx0c2tpcCA9IGNvbWJpbmF0b3IubmV4dCxcblx0XHRrZXkgPSBza2lwIHx8IGRpcixcblx0XHRjaGVja05vbkVsZW1lbnRzID0gYmFzZSAmJiBrZXkgPT09IFwicGFyZW50Tm9kZVwiLFxuXHRcdGRvbmVOYW1lID0gZG9uZSsrO1xuXG5cdHJldHVybiBjb21iaW5hdG9yLmZpcnN0ID9cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGNsb3Nlc3QgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSA6XG5cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGFsbCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudHNcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIG9sZENhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSxcblx0XHRcdFx0bmV3Q2FjaGUgPSBbIGRpcnJ1bnMsIGRvbmVOYW1lIF07XG5cblx0XHRcdC8vIFdlIGNhbid0IHNldCBhcmJpdHJhcnkgZGF0YSBvbiBYTUwgbm9kZXMsIHNvIHRoZXkgZG9uJ3QgYmVuZWZpdCBmcm9tIGNvbWJpbmF0b3IgY2FjaGluZ1xuXHRcdFx0aWYgKCB4bWwgKSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gZWxlbVsgZXhwYW5kbyBdIHx8IChlbGVtWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gfHwgKG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0aWYgKCBza2lwICYmIHNraXAgPT09IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSApIHtcblx0XHRcdFx0XHRcdFx0ZWxlbSA9IGVsZW1bIGRpciBdIHx8IGVsZW07XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCAob2xkQ2FjaGUgPSB1bmlxdWVDYWNoZVsga2V5IF0pICYmXG5cdFx0XHRcdFx0XHRcdG9sZENhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgb2xkQ2FjaGVbIDEgXSA9PT0gZG9uZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQXNzaWduIHRvIG5ld0NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0cmV0dXJuIChuZXdDYWNoZVsgMiBdID0gb2xkQ2FjaGVbIDIgXSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBSZXVzZSBuZXdjYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyBrZXkgXSA9IG5ld0NhY2hlO1xuXG5cdFx0XHRcdFx0XHRcdC8vIEEgbWF0Y2ggbWVhbnMgd2UncmUgZG9uZTsgYSBmYWlsIG1lYW5zIHdlIGhhdmUgdG8ga2VlcCBjaGVja2luZ1xuXHRcdFx0XHRcdFx0XHRpZiAoIChuZXdDYWNoZVsgMiBdID0gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkpICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcbn1cblxuZnVuY3Rpb24gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICkge1xuXHRyZXR1cm4gbWF0Y2hlcnMubGVuZ3RoID4gMSA/XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBpID0gbWF0Y2hlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggIW1hdGNoZXJzW2ldKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gOlxuXHRcdG1hdGNoZXJzWzBdO1xufVxuXG5mdW5jdGlvbiBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciwgY29udGV4dHMsIHJlc3VsdHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBjb250ZXh0cy5sZW5ndGg7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHRzW2ldLCByZXN1bHRzICk7XG5cdH1cblx0cmV0dXJuIHJlc3VsdHM7XG59XG5cbmZ1bmN0aW9uIGNvbmRlbnNlKCB1bm1hdGNoZWQsIG1hcCwgZmlsdGVyLCBjb250ZXh0LCB4bWwgKSB7XG5cdHZhciBlbGVtLFxuXHRcdG5ld1VubWF0Y2hlZCA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGxlbiA9IHVubWF0Y2hlZC5sZW5ndGgsXG5cdFx0bWFwcGVkID0gbWFwICE9IG51bGw7XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRpZiAoICFmaWx0ZXIgfHwgZmlsdGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0bmV3VW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0aWYgKCBtYXBwZWQgKSB7XG5cdFx0XHRcdFx0bWFwLnB1c2goIGkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBuZXdVbm1hdGNoZWQ7XG59XG5cbmZ1bmN0aW9uIHNldE1hdGNoZXIoIHByZUZpbHRlciwgc2VsZWN0b3IsIG1hdGNoZXIsIHBvc3RGaWx0ZXIsIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApIHtcblx0aWYgKCBwb3N0RmlsdGVyICYmICFwb3N0RmlsdGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbHRlciA9IHNldE1hdGNoZXIoIHBvc3RGaWx0ZXIgKTtcblx0fVxuXHRpZiAoIHBvc3RGaW5kZXIgJiYgIXBvc3RGaW5kZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmluZGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICk7XG5cdH1cblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgcmVzdWx0cywgY29udGV4dCwgeG1sICkge1xuXHRcdHZhciB0ZW1wLCBpLCBlbGVtLFxuXHRcdFx0cHJlTWFwID0gW10sXG5cdFx0XHRwb3N0TWFwID0gW10sXG5cdFx0XHRwcmVleGlzdGluZyA9IHJlc3VsdHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBHZXQgaW5pdGlhbCBlbGVtZW50cyBmcm9tIHNlZWQgb3IgY29udGV4dFxuXHRcdFx0ZWxlbXMgPSBzZWVkIHx8IG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yIHx8IFwiKlwiLCBjb250ZXh0Lm5vZGVUeXBlID8gWyBjb250ZXh0IF0gOiBjb250ZXh0LCBbXSApLFxuXG5cdFx0XHQvLyBQcmVmaWx0ZXIgdG8gZ2V0IG1hdGNoZXIgaW5wdXQsIHByZXNlcnZpbmcgYSBtYXAgZm9yIHNlZWQtcmVzdWx0cyBzeW5jaHJvbml6YXRpb25cblx0XHRcdG1hdGNoZXJJbiA9IHByZUZpbHRlciAmJiAoIHNlZWQgfHwgIXNlbGVjdG9yICkgP1xuXHRcdFx0XHRjb25kZW5zZSggZWxlbXMsIHByZU1hcCwgcHJlRmlsdGVyLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdGVsZW1zLFxuXG5cdFx0XHRtYXRjaGVyT3V0ID0gbWF0Y2hlciA/XG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgYSBwb3N0RmluZGVyLCBvciBmaWx0ZXJlZCBzZWVkLCBvciBub24tc2VlZCBwb3N0RmlsdGVyIG9yIHByZWV4aXN0aW5nIHJlc3VsdHMsXG5cdFx0XHRcdHBvc3RGaW5kZXIgfHwgKCBzZWVkID8gcHJlRmlsdGVyIDogcHJlZXhpc3RpbmcgfHwgcG9zdEZpbHRlciApID9cblxuXHRcdFx0XHRcdC8vIC4uLmludGVybWVkaWF0ZSBwcm9jZXNzaW5nIGlzIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdFtdIDpcblxuXHRcdFx0XHRcdC8vIC4uLm90aGVyd2lzZSB1c2UgcmVzdWx0cyBkaXJlY3RseVxuXHRcdFx0XHRcdHJlc3VsdHMgOlxuXHRcdFx0XHRtYXRjaGVySW47XG5cblx0XHQvLyBGaW5kIHByaW1hcnkgbWF0Y2hlc1xuXHRcdGlmICggbWF0Y2hlciApIHtcblx0XHRcdG1hdGNoZXIoIG1hdGNoZXJJbiwgbWF0Y2hlck91dCwgY29udGV4dCwgeG1sICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcG9zdEZpbHRlclxuXHRcdGlmICggcG9zdEZpbHRlciApIHtcblx0XHRcdHRlbXAgPSBjb25kZW5zZSggbWF0Y2hlck91dCwgcG9zdE1hcCApO1xuXHRcdFx0cG9zdEZpbHRlciggdGVtcCwgW10sIGNvbnRleHQsIHhtbCApO1xuXG5cdFx0XHQvLyBVbi1tYXRjaCBmYWlsaW5nIGVsZW1lbnRzIGJ5IG1vdmluZyB0aGVtIGJhY2sgdG8gbWF0Y2hlckluXG5cdFx0XHRpID0gdGVtcC5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAoZWxlbSA9IHRlbXBbaV0pICkge1xuXHRcdFx0XHRcdG1hdGNoZXJPdXRbIHBvc3RNYXBbaV0gXSA9ICEobWF0Y2hlckluWyBwb3N0TWFwW2ldIF0gPSBlbGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggc2VlZCApIHtcblx0XHRcdGlmICggcG9zdEZpbmRlciB8fCBwcmVGaWx0ZXIgKSB7XG5cdFx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblx0XHRcdFx0XHQvLyBHZXQgdGhlIGZpbmFsIG1hdGNoZXJPdXQgYnkgY29uZGVuc2luZyB0aGlzIGludGVybWVkaWF0ZSBpbnRvIHBvc3RGaW5kZXIgY29udGV4dHNcblx0XHRcdFx0XHR0ZW1wID0gW107XG5cdFx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHQvLyBSZXN0b3JlIG1hdGNoZXJJbiBzaW5jZSBlbGVtIGlzIG5vdCB5ZXQgYSBmaW5hbCBtYXRjaFxuXHRcdFx0XHRcdFx0XHR0ZW1wLnB1c2goIChtYXRjaGVySW5baV0gPSBlbGVtKSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCAobWF0Y2hlck91dCA9IFtdKSwgdGVtcCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBNb3ZlIG1hdGNoZWQgZWxlbWVudHMgZnJvbSBzZWVkIHRvIHJlc3VsdHMgdG8ga2VlcCB0aGVtIHN5bmNocm9uaXplZFxuXHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSAmJlxuXHRcdFx0XHRcdFx0KHRlbXAgPSBwb3N0RmluZGVyID8gaW5kZXhPZiggc2VlZCwgZWxlbSApIDogcHJlTWFwW2ldKSA+IC0xICkge1xuXG5cdFx0XHRcdFx0XHRzZWVkW3RlbXBdID0gIShyZXN1bHRzW3RlbXBdID0gZWxlbSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBBZGQgZWxlbWVudHMgdG8gcmVzdWx0cywgdGhyb3VnaCBwb3N0RmluZGVyIGlmIGRlZmluZWRcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlck91dCA9IGNvbmRlbnNlKFxuXHRcdFx0XHRtYXRjaGVyT3V0ID09PSByZXN1bHRzID9cblx0XHRcdFx0XHRtYXRjaGVyT3V0LnNwbGljZSggcHJlZXhpc3RpbmcsIG1hdGNoZXJPdXQubGVuZ3RoICkgOlxuXHRcdFx0XHRcdG1hdGNoZXJPdXRcblx0XHRcdCk7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsIHJlc3VsdHMsIG1hdGNoZXJPdXQsIHhtbCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgbWF0Y2hlck91dCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMgKSB7XG5cdHZhciBjaGVja0NvbnRleHQsIG1hdGNoZXIsIGosXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRsZWFkaW5nUmVsYXRpdmUgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbMF0udHlwZSBdLFxuXHRcdGltcGxpY2l0UmVsYXRpdmUgPSBsZWFkaW5nUmVsYXRpdmUgfHwgRXhwci5yZWxhdGl2ZVtcIiBcIl0sXG5cdFx0aSA9IGxlYWRpbmdSZWxhdGl2ZSA/IDEgOiAwLFxuXG5cdFx0Ly8gVGhlIGZvdW5kYXRpb25hbCBtYXRjaGVyIGVuc3VyZXMgdGhhdCBlbGVtZW50cyBhcmUgcmVhY2hhYmxlIGZyb20gdG9wLWxldmVsIGNvbnRleHQocylcblx0XHRtYXRjaENvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBjaGVja0NvbnRleHQ7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoQW55Q29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YoIGNoZWNrQ29udGV4dCwgZWxlbSApID4gLTE7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoZXJzID0gWyBmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIHJldCA9ICggIWxlYWRpbmdSZWxhdGl2ZSAmJiAoIHhtbCB8fCBjb250ZXh0ICE9PSBvdXRlcm1vc3RDb250ZXh0ICkgKSB8fCAoXG5cdFx0XHRcdChjaGVja0NvbnRleHQgPSBjb250ZXh0KS5ub2RlVHlwZSA/XG5cdFx0XHRcdFx0bWF0Y2hDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdFx0bWF0Y2hBbnlDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSApO1xuXHRcdFx0Ly8gQXZvaWQgaGFuZ2luZyBvbnRvIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRjaGVja0NvbnRleHQgPSBudWxsO1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9IF07XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAobWF0Y2hlciA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1tpXS50eXBlIF0pICkge1xuXHRcdFx0bWF0Y2hlcnMgPSBbIGFkZENvbWJpbmF0b3IoZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksIG1hdGNoZXIpIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXIgPSBFeHByLmZpbHRlclsgdG9rZW5zW2ldLnR5cGUgXS5hcHBseSggbnVsbCwgdG9rZW5zW2ldLm1hdGNoZXMgKTtcblxuXHRcdFx0Ly8gUmV0dXJuIHNwZWNpYWwgdXBvbiBzZWVpbmcgYSBwb3NpdGlvbmFsIG1hdGNoZXJcblx0XHRcdGlmICggbWF0Y2hlclsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHQvLyBGaW5kIHRoZSBuZXh0IHJlbGF0aXZlIG9wZXJhdG9yIChpZiBhbnkpIGZvciBwcm9wZXIgaGFuZGxpbmdcblx0XHRcdFx0aiA9ICsraTtcblx0XHRcdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyB0b2tlbnNbal0udHlwZSBdICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBzZXRNYXRjaGVyKFxuXHRcdFx0XHRcdGkgPiAxICYmIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLFxuXHRcdFx0XHRcdGkgPiAxICYmIHRvU2VsZWN0b3IoXG5cdFx0XHRcdFx0XHQvLyBJZiB0aGUgcHJlY2VkaW5nIHRva2VuIHdhcyBhIGRlc2NlbmRhbnQgY29tYmluYXRvciwgaW5zZXJ0IGFuIGltcGxpY2l0IGFueS1lbGVtZW50IGAqYFxuXHRcdFx0XHRcdFx0dG9rZW5zLnNsaWNlKCAwLCBpIC0gMSApLmNvbmNhdCh7IHZhbHVlOiB0b2tlbnNbIGkgLSAyIF0udHlwZSA9PT0gXCIgXCIgPyBcIipcIiA6IFwiXCIgfSlcblx0XHRcdFx0XHQpLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSxcblx0XHRcdFx0XHRtYXRjaGVyLFxuXHRcdFx0XHRcdGkgPCBqICYmIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMuc2xpY2UoIGksIGogKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgbWF0Y2hlckZyb21Ub2tlbnMoICh0b2tlbnMgPSB0b2tlbnMuc2xpY2UoIGogKSkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIHRvU2VsZWN0b3IoIHRva2VucyApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHRtYXRjaGVycy5wdXNoKCBtYXRjaGVyICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSB7XG5cdHZhciBieVNldCA9IHNldE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0YnlFbGVtZW50ID0gZWxlbWVudE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0c3VwZXJNYXRjaGVyID0gZnVuY3Rpb24oIHNlZWQsIGNvbnRleHQsIHhtbCwgcmVzdWx0cywgb3V0ZXJtb3N0ICkge1xuXHRcdFx0dmFyIGVsZW0sIGosIG1hdGNoZXIsXG5cdFx0XHRcdG1hdGNoZWRDb3VudCA9IDAsXG5cdFx0XHRcdGkgPSBcIjBcIixcblx0XHRcdFx0dW5tYXRjaGVkID0gc2VlZCAmJiBbXSxcblx0XHRcdFx0c2V0TWF0Y2hlZCA9IFtdLFxuXHRcdFx0XHRjb250ZXh0QmFja3VwID0gb3V0ZXJtb3N0Q29udGV4dCxcblx0XHRcdFx0Ly8gV2UgbXVzdCBhbHdheXMgaGF2ZSBlaXRoZXIgc2VlZCBlbGVtZW50cyBvciBvdXRlcm1vc3QgY29udGV4dFxuXHRcdFx0XHRlbGVtcyA9IHNlZWQgfHwgYnlFbGVtZW50ICYmIEV4cHIuZmluZFtcIlRBR1wiXSggXCIqXCIsIG91dGVybW9zdCApLFxuXHRcdFx0XHQvLyBVc2UgaW50ZWdlciBkaXJydW5zIGlmZiB0aGlzIGlzIHRoZSBvdXRlcm1vc3QgbWF0Y2hlclxuXHRcdFx0XHRkaXJydW5zVW5pcXVlID0gKGRpcnJ1bnMgKz0gY29udGV4dEJhY2t1cCA9PSBudWxsID8gMSA6IE1hdGgucmFuZG9tKCkgfHwgMC4xKSxcblx0XHRcdFx0bGVuID0gZWxlbXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHQgPT09IGRvY3VtZW50IHx8IGNvbnRleHQgfHwgb3V0ZXJtb3N0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgZWxlbWVudHMgcGFzc2luZyBlbGVtZW50TWF0Y2hlcnMgZGlyZWN0bHkgdG8gcmVzdWx0c1xuXHRcdFx0Ly8gU3VwcG9ydDogSUU8OSwgU2FmYXJpXG5cdFx0XHQvLyBUb2xlcmF0ZSBOb2RlTGlzdCBwcm9wZXJ0aWVzIChJRTogXCJsZW5ndGhcIjsgU2FmYXJpOiA8bnVtYmVyPikgbWF0Y2hpbmcgZWxlbWVudHMgYnkgaWRcblx0XHRcdGZvciAoIDsgaSAhPT0gbGVuICYmIChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBieUVsZW1lbnQgJiYgZWxlbSApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHRpZiAoICFjb250ZXh0ICYmIGVsZW0ub3duZXJEb2N1bWVudCAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHRcdFx0XHRcdFx0eG1sID0gIWRvY3VtZW50SXNIVE1MO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR3aGlsZSAoIChtYXRjaGVyID0gZWxlbWVudE1hdGNoZXJzW2orK10pICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0IHx8IGRvY3VtZW50LCB4bWwpICkge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHJhY2sgdW5tYXRjaGVkIGVsZW1lbnRzIGZvciBzZXQgZmlsdGVyc1xuXHRcdFx0XHRpZiAoIGJ5U2V0ICkge1xuXHRcdFx0XHRcdC8vIFRoZXkgd2lsbCBoYXZlIGdvbmUgdGhyb3VnaCBhbGwgcG9zc2libGUgbWF0Y2hlcnNcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gIW1hdGNoZXIgJiYgZWxlbSkgKSB7XG5cdFx0XHRcdFx0XHRtYXRjaGVkQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBMZW5ndGhlbiB0aGUgYXJyYXkgZm9yIGV2ZXJ5IGVsZW1lbnQsIG1hdGNoZWQgb3Igbm90XG5cdFx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdFx0dW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gYGlgIGlzIG5vdyB0aGUgY291bnQgb2YgZWxlbWVudHMgdmlzaXRlZCBhYm92ZSwgYW5kIGFkZGluZyBpdCB0byBgbWF0Y2hlZENvdW50YFxuXHRcdFx0Ly8gbWFrZXMgdGhlIGxhdHRlciBub25uZWdhdGl2ZS5cblx0XHRcdG1hdGNoZWRDb3VudCArPSBpO1xuXG5cdFx0XHQvLyBBcHBseSBzZXQgZmlsdGVycyB0byB1bm1hdGNoZWQgZWxlbWVudHNcblx0XHRcdC8vIE5PVEU6IFRoaXMgY2FuIGJlIHNraXBwZWQgaWYgdGhlcmUgYXJlIG5vIHVubWF0Y2hlZCBlbGVtZW50cyAoaS5lLiwgYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIGVxdWFscyBgaWApLCB1bmxlc3Mgd2UgZGlkbid0IHZpc2l0IF9hbnlfIGVsZW1lbnRzIGluIHRoZSBhYm92ZSBsb29wIGJlY2F1c2Ugd2UgaGF2ZVxuXHRcdFx0Ly8gbm8gZWxlbWVudCBtYXRjaGVycyBhbmQgbm8gc2VlZC5cblx0XHRcdC8vIEluY3JlbWVudGluZyBhbiBpbml0aWFsbHktc3RyaW5nIFwiMFwiIGBpYCBhbGxvd3MgYGlgIHRvIHJlbWFpbiBhIHN0cmluZyBvbmx5IGluIHRoYXRcblx0XHRcdC8vIGNhc2UsIHdoaWNoIHdpbGwgcmVzdWx0IGluIGEgXCIwMFwiIGBtYXRjaGVkQ291bnRgIHRoYXQgZGlmZmVycyBmcm9tIGBpYCBidXQgaXMgYWxzb1xuXHRcdFx0Ly8gbnVtZXJpY2FsbHkgemVyby5cblx0XHRcdGlmICggYnlTZXQgJiYgaSAhPT0gbWF0Y2hlZENvdW50ICkge1xuXHRcdFx0XHRqID0gMDtcblx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IHNldE1hdGNoZXJzW2orK10pICkge1xuXHRcdFx0XHRcdG1hdGNoZXIoIHVubWF0Y2hlZCwgc2V0TWF0Y2hlZCwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRcdFx0Ly8gUmVpbnRlZ3JhdGUgZWxlbWVudCBtYXRjaGVzIHRvIGVsaW1pbmF0ZSB0aGUgbmVlZCBmb3Igc29ydGluZ1xuXHRcdFx0XHRcdGlmICggbWF0Y2hlZENvdW50ID4gMCApIHtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoICEodW5tYXRjaGVkW2ldIHx8IHNldE1hdGNoZWRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHRcdHNldE1hdGNoZWRbaV0gPSBwb3AuY2FsbCggcmVzdWx0cyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRGlzY2FyZCBpbmRleCBwbGFjZWhvbGRlciB2YWx1ZXMgdG8gZ2V0IG9ubHkgYWN0dWFsIG1hdGNoZXNcblx0XHRcdFx0XHRzZXRNYXRjaGVkID0gY29uZGVuc2UoIHNldE1hdGNoZWQgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFkZCBtYXRjaGVzIHRvIHJlc3VsdHNcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2V0TWF0Y2hlZCApO1xuXG5cdFx0XHRcdC8vIFNlZWRsZXNzIHNldCBtYXRjaGVzIHN1Y2NlZWRpbmcgbXVsdGlwbGUgc3VjY2Vzc2Z1bCBtYXRjaGVycyBzdGlwdWxhdGUgc29ydGluZ1xuXHRcdFx0XHRpZiAoIG91dGVybW9zdCAmJiAhc2VlZCAmJiBzZXRNYXRjaGVkLmxlbmd0aCA+IDAgJiZcblx0XHRcdFx0XHQoIG1hdGNoZWRDb3VudCArIHNldE1hdGNoZXJzLmxlbmd0aCApID4gMSApIHtcblxuXHRcdFx0XHRcdFNpenpsZS51bmlxdWVTb3J0KCByZXN1bHRzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gT3ZlcnJpZGUgbWFuaXB1bGF0aW9uIG9mIGdsb2JhbHMgYnkgbmVzdGVkIG1hdGNoZXJzXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0QmFja3VwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdW5tYXRjaGVkO1xuXHRcdH07XG5cblx0cmV0dXJuIGJ5U2V0ID9cblx0XHRtYXJrRnVuY3Rpb24oIHN1cGVyTWF0Y2hlciApIDpcblx0XHRzdXBlck1hdGNoZXI7XG59XG5cbmNvbXBpbGUgPSBTaXp6bGUuY29tcGlsZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgbWF0Y2ggLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XG5cdHZhciBpLFxuXHRcdHNldE1hdGNoZXJzID0gW10sXG5cdFx0ZWxlbWVudE1hdGNoZXJzID0gW10sXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggIWNhY2hlZCApIHtcblx0XHQvLyBHZW5lcmF0ZSBhIGZ1bmN0aW9uIG9mIHJlY3Vyc2l2ZSBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCB0byBjaGVjayBlYWNoIGVsZW1lbnRcblx0XHRpZiAoICFtYXRjaCApIHtcblx0XHRcdG1hdGNoID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0fVxuXHRcdGkgPSBtYXRjaC5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRjYWNoZWQgPSBtYXRjaGVyRnJvbVRva2VucyggbWF0Y2hbaV0gKTtcblx0XHRcdGlmICggY2FjaGVkWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHNldE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbWVudE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhY2hlIHRoZSBjb21waWxlZCBmdW5jdGlvblxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGUoIHNlbGVjdG9yLCBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSApO1xuXG5cdFx0Ly8gU2F2ZSBzZWxlY3RvciBhbmQgdG9rZW5pemF0aW9uXG5cdFx0Y2FjaGVkLnNlbGVjdG9yID0gc2VsZWN0b3I7XG5cdH1cblx0cmV0dXJuIGNhY2hlZDtcbn07XG5cbi8qKlxuICogQSBsb3ctbGV2ZWwgc2VsZWN0aW9uIGZ1bmN0aW9uIHRoYXQgd29ya3Mgd2l0aCBTaXp6bGUncyBjb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHNlbGVjdG9yIEEgc2VsZWN0b3Igb3IgYSBwcmUtY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbiBidWlsdCB3aXRoIFNpenpsZS5jb21waWxlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRleHRcbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHRzXVxuICogQHBhcmFtIHtBcnJheX0gW3NlZWRdIEEgc2V0IG9mIGVsZW1lbnRzIHRvIG1hdGNoIGFnYWluc3RcbiAqL1xuc2VsZWN0ID0gU2l6emxlLnNlbGVjdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIGksIHRva2VucywgdG9rZW4sIHR5cGUsIGZpbmQsXG5cdFx0Y29tcGlsZWQgPSB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBzZWxlY3Rvcixcblx0XHRtYXRjaCA9ICFzZWVkICYmIHRva2VuaXplKCAoc2VsZWN0b3IgPSBjb21waWxlZC5zZWxlY3RvciB8fCBzZWxlY3RvcikgKTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBUcnkgdG8gbWluaW1pemUgb3BlcmF0aW9ucyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBzZWxlY3RvciBpbiB0aGUgbGlzdCBhbmQgbm8gc2VlZFxuXHQvLyAodGhlIGxhdHRlciBvZiB3aGljaCBndWFyYW50ZWVzIHVzIGNvbnRleHQpXG5cdGlmICggbWF0Y2gubGVuZ3RoID09PSAxICkge1xuXG5cdFx0Ly8gUmVkdWNlIGNvbnRleHQgaWYgdGhlIGxlYWRpbmcgY29tcG91bmQgc2VsZWN0b3IgaXMgYW4gSURcblx0XHR0b2tlbnMgPSBtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwICk7XG5cdFx0aWYgKCB0b2tlbnMubGVuZ3RoID4gMiAmJiAodG9rZW4gPSB0b2tlbnNbMF0pLnR5cGUgPT09IFwiSURcIiAmJlxuXHRcdFx0XHRjb250ZXh0Lm5vZGVUeXBlID09PSA5ICYmIGRvY3VtZW50SXNIVE1MICYmIEV4cHIucmVsYXRpdmVbIHRva2Vuc1sxXS50eXBlIF0gKSB7XG5cblx0XHRcdGNvbnRleHQgPSAoIEV4cHIuZmluZFtcIklEXCJdKCB0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpLCBjb250ZXh0ICkgfHwgW10gKVswXTtcblx0XHRcdGlmICggIWNvbnRleHQgKSB7XG5cdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHQvLyBQcmVjb21waWxlZCBtYXRjaGVycyB3aWxsIHN0aWxsIHZlcmlmeSBhbmNlc3RyeSwgc28gc3RlcCB1cCBhIGxldmVsXG5cdFx0XHR9IGVsc2UgaWYgKCBjb21waWxlZCApIHtcblx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQucGFyZW50Tm9kZTtcblx0XHRcdH1cblxuXHRcdFx0c2VsZWN0b3IgPSBzZWxlY3Rvci5zbGljZSggdG9rZW5zLnNoaWZ0KCkudmFsdWUubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmV0Y2ggYSBzZWVkIHNldCBmb3IgcmlnaHQtdG8tbGVmdCBtYXRjaGluZ1xuXHRcdGkgPSBtYXRjaEV4cHJbXCJuZWVkc0NvbnRleHRcIl0udGVzdCggc2VsZWN0b3IgKSA/IDAgOiB0b2tlbnMubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG9rZW4gPSB0b2tlbnNbaV07XG5cblx0XHRcdC8vIEFib3J0IGlmIHdlIGhpdCBhIGNvbWJpbmF0b3Jcblx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgKHR5cGUgPSB0b2tlbi50eXBlKSBdICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggKGZpbmQgPSBFeHByLmZpbmRbIHR5cGUgXSkgKSB7XG5cdFx0XHRcdC8vIFNlYXJjaCwgZXhwYW5kaW5nIGNvbnRleHQgZm9yIGxlYWRpbmcgc2libGluZyBjb21iaW5hdG9yc1xuXHRcdFx0XHRpZiAoIChzZWVkID0gZmluZChcblx0XHRcdFx0XHR0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICksXG5cdFx0XHRcdFx0cnNpYmxpbmcudGVzdCggdG9rZW5zWzBdLnR5cGUgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHRcdFx0XHQpKSApIHtcblxuXHRcdFx0XHRcdC8vIElmIHNlZWQgaXMgZW1wdHkgb3Igbm8gdG9rZW5zIHJlbWFpbiwgd2UgY2FuIHJldHVybiBlYXJseVxuXHRcdFx0XHRcdHRva2Vucy5zcGxpY2UoIGksIDEgKTtcblx0XHRcdFx0XHRzZWxlY3RvciA9IHNlZWQubGVuZ3RoICYmIHRvU2VsZWN0b3IoIHRva2VucyApO1xuXHRcdFx0XHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2VlZCApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDb21waWxlIGFuZCBleGVjdXRlIGEgZmlsdGVyaW5nIGZ1bmN0aW9uIGlmIG9uZSBpcyBub3QgcHJvdmlkZWRcblx0Ly8gUHJvdmlkZSBgbWF0Y2hgIHRvIGF2b2lkIHJldG9rZW5pemF0aW9uIGlmIHdlIG1vZGlmaWVkIHRoZSBzZWxlY3RvciBhYm92ZVxuXHQoIGNvbXBpbGVkIHx8IGNvbXBpbGUoIHNlbGVjdG9yLCBtYXRjaCApICkoXG5cdFx0c2VlZCxcblx0XHRjb250ZXh0LFxuXHRcdCFkb2N1bWVudElzSFRNTCxcblx0XHRyZXN1bHRzLFxuXHRcdCFjb250ZXh0IHx8IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0KTtcblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vLyBPbmUtdGltZSBhc3NpZ25tZW50c1xuXG4vLyBTb3J0IHN0YWJpbGl0eVxuc3VwcG9ydC5zb3J0U3RhYmxlID0gZXhwYW5kby5zcGxpdChcIlwiKS5zb3J0KCBzb3J0T3JkZXIgKS5qb2luKFwiXCIpID09PSBleHBhbmRvO1xuXG4vLyBTdXBwb3J0OiBDaHJvbWUgMTQtMzUrXG4vLyBBbHdheXMgYXNzdW1lIGR1cGxpY2F0ZXMgaWYgdGhleSBhcmVuJ3QgcGFzc2VkIHRvIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9uXG5zdXBwb3J0LmRldGVjdER1cGxpY2F0ZXMgPSAhIWhhc0R1cGxpY2F0ZTtcblxuLy8gSW5pdGlhbGl6ZSBhZ2FpbnN0IHRoZSBkZWZhdWx0IGRvY3VtZW50XG5zZXREb2N1bWVudCgpO1xuXG4vLyBTdXBwb3J0OiBXZWJraXQ8NTM3LjMyIC0gU2FmYXJpIDYuMC4zL0Nocm9tZSAyNSAoZml4ZWQgaW4gQ2hyb21lIDI3KVxuLy8gRGV0YWNoZWQgbm9kZXMgY29uZm91bmRpbmdseSBmb2xsb3cgKmVhY2ggb3RoZXIqXG5zdXBwb3J0LnNvcnREZXRhY2hlZCA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdC8vIFNob3VsZCByZXR1cm4gMSwgYnV0IHJldHVybnMgNCAoZm9sbG93aW5nKVxuXHRyZXR1cm4gZWwuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmaWVsZHNldFwiKSApICYgMTtcbn0pO1xuXG4vLyBTdXBwb3J0OiBJRTw4XG4vLyBQcmV2ZW50IGF0dHJpYnV0ZS9wcm9wZXJ0eSBcImludGVycG9sYXRpb25cIlxuLy8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNjQyOSUyOFZTLjg1JTI5LmFzcHhcbmlmICggIWFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdGVsLmlubmVySFRNTCA9IFwiPGEgaHJlZj0nIyc+PC9hPlwiO1xuXHRyZXR1cm4gZWwuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpID09PSBcIiNcIiA7XG59KSApIHtcblx0YWRkSGFuZGxlKCBcInR5cGV8aHJlZnxoZWlnaHR8d2lkdGhcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwidHlwZVwiID8gMSA6IDIgKTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZGVmYXVsdFZhbHVlIGluIHBsYWNlIG9mIGdldEF0dHJpYnV0ZShcInZhbHVlXCIpXG5pZiAoICFzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdGVsLmlubmVySFRNTCA9IFwiPGlucHV0Lz5cIjtcblx0ZWwuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiwgXCJcIiApO1xuXHRyZXR1cm4gZWwuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBcIlwiO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggXCJ2YWx1ZVwiLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0aWYgKCAhaXNYTUwgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kZWZhdWx0VmFsdWU7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGdldEF0dHJpYnV0ZU5vZGUgdG8gZmV0Y2ggYm9vbGVhbnMgd2hlbiBnZXRBdHRyaWJ1dGUgbGllc1xuaWYgKCAhYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0cmV0dXJuIGVsLmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpID09IG51bGw7XG59KSApIHtcblx0YWRkSGFuZGxlKCBib29sZWFucywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciB2YWw7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdID09PSB0cnVlID8gbmFtZS50b0xvd2VyQ2FzZSgpIDpcblx0XHRcdFx0XHQodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0fVxuXHR9KTtcbn1cblxucmV0dXJuIFNpenpsZTtcblxufSkoIHdpbmRvdyApO1xuXG5cblxualF1ZXJ5LmZpbmQgPSBTaXp6bGU7XG5qUXVlcnkuZXhwciA9IFNpenpsZS5zZWxlY3RvcnM7XG5cbi8vIERlcHJlY2F0ZWRcbmpRdWVyeS5leHByWyBcIjpcIiBdID0galF1ZXJ5LmV4cHIucHNldWRvcztcbmpRdWVyeS51bmlxdWVTb3J0ID0galF1ZXJ5LnVuaXF1ZSA9IFNpenpsZS51bmlxdWVTb3J0O1xualF1ZXJ5LnRleHQgPSBTaXp6bGUuZ2V0VGV4dDtcbmpRdWVyeS5pc1hNTERvYyA9IFNpenpsZS5pc1hNTDtcbmpRdWVyeS5jb250YWlucyA9IFNpenpsZS5jb250YWlucztcbmpRdWVyeS5lc2NhcGVTZWxlY3RvciA9IFNpenpsZS5lc2NhcGU7XG5cblxuXG5cbnZhciBkaXIgPSBmdW5jdGlvbiggZWxlbSwgZGlyLCB1bnRpbCApIHtcblx0dmFyIG1hdGNoZWQgPSBbXSxcblx0XHR0cnVuY2F0ZSA9IHVudGlsICE9PSB1bmRlZmluZWQ7XG5cblx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICYmIGVsZW0ubm9kZVR5cGUgIT09IDkgKSB7XG5cdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0aWYgKCB0cnVuY2F0ZSAmJiBqUXVlcnkoIGVsZW0gKS5pcyggdW50aWwgKSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRtYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBzaWJsaW5ncyA9IGZ1bmN0aW9uKCBuLCBlbGVtICkge1xuXHR2YXIgbWF0Y2hlZCA9IFtdO1xuXG5cdGZvciAoIDsgbjsgbiA9IG4ubmV4dFNpYmxpbmcgKSB7XG5cdFx0aWYgKCBuLm5vZGVUeXBlID09PSAxICYmIG4gIT09IGVsZW0gKSB7XG5cdFx0XHRtYXRjaGVkLnB1c2goIG4gKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbWF0Y2hlZDtcbn07XG5cblxudmFyIHJuZWVkc0NvbnRleHQgPSBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQ7XG5cbnZhciByc2luZ2xlVGFnID0gKCAvXjwoW2Etel1bXlxcL1xcMD46XFx4MjBcXHRcXHJcXG5cXGZdKilbXFx4MjBcXHRcXHJcXG5cXGZdKlxcLz8+KD86PFxcL1xcMT58KSQvaSApO1xuXG5cblxudmFyIHJpc1NpbXBsZSA9IC9eLlteOiNcXFtcXC4sXSokLztcblxuLy8gSW1wbGVtZW50IHRoZSBpZGVudGljYWwgZnVuY3Rpb25hbGl0eSBmb3IgZmlsdGVyIGFuZCBub3RcbmZ1bmN0aW9uIHdpbm5vdyggZWxlbWVudHMsIHF1YWxpZmllciwgbm90ICkge1xuXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBxdWFsaWZpZXIgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiAhIXF1YWxpZmllci5jYWxsKCBlbGVtLCBpLCBlbGVtICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBTaW5nbGUgZWxlbWVudFxuXHRpZiAoIHF1YWxpZmllci5ub2RlVHlwZSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGVsZW0gPT09IHF1YWxpZmllciApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gQXJyYXlsaWtlIG9mIGVsZW1lbnRzIChqUXVlcnksIGFyZ3VtZW50cywgQXJyYXkpXG5cdGlmICggdHlwZW9mIHF1YWxpZmllciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGluZGV4T2YuY2FsbCggcXVhbGlmaWVyLCBlbGVtICkgPiAtMSApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gU2ltcGxlIHNlbGVjdG9yIHRoYXQgY2FuIGJlIGZpbHRlcmVkIGRpcmVjdGx5LCByZW1vdmluZyBub24tRWxlbWVudHNcblx0aWYgKCByaXNTaW1wbGUudGVzdCggcXVhbGlmaWVyICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5maWx0ZXIoIHF1YWxpZmllciwgZWxlbWVudHMsIG5vdCApO1xuXHR9XG5cblx0Ly8gQ29tcGxleCBzZWxlY3RvciwgY29tcGFyZSB0aGUgdHdvIHNldHMsIHJlbW92aW5nIG5vbi1FbGVtZW50c1xuXHRxdWFsaWZpZXIgPSBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGVsZW1lbnRzICk7XG5cdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiAoIGluZGV4T2YuY2FsbCggcXVhbGlmaWVyLCBlbGVtICkgPiAtMSApICE9PSBub3QgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMTtcblx0fSApO1xufVxuXG5qUXVlcnkuZmlsdGVyID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1zLCBub3QgKSB7XG5cdHZhciBlbGVtID0gZWxlbXNbIDAgXTtcblxuXHRpZiAoIG5vdCApIHtcblx0XHRleHByID0gXCI6bm90KFwiICsgZXhwciArIFwiKVwiO1xuXHR9XG5cblx0aWYgKCBlbGVtcy5sZW5ndGggPT09IDEgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBlbGVtLCBleHByICkgPyBbIGVsZW0gXSA6IFtdO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5maW5kLm1hdGNoZXMoIGV4cHIsIGpRdWVyeS5ncmVwKCBlbGVtcywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZVR5cGUgPT09IDE7XG5cdH0gKSApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmaW5kOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGksIHJldCxcblx0XHRcdGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0c2VsZiA9IHRoaXM7XG5cblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5KCBzZWxlY3RvciApLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHNlbGZbIGkgXSwgdGhpcyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9ICkgKTtcblx0XHR9XG5cblx0XHRyZXQgPSB0aGlzLnB1c2hTdGFjayggW10gKTtcblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRqUXVlcnkuZmluZCggc2VsZWN0b3IsIHNlbGZbIGkgXSwgcmV0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGxlbiA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggcmV0ICkgOiByZXQ7XG5cdH0sXG5cdGZpbHRlcjogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgZmFsc2UgKSApO1xuXHR9LFxuXHRub3Q6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIHRydWUgKSApO1xuXHR9LFxuXHRpczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiAhIXdpbm5vdyhcblx0XHRcdHRoaXMsXG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBwb3NpdGlvbmFsL3JlbGF0aXZlIHNlbGVjdG9yLCBjaGVjayBtZW1iZXJzaGlwIGluIHRoZSByZXR1cm5lZCBzZXRcblx0XHRcdC8vIHNvICQoXCJwOmZpcnN0XCIpLmlzKFwicDpsYXN0XCIpIHdvbid0IHJldHVybiB0cnVlIGZvciBhIGRvYyB3aXRoIHR3byBcInBcIi5cblx0XHRcdHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiAmJiBybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICkgP1xuXHRcdFx0XHRqUXVlcnkoIHNlbGVjdG9yICkgOlxuXHRcdFx0XHRzZWxlY3RvciB8fCBbXSxcblx0XHRcdGZhbHNlXG5cdFx0KS5sZW5ndGg7XG5cdH1cbn0gKTtcblxuXG4vLyBJbml0aWFsaXplIGEgalF1ZXJ5IG9iamVjdFxuXG5cbi8vIEEgY2VudHJhbCByZWZlcmVuY2UgdG8gdGhlIHJvb3QgalF1ZXJ5KGRvY3VtZW50KVxudmFyIHJvb3RqUXVlcnksXG5cblx0Ly8gQSBzaW1wbGUgd2F5IHRvIGNoZWNrIGZvciBIVE1MIHN0cmluZ3Ncblx0Ly8gUHJpb3JpdGl6ZSAjaWQgb3ZlciA8dGFnPiB0byBhdm9pZCBYU1MgdmlhIGxvY2F0aW9uLmhhc2ggKCM5NTIxKVxuXHQvLyBTdHJpY3QgSFRNTCByZWNvZ25pdGlvbiAoIzExMjkwOiBtdXN0IHN0YXJ0IHdpdGggPClcblx0Ly8gU2hvcnRjdXQgc2ltcGxlICNpZCBjYXNlIGZvciBzcGVlZFxuXHRycXVpY2tFeHByID0gL14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qfCMoW1xcdy1dKykpJC8sXG5cblx0aW5pdCA9IGpRdWVyeS5mbi5pbml0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByb290ICkge1xuXHRcdHZhciBtYXRjaCwgZWxlbTtcblxuXHRcdC8vIEhBTkRMRTogJChcIlwiKSwgJChudWxsKSwgJCh1bmRlZmluZWQpLCAkKGZhbHNlKVxuXHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gTWV0aG9kIGluaXQoKSBhY2NlcHRzIGFuIGFsdGVybmF0ZSByb290alF1ZXJ5XG5cdFx0Ly8gc28gbWlncmF0ZSBjYW4gc3VwcG9ydCBqUXVlcnkuc3ViIChnaC0yMTAxKVxuXHRcdHJvb3QgPSByb290IHx8IHJvb3RqUXVlcnk7XG5cblx0XHQvLyBIYW5kbGUgSFRNTCBzdHJpbmdzXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRpZiAoIHNlbGVjdG9yWyAwIF0gPT09IFwiPFwiICYmXG5cdFx0XHRcdHNlbGVjdG9yWyBzZWxlY3Rvci5sZW5ndGggLSAxIF0gPT09IFwiPlwiICYmXG5cdFx0XHRcdHNlbGVjdG9yLmxlbmd0aCA+PSAzICkge1xuXG5cdFx0XHRcdC8vIEFzc3VtZSB0aGF0IHN0cmluZ3MgdGhhdCBzdGFydCBhbmQgZW5kIHdpdGggPD4gYXJlIEhUTUwgYW5kIHNraXAgdGhlIHJlZ2V4IGNoZWNrXG5cdFx0XHRcdG1hdGNoID0gWyBudWxsLCBzZWxlY3RvciwgbnVsbCBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWF0Y2ggaHRtbCBvciBtYWtlIHN1cmUgbm8gY29udGV4dCBpcyBzcGVjaWZpZWQgZm9yICNpZFxuXHRcdFx0aWYgKCBtYXRjaCAmJiAoIG1hdGNoWyAxIF0gfHwgIWNvbnRleHQgKSApIHtcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCkgLT4gJChhcnJheSlcblx0XHRcdFx0aWYgKCBtYXRjaFsgMSBdICkge1xuXHRcdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGV4dFsgMCBdIDogY29udGV4dDtcblxuXHRcdFx0XHRcdC8vIE9wdGlvbiB0byBydW4gc2NyaXB0cyBpcyB0cnVlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRcdC8vIEludGVudGlvbmFsbHkgbGV0IHRoZSBlcnJvciBiZSB0aHJvd24gaWYgcGFyc2VIVE1MIGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLCBqUXVlcnkucGFyc2VIVE1MKFxuXHRcdFx0XHRcdFx0bWF0Y2hbIDEgXSxcblx0XHRcdFx0XHRcdGNvbnRleHQgJiYgY29udGV4dC5ub2RlVHlwZSA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogZG9jdW1lbnQsXG5cdFx0XHRcdFx0XHR0cnVlXG5cdFx0XHRcdFx0KSApO1xuXG5cdFx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwsIHByb3BzKVxuXHRcdFx0XHRcdGlmICggcnNpbmdsZVRhZy50ZXN0KCBtYXRjaFsgMSBdICkgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvbnRleHQgKSApIHtcblx0XHRcdFx0XHRcdGZvciAoIG1hdGNoIGluIGNvbnRleHQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUHJvcGVydGllcyBvZiBjb250ZXh0IGFyZSBjYWxsZWQgYXMgbWV0aG9kcyBpZiBwb3NzaWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB0aGlzWyBtYXRjaCBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpc1sgbWF0Y2ggXSggY29udGV4dFsgbWF0Y2ggXSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBvdGhlcndpc2Ugc2V0IGFzIGF0dHJpYnV0ZXNcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmF0dHIoIG1hdGNoLCBjb250ZXh0WyBtYXRjaCBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoI2lkKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggbWF0Y2hbIDIgXSApO1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtICkge1xuXG5cdFx0XHRcdFx0XHQvLyBJbmplY3QgdGhlIGVsZW1lbnQgZGlyZWN0bHkgaW50byB0aGUgalF1ZXJ5IG9iamVjdFxuXHRcdFx0XHRcdFx0dGhpc1sgMCBdID0gZWxlbTtcblx0XHRcdFx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsICQoLi4uKSlcblx0XHRcdH0gZWxzZSBpZiAoICFjb250ZXh0IHx8IGNvbnRleHQuanF1ZXJ5ICkge1xuXHRcdFx0XHRyZXR1cm4gKCBjb250ZXh0IHx8IHJvb3QgKS5maW5kKCBzZWxlY3RvciApO1xuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgY29udGV4dClcblx0XHRcdC8vICh3aGljaCBpcyBqdXN0IGVxdWl2YWxlbnQgdG86ICQoY29udGV4dCkuZmluZChleHByKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IoIGNvbnRleHQgKS5maW5kKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0Ly8gSEFORExFOiAkKERPTUVsZW1lbnQpXG5cdFx0fSBlbHNlIGlmICggc2VsZWN0b3Iubm9kZVR5cGUgKSB7XG5cdFx0XHR0aGlzWyAwIF0gPSBzZWxlY3Rvcjtcblx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0Ly8gSEFORExFOiAkKGZ1bmN0aW9uKVxuXHRcdC8vIFNob3J0Y3V0IGZvciBkb2N1bWVudCByZWFkeVxuXHRcdH0gZWxzZSBpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBzZWxlY3RvciApICkge1xuXHRcdFx0cmV0dXJuIHJvb3QucmVhZHkgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHJvb3QucmVhZHkoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIEV4ZWN1dGUgaW1tZWRpYXRlbHkgaWYgcmVhZHkgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0c2VsZWN0b3IoIGpRdWVyeSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWFrZUFycmF5KCBzZWxlY3RvciwgdGhpcyApO1xuXHR9O1xuXG4vLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXG5pbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcblxuLy8gSW5pdGlhbGl6ZSBjZW50cmFsIHJlZmVyZW5jZVxucm9vdGpRdWVyeSA9IGpRdWVyeSggZG9jdW1lbnQgKTtcblxuXG52YXIgcnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXG5cblx0Ly8gTWV0aG9kcyBndWFyYW50ZWVkIHRvIHByb2R1Y2UgYSB1bmlxdWUgc2V0IHdoZW4gc3RhcnRpbmcgZnJvbSBhIHVuaXF1ZSBzZXRcblx0Z3VhcmFudGVlZFVuaXF1ZSA9IHtcblx0XHRjaGlsZHJlbjogdHJ1ZSxcblx0XHRjb250ZW50czogdHJ1ZSxcblx0XHRuZXh0OiB0cnVlLFxuXHRcdHByZXY6IHRydWVcblx0fTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRoYXM6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0dmFyIHRhcmdldHMgPSBqUXVlcnkoIHRhcmdldCwgdGhpcyApLFxuXHRcdFx0bCA9IHRhcmdldHMubGVuZ3RoO1xuXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHRoaXMsIHRhcmdldHNbIGkgXSApICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGNsb3Nlc3Q6IGZ1bmN0aW9uKCBzZWxlY3RvcnMsIGNvbnRleHQgKSB7XG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0bWF0Y2hlZCA9IFtdLFxuXHRcdFx0dGFyZ2V0cyA9IHR5cGVvZiBzZWxlY3RvcnMgIT09IFwic3RyaW5nXCIgJiYgalF1ZXJ5KCBzZWxlY3RvcnMgKTtcblxuXHRcdC8vIFBvc2l0aW9uYWwgc2VsZWN0b3JzIG5ldmVyIG1hdGNoLCBzaW5jZSB0aGVyZSdzIG5vIF9zZWxlY3Rpb25fIGNvbnRleHRcblx0XHRpZiAoICFybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9ycyApICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmb3IgKCBjdXIgPSB0aGlzWyBpIF07IGN1ciAmJiBjdXIgIT09IGNvbnRleHQ7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXG5cdFx0XHRcdFx0Ly8gQWx3YXlzIHNraXAgZG9jdW1lbnQgZnJhZ21lbnRzXG5cdFx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPCAxMSAmJiAoIHRhcmdldHMgP1xuXHRcdFx0XHRcdFx0dGFyZ2V0cy5pbmRleCggY3VyICkgPiAtMSA6XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IHBhc3Mgbm9uLWVsZW1lbnRzIHRvIFNpenpsZVxuXHRcdFx0XHRcdFx0Y3VyLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggY3VyLCBzZWxlY3RvcnMgKSApICkge1xuXG5cdFx0XHRcdFx0XHRtYXRjaGVkLnB1c2goIGN1ciApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkLmxlbmd0aCA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApIDogbWF0Y2hlZCApO1xuXHR9LFxuXG5cdC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gb2YgYW4gZWxlbWVudCB3aXRoaW4gdGhlIHNldFxuXHRpbmRleDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBObyBhcmd1bWVudCwgcmV0dXJuIGluZGV4IGluIHBhcmVudFxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCB0aGlzWyAwIF0gJiYgdGhpc1sgMCBdLnBhcmVudE5vZGUgKSA/IHRoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoIDogLTE7XG5cdFx0fVxuXG5cdFx0Ly8gSW5kZXggaW4gc2VsZWN0b3Jcblx0XHRpZiAoIHR5cGVvZiBlbGVtID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggalF1ZXJ5KCBlbGVtICksIHRoaXNbIDAgXSApO1xuXHRcdH1cblxuXHRcdC8vIExvY2F0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGRlc2lyZWQgZWxlbWVudFxuXHRcdHJldHVybiBpbmRleE9mLmNhbGwoIHRoaXMsXG5cblx0XHRcdC8vIElmIGl0IHJlY2VpdmVzIGEgalF1ZXJ5IG9iamVjdCwgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdXNlZFxuXHRcdFx0ZWxlbS5qcXVlcnkgPyBlbGVtWyAwIF0gOiBlbGVtXG5cdFx0KTtcblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soXG5cdFx0XHRqUXVlcnkudW5pcXVlU29ydChcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLmdldCgpLCBqUXVlcnkoIHNlbGVjdG9yLCBjb250ZXh0ICkgKVxuXHRcdFx0KVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkQmFjazogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLmFkZCggc2VsZWN0b3IgPT0gbnVsbCA/XG5cdFx0XHR0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKCBzZWxlY3RvciApXG5cdFx0KTtcblx0fVxufSApO1xuXG5mdW5jdGlvbiBzaWJsaW5nKCBjdXIsIGRpciApIHtcblx0d2hpbGUgKCAoIGN1ciA9IGN1clsgZGlyIF0gKSAmJiBjdXIubm9kZVR5cGUgIT09IDEgKSB7fVxuXHRyZXR1cm4gY3VyO1xufVxuXG5qUXVlcnkuZWFjaCgge1xuXHRwYXJlbnQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0cmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDExID8gcGFyZW50IDogbnVsbDtcblx0fSxcblx0cGFyZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIgKTtcblx0fSxcblx0cGFyZW50c1VudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIsIHVudGlsICk7XG5cdH0sXG5cdG5leHQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dEFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXZBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dFVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRwcmV2VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRzaWJsaW5nczogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmdzKCAoIGVsZW0ucGFyZW50Tm9kZSB8fCB7fSApLmZpcnN0Q2hpbGQsIGVsZW0gKTtcblx0fSxcblx0Y2hpbGRyZW46IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggZWxlbS5maXJzdENoaWxkICk7XG5cdH0sXG5cdGNvbnRlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZWxlbS5jb250ZW50RG9jdW1lbnQgfHwgalF1ZXJ5Lm1lcmdlKCBbXSwgZWxlbS5jaGlsZE5vZGVzICk7XG5cdH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBmbiApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggdW50aWwsIHNlbGVjdG9yICkge1xuXHRcdHZhciBtYXRjaGVkID0galF1ZXJ5Lm1hcCggdGhpcywgZm4sIHVudGlsICk7XG5cblx0XHRpZiAoIG5hbWUuc2xpY2UoIC01ICkgIT09IFwiVW50aWxcIiApIHtcblx0XHRcdHNlbGVjdG9yID0gdW50aWw7XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxlY3RvciAmJiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRtYXRjaGVkID0galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIG1hdGNoZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGR1cGxpY2F0ZXNcblx0XHRcdGlmICggIWd1YXJhbnRlZWRVbmlxdWVbIG5hbWUgXSApIHtcblx0XHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV2ZXJzZSBvcmRlciBmb3IgcGFyZW50cyogYW5kIHByZXYtZGVyaXZhdGl2ZXNcblx0XHRcdGlmICggcnBhcmVudHNwcmV2LnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdFx0bWF0Y2hlZC5yZXZlcnNlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkICk7XG5cdH07XG59ICk7XG52YXIgcm5vdGh0bWx3aGl0ZSA9ICggL1teXFx4MjBcXHRcXHJcXG5cXGZdKy9nICk7XG5cblxuXG4vLyBDb252ZXJ0IFN0cmluZy1mb3JtYXR0ZWQgb3B0aW9ucyBpbnRvIE9iamVjdC1mb3JtYXR0ZWQgb25lc1xuZnVuY3Rpb24gY3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIHtcblx0dmFyIG9iamVjdCA9IHt9O1xuXHRqUXVlcnkuZWFjaCggb3B0aW9ucy5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdLCBmdW5jdGlvbiggXywgZmxhZyApIHtcblx0XHRvYmplY3RbIGZsYWcgXSA9IHRydWU7XG5cdH0gKTtcblx0cmV0dXJuIG9iamVjdDtcbn1cblxuLypcbiAqIENyZWF0ZSBhIGNhbGxiYWNrIGxpc3QgdXNpbmcgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICpcbiAqXHRvcHRpb25zOiBhbiBvcHRpb25hbCBsaXN0IG9mIHNwYWNlLXNlcGFyYXRlZCBvcHRpb25zIHRoYXQgd2lsbCBjaGFuZ2UgaG93XG4gKlx0XHRcdHRoZSBjYWxsYmFjayBsaXN0IGJlaGF2ZXMgb3IgYSBtb3JlIHRyYWRpdGlvbmFsIG9wdGlvbiBvYmplY3RcbiAqXG4gKiBCeSBkZWZhdWx0IGEgY2FsbGJhY2sgbGlzdCB3aWxsIGFjdCBsaWtlIGFuIGV2ZW50IGNhbGxiYWNrIGxpc3QgYW5kIGNhbiBiZVxuICogXCJmaXJlZFwiIG11bHRpcGxlIHRpbWVzLlxuICpcbiAqIFBvc3NpYmxlIG9wdGlvbnM6XG4gKlxuICpcdG9uY2U6XHRcdFx0d2lsbCBlbnN1cmUgdGhlIGNhbGxiYWNrIGxpc3QgY2FuIG9ubHkgYmUgZmlyZWQgb25jZSAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHRtZW1vcnk6XHRcdFx0d2lsbCBrZWVwIHRyYWNrIG9mIHByZXZpb3VzIHZhbHVlcyBhbmQgd2lsbCBjYWxsIGFueSBjYWxsYmFjayBhZGRlZFxuICpcdFx0XHRcdFx0YWZ0ZXIgdGhlIGxpc3QgaGFzIGJlZW4gZmlyZWQgcmlnaHQgYXdheSB3aXRoIHRoZSBsYXRlc3QgXCJtZW1vcml6ZWRcIlxuICpcdFx0XHRcdFx0dmFsdWVzIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdHVuaXF1ZTpcdFx0XHR3aWxsIGVuc3VyZSBhIGNhbGxiYWNrIGNhbiBvbmx5IGJlIGFkZGVkIG9uY2UgKG5vIGR1cGxpY2F0ZSBpbiB0aGUgbGlzdClcbiAqXG4gKlx0c3RvcE9uRmFsc2U6XHRpbnRlcnJ1cHQgY2FsbGluZ3Mgd2hlbiBhIGNhbGxiYWNrIHJldHVybnMgZmFsc2VcbiAqXG4gKi9cbmpRdWVyeS5DYWxsYmFja3MgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHQvLyBDb252ZXJ0IG9wdGlvbnMgZnJvbSBTdHJpbmctZm9ybWF0dGVkIHRvIE9iamVjdC1mb3JtYXR0ZWQgaWYgbmVlZGVkXG5cdC8vICh3ZSBjaGVjayBpbiBjYWNoZSBmaXJzdClcblx0b3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiID9cblx0XHRjcmVhdGVPcHRpb25zKCBvcHRpb25zICkgOlxuXHRcdGpRdWVyeS5leHRlbmQoIHt9LCBvcHRpb25zICk7XG5cblx0dmFyIC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IGlzIGN1cnJlbnRseSBmaXJpbmdcblx0XHRmaXJpbmcsXG5cblx0XHQvLyBMYXN0IGZpcmUgdmFsdWUgZm9yIG5vbi1mb3JnZXR0YWJsZSBsaXN0c1xuXHRcdG1lbW9yeSxcblxuXHRcdC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IHdhcyBhbHJlYWR5IGZpcmVkXG5cdFx0ZmlyZWQsXG5cblx0XHQvLyBGbGFnIHRvIHByZXZlbnQgZmlyaW5nXG5cdFx0bG9ja2VkLFxuXG5cdFx0Ly8gQWN0dWFsIGNhbGxiYWNrIGxpc3Rcblx0XHRsaXN0ID0gW10sXG5cblx0XHQvLyBRdWV1ZSBvZiBleGVjdXRpb24gZGF0YSBmb3IgcmVwZWF0YWJsZSBsaXN0c1xuXHRcdHF1ZXVlID0gW10sXG5cblx0XHQvLyBJbmRleCBvZiBjdXJyZW50bHkgZmlyaW5nIGNhbGxiYWNrIChtb2RpZmllZCBieSBhZGQvcmVtb3ZlIGFzIG5lZWRlZClcblx0XHRmaXJpbmdJbmRleCA9IC0xLFxuXG5cdFx0Ly8gRmlyZSBjYWxsYmFja3Ncblx0XHRmaXJlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuZm9yY2Ugc2luZ2xlLWZpcmluZ1xuXHRcdFx0bG9ja2VkID0gb3B0aW9ucy5vbmNlO1xuXG5cdFx0XHQvLyBFeGVjdXRlIGNhbGxiYWNrcyBmb3IgYWxsIHBlbmRpbmcgZXhlY3V0aW9ucyxcblx0XHRcdC8vIHJlc3BlY3RpbmcgZmlyaW5nSW5kZXggb3ZlcnJpZGVzIGFuZCBydW50aW1lIGNoYW5nZXNcblx0XHRcdGZpcmVkID0gZmlyaW5nID0gdHJ1ZTtcblx0XHRcdGZvciAoIDsgcXVldWUubGVuZ3RoOyBmaXJpbmdJbmRleCA9IC0xICkge1xuXHRcdFx0XHRtZW1vcnkgPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0XHR3aGlsZSAoICsrZmlyaW5nSW5kZXggPCBsaXN0Lmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdC8vIFJ1biBjYWxsYmFjayBhbmQgY2hlY2sgZm9yIGVhcmx5IHRlcm1pbmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBsaXN0WyBmaXJpbmdJbmRleCBdLmFwcGx5KCBtZW1vcnlbIDAgXSwgbWVtb3J5WyAxIF0gKSA9PT0gZmFsc2UgJiZcblx0XHRcdFx0XHRcdG9wdGlvbnMuc3RvcE9uRmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEp1bXAgdG8gZW5kIGFuZCBmb3JnZXQgdGhlIGRhdGEgc28gLmFkZCBkb2Vzbid0IHJlLWZpcmVcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yZ2V0IHRoZSBkYXRhIGlmIHdlJ3JlIGRvbmUgd2l0aCBpdFxuXHRcdFx0aWYgKCAhb3B0aW9ucy5tZW1vcnkgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRmaXJpbmcgPSBmYWxzZTtcblxuXHRcdFx0Ly8gQ2xlYW4gdXAgaWYgd2UncmUgZG9uZSBmaXJpbmcgZm9yIGdvb2Rcblx0XHRcdGlmICggbG9ja2VkICkge1xuXG5cdFx0XHRcdC8vIEtlZXAgYW4gZW1wdHkgbGlzdCBpZiB3ZSBoYXZlIGRhdGEgZm9yIGZ1dHVyZSBhZGQgY2FsbHNcblx0XHRcdFx0aWYgKCBtZW1vcnkgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgdGhpcyBvYmplY3QgaXMgc3BlbnRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsaXN0ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxuXHRcdHNlbGYgPSB7XG5cblx0XHRcdC8vIEFkZCBhIGNhbGxiYWNrIG9yIGEgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MgdG8gdGhlIGxpc3Rcblx0XHRcdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblxuXHRcdFx0XHRcdC8vIElmIHdlIGhhdmUgbWVtb3J5IGZyb20gYSBwYXN0IHJ1biwgd2Ugc2hvdWxkIGZpcmUgYWZ0ZXIgYWRkaW5nXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0cXVldWUucHVzaCggbWVtb3J5ICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0KCBmdW5jdGlvbiBhZGQoIGFyZ3MgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggYXJncywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCAhb3B0aW9ucy51bmlxdWUgfHwgIXNlbGYuaGFzKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGxpc3QucHVzaCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBhcmcgJiYgYXJnLmxlbmd0aCAmJiBqUXVlcnkudHlwZSggYXJnICkgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBJbnNwZWN0IHJlY3Vyc2l2ZWx5XG5cdFx0XHRcdFx0XHRcdFx0YWRkKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH0gKSggYXJndW1lbnRzICk7XG5cblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3Rcblx0XHRcdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0dmFyIGluZGV4O1xuXHRcdFx0XHRcdHdoaWxlICggKCBpbmRleCA9IGpRdWVyeS5pbkFycmF5KCBhcmcsIGxpc3QsIGluZGV4ICkgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0bGlzdC5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRcdFx0XHRcdC8vIEhhbmRsZSBmaXJpbmcgaW5kZXhlc1xuXHRcdFx0XHRcdFx0aWYgKCBpbmRleCA8PSBmaXJpbmdJbmRleCApIHtcblx0XHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXgtLTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LlxuXHRcdFx0Ly8gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHJldHVybiB3aGV0aGVyIG9yIG5vdCBsaXN0IGhhcyBjYWxsYmFja3MgYXR0YWNoZWQuXG5cdFx0XHRoYXM6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0cmV0dXJuIGZuID9cblx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggZm4sIGxpc3QgKSA+IC0xIDpcblx0XHRcdFx0XHRsaXN0Lmxlbmd0aCA+IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XG5cdFx0XHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlIGFuZCAuYWRkXG5cdFx0XHQvLyBBYm9ydCBhbnkgY3VycmVudC9wZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdC8vIENsZWFyIGFsbCBjYWxsYmFja3MgYW5kIHZhbHVlc1xuXHRcdFx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRkaXNhYmxlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhbGlzdDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmVcblx0XHRcdC8vIEFsc28gZGlzYWJsZSAuYWRkIHVubGVzcyB3ZSBoYXZlIG1lbW9yeSAoc2luY2UgaXQgd291bGQgaGF2ZSBubyBlZmZlY3QpXG5cdFx0XHQvLyBBYm9ydCBhbnkgcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHRsb2NrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0aWYgKCAhbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0bG9ja2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhbG9ja2VkO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGNvbnRleHQgYW5kIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZVdpdGg6IGZ1bmN0aW9uKCBjb250ZXh0LCBhcmdzICkge1xuXHRcdFx0XHRpZiAoICFsb2NrZWQgKSB7XG5cdFx0XHRcdFx0YXJncyA9IGFyZ3MgfHwgW107XG5cdFx0XHRcdFx0YXJncyA9IFsgY29udGV4dCwgYXJncy5zbGljZSA/IGFyZ3Muc2xpY2UoKSA6IGFyZ3MgXTtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBhcmdzICk7XG5cdFx0XHRcdFx0aWYgKCAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIHRoZSBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzXG5cdFx0XHRmaXJlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5maXJlV2l0aCggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXG5cdFx0XHRmaXJlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWZpcmVkO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0cmV0dXJuIHNlbGY7XG59O1xuXG5cbmZ1bmN0aW9uIElkZW50aXR5KCB2ICkge1xuXHRyZXR1cm4gdjtcbn1cbmZ1bmN0aW9uIFRocm93ZXIoIGV4ICkge1xuXHR0aHJvdyBleDtcbn1cblxuZnVuY3Rpb24gYWRvcHRWYWx1ZSggdmFsdWUsIHJlc29sdmUsIHJlamVjdCApIHtcblx0dmFyIG1ldGhvZDtcblxuXHR0cnkge1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIHByb21pc2UgYXNwZWN0IGZpcnN0IHRvIHByaXZpbGVnZSBzeW5jaHJvbm91cyBiZWhhdmlvclxuXHRcdGlmICggdmFsdWUgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUucHJvbWlzZSApICkgKSB7XG5cdFx0XHRtZXRob2QuY2FsbCggdmFsdWUgKS5kb25lKCByZXNvbHZlICkuZmFpbCggcmVqZWN0ICk7XG5cblx0XHQvLyBPdGhlciB0aGVuYWJsZXNcblx0XHR9IGVsc2UgaWYgKCB2YWx1ZSAmJiBqUXVlcnkuaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS50aGVuICkgKSApIHtcblx0XHRcdG1ldGhvZC5jYWxsKCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0ICk7XG5cblx0XHQvLyBPdGhlciBub24tdGhlbmFibGVzXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgb25seVxuXHRcdFx0Ly8gU3RyaWN0IG1vZGUgZnVuY3Rpb25zIGludm9rZWQgd2l0aG91dCAuY2FsbC8uYXBwbHkgZ2V0IGdsb2JhbC1vYmplY3QgY29udGV4dFxuXHRcdFx0cmVzb2x2ZS5jYWxsKCB1bmRlZmluZWQsIHZhbHVlICk7XG5cdFx0fVxuXG5cdC8vIEZvciBQcm9taXNlcy9BKywgY29udmVydCBleGNlcHRpb25zIGludG8gcmVqZWN0aW9uc1xuXHQvLyBTaW5jZSBqUXVlcnkud2hlbiBkb2Vzbid0IHVud3JhcCB0aGVuYWJsZXMsIHdlIGNhbiBza2lwIHRoZSBleHRyYSBjaGVja3MgYXBwZWFyaW5nIGluXG5cdC8vIERlZmVycmVkI3RoZW4gdG8gY29uZGl0aW9uYWxseSBzdXBwcmVzcyByZWplY3Rpb24uXG5cdH0gY2F0Y2ggKCB2YWx1ZSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIG9ubHlcblx0XHQvLyBTdHJpY3QgbW9kZSBmdW5jdGlvbnMgaW52b2tlZCB3aXRob3V0IC5jYWxsLy5hcHBseSBnZXQgZ2xvYmFsLW9iamVjdCBjb250ZXh0XG5cdFx0cmVqZWN0LmNhbGwoIHVuZGVmaW5lZCwgdmFsdWUgKTtcblx0fVxufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0RGVmZXJyZWQ6IGZ1bmN0aW9uKCBmdW5jICkge1xuXHRcdHZhciB0dXBsZXMgPSBbXG5cblx0XHRcdFx0Ly8gYWN0aW9uLCBhZGQgbGlzdGVuZXIsIGNhbGxiYWNrcyxcblx0XHRcdFx0Ly8gLi4uIC50aGVuIGhhbmRsZXJzLCBhcmd1bWVudCBpbmRleCwgW2ZpbmFsIHN0YXRlXVxuXHRcdFx0XHRbIFwibm90aWZ5XCIsIFwicHJvZ3Jlc3NcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSwgMiBdLFxuXHRcdFx0XHRbIFwicmVzb2x2ZVwiLCBcImRvbmVcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIDAsIFwicmVzb2x2ZWRcIiBdLFxuXHRcdFx0XHRbIFwicmVqZWN0XCIsIFwiZmFpbFwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMSwgXCJyZWplY3RlZFwiIF1cblx0XHRcdF0sXG5cdFx0XHRzdGF0ZSA9IFwicGVuZGluZ1wiLFxuXHRcdFx0cHJvbWlzZSA9IHtcblx0XHRcdFx0c3RhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZTtcblx0XHRcdFx0fSxcblx0XHRcdFx0YWx3YXlzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5kb25lKCBhcmd1bWVudHMgKS5mYWlsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblx0XHRcdFx0XCJjYXRjaFwiOiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHByb21pc2UudGhlbiggbnVsbCwgZm4gKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBLZWVwIHBpcGUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdHBpcGU6IGZ1bmN0aW9uKCAvKiBmbkRvbmUsIGZuRmFpbCwgZm5Qcm9ncmVzcyAqLyApIHtcblx0XHRcdFx0XHR2YXIgZm5zID0gYXJndW1lbnRzO1xuXG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZCggZnVuY3Rpb24oIG5ld0RlZmVyICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIE1hcCB0dXBsZXMgKHByb2dyZXNzLCBkb25lLCBmYWlsKSB0byBhcmd1bWVudHMgKGRvbmUsIGZhaWwsIHByb2dyZXNzKVxuXHRcdFx0XHRcdFx0XHR2YXIgZm4gPSBqUXVlcnkuaXNGdW5jdGlvbiggZm5zWyB0dXBsZVsgNCBdIF0gKSAmJiBmbnNbIHR1cGxlWyA0IF0gXTtcblxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5wcm9ncmVzcyhmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5ub3RpZnkgfSlcblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQuZG9uZShmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZXNvbHZlIH0pXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLmZhaWwoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVqZWN0IH0pXG5cdFx0XHRcdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMSBdIF0oIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCA9IGZuICYmIGZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXR1cm5lZC5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC5wcm9taXNlKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LnByb2dyZXNzKCBuZXdEZWZlci5ub3RpZnkgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZG9uZSggbmV3RGVmZXIucmVzb2x2ZSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5mYWlsKCBuZXdEZWZlci5yZWplY3QgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXJbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmbiA/IFsgcmV0dXJuZWQgXSA6IGFyZ3VtZW50c1xuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdGZucyA9IG51bGw7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0dGhlbjogZnVuY3Rpb24oIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzICkge1xuXHRcdFx0XHRcdHZhciBtYXhEZXB0aCA9IDA7XG5cdFx0XHRcdFx0ZnVuY3Rpb24gcmVzb2x2ZSggZGVwdGgsIGRlZmVycmVkLCBoYW5kbGVyLCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0YXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQsIHRoZW47XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4zXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01OVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWdub3JlIGRvdWJsZS1yZXNvbHV0aW9uIGF0dGVtcHRzXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoIDwgbWF4RGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQgPSBoYW5kbGVyLmFwcGx5KCB0aGF0LCBhcmdzICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjFcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTQ4XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkID09PSBkZWZlcnJlZC5wcm9taXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoIFwiVGhlbmFibGUgc2VsZi1yZXNvbHV0aW9uXCIgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbnMgMi4zLjMuMSwgMy41XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01NFxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNzVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIFJldHJpZXZlIGB0aGVuYCBvbmx5IG9uY2Vcblx0XHRcdFx0XHRcdFx0XHRcdHRoZW4gPSByZXR1cm5lZCAmJlxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBjaGVjayBvYmplY3RzIGFuZCBmdW5jdGlvbnMgZm9yIHRoZW5hYmlsaXR5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggdHlwZW9mIHJldHVybmVkID09PSBcIm9iamVjdFwiIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHJldHVybmVkID09PSBcImZ1bmN0aW9uXCIgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC50aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYSByZXR1cm5lZCB0aGVuYWJsZVxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdGhlbiApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFNwZWNpYWwgcHJvY2Vzc29ycyAobm90aWZ5KSBqdXN0IHdhaXQgZm9yIHJlc29sdXRpb25cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBhbHNvIGhvb2sgaW50byBwcm9ncmVzc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIGRpc3JlZ2FyZCBvbGRlciByZXNvbHV0aW9uIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1heERlcHRoKys7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGVuLmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYWxsIG90aGVyIHJldHVybmVkIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IElkZW50aXR5ICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXJncyA9IFsgcmV0dXJuZWQgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFByb2Nlc3MgdGhlIHZhbHVlKHMpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmF1bHQgcHJvY2VzcyBpcyByZXNvbHZlXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggc3BlY2lhbCB8fCBkZWZlcnJlZC5yZXNvbHZlV2l0aCApKCB0aGF0LCBhcmdzICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgbm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGNhdGNoIGFuZCByZWplY3QgZXhjZXB0aW9uc1xuXHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MgPSBzcGVjaWFsID9cblx0XHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3cgOlxuXHRcdFx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdygpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayggZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5zdGFja1RyYWNlICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjQuMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTYxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWdub3JlIHBvc3QtcmVzb2x1dGlvbiBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCArIDEgPj0gbWF4RGVwdGggKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBoYW5kbGVyICE9PSBUaHJvd2VyICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGF0ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzID0gWyBlIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjFcblx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTdcblx0XHRcdFx0XHRcdFx0Ly8gUmUtcmVzb2x2ZSBwcm9taXNlcyBpbW1lZGlhdGVseSB0byBkb2RnZSBmYWxzZSByZWplY3Rpb24gZnJvbVxuXHRcdFx0XHRcdFx0XHQvLyBzdWJzZXF1ZW50IGVycm9yc1xuXHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENhbGwgYW4gb3B0aW9uYWwgaG9vayB0byByZWNvcmQgdGhlIHN0YWNrLCBpbiBjYXNlIG9mIGV4Y2VwdGlvblxuXHRcdFx0XHRcdFx0XHRcdC8vIHNpbmNlIGl0J3Mgb3RoZXJ3aXNlIGxvc3Qgd2hlbiBleGVjdXRpb24gZ29lcyBhc3luY1xuXHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHByb2Nlc3Muc3RhY2tUcmFjZSA9IGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIHByb2Nlc3MgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cblx0XHRcdFx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIG9uUHJvZ3Jlc3MgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvblByb2dyZXNzIDpcblx0XHRcdFx0XHRcdFx0XHRcdElkZW50aXR5LFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLm5vdGlmeVdpdGhcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMSBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIG9uRnVsZmlsbGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25GdWxmaWxsZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHlcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAyIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuaXNGdW5jdGlvbiggb25SZWplY3RlZCApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uUmVqZWN0ZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0VGhyb3dlclxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gR2V0IGEgcHJvbWlzZSBmb3IgdGhpcyBkZWZlcnJlZFxuXHRcdFx0XHQvLyBJZiBvYmogaXMgcHJvdmlkZWQsIHRoZSBwcm9taXNlIGFzcGVjdCBpcyBhZGRlZCB0byB0aGUgb2JqZWN0XG5cdFx0XHRcdHByb21pc2U6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9iaiAhPSBudWxsID8galF1ZXJ5LmV4dGVuZCggb2JqLCBwcm9taXNlICkgOiBwcm9taXNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVmZXJyZWQgPSB7fTtcblxuXHRcdC8vIEFkZCBsaXN0LXNwZWNpZmljIG1ldGhvZHNcblx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cdFx0XHR2YXIgbGlzdCA9IHR1cGxlWyAyIF0sXG5cdFx0XHRcdHN0YXRlU3RyaW5nID0gdHVwbGVbIDUgXTtcblxuXHRcdFx0Ly8gcHJvbWlzZS5wcm9ncmVzcyA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmRvbmUgPSBsaXN0LmFkZFxuXHRcdFx0Ly8gcHJvbWlzZS5mYWlsID0gbGlzdC5hZGRcblx0XHRcdHByb21pc2VbIHR1cGxlWyAxIF0gXSA9IGxpc3QuYWRkO1xuXG5cdFx0XHQvLyBIYW5kbGUgc3RhdGVcblx0XHRcdGlmICggc3RhdGVTdHJpbmcgKSB7XG5cdFx0XHRcdGxpc3QuYWRkKFxuXHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVzb2x2ZWRcIiAoaS5lLiwgZnVsZmlsbGVkKVxuXHRcdFx0XHRcdFx0Ly8gc3RhdGUgPSBcInJlamVjdGVkXCJcblx0XHRcdFx0XHRcdHN0YXRlID0gc3RhdGVTdHJpbmc7XG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdC8vIHJlamVjdGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0dHVwbGVzWyAzIC0gaSBdWyAyIF0uZGlzYWJsZSxcblxuXHRcdFx0XHRcdC8vIHByb2dyZXNzX2NhbGxiYWNrcy5sb2NrXG5cdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDIgXS5sb2NrXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmZpcmVcblx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5maXJlXG5cdFx0XHQvLyByZWplY3RlZF9oYW5kbGVycy5maXJlXG5cdFx0XHRsaXN0LmFkZCggdHVwbGVbIDMgXS5maXJlICk7XG5cblx0XHRcdC8vIGRlZmVycmVkLm5vdGlmeSA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5ub3RpZnlXaXRoKC4uLikgfVxuXHRcdFx0Ly8gZGVmZXJyZWQucmVzb2x2ZSA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5yZXNvbHZlV2l0aCguLi4pIH1cblx0XHRcdC8vIGRlZmVycmVkLnJlamVjdCA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5yZWplY3RXaXRoKC4uLikgfVxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0oIHRoaXMgPT09IGRlZmVycmVkID8gdW5kZWZpbmVkIDogdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gZGVmZXJyZWQubm90aWZ5V2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdC8vIGRlZmVycmVkLnJlc29sdmVXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0Ly8gZGVmZXJyZWQucmVqZWN0V2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSA9IGxpc3QuZmlyZVdpdGg7XG5cdFx0fSApO1xuXG5cdFx0Ly8gTWFrZSB0aGUgZGVmZXJyZWQgYSBwcm9taXNlXG5cdFx0cHJvbWlzZS5wcm9taXNlKCBkZWZlcnJlZCApO1xuXG5cdFx0Ly8gQ2FsbCBnaXZlbiBmdW5jIGlmIGFueVxuXHRcdGlmICggZnVuYyApIHtcblx0XHRcdGZ1bmMuY2FsbCggZGVmZXJyZWQsIGRlZmVycmVkICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsIGRvbmUhXG5cdFx0cmV0dXJuIGRlZmVycmVkO1xuXHR9LFxuXG5cdC8vIERlZmVycmVkIGhlbHBlclxuXHR3aGVuOiBmdW5jdGlvbiggc2luZ2xlVmFsdWUgKSB7XG5cdFx0dmFyXG5cblx0XHRcdC8vIGNvdW50IG9mIHVuY29tcGxldGVkIHN1Ym9yZGluYXRlc1xuXHRcdFx0cmVtYWluaW5nID0gYXJndW1lbnRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gY291bnQgb2YgdW5wcm9jZXNzZWQgYXJndW1lbnRzXG5cdFx0XHRpID0gcmVtYWluaW5nLFxuXG5cdFx0XHQvLyBzdWJvcmRpbmF0ZSBmdWxmaWxsbWVudCBkYXRhXG5cdFx0XHRyZXNvbHZlQ29udGV4dHMgPSBBcnJheSggaSApLFxuXHRcdFx0cmVzb2x2ZVZhbHVlcyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApLFxuXG5cdFx0XHQvLyB0aGUgbWFzdGVyIERlZmVycmVkXG5cdFx0XHRtYXN0ZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblxuXHRcdFx0Ly8gc3Vib3JkaW5hdGUgY2FsbGJhY2sgZmFjdG9yeVxuXHRcdFx0dXBkYXRlRnVuYyA9IGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdHJlc29sdmVDb250ZXh0c1sgaSBdID0gdGhpcztcblx0XHRcdFx0XHRyZXNvbHZlVmFsdWVzWyBpIF0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApIDogdmFsdWU7XG5cdFx0XHRcdFx0aWYgKCAhKCAtLXJlbWFpbmluZyApICkge1xuXHRcdFx0XHRcdFx0bWFzdGVyLnJlc29sdmVXaXRoKCByZXNvbHZlQ29udGV4dHMsIHJlc29sdmVWYWx1ZXMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXG5cdFx0Ly8gU2luZ2xlLSBhbmQgZW1wdHkgYXJndW1lbnRzIGFyZSBhZG9wdGVkIGxpa2UgUHJvbWlzZS5yZXNvbHZlXG5cdFx0aWYgKCByZW1haW5pbmcgPD0gMSApIHtcblx0XHRcdGFkb3B0VmFsdWUoIHNpbmdsZVZhbHVlLCBtYXN0ZXIuZG9uZSggdXBkYXRlRnVuYyggaSApICkucmVzb2x2ZSwgbWFzdGVyLnJlamVjdCApO1xuXG5cdFx0XHQvLyBVc2UgLnRoZW4oKSB0byB1bndyYXAgc2Vjb25kYXJ5IHRoZW5hYmxlcyAoY2YuIGdoLTMwMDApXG5cdFx0XHRpZiAoIG1hc3Rlci5zdGF0ZSgpID09PSBcInBlbmRpbmdcIiB8fFxuXHRcdFx0XHRqUXVlcnkuaXNGdW5jdGlvbiggcmVzb2x2ZVZhbHVlc1sgaSBdICYmIHJlc29sdmVWYWx1ZXNbIGkgXS50aGVuICkgKSB7XG5cblx0XHRcdFx0cmV0dXJuIG1hc3Rlci50aGVuKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gTXVsdGlwbGUgYXJndW1lbnRzIGFyZSBhZ2dyZWdhdGVkIGxpa2UgUHJvbWlzZS5hbGwgYXJyYXkgZWxlbWVudHNcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGFkb3B0VmFsdWUoIHJlc29sdmVWYWx1ZXNbIGkgXSwgdXBkYXRlRnVuYyggaSApLCBtYXN0ZXIucmVqZWN0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hc3Rlci5wcm9taXNlKCk7XG5cdH1cbn0gKTtcblxuXG4vLyBUaGVzZSB1c3VhbGx5IGluZGljYXRlIGEgcHJvZ3JhbW1lciBtaXN0YWtlIGR1cmluZyBkZXZlbG9wbWVudCxcbi8vIHdhcm4gYWJvdXQgdGhlbSBBU0FQIHJhdGhlciB0aGFuIHN3YWxsb3dpbmcgdGhlbSBieSBkZWZhdWx0LlxudmFyIHJlcnJvck5hbWVzID0gL14oRXZhbHxJbnRlcm5hbHxSYW5nZXxSZWZlcmVuY2V8U3ludGF4fFR5cGV8VVJJKUVycm9yJC87XG5cbmpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rID0gZnVuY3Rpb24oIGVycm9yLCBzdGFjayApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA4IC0gOSBvbmx5XG5cdC8vIENvbnNvbGUgZXhpc3RzIHdoZW4gZGV2IHRvb2xzIGFyZSBvcGVuLCB3aGljaCBjYW4gaGFwcGVuIGF0IGFueSB0aW1lXG5cdGlmICggd2luZG93LmNvbnNvbGUgJiYgd2luZG93LmNvbnNvbGUud2FybiAmJiBlcnJvciAmJiByZXJyb3JOYW1lcy50ZXN0KCBlcnJvci5uYW1lICkgKSB7XG5cdFx0d2luZG93LmNvbnNvbGUud2FybiggXCJqUXVlcnkuRGVmZXJyZWQgZXhjZXB0aW9uOiBcIiArIGVycm9yLm1lc3NhZ2UsIGVycm9yLnN0YWNrLCBzdGFjayApO1xuXHR9XG59O1xuXG5cblxuXG5qUXVlcnkucmVhZHlFeGNlcHRpb24gPSBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHR0aHJvdyBlcnJvcjtcblx0fSApO1xufTtcblxuXG5cblxuLy8gVGhlIGRlZmVycmVkIHVzZWQgb24gRE9NIHJlYWR5XG52YXIgcmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7XG5cbmpRdWVyeS5mbi5yZWFkeSA9IGZ1bmN0aW9uKCBmbiApIHtcblxuXHRyZWFkeUxpc3Rcblx0XHQudGhlbiggZm4gKVxuXG5cdFx0Ly8gV3JhcCBqUXVlcnkucmVhZHlFeGNlcHRpb24gaW4gYSBmdW5jdGlvbiBzbyB0aGF0IHRoZSBsb29rdXBcblx0XHQvLyBoYXBwZW5zIGF0IHRoZSB0aW1lIG9mIGVycm9yIGhhbmRsaW5nIGluc3RlYWQgb2YgY2FsbGJhY2tcblx0XHQvLyByZWdpc3RyYXRpb24uXG5cdFx0LmNhdGNoKCBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdFx0XHRqUXVlcnkucmVhZHlFeGNlcHRpb24oIGVycm9yICk7XG5cdFx0fSApO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIElzIHRoZSBET00gcmVhZHkgdG8gYmUgdXNlZD8gU2V0IHRvIHRydWUgb25jZSBpdCBvY2N1cnMuXG5cdGlzUmVhZHk6IGZhbHNlLFxuXG5cdC8vIEEgY291bnRlciB0byB0cmFjayBob3cgbWFueSBpdGVtcyB0byB3YWl0IGZvciBiZWZvcmVcblx0Ly8gdGhlIHJlYWR5IGV2ZW50IGZpcmVzLiBTZWUgIzY3ODFcblx0cmVhZHlXYWl0OiAxLFxuXG5cdC8vIEhvbGQgKG9yIHJlbGVhc2UpIHRoZSByZWFkeSBldmVudFxuXHRob2xkUmVhZHk6IGZ1bmN0aW9uKCBob2xkICkge1xuXHRcdGlmICggaG9sZCApIHtcblx0XHRcdGpRdWVyeS5yZWFkeVdhaXQrKztcblx0XHR9IGVsc2Uge1xuXHRcdFx0alF1ZXJ5LnJlYWR5KCB0cnVlICk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIEhhbmRsZSB3aGVuIHRoZSBET00gaXMgcmVhZHlcblx0cmVhZHk6IGZ1bmN0aW9uKCB3YWl0ICkge1xuXG5cdFx0Ly8gQWJvcnQgaWYgdGhlcmUgYXJlIHBlbmRpbmcgaG9sZHMgb3Igd2UncmUgYWxyZWFkeSByZWFkeVxuXHRcdGlmICggd2FpdCA9PT0gdHJ1ZSA/IC0talF1ZXJ5LnJlYWR5V2FpdCA6IGpRdWVyeS5pc1JlYWR5ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxuXHRcdGpRdWVyeS5pc1JlYWR5ID0gdHJ1ZTtcblxuXHRcdC8vIElmIGEgbm9ybWFsIERPTSBSZWFkeSBldmVudCBmaXJlZCwgZGVjcmVtZW50LCBhbmQgd2FpdCBpZiBuZWVkIGJlXG5cdFx0aWYgKCB3YWl0ICE9PSB0cnVlICYmIC0talF1ZXJ5LnJlYWR5V2FpdCA+IDAgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlcmUgYXJlIGZ1bmN0aW9ucyBib3VuZCwgdG8gZXhlY3V0ZVxuXHRcdHJlYWR5TGlzdC5yZXNvbHZlV2l0aCggZG9jdW1lbnQsIFsgalF1ZXJ5IF0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkucmVhZHkudGhlbiA9IHJlYWR5TGlzdC50aGVuO1xuXG4vLyBUaGUgcmVhZHkgZXZlbnQgaGFuZGxlciBhbmQgc2VsZiBjbGVhbnVwIG1ldGhvZFxuZnVuY3Rpb24gY29tcGxldGVkKCkge1xuXHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG5cdGpRdWVyeS5yZWFkeSgpO1xufVxuXG4vLyBDYXRjaCBjYXNlcyB3aGVyZSAkKGRvY3VtZW50KS5yZWFkeSgpIGlzIGNhbGxlZFxuLy8gYWZ0ZXIgdGhlIGJyb3dzZXIgZXZlbnQgaGFzIGFscmVhZHkgb2NjdXJyZWQuXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMCBvbmx5XG4vLyBPbGRlciBJRSBzb21ldGltZXMgc2lnbmFscyBcImludGVyYWN0aXZlXCIgdG9vIHNvb25cbmlmICggZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiIHx8XG5cdCggZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJsb2FkaW5nXCIgJiYgIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCApICkge1xuXG5cdC8vIEhhbmRsZSBpdCBhc3luY2hyb25vdXNseSB0byBhbGxvdyBzY3JpcHRzIHRoZSBvcHBvcnR1bml0eSB0byBkZWxheSByZWFkeVxuXHR3aW5kb3cuc2V0VGltZW91dCggalF1ZXJ5LnJlYWR5ICk7XG5cbn0gZWxzZSB7XG5cblx0Ly8gVXNlIHRoZSBoYW5keSBldmVudCBjYWxsYmFja1xuXHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cblx0Ly8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcblx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcbn1cblxuXG5cblxuLy8gTXVsdGlmdW5jdGlvbmFsIG1ldGhvZCB0byBnZXQgYW5kIHNldCB2YWx1ZXMgb2YgYSBjb2xsZWN0aW9uXG4vLyBUaGUgdmFsdWUvcyBjYW4gb3B0aW9uYWxseSBiZSBleGVjdXRlZCBpZiBpdCdzIGEgZnVuY3Rpb25cbnZhciBhY2Nlc3MgPSBmdW5jdGlvbiggZWxlbXMsIGZuLCBrZXksIHZhbHVlLCBjaGFpbmFibGUsIGVtcHR5R2V0LCByYXcgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBlbGVtcy5sZW5ndGgsXG5cdFx0YnVsayA9IGtleSA9PSBudWxsO1xuXG5cdC8vIFNldHMgbWFueSB2YWx1ZXNcblx0aWYgKCBqUXVlcnkudHlwZSgga2V5ICkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblx0XHRmb3IgKCBpIGluIGtleSApIHtcblx0XHRcdGFjY2VzcyggZWxlbXMsIGZuLCBpLCBrZXlbIGkgXSwgdHJ1ZSwgZW1wdHlHZXQsIHJhdyApO1xuXHRcdH1cblxuXHQvLyBTZXRzIG9uZSB2YWx1ZVxuXHR9IGVsc2UgaWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cblx0XHRpZiAoICFqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJhdyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBidWxrICkge1xuXG5cdFx0XHQvLyBCdWxrIG9wZXJhdGlvbnMgcnVuIGFnYWluc3QgdGhlIGVudGlyZSBzZXRcblx0XHRcdGlmICggcmF3ICkge1xuXHRcdFx0XHRmbi5jYWxsKCBlbGVtcywgdmFsdWUgKTtcblx0XHRcdFx0Zm4gPSBudWxsO1xuXG5cdFx0XHQvLyAuLi5leGNlcHQgd2hlbiBleGVjdXRpbmcgZnVuY3Rpb24gdmFsdWVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRidWxrID0gZm47XG5cdFx0XHRcdGZuID0gZnVuY3Rpb24oIGVsZW0sIGtleSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGJ1bGsuY2FsbCggalF1ZXJ5KCBlbGVtICksIHZhbHVlICk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRmbihcblx0XHRcdFx0XHRlbGVtc1sgaSBdLCBrZXksIHJhdyA/XG5cdFx0XHRcdFx0dmFsdWUgOlxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIGVsZW1zWyBpIF0sIGksIGZuKCBlbGVtc1sgaSBdLCBrZXkgKSApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBjaGFpbmFibGUgKSB7XG5cdFx0cmV0dXJuIGVsZW1zO1xuXHR9XG5cblx0Ly8gR2V0c1xuXHRpZiAoIGJ1bGsgKSB7XG5cdFx0cmV0dXJuIGZuLmNhbGwoIGVsZW1zICk7XG5cdH1cblxuXHRyZXR1cm4gbGVuID8gZm4oIGVsZW1zWyAwIF0sIGtleSApIDogZW1wdHlHZXQ7XG59O1xudmFyIGFjY2VwdERhdGEgPSBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0Ly8gQWNjZXB0cyBvbmx5OlxuXHQvLyAgLSBOb2RlXG5cdC8vICAgIC0gTm9kZS5FTEVNRU5UX05PREVcblx0Ly8gICAgLSBOb2RlLkRPQ1VNRU5UX05PREVcblx0Ly8gIC0gT2JqZWN0XG5cdC8vICAgIC0gQW55XG5cdHJldHVybiBvd25lci5ub2RlVHlwZSA9PT0gMSB8fCBvd25lci5ub2RlVHlwZSA9PT0gOSB8fCAhKCArb3duZXIubm9kZVR5cGUgKTtcbn07XG5cblxuXG5cbmZ1bmN0aW9uIERhdGEoKSB7XG5cdHRoaXMuZXhwYW5kbyA9IGpRdWVyeS5leHBhbmRvICsgRGF0YS51aWQrKztcbn1cblxuRGF0YS51aWQgPSAxO1xuXG5EYXRhLnByb3RvdHlwZSA9IHtcblxuXHRjYWNoZTogZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdFx0Ly8gQ2hlY2sgaWYgdGhlIG93bmVyIG9iamVjdCBhbHJlYWR5IGhhcyBhIGNhY2hlXG5cdFx0dmFyIHZhbHVlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0Ly8gSWYgbm90LCBjcmVhdGUgb25lXG5cdFx0aWYgKCAhdmFsdWUgKSB7XG5cdFx0XHR2YWx1ZSA9IHt9O1xuXG5cdFx0XHQvLyBXZSBjYW4gYWNjZXB0IGRhdGEgZm9yIG5vbi1lbGVtZW50IG5vZGVzIGluIG1vZGVybiBicm93c2Vycyxcblx0XHRcdC8vIGJ1dCB3ZSBzaG91bGQgbm90LCBzZWUgIzgzMzUuXG5cdFx0XHQvLyBBbHdheXMgcmV0dXJuIGFuIGVtcHR5IG9iamVjdC5cblx0XHRcdGlmICggYWNjZXB0RGF0YSggb3duZXIgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBpdCBpcyBhIG5vZGUgdW5saWtlbHkgdG8gYmUgc3RyaW5naWZ5LWVkIG9yIGxvb3BlZCBvdmVyXG5cdFx0XHRcdC8vIHVzZSBwbGFpbiBhc3NpZ25tZW50XG5cdFx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdmFsdWU7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHNlY3VyZSBpdCBpbiBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5XG5cdFx0XHRcdC8vIGNvbmZpZ3VyYWJsZSBtdXN0IGJlIHRydWUgdG8gYWxsb3cgdGhlIHByb3BlcnR5IHRvIGJlXG5cdFx0XHRcdC8vIGRlbGV0ZWQgd2hlbiBkYXRhIGlzIHJlbW92ZWRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIG93bmVyLCB0aGlzLmV4cGFuZG8sIHtcblx0XHRcdFx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZTtcblx0fSxcblx0c2V0OiBmdW5jdGlvbiggb3duZXIsIGRhdGEsIHZhbHVlICkge1xuXHRcdHZhciBwcm9wLFxuXHRcdFx0Y2FjaGUgPSB0aGlzLmNhY2hlKCBvd25lciApO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCBrZXksIHZhbHVlIF0gYXJnc1xuXHRcdC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1Nylcblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Y2FjaGVbIGpRdWVyeS5jYW1lbENhc2UoIGRhdGEgKSBdID0gdmFsdWU7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIHsgcHJvcGVydGllcyB9IF0gYXJnc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvcHkgdGhlIHByb3BlcnRpZXMgb25lLWJ5LW9uZSB0byB0aGUgY2FjaGUgb2JqZWN0XG5cdFx0XHRmb3IgKCBwcm9wIGluIGRhdGEgKSB7XG5cdFx0XHRcdGNhY2hlWyBqUXVlcnkuY2FtZWxDYXNlKCBwcm9wICkgXSA9IGRhdGFbIHByb3AgXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNhY2hlO1xuXHR9LFxuXHRnZXQ6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzLmNhY2hlKCBvd25lciApIDpcblxuXHRcdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdICYmIG93bmVyWyB0aGlzLmV4cGFuZG8gXVsgalF1ZXJ5LmNhbWVsQ2FzZSgga2V5ICkgXTtcblx0fSxcblx0YWNjZXNzOiBmdW5jdGlvbiggb3duZXIsIGtleSwgdmFsdWUgKSB7XG5cblx0XHQvLyBJbiBjYXNlcyB3aGVyZSBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIE5vIGtleSB3YXMgc3BlY2lmaWVkXG5cdFx0Ly8gICAyLiBBIHN0cmluZyBrZXkgd2FzIHNwZWNpZmllZCwgYnV0IG5vIHZhbHVlIHByb3ZpZGVkXG5cdFx0Ly9cblx0XHQvLyBUYWtlIHRoZSBcInJlYWRcIiBwYXRoIGFuZCBhbGxvdyB0aGUgZ2V0IG1ldGhvZCB0byBkZXRlcm1pbmVcblx0XHQvLyB3aGljaCB2YWx1ZSB0byByZXR1cm4sIHJlc3BlY3RpdmVseSBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIFRoZSBlbnRpcmUgY2FjaGUgb2JqZWN0XG5cdFx0Ly8gICAyLiBUaGUgZGF0YSBzdG9yZWQgYXQgdGhlIGtleVxuXHRcdC8vXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fFxuXHRcdFx0XHQoICgga2V5ICYmIHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgKSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmdldCggb3duZXIsIGtleSApO1xuXHRcdH1cblxuXHRcdC8vIFdoZW4gdGhlIGtleSBpcyBub3QgYSBzdHJpbmcsIG9yIGJvdGggYSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly8gYXJlIHNwZWNpZmllZCwgc2V0IG9yIGV4dGVuZCAoZXhpc3Rpbmcgb2JqZWN0cykgd2l0aCBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIEFuIG9iamVjdCBvZiBwcm9wZXJ0aWVzXG5cdFx0Ly8gICAyLiBBIGtleSBhbmQgdmFsdWVcblx0XHQvL1xuXHRcdHRoaXMuc2V0KCBvd25lciwga2V5LCB2YWx1ZSApO1xuXG5cdFx0Ly8gU2luY2UgdGhlIFwic2V0XCIgcGF0aCBjYW4gaGF2ZSB0d28gcG9zc2libGUgZW50cnkgcG9pbnRzXG5cdFx0Ly8gcmV0dXJuIHRoZSBleHBlY3RlZCBkYXRhIGJhc2VkIG9uIHdoaWNoIHBhdGggd2FzIHRha2VuWypdXG5cdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IGtleTtcblx0fSxcblx0cmVtb3ZlOiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHR2YXIgaSxcblx0XHRcdGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0aWYgKCBjYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICgga2V5ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQgYXJyYXkgb3Igc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBrZXlzXG5cdFx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCBrZXkgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBrZXkgaXMgYW4gYXJyYXkgb2Yga2V5cy4uLlxuXHRcdFx0XHQvLyBXZSBhbHdheXMgc2V0IGNhbWVsQ2FzZSBrZXlzLCBzbyByZW1vdmUgdGhhdC5cblx0XHRcdFx0a2V5ID0ga2V5Lm1hcCggalF1ZXJ5LmNhbWVsQ2FzZSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0a2V5ID0galF1ZXJ5LmNhbWVsQ2FzZSgga2V5ICk7XG5cblx0XHRcdFx0Ly8gSWYgYSBrZXkgd2l0aCB0aGUgc3BhY2VzIGV4aXN0cywgdXNlIGl0LlxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIGNyZWF0ZSBhbiBhcnJheSBieSBtYXRjaGluZyBub24td2hpdGVzcGFjZVxuXHRcdFx0XHRrZXkgPSBrZXkgaW4gY2FjaGUgP1xuXHRcdFx0XHRcdFsga2V5IF0gOlxuXHRcdFx0XHRcdCgga2V5Lm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW10gKTtcblx0XHRcdH1cblxuXHRcdFx0aSA9IGtleS5sZW5ndGg7XG5cblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRkZWxldGUgY2FjaGVbIGtleVsgaSBdIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIHRoZSBleHBhbmRvIGlmIHRoZXJlJ3Mgbm8gbW9yZSBkYXRhXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fCBqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKSApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NVxuXHRcdFx0Ly8gV2Via2l0ICYgQmxpbmsgcGVyZm9ybWFuY2Ugc3VmZmVycyB3aGVuIGRlbGV0aW5nIHByb3BlcnRpZXNcblx0XHRcdC8vIGZyb20gRE9NIG5vZGVzLCBzbyBzZXQgdG8gdW5kZWZpbmVkIGluc3RlYWRcblx0XHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM3ODYwNyAoYnVnIHJlc3RyaWN0ZWQpXG5cdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWxldGUgb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0aGFzRGF0YTogZnVuY3Rpb24oIG93bmVyICkge1xuXHRcdHZhciBjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRyZXR1cm4gY2FjaGUgIT09IHVuZGVmaW5lZCAmJiAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICk7XG5cdH1cbn07XG52YXIgZGF0YVByaXYgPSBuZXcgRGF0YSgpO1xuXG52YXIgZGF0YVVzZXIgPSBuZXcgRGF0YSgpO1xuXG5cblxuLy9cdEltcGxlbWVudGF0aW9uIFN1bW1hcnlcbi8vXG4vL1x0MS4gRW5mb3JjZSBBUEkgc3VyZmFjZSBhbmQgc2VtYW50aWMgY29tcGF0aWJpbGl0eSB3aXRoIDEuOS54IGJyYW5jaFxuLy9cdDIuIEltcHJvdmUgdGhlIG1vZHVsZSdzIG1haW50YWluYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgc3RvcmFnZVxuLy9cdFx0cGF0aHMgdG8gYSBzaW5nbGUgbWVjaGFuaXNtLlxuLy9cdDMuIFVzZSB0aGUgc2FtZSBzaW5nbGUgbWVjaGFuaXNtIHRvIHN1cHBvcnQgXCJwcml2YXRlXCIgYW5kIFwidXNlclwiIGRhdGEuXG4vL1x0NC4gX05ldmVyXyBleHBvc2UgXCJwcml2YXRlXCIgZGF0YSB0byB1c2VyIGNvZGUgKFRPRE86IERyb3AgX2RhdGEsIF9yZW1vdmVEYXRhKVxuLy9cdDUuIEF2b2lkIGV4cG9zaW5nIGltcGxlbWVudGF0aW9uIGRldGFpbHMgb24gdXNlciBvYmplY3RzIChlZy4gZXhwYW5kbyBwcm9wZXJ0aWVzKVxuLy9cdDYuIFByb3ZpZGUgYSBjbGVhciBwYXRoIGZvciBpbXBsZW1lbnRhdGlvbiB1cGdyYWRlIHRvIFdlYWtNYXAgaW4gMjAxNFxuXG52YXIgcmJyYWNlID0gL14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLFxuXHRybXVsdGlEYXNoID0gL1tBLVpdL2c7XG5cbmZ1bmN0aW9uIGdldERhdGEoIGRhdGEgKSB7XG5cdGlmICggZGF0YSA9PT0gXCJ0cnVlXCIgKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRpZiAoIGRhdGEgPT09IFwiZmFsc2VcIiApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRpZiAoIGRhdGEgPT09IFwibnVsbFwiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gT25seSBjb252ZXJ0IHRvIGEgbnVtYmVyIGlmIGl0IGRvZXNuJ3QgY2hhbmdlIHRoZSBzdHJpbmdcblx0aWYgKCBkYXRhID09PSArZGF0YSArIFwiXCIgKSB7XG5cdFx0cmV0dXJuICtkYXRhO1xuXHR9XG5cblx0aWYgKCByYnJhY2UudGVzdCggZGF0YSApICkge1xuXHRcdHJldHVybiBKU09OLnBhcnNlKCBkYXRhICk7XG5cdH1cblxuXHRyZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gZGF0YUF0dHIoIGVsZW0sIGtleSwgZGF0YSApIHtcblx0dmFyIG5hbWU7XG5cblx0Ly8gSWYgbm90aGluZyB3YXMgZm91bmQgaW50ZXJuYWxseSwgdHJ5IHRvIGZldGNoIGFueVxuXHQvLyBkYXRhIGZyb20gdGhlIEhUTUw1IGRhdGEtKiBhdHRyaWJ1dGVcblx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRuYW1lID0gXCJkYXRhLVwiICsga2V5LnJlcGxhY2UoIHJtdWx0aURhc2gsIFwiLSQmXCIgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdGRhdGEgPSBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApO1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGRhdGEgPSBnZXREYXRhKCBkYXRhICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHt9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGRhdGEgc28gaXQgaXNuJ3QgY2hhbmdlZCBsYXRlclxuXHRcdFx0ZGF0YVVzZXIuc2V0KCBlbGVtLCBrZXksIGRhdGEgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGRhdGE7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aGFzRGF0YTogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmhhc0RhdGEoIGVsZW0gKSB8fCBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICk7XG5cdH0sXG5cblx0ZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFVc2VyLnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9LFxuXG5cdC8vIFRPRE86IE5vdyB0aGF0IGFsbCBjYWxscyB0byBfZGF0YSBhbmQgX3JlbW92ZURhdGEgaGF2ZSBiZWVuIHJlcGxhY2VkXG5cdC8vIHdpdGggZGlyZWN0IGNhbGxzIHRvIGRhdGFQcml2IG1ldGhvZHMsIHRoZXNlIGNhbiBiZSBkZXByZWNhdGVkLlxuXHRfZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdF9yZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRhdGE6IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBpLCBuYW1lLCBkYXRhLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdGF0dHJzID0gZWxlbSAmJiBlbGVtLmF0dHJpYnV0ZXM7XG5cblx0XHQvLyBHZXRzIGFsbCB2YWx1ZXNcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB0aGlzLmxlbmd0aCApIHtcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSApO1xuXG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAhZGF0YVByaXYuZ2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiICkgKSB7XG5cdFx0XHRcdFx0aSA9IGF0dHJzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgMTEgb25seVxuXHRcdFx0XHRcdFx0Ly8gVGhlIGF0dHJzIGVsZW1lbnRzIGNhbiBiZSBudWxsICgjMTQ4OTQpXG5cdFx0XHRcdFx0XHRpZiAoIGF0dHJzWyBpIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG5hbWUgPSBhdHRyc1sgaSBdLm5hbWU7XG5cdFx0XHRcdFx0XHRcdGlmICggbmFtZS5pbmRleE9mKCBcImRhdGEtXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0XHRcdFx0XHRuYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZS5zbGljZSggNSApICk7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YUF0dHIoIGVsZW0sIG5hbWUsIGRhdGFbIG5hbWUgXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHRcdC8vIFNldHMgbXVsdGlwbGUgdmFsdWVzXG5cdFx0aWYgKCB0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5ICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGRhdGE7XG5cblx0XHRcdC8vIFRoZSBjYWxsaW5nIGpRdWVyeSBvYmplY3QgKGVsZW1lbnQgbWF0Y2hlcykgaXMgbm90IGVtcHR5XG5cdFx0XHQvLyAoYW5kIHRoZXJlZm9yZSBoYXMgYW4gZWxlbWVudCBhcHBlYXJzIGF0IHRoaXNbIDAgXSkgYW5kIHRoZVxuXHRcdFx0Ly8gYHZhbHVlYCBwYXJhbWV0ZXIgd2FzIG5vdCB1bmRlZmluZWQuIEFuIGVtcHR5IGpRdWVyeSBvYmplY3Rcblx0XHRcdC8vIHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGZvciBlbGVtID0gdGhpc1sgMCBdIHdoaWNoIHdpbGxcblx0XHRcdC8vIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhbiBhdHRlbXB0IHRvIHJlYWQgYSBkYXRhIGNhY2hlIGlzIG1hZGUuXG5cdFx0XHRpZiAoIGVsZW0gJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIGdldCBkYXRhIGZyb20gdGhlIGNhY2hlXG5cdFx0XHRcdC8vIFRoZSBrZXkgd2lsbCBhbHdheXMgYmUgY2FtZWxDYXNlZCBpbiBEYXRhXG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0sIGtleSApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gXCJkaXNjb3ZlclwiIHRoZSBkYXRhIGluXG5cdFx0XHRcdC8vIEhUTUw1IGN1c3RvbSBkYXRhLSogYXR0cnNcblx0XHRcdFx0ZGF0YSA9IGRhdGFBdHRyKCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBXZSB0cmllZCByZWFsbHkgaGFyZCwgYnV0IHRoZSBkYXRhIGRvZXNuJ3QgZXhpc3QuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IHRoZSBkYXRhLi4uXG5cdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIFdlIGFsd2F5cyBzdG9yZSB0aGUgY2FtZWxDYXNlZCBrZXlcblx0XHRcdFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXksIHZhbHVlICk7XG5cdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxLCBudWxsLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGtleSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRhdGFVc2VyLnJlbW92ZSggdGhpcywga2V5ICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHF1ZXVlO1xuXG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0dHlwZSA9ICggdHlwZSB8fCBcImZ4XCIgKSArIFwicXVldWVcIjtcblx0XHRcdHF1ZXVlID0gZGF0YVByaXYuZ2V0KCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdC8vIFNwZWVkIHVwIGRlcXVldWUgYnkgZ2V0dGluZyBvdXQgcXVpY2tseSBpZiB0aGlzIGlzIGp1c3QgYSBsb29rdXBcblx0XHRcdGlmICggZGF0YSApIHtcblx0XHRcdFx0aWYgKCAhcXVldWUgfHwgalF1ZXJ5LmlzQXJyYXkoIGRhdGEgKSApIHtcblx0XHRcdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgdHlwZSwgalF1ZXJ5Lm1ha2VBcnJheSggZGF0YSApICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaCggZGF0YSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcXVldWUgfHwgW107XG5cdFx0fVxuXHR9LFxuXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggZWxlbSwgdHlwZSApLFxuXHRcdFx0c3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCksXG5cdFx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgdHlwZSApLFxuXHRcdFx0bmV4dCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggZWxlbSwgdHlwZSApO1xuXHRcdFx0fTtcblxuXHRcdC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcblx0XHRpZiAoIGZuID09PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdHN0YXJ0TGVuZ3RoLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblxuXHRcdFx0Ly8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xuXHRcdFx0Ly8gYXV0b21hdGljYWxseSBkZXF1ZXVlZFxuXHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgKSB7XG5cdFx0XHRcdHF1ZXVlLnVuc2hpZnQoIFwiaW5wcm9ncmVzc1wiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0Zm4uY2FsbCggZWxlbSwgbmV4dCwgaG9va3MgKTtcblx0XHR9XG5cblx0XHRpZiAoICFzdGFydExlbmd0aCAmJiBob29rcyApIHtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gTm90IHB1YmxpYyAtIGdlbmVyYXRlIGEgcXVldWVIb29rcyBvYmplY3QsIG9yIHJldHVybiB0aGUgY3VycmVudCBvbmVcblx0X3F1ZXVlSG9va3M6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHZhciBrZXkgPSB0eXBlICsgXCJxdWV1ZUhvb2tzXCI7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmdldCggZWxlbSwga2V5ICkgfHwgZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBrZXksIHtcblx0XHRcdGVtcHR5OiBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKS5hZGQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFsgdHlwZSArIFwicXVldWVcIiwga2V5IF0gKTtcblx0XHRcdH0gKVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgc2V0dGVyID0gMjtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRkYXRhID0gdHlwZTtcblx0XHRcdHR5cGUgPSBcImZ4XCI7XG5cdFx0XHRzZXR0ZXItLTtcblx0XHR9XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPCBzZXR0ZXIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnF1ZXVlKCB0aGlzWyAwIF0sIHR5cGUgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMgOlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBkYXRhICk7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIGEgaG9va3MgZm9yIHRoaXMgcXVldWVcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgJiYgcXVldWVbIDAgXSAhPT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHR9LFxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0fSApO1xuXHR9LFxuXHRjbGVhclF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdH0sXG5cblx0Ly8gR2V0IGEgcHJvbWlzZSByZXNvbHZlZCB3aGVuIHF1ZXVlcyBvZiBhIGNlcnRhaW4gdHlwZVxuXHQvLyBhcmUgZW1wdGllZCAoZnggaXMgdGhlIHR5cGUgYnkgZGVmYXVsdClcblx0cHJvbWlzZTogZnVuY3Rpb24oIHR5cGUsIG9iaiApIHtcblx0XHR2YXIgdG1wLFxuXHRcdFx0Y291bnQgPSAxLFxuXHRcdFx0ZGVmZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGVsZW1lbnRzID0gdGhpcyxcblx0XHRcdGkgPSB0aGlzLmxlbmd0aCxcblx0XHRcdHJlc29sdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhKCAtLWNvdW50ICkgKSB7XG5cdFx0XHRcdFx0ZGVmZXIucmVzb2x2ZVdpdGgoIGVsZW1lbnRzLCBbIGVsZW1lbnRzIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRvYmogPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0bXAgPSBkYXRhUHJpdi5nZXQoIGVsZW1lbnRzWyBpIF0sIHR5cGUgKyBcInF1ZXVlSG9va3NcIiApO1xuXHRcdFx0aWYgKCB0bXAgJiYgdG1wLmVtcHR5ICkge1xuXHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHR0bXAuZW1wdHkuYWRkKCByZXNvbHZlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJlc29sdmUoKTtcblx0XHRyZXR1cm4gZGVmZXIucHJvbWlzZSggb2JqICk7XG5cdH1cbn0gKTtcbnZhciBwbnVtID0gKCAvWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLyApLnNvdXJjZTtcblxudmFyIHJjc3NOdW0gPSBuZXcgUmVnRXhwKCBcIl4oPzooWystXSk9fCkoXCIgKyBwbnVtICsgXCIpKFthLXolXSopJFwiLCBcImlcIiApO1xuXG5cbnZhciBjc3NFeHBhbmQgPSBbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIgXTtcblxudmFyIGlzSGlkZGVuV2l0aGluVHJlZSA9IGZ1bmN0aW9uKCBlbGVtLCBlbCApIHtcblxuXHRcdC8vIGlzSGlkZGVuV2l0aGluVHJlZSBtaWdodCBiZSBjYWxsZWQgZnJvbSBqUXVlcnkjZmlsdGVyIGZ1bmN0aW9uO1xuXHRcdC8vIGluIHRoYXQgY2FzZSwgZWxlbWVudCB3aWxsIGJlIHNlY29uZCBhcmd1bWVudFxuXHRcdGVsZW0gPSBlbCB8fCBlbGVtO1xuXG5cdFx0Ly8gSW5saW5lIHN0eWxlIHRydW1wcyBhbGxcblx0XHRyZXR1cm4gZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiB8fFxuXHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmXG5cblx0XHRcdC8vIE90aGVyd2lzZSwgY2hlY2sgY29tcHV0ZWQgc3R5bGVcblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MyAtIDQ1XG5cdFx0XHQvLyBEaXNjb25uZWN0ZWQgZWxlbWVudHMgY2FuIGhhdmUgY29tcHV0ZWQgZGlzcGxheTogbm9uZSwgc28gZmlyc3QgY29uZmlybSB0aGF0IGVsZW0gaXNcblx0XHRcdC8vIGluIHRoZSBkb2N1bWVudC5cblx0XHRcdGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgJiZcblxuXHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSA9PT0gXCJub25lXCI7XG5cdH07XG5cbnZhciBzd2FwID0gZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGNhbGxiYWNrLCBhcmdzICkge1xuXHR2YXIgcmV0LCBuYW1lLFxuXHRcdG9sZCA9IHt9O1xuXG5cdC8vIFJlbWVtYmVyIHRoZSBvbGQgdmFsdWVzLCBhbmQgaW5zZXJ0IHRoZSBuZXcgb25lc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0b2xkWyBuYW1lIF0gPSBlbGVtLnN0eWxlWyBuYW1lIF07XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb3B0aW9uc1sgbmFtZSBdO1xuXHR9XG5cblx0cmV0ID0gY2FsbGJhY2suYXBwbHkoIGVsZW0sIGFyZ3MgfHwgW10gKTtcblxuXHQvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9sZFsgbmFtZSBdO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn07XG5cblxuXG5cbmZ1bmN0aW9uIGFkanVzdENTUyggZWxlbSwgcHJvcCwgdmFsdWVQYXJ0cywgdHdlZW4gKSB7XG5cdHZhciBhZGp1c3RlZCxcblx0XHRzY2FsZSA9IDEsXG5cdFx0bWF4SXRlcmF0aW9ucyA9IDIwLFxuXHRcdGN1cnJlbnRWYWx1ZSA9IHR3ZWVuID9cblx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uY3VyKCk7XG5cdFx0XHR9IDpcblx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5LmNzcyggZWxlbSwgcHJvcCwgXCJcIiApO1xuXHRcdFx0fSxcblx0XHRpbml0aWFsID0gY3VycmVudFZhbHVlKCksXG5cdFx0dW5pdCA9IHZhbHVlUGFydHMgJiYgdmFsdWVQYXJ0c1sgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApLFxuXG5cdFx0Ly8gU3RhcnRpbmcgdmFsdWUgY29tcHV0YXRpb24gaXMgcmVxdWlyZWQgZm9yIHBvdGVudGlhbCB1bml0IG1pc21hdGNoZXNcblx0XHRpbml0aWFsSW5Vbml0ID0gKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gfHwgdW5pdCAhPT0gXCJweFwiICYmICtpbml0aWFsICkgJiZcblx0XHRcdHJjc3NOdW0uZXhlYyggalF1ZXJ5LmNzcyggZWxlbSwgcHJvcCApICk7XG5cblx0aWYgKCBpbml0aWFsSW5Vbml0ICYmIGluaXRpYWxJblVuaXRbIDMgXSAhPT0gdW5pdCApIHtcblxuXHRcdC8vIFRydXN0IHVuaXRzIHJlcG9ydGVkIGJ5IGpRdWVyeS5jc3Ncblx0XHR1bml0ID0gdW5pdCB8fCBpbml0aWFsSW5Vbml0WyAzIF07XG5cblx0XHQvLyBNYWtlIHN1cmUgd2UgdXBkYXRlIHRoZSB0d2VlbiBwcm9wZXJ0aWVzIGxhdGVyIG9uXG5cdFx0dmFsdWVQYXJ0cyA9IHZhbHVlUGFydHMgfHwgW107XG5cblx0XHQvLyBJdGVyYXRpdmVseSBhcHByb3hpbWF0ZSBmcm9tIGEgbm9uemVybyBzdGFydGluZyBwb2ludFxuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbCB8fCAxO1xuXG5cdFx0ZG8ge1xuXG5cdFx0XHQvLyBJZiBwcmV2aW91cyBpdGVyYXRpb24gemVyb2VkIG91dCwgZG91YmxlIHVudGlsIHdlIGdldCAqc29tZXRoaW5nKi5cblx0XHRcdC8vIFVzZSBzdHJpbmcgZm9yIGRvdWJsaW5nIHNvIHdlIGRvbid0IGFjY2lkZW50YWxseSBzZWUgc2NhbGUgYXMgdW5jaGFuZ2VkIGJlbG93XG5cdFx0XHRzY2FsZSA9IHNjYWxlIHx8IFwiLjVcIjtcblxuXHRcdFx0Ly8gQWRqdXN0IGFuZCBhcHBseVxuXHRcdFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgLyBzY2FsZTtcblx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcblxuXHRcdC8vIFVwZGF0ZSBzY2FsZSwgdG9sZXJhdGluZyB6ZXJvIG9yIE5hTiBmcm9tIHR3ZWVuLmN1cigpXG5cdFx0Ly8gQnJlYWsgdGhlIGxvb3AgaWYgc2NhbGUgaXMgdW5jaGFuZ2VkIG9yIHBlcmZlY3QsIG9yIGlmIHdlJ3ZlIGp1c3QgaGFkIGVub3VnaC5cblx0XHR9IHdoaWxlIChcblx0XHRcdHNjYWxlICE9PSAoIHNjYWxlID0gY3VycmVudFZhbHVlKCkgLyBpbml0aWFsICkgJiYgc2NhbGUgIT09IDEgJiYgLS1tYXhJdGVyYXRpb25zXG5cdFx0KTtcblx0fVxuXG5cdGlmICggdmFsdWVQYXJ0cyApIHtcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWxJblVuaXQgfHwgK2luaXRpYWwgfHwgMDtcblxuXHRcdC8vIEFwcGx5IHJlbGF0aXZlIG9mZnNldCAoKz0vLT0pIGlmIHNwZWNpZmllZFxuXHRcdGFkanVzdGVkID0gdmFsdWVQYXJ0c1sgMSBdID9cblx0XHRcdGluaXRpYWxJblVuaXQgKyAoIHZhbHVlUGFydHNbIDEgXSArIDEgKSAqIHZhbHVlUGFydHNbIDIgXSA6XG5cdFx0XHQrdmFsdWVQYXJ0c1sgMiBdO1xuXHRcdGlmICggdHdlZW4gKSB7XG5cdFx0XHR0d2Vlbi51bml0ID0gdW5pdDtcblx0XHRcdHR3ZWVuLnN0YXJ0ID0gaW5pdGlhbEluVW5pdDtcblx0XHRcdHR3ZWVuLmVuZCA9IGFkanVzdGVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gYWRqdXN0ZWQ7XG59XG5cblxudmFyIGRlZmF1bHREaXNwbGF5TWFwID0ge307XG5cbmZ1bmN0aW9uIGdldERlZmF1bHREaXNwbGF5KCBlbGVtICkge1xuXHR2YXIgdGVtcCxcblx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQsXG5cdFx0bm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLFxuXHRcdGRpc3BsYXkgPSBkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXTtcblxuXHRpZiAoIGRpc3BsYXkgKSB7XG5cdFx0cmV0dXJuIGRpc3BsYXk7XG5cdH1cblxuXHR0ZW1wID0gZG9jLmJvZHkuYXBwZW5kQ2hpbGQoIGRvYy5jcmVhdGVFbGVtZW50KCBub2RlTmFtZSApICk7XG5cdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCB0ZW1wLCBcImRpc3BsYXlcIiApO1xuXG5cdHRlbXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggdGVtcCApO1xuXG5cdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0ZGlzcGxheSA9IFwiYmxvY2tcIjtcblx0fVxuXHRkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXSA9IGRpc3BsYXk7XG5cblx0cmV0dXJuIGRpc3BsYXk7XG59XG5cbmZ1bmN0aW9uIHNob3dIaWRlKCBlbGVtZW50cywgc2hvdyApIHtcblx0dmFyIGRpc3BsYXksIGVsZW0sXG5cdFx0dmFsdWVzID0gW10sXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcblxuXHQvLyBEZXRlcm1pbmUgbmV3IGRpc3BsYXkgdmFsdWUgZm9yIGVsZW1lbnRzIHRoYXQgbmVlZCB0byBjaGFuZ2Vcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGRpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXk7XG5cdFx0aWYgKCBzaG93ICkge1xuXG5cdFx0XHQvLyBTaW5jZSB3ZSBmb3JjZSB2aXNpYmlsaXR5IHVwb24gY2FzY2FkZS1oaWRkZW4gZWxlbWVudHMsIGFuIGltbWVkaWF0ZSAoYW5kIHNsb3cpXG5cdFx0XHQvLyBjaGVjayBpcyByZXF1aXJlZCBpbiB0aGlzIGZpcnN0IGxvb3AgdW5sZXNzIHdlIGhhdmUgYSBub25lbXB0eSBkaXNwbGF5IHZhbHVlIChlaXRoZXJcblx0XHRcdC8vIGlubGluZSBvciBhYm91dC10by1iZS1yZXN0b3JlZClcblx0XHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJkaXNwbGF5XCIgKSB8fCBudWxsO1xuXHRcdFx0XHRpZiAoICF2YWx1ZXNbIGluZGV4IF0gKSB7XG5cdFx0XHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICkgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGdldERlZmF1bHREaXNwbGF5KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggZGlzcGxheSAhPT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IFwibm9uZVwiO1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHdoYXQgd2UncmUgb3ZlcndyaXRpbmdcblx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImRpc3BsYXlcIiwgZGlzcGxheSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFNldCB0aGUgZGlzcGxheSBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcCB0byBhdm9pZCBjb25zdGFudCByZWZsb3dcblx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoIHZhbHVlc1sgaW5kZXggXSAhPSBudWxsICkge1xuXHRcdFx0ZWxlbWVudHNbIGluZGV4IF0uc3R5bGUuZGlzcGxheSA9IHZhbHVlc1sgaW5kZXggXTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudHM7XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2hvdzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzLCB0cnVlICk7XG5cdH0sXG5cdGhpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcyApO1xuXHR9LFxuXHR0b2dnbGU6IGZ1bmN0aW9uKCBzdGF0ZSApIHtcblx0XHRpZiAoIHR5cGVvZiBzdGF0ZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGUgPyB0aGlzLnNob3coKSA6IHRoaXMuaGlkZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBpc0hpZGRlbldpdGhpblRyZWUoIHRoaXMgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuc2hvdygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xudmFyIHJjaGVja2FibGVUeXBlID0gKCAvXig/OmNoZWNrYm94fHJhZGlvKSQvaSApO1xuXG52YXIgcnRhZ05hbWUgPSAoIC88KFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKykvaSApO1xuXG52YXIgcnNjcmlwdFR5cGUgPSAoIC9eJHxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2kgKTtcblxuXG5cbi8vIFdlIGhhdmUgdG8gY2xvc2UgdGhlc2UgdGFncyB0byBzdXBwb3J0IFhIVE1MICgjMTMyMDApXG52YXIgd3JhcE1hcCA9IHtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRvcHRpb246IFsgMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCIgXSxcblxuXHQvLyBYSFRNTCBwYXJzZXJzIGRvIG5vdCBtYWdpY2FsbHkgaW5zZXJ0IGVsZW1lbnRzIGluIHRoZVxuXHQvLyBzYW1lIHdheSB0aGF0IHRhZyBzb3VwIHBhcnNlcnMgZG8uIFNvIHdlIGNhbm5vdCBzaG9ydGVuXG5cdC8vIHRoaXMgYnkgb21pdHRpbmcgPHRib2R5PiBvciBvdGhlciByZXF1aXJlZCBlbGVtZW50cy5cblx0dGhlYWQ6IFsgMSwgXCI8dGFibGU+XCIsIFwiPC90YWJsZT5cIiBdLFxuXHRjb2w6IFsgMiwgXCI8dGFibGU+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIiBdLFxuXHR0cjogWyAyLCBcIjx0YWJsZT48dGJvZHk+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiIF0sXG5cdHRkOiBbIDMsIFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsIFwiPC90cj48L3Rib2R5PjwvdGFibGU+XCIgXSxcblxuXHRfZGVmYXVsdDogWyAwLCBcIlwiLCBcIlwiIF1cbn07XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG53cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb247XG5cbndyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XG53cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcblxuXG5mdW5jdGlvbiBnZXRBbGwoIGNvbnRleHQsIHRhZyApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFVzZSB0eXBlb2YgdG8gYXZvaWQgemVyby1hcmd1bWVudCBtZXRob2QgaW52b2NhdGlvbiBvbiBob3N0IG9iamVjdHMgKCMxNTE1MSlcblx0dmFyIHJldDtcblxuXHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdHJldCA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyB8fCBcIipcIiApO1xuXG5cdH0gZWxzZSBpZiAoIHR5cGVvZiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0cmV0ID0gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgfHwgXCIqXCIgKTtcblxuXHR9IGVsc2Uge1xuXHRcdHJldCA9IFtdO1xuXHR9XG5cblx0aWYgKCB0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgalF1ZXJ5Lm5vZGVOYW1lKCBjb250ZXh0LCB0YWcgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbIGNvbnRleHQgXSwgcmV0ICk7XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufVxuXG5cbi8vIE1hcmsgc2NyaXB0cyBhcyBoYXZpbmcgYWxyZWFkeSBiZWVuIGV2YWx1YXRlZFxuZnVuY3Rpb24gc2V0R2xvYmFsRXZhbCggZWxlbXMsIHJlZkVsZW1lbnRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZGF0YVByaXYuc2V0KFxuXHRcdFx0ZWxlbXNbIGkgXSxcblx0XHRcdFwiZ2xvYmFsRXZhbFwiLFxuXHRcdFx0IXJlZkVsZW1lbnRzIHx8IGRhdGFQcml2LmdldCggcmVmRWxlbWVudHNbIGkgXSwgXCJnbG9iYWxFdmFsXCIgKVxuXHRcdCk7XG5cdH1cbn1cblxuXG52YXIgcmh0bWwgPSAvPHwmIz9cXHcrOy87XG5cbmZ1bmN0aW9uIGJ1aWxkRnJhZ21lbnQoIGVsZW1zLCBjb250ZXh0LCBzY3JpcHRzLCBzZWxlY3Rpb24sIGlnbm9yZWQgKSB7XG5cdHZhciBlbGVtLCB0bXAsIHRhZywgd3JhcCwgY29udGFpbnMsIGosXG5cdFx0ZnJhZ21lbnQgPSBjb250ZXh0LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRub2RlcyA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGVsZW0gPSBlbGVtc1sgaSBdO1xuXG5cdFx0aWYgKCBlbGVtIHx8IGVsZW0gPT09IDAgKSB7XG5cblx0XHRcdC8vIEFkZCBub2RlcyBkaXJlY3RseVxuXHRcdFx0aWYgKCBqUXVlcnkudHlwZSggZWxlbSApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIGVsZW0ubm9kZVR5cGUgPyBbIGVsZW0gXSA6IGVsZW0gKTtcblxuXHRcdFx0Ly8gQ29udmVydCBub24taHRtbCBpbnRvIGEgdGV4dCBub2RlXG5cdFx0XHR9IGVsc2UgaWYgKCAhcmh0bWwudGVzdCggZWxlbSApICkge1xuXHRcdFx0XHRub2Rlcy5wdXNoKCBjb250ZXh0LmNyZWF0ZVRleHROb2RlKCBlbGVtICkgKTtcblxuXHRcdFx0Ly8gQ29udmVydCBodG1sIGludG8gRE9NIG5vZGVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0bXAgPSB0bXAgfHwgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICk7XG5cblx0XHRcdFx0Ly8gRGVzZXJpYWxpemUgYSBzdGFuZGFyZCByZXByZXNlbnRhdGlvblxuXHRcdFx0XHR0YWcgPSAoIHJ0YWdOYW1lLmV4ZWMoIGVsZW0gKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0d3JhcCA9IHdyYXBNYXBbIHRhZyBdIHx8IHdyYXBNYXAuX2RlZmF1bHQ7XG5cdFx0XHRcdHRtcC5pbm5lckhUTUwgPSB3cmFwWyAxIF0gKyBqUXVlcnkuaHRtbFByZWZpbHRlciggZWxlbSApICsgd3JhcFsgMiBdO1xuXG5cdFx0XHRcdC8vIERlc2NlbmQgdGhyb3VnaCB3cmFwcGVycyB0byB0aGUgcmlnaHQgY29udGVudFxuXHRcdFx0XHRqID0gd3JhcFsgMCBdO1xuXHRcdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0XHR0bXAgPSB0bXAubGFzdENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgdG1wLmNoaWxkTm9kZXMgKTtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB0aGUgdG9wLWxldmVsIGNvbnRhaW5lclxuXHRcdFx0XHR0bXAgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSB0aGUgY3JlYXRlZCBub2RlcyBhcmUgb3JwaGFuZWQgKCMxMjM5Milcblx0XHRcdFx0dG1wLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZW1vdmUgd3JhcHBlciBmcm9tIGZyYWdtZW50XG5cdGZyYWdtZW50LnRleHRDb250ZW50ID0gXCJcIjtcblxuXHRpID0gMDtcblx0d2hpbGUgKCAoIGVsZW0gPSBub2Rlc1sgaSsrIF0gKSApIHtcblxuXHRcdC8vIFNraXAgZWxlbWVudHMgYWxyZWFkeSBpbiB0aGUgY29udGV4dCBjb2xsZWN0aW9uICh0cmFjLTQwODcpXG5cdFx0aWYgKCBzZWxlY3Rpb24gJiYgalF1ZXJ5LmluQXJyYXkoIGVsZW0sIHNlbGVjdGlvbiApID4gLTEgKSB7XG5cdFx0XHRpZiAoIGlnbm9yZWQgKSB7XG5cdFx0XHRcdGlnbm9yZWQucHVzaCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0Y29udGFpbnMgPSBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXG5cdFx0Ly8gQXBwZW5kIHRvIGZyYWdtZW50XG5cdFx0dG1wID0gZ2V0QWxsKCBmcmFnbWVudC5hcHBlbmRDaGlsZCggZWxlbSApLCBcInNjcmlwdFwiICk7XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0aWYgKCBjb250YWlucyApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIHRtcCApO1xuXHRcdH1cblxuXHRcdC8vIENhcHR1cmUgZXhlY3V0YWJsZXNcblx0XHRpZiAoIHNjcmlwdHMgKSB7XG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gdG1wWyBqKysgXSApICkge1xuXHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIGVsZW0udHlwZSB8fCBcIlwiICkgKSB7XG5cdFx0XHRcdFx0c2NyaXB0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZnJhZ21lbnQ7XG59XG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdGRpdiA9IGZyYWdtZW50LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKSxcblx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHlcblx0Ly8gQ2hlY2sgc3RhdGUgbG9zdCBpZiB0aGUgbmFtZSBpcyBzZXQgKCMxMTIxNylcblx0Ly8gU3VwcG9ydDogV2luZG93cyBXZWIgQXBwcyAoV1dBKVxuXHQvLyBgbmFtZWAgYW5kIGB0eXBlYCBtdXN0IHVzZSAuc2V0QXR0cmlidXRlIGZvciBXV0EgKCMxNDkwMSlcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJyYWRpb1wiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJjaGVja2VkXCIsIFwiY2hlY2tlZFwiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwidFwiICk7XG5cblx0ZGl2LmFwcGVuZENoaWxkKCBpbnB1dCApO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjEgb25seVxuXHQvLyBPbGRlciBXZWJLaXQgZG9lc24ndCBjbG9uZSBjaGVja2VkIHN0YXRlIGNvcnJlY3RseSBpbiBmcmFnbWVudHNcblx0c3VwcG9ydC5jaGVja0Nsb25lID0gZGl2LmNsb25lTm9kZSggdHJ1ZSApLmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5jaGVja2VkO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBNYWtlIHN1cmUgdGV4dGFyZWEgKGFuZCBjaGVja2JveCkgZGVmYXVsdFZhbHVlIGlzIHByb3Blcmx5IGNsb25lZFxuXHRkaXYuaW5uZXJIVE1MID0gXCI8dGV4dGFyZWE+eDwvdGV4dGFyZWE+XCI7XG5cdHN1cHBvcnQubm9DbG9uZUNoZWNrZWQgPSAhIWRpdi5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuZGVmYXVsdFZhbHVlO1xufSApKCk7XG52YXIgZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cblxudmFyXG5cdHJrZXlFdmVudCA9IC9ea2V5Lyxcblx0cm1vdXNlRXZlbnQgPSAvXig/Om1vdXNlfHBvaW50ZXJ8Y29udGV4dG1lbnV8ZHJhZ3xkcm9wKXxjbGljay8sXG5cdHJ0eXBlbmFtZXNwYWNlID0gL14oW14uXSopKD86XFwuKC4rKXwpLztcblxuZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcblx0cmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJldHVybkZhbHNlKCkge1xuXHRyZXR1cm4gZmFsc2U7XG59XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4vLyBTZWUgIzEzMzkzIGZvciBtb3JlIGluZm9cbmZ1bmN0aW9uIHNhZmVBY3RpdmVFbGVtZW50KCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXHR9IGNhdGNoICggZXJyICkgeyB9XG59XG5cbmZ1bmN0aW9uIG9uKCBlbGVtLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCBvbmUgKSB7XG5cdHZhciBvcmlnRm4sIHR5cGU7XG5cblx0Ly8gVHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXG5cdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gKCB0eXBlcy1PYmplY3QsIHNlbGVjdG9yLCBkYXRhIClcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1PYmplY3QsIGRhdGEgKVxuXHRcdFx0ZGF0YSA9IGRhdGEgfHwgc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdG9uKCBlbGVtLCB0eXBlLCBzZWxlY3RvciwgZGF0YSwgdHlwZXNbIHR5cGUgXSwgb25lICk7XG5cdFx0fVxuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBkYXRhID09IG51bGwgJiYgZm4gPT0gbnVsbCApIHtcblxuXHRcdC8vICggdHlwZXMsIGZuIClcblx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdGRhdGEgPSBzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmICggZm4gPT0gbnVsbCApIHtcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgc2VsZWN0b3IsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgZGF0YSwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdH0gZWxzZSBpZiAoICFmbiApIHtcblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggb25lID09PSAxICkge1xuXHRcdG9yaWdGbiA9IGZuO1xuXHRcdGZuID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHQvLyBDYW4gdXNlIGFuIGVtcHR5IHNldCwgc2luY2UgZXZlbnQgY29udGFpbnMgdGhlIGluZm9cblx0XHRcdGpRdWVyeSgpLm9mZiggZXZlbnQgKTtcblx0XHRcdHJldHVybiBvcmlnRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH07XG5cblx0XHQvLyBVc2Ugc2FtZSBndWlkIHNvIGNhbGxlciBjYW4gcmVtb3ZlIHVzaW5nIG9yaWdGblxuXHRcdGZuLmd1aWQgPSBvcmlnRm4uZ3VpZCB8fCAoIG9yaWdGbi5ndWlkID0galF1ZXJ5Lmd1aWQrKyApO1xuXHR9XG5cdHJldHVybiBlbGVtLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIHR5cGVzLCBmbiwgZGF0YSwgc2VsZWN0b3IgKTtcblx0fSApO1xufVxuXG4vKlxuICogSGVscGVyIGZ1bmN0aW9ucyBmb3IgbWFuYWdpbmcgZXZlbnRzIC0tIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgaW50ZXJmYWNlLlxuICogUHJvcHMgdG8gRGVhbiBFZHdhcmRzJyBhZGRFdmVudCBsaWJyYXJ5IGZvciBtYW55IG9mIHRoZSBpZGVhcy5cbiAqL1xualF1ZXJ5LmV2ZW50ID0ge1xuXG5cdGdsb2JhbDoge30sXG5cblx0YWRkOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIGRhdGEsIHNlbGVjdG9yICkge1xuXG5cdFx0dmFyIGhhbmRsZU9iakluLCBldmVudEhhbmRsZSwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0Ly8gRG9uJ3QgYXR0YWNoIGV2ZW50cyB0byBub0RhdGEgb3IgdGV4dC9jb21tZW50IG5vZGVzIChidXQgYWxsb3cgcGxhaW4gb2JqZWN0cylcblx0XHRpZiAoICFlbGVtRGF0YSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYW4gb2JqZWN0IG9mIGN1c3RvbSBkYXRhIGluIGxpZXUgb2YgdGhlIGhhbmRsZXJcblx0XHRpZiAoIGhhbmRsZXIuaGFuZGxlciApIHtcblx0XHRcdGhhbmRsZU9iakluID0gaGFuZGxlcjtcblx0XHRcdGhhbmRsZXIgPSBoYW5kbGVPYmpJbi5oYW5kbGVyO1xuXHRcdFx0c2VsZWN0b3IgPSBoYW5kbGVPYmpJbi5zZWxlY3Rvcjtcblx0XHR9XG5cblx0XHQvLyBFbnN1cmUgdGhhdCBpbnZhbGlkIHNlbGVjdG9ycyB0aHJvdyBleGNlcHRpb25zIGF0IGF0dGFjaCB0aW1lXG5cdFx0Ly8gRXZhbHVhdGUgYWdhaW5zdCBkb2N1bWVudEVsZW1lbnQgaW4gY2FzZSBlbGVtIGlzIGEgbm9uLWVsZW1lbnQgbm9kZSAoZS5nLiwgZG9jdW1lbnQpXG5cdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZG9jdW1lbnRFbGVtZW50LCBzZWxlY3RvciApO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBoYW5kbGVyIGhhcyBhIHVuaXF1ZSBJRCwgdXNlZCB0byBmaW5kL3JlbW92ZSBpdCBsYXRlclxuXHRcdGlmICggIWhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdGhhbmRsZXIuZ3VpZCA9IGpRdWVyeS5ndWlkKys7XG5cdFx0fVxuXG5cdFx0Ly8gSW5pdCB0aGUgZWxlbWVudCdzIGV2ZW50IHN0cnVjdHVyZSBhbmQgbWFpbiBoYW5kbGVyLCBpZiB0aGlzIGlzIHRoZSBmaXJzdFxuXHRcdGlmICggISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgPSB7fTtcblx0XHR9XG5cdFx0aWYgKCAhKCBldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSApICkge1xuXHRcdFx0ZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgPSBmdW5jdGlvbiggZSApIHtcblxuXHRcdFx0XHQvLyBEaXNjYXJkIHRoZSBzZWNvbmQgZXZlbnQgb2YgYSBqUXVlcnkuZXZlbnQudHJpZ2dlcigpIGFuZFxuXHRcdFx0XHQvLyB3aGVuIGFuIGV2ZW50IGlzIGNhbGxlZCBhZnRlciBhIHBhZ2UgaGFzIHVubG9hZGVkXG5cdFx0XHRcdHJldHVybiB0eXBlb2YgalF1ZXJ5ICE9PSBcInVuZGVmaW5lZFwiICYmIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgIT09IGUudHlwZSA/XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmRpc3BhdGNoLmFwcGx5KCBlbGVtLCBhcmd1bWVudHMgKSA6IHVuZGVmaW5lZDtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gSGFuZGxlIG11bHRpcGxlIGV2ZW50cyBzZXBhcmF0ZWQgYnkgYSBzcGFjZVxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBUaGVyZSAqbXVzdCogYmUgYSB0eXBlLCBubyBhdHRhY2hpbmcgbmFtZXNwYWNlLW9ubHkgaGFuZGxlcnNcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBldmVudCBjaGFuZ2VzIGl0cyB0eXBlLCB1c2UgdGhlIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBjaGFuZ2VkIHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBJZiBzZWxlY3RvciBkZWZpbmVkLCBkZXRlcm1pbmUgc3BlY2lhbCBldmVudCBhcGkgdHlwZSwgb3RoZXJ3aXNlIGdpdmVuIHR5cGVcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblxuXHRcdFx0Ly8gVXBkYXRlIHNwZWNpYWwgYmFzZWQgb24gbmV3bHkgcmVzZXQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIGhhbmRsZU9iaiBpcyBwYXNzZWQgdG8gYWxsIGV2ZW50IGhhbmRsZXJzXG5cdFx0XHRoYW5kbGVPYmogPSBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdG9yaWdUeXBlOiBvcmlnVHlwZSxcblx0XHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdFx0aGFuZGxlcjogaGFuZGxlcixcblx0XHRcdFx0Z3VpZDogaGFuZGxlci5ndWlkLFxuXHRcdFx0XHRzZWxlY3Rvcjogc2VsZWN0b3IsXG5cdFx0XHRcdG5lZWRzQ29udGV4dDogc2VsZWN0b3IgJiYgalF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICksXG5cdFx0XHRcdG5hbWVzcGFjZTogbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApXG5cdFx0XHR9LCBoYW5kbGVPYmpJbiApO1xuXG5cdFx0XHQvLyBJbml0IHRoZSBldmVudCBoYW5kbGVyIHF1ZXVlIGlmIHdlJ3JlIHRoZSBmaXJzdFxuXHRcdFx0aWYgKCAhKCBoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdICkgKSB7XG5cdFx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gPSBbXTtcblx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudCA9IDA7XG5cblx0XHRcdFx0Ly8gT25seSB1c2UgYWRkRXZlbnRMaXN0ZW5lciBpZiB0aGUgc3BlY2lhbCBldmVudHMgaGFuZGxlciByZXR1cm5zIGZhbHNlXG5cdFx0XHRcdGlmICggIXNwZWNpYWwuc2V0dXAgfHxcblx0XHRcdFx0XHRzcGVjaWFsLnNldHVwLmNhbGwoIGVsZW0sIGRhdGEsIG5hbWVzcGFjZXMsIGV2ZW50SGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtLmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIGV2ZW50SGFuZGxlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggc3BlY2lhbC5hZGQgKSB7XG5cdFx0XHRcdHNwZWNpYWwuYWRkLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXG5cdFx0XHRcdGlmICggIWhhbmRsZU9iai5oYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCA9IGhhbmRsZXIuZ3VpZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udFxuXHRcdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50KyssIDAsIGhhbmRsZU9iaiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnRzIGhhdmUgZXZlciBiZWVuIHVzZWQsIGZvciBldmVudCBvcHRpbWl6YXRpb25cblx0XHRcdGpRdWVyeS5ldmVudC5nbG9iYWxbIHR5cGUgXSA9IHRydWU7XG5cdFx0fVxuXG5cdH0sXG5cblx0Ly8gRGV0YWNoIGFuIGV2ZW50IG9yIHNldCBvZiBldmVudHMgZnJvbSBhbiBlbGVtZW50XG5cdHJlbW92ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBzZWxlY3RvciwgbWFwcGVkVHlwZXMgKSB7XG5cblx0XHR2YXIgaiwgb3JpZ0NvdW50LCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuaGFzRGF0YSggZWxlbSApICYmIGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0aWYgKCAhZWxlbURhdGEgfHwgISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gT25jZSBmb3IgZWFjaCB0eXBlLm5hbWVzcGFjZSBpbiB0eXBlczsgdHlwZSBtYXkgYmUgb21pdHRlZFxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBVbmJpbmQgYWxsIGV2ZW50cyAob24gdGhpcyBuYW1lc3BhY2UsIGlmIHByb3ZpZGVkKSBmb3IgdGhlIGVsZW1lbnRcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKyB0eXBlc1sgdCBdLCBoYW5kbGVyLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gfHwgW107XG5cdFx0XHR0bXAgPSB0bXBbIDIgXSAmJlxuXHRcdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKTtcblxuXHRcdFx0Ly8gUmVtb3ZlIG1hdGNoaW5nIGV2ZW50c1xuXHRcdFx0b3JpZ0NvdW50ID0gaiA9IGhhbmRsZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaiBdO1xuXG5cdFx0XHRcdGlmICggKCBtYXBwZWRUeXBlcyB8fCBvcmlnVHlwZSA9PT0gaGFuZGxlT2JqLm9yaWdUeXBlICkgJiZcblx0XHRcdFx0XHQoICFoYW5kbGVyIHx8IGhhbmRsZXIuZ3VpZCA9PT0gaGFuZGxlT2JqLmd1aWQgKSAmJlxuXHRcdFx0XHRcdCggIXRtcCB8fCB0bXAudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkgJiZcblx0XHRcdFx0XHQoICFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gaGFuZGxlT2JqLnNlbGVjdG9yIHx8XG5cdFx0XHRcdFx0XHRzZWxlY3RvciA9PT0gXCIqKlwiICYmIGhhbmRsZU9iai5zZWxlY3RvciApICkge1xuXHRcdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaiwgMSApO1xuXG5cdFx0XHRcdFx0aWYgKCBoYW5kbGVPYmouc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LS07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggc3BlY2lhbC5yZW1vdmUgKSB7XG5cdFx0XHRcdFx0XHRzcGVjaWFsLnJlbW92ZS5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVtb3ZlIGdlbmVyaWMgZXZlbnQgaGFuZGxlciBpZiB3ZSByZW1vdmVkIHNvbWV0aGluZyBhbmQgbm8gbW9yZSBoYW5kbGVycyBleGlzdFxuXHRcdFx0Ly8gKGF2b2lkcyBwb3RlbnRpYWwgZm9yIGVuZGxlc3MgcmVjdXJzaW9uIGR1cmluZyByZW1vdmFsIG9mIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMpXG5cdFx0XHRpZiAoIG9yaWdDb3VudCAmJiAhaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnRlYXJkb3duIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC50ZWFyZG93bi5jYWxsKCBlbGVtLCBuYW1lc3BhY2VzLCBlbGVtRGF0YS5oYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGVsZW1EYXRhLmhhbmRsZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVsZXRlIGV2ZW50c1sgdHlwZSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSBkYXRhIGFuZCB0aGUgZXhwYW5kbyBpZiBpdCdzIG5vIGxvbmdlciB1c2VkXG5cdFx0aWYgKCBqUXVlcnkuaXNFbXB0eU9iamVjdCggZXZlbnRzICkgKSB7XG5cdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiaGFuZGxlIGV2ZW50c1wiICk7XG5cdFx0fVxuXHR9LFxuXG5cdGRpc3BhdGNoOiBmdW5jdGlvbiggbmF0aXZlRXZlbnQgKSB7XG5cblx0XHQvLyBNYWtlIGEgd3JpdGFibGUgalF1ZXJ5LkV2ZW50IGZyb20gdGhlIG5hdGl2ZSBldmVudCBvYmplY3Rcblx0XHR2YXIgZXZlbnQgPSBqUXVlcnkuZXZlbnQuZml4KCBuYXRpdmVFdmVudCApO1xuXG5cdFx0dmFyIGksIGosIHJldCwgbWF0Y2hlZCwgaGFuZGxlT2JqLCBoYW5kbGVyUXVldWUsXG5cdFx0XHRhcmdzID0gbmV3IEFycmF5KCBhcmd1bWVudHMubGVuZ3RoICksXG5cdFx0XHRoYW5kbGVycyA9ICggZGF0YVByaXYuZ2V0KCB0aGlzLCBcImV2ZW50c1wiICkgfHwge30gKVsgZXZlbnQudHlwZSBdIHx8IFtdLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyBldmVudC50eXBlIF0gfHwge307XG5cblx0XHQvLyBVc2UgdGhlIGZpeC1lZCBqUXVlcnkuRXZlbnQgcmF0aGVyIHRoYW4gdGhlIChyZWFkLW9ubHkpIG5hdGl2ZSBldmVudFxuXHRcdGFyZ3NbIDAgXSA9IGV2ZW50O1xuXG5cdFx0Zm9yICggaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRhcmdzWyBpIF0gPSBhcmd1bWVudHNbIGkgXTtcblx0XHR9XG5cblx0XHRldmVudC5kZWxlZ2F0ZVRhcmdldCA9IHRoaXM7XG5cblx0XHQvLyBDYWxsIHRoZSBwcmVEaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGUsIGFuZCBsZXQgaXQgYmFpbCBpZiBkZXNpcmVkXG5cdFx0aWYgKCBzcGVjaWFsLnByZURpc3BhdGNoICYmIHNwZWNpYWwucHJlRGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGhhbmRsZXJzXG5cdFx0aGFuZGxlclF1ZXVlID0galF1ZXJ5LmV2ZW50LmhhbmRsZXJzLmNhbGwoIHRoaXMsIGV2ZW50LCBoYW5kbGVycyApO1xuXG5cdFx0Ly8gUnVuIGRlbGVnYXRlcyBmaXJzdDsgdGhleSBtYXkgd2FudCB0byBzdG9wIHByb3BhZ2F0aW9uIGJlbmVhdGggdXNcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggbWF0Y2hlZCA9IGhhbmRsZXJRdWV1ZVsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBtYXRjaGVkLmVsZW07XG5cblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGhhbmRsZU9iaiA9IG1hdGNoZWQuaGFuZGxlcnNbIGorKyBdICkgJiZcblx0XHRcdFx0IWV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cblx0XHRcdFx0Ly8gVHJpZ2dlcmVkIGV2ZW50IG11c3QgZWl0aGVyIDEpIGhhdmUgbm8gbmFtZXNwYWNlLCBvciAyKSBoYXZlIG5hbWVzcGFjZShzKVxuXHRcdFx0XHQvLyBhIHN1YnNldCBvciBlcXVhbCB0byB0aG9zZSBpbiB0aGUgYm91bmQgZXZlbnQgKGJvdGggY2FuIGhhdmUgbm8gbmFtZXNwYWNlKS5cblx0XHRcdFx0aWYgKCAhZXZlbnQucm5hbWVzcGFjZSB8fCBldmVudC5ybmFtZXNwYWNlLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApIHtcblxuXHRcdFx0XHRcdGV2ZW50LmhhbmRsZU9iaiA9IGhhbmRsZU9iajtcblx0XHRcdFx0XHRldmVudC5kYXRhID0gaGFuZGxlT2JqLmRhdGE7XG5cblx0XHRcdFx0XHRyZXQgPSAoICggalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGhhbmRsZU9iai5vcmlnVHlwZSBdIHx8IHt9ICkuaGFuZGxlIHx8XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlciApLmFwcGx5KCBtYXRjaGVkLmVsZW0sIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZXZlbnQucmVzdWx0ID0gcmV0ICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsIHRoZSBwb3N0RGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlXG5cdFx0aWYgKCBzcGVjaWFsLnBvc3REaXNwYXRjaCApIHtcblx0XHRcdHNwZWNpYWwucG9zdERpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHRoYW5kbGVyczogZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVycyApIHtcblx0XHR2YXIgaSwgaGFuZGxlT2JqLCBzZWwsIG1hdGNoZWRIYW5kbGVycywgbWF0Y2hlZFNlbGVjdG9ycyxcblx0XHRcdGhhbmRsZXJRdWV1ZSA9IFtdLFxuXHRcdFx0ZGVsZWdhdGVDb3VudCA9IGhhbmRsZXJzLmRlbGVnYXRlQ291bnQsXG5cdFx0XHRjdXIgPSBldmVudC50YXJnZXQ7XG5cblx0XHQvLyBGaW5kIGRlbGVnYXRlIGhhbmRsZXJzXG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50ICYmXG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OVxuXHRcdFx0Ly8gQmxhY2staG9sZSBTVkcgPHVzZT4gaW5zdGFuY2UgdHJlZXMgKHRyYWMtMTMxODApXG5cdFx0XHRjdXIubm9kZVR5cGUgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTQyXG5cdFx0XHQvLyBTdXBwcmVzcyBzcGVjLXZpb2xhdGluZyBjbGlja3MgaW5kaWNhdGluZyBhIG5vbi1wcmltYXJ5IHBvaW50ZXIgYnV0dG9uICh0cmFjLTM4NjEpXG5cdFx0XHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudC10eXBlLWNsaWNrXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG5cdFx0XHQvLyAuLi5idXQgbm90IGFycm93IGtleSBcImNsaWNrc1wiIG9mIHJhZGlvIGlucHV0cywgd2hpY2ggY2FuIGhhdmUgYGJ1dHRvbmAgLTEgKGdoLTIzNDMpXG5cdFx0XHQhKCBldmVudC50eXBlID09PSBcImNsaWNrXCIgJiYgZXZlbnQuYnV0dG9uID49IDEgKSApIHtcblxuXHRcdFx0Zm9yICggOyBjdXIgIT09IHRoaXM7IGN1ciA9IGN1ci5wYXJlbnROb2RlIHx8IHRoaXMgKSB7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgY2hlY2sgbm9uLWVsZW1lbnRzICgjMTMyMDgpXG5cdFx0XHRcdC8vIERvbid0IHByb2Nlc3MgY2xpY2tzIG9uIGRpc2FibGVkIGVsZW1lbnRzICgjNjkxMSwgIzgxNjUsICMxMTM4MiwgIzExNzY0KVxuXHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA9PT0gMSAmJiAhKCBldmVudC50eXBlID09PSBcImNsaWNrXCIgJiYgY3VyLmRpc2FibGVkID09PSB0cnVlICkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlZEhhbmRsZXJzID0gW107XG5cdFx0XHRcdFx0bWF0Y2hlZFNlbGVjdG9ycyA9IHt9O1xuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZGVsZWdhdGVDb3VudDsgaSsrICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGkgXTtcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKCMxMzIwMylcblx0XHRcdFx0XHRcdHNlbCA9IGhhbmRsZU9iai5zZWxlY3RvciArIFwiIFwiO1xuXG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdID0gaGFuZGxlT2JqLm5lZWRzQ29udGV4dCA/XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5KCBzZWwsIHRoaXMgKS5pbmRleCggY3VyICkgPiAtMSA6XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQoIHNlbCwgdGhpcywgbnVsbCwgWyBjdXIgXSApLmxlbmd0aDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZWRIYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVkSGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogY3VyLCBoYW5kbGVyczogbWF0Y2hlZEhhbmRsZXJzIH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBZGQgdGhlIHJlbWFpbmluZyAoZGlyZWN0bHktYm91bmQpIGhhbmRsZXJzXG5cdFx0Y3VyID0gdGhpcztcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgPCBoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBoYW5kbGVycy5zbGljZSggZGVsZWdhdGVDb3VudCApIH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaGFuZGxlclF1ZXVlO1xuXHR9LFxuXG5cdGFkZFByb3A6IGZ1bmN0aW9uKCBuYW1lLCBob29rICkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggalF1ZXJ5LkV2ZW50LnByb3RvdHlwZSwgbmFtZSwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblxuXHRcdFx0Z2V0OiBqUXVlcnkuaXNGdW5jdGlvbiggaG9vayApID9cblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBob29rKCB0aGlzLm9yaWdpbmFsRXZlbnQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gOlxuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMub3JpZ2luYWxFdmVudFsgbmFtZSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgbmFtZSwge1xuXHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGZpeDogZnVuY3Rpb24oIG9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0cmV0dXJuIG9yaWdpbmFsRXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0b3JpZ2luYWxFdmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCBvcmlnaW5hbEV2ZW50ICk7XG5cdH0sXG5cblx0c3BlY2lhbDoge1xuXHRcdGxvYWQ6IHtcblxuXHRcdFx0Ly8gUHJldmVudCB0cmlnZ2VyZWQgaW1hZ2UubG9hZCBldmVudHMgZnJvbSBidWJibGluZyB0byB3aW5kb3cubG9hZFxuXHRcdFx0bm9CdWJibGU6IHRydWVcblx0XHR9LFxuXHRcdGZvY3VzOiB7XG5cblx0XHRcdC8vIEZpcmUgbmF0aXZlIGV2ZW50IGlmIHBvc3NpYmxlIHNvIGJsdXIvZm9jdXMgc2VxdWVuY2UgaXMgY29ycmVjdFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcyAhPT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJiB0aGlzLmZvY3VzICkge1xuXHRcdFx0XHRcdHRoaXMuZm9jdXMoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNpblwiXG5cdFx0fSxcblx0XHRibHVyOiB7XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzID09PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuYmx1ciApIHtcblx0XHRcdFx0XHR0aGlzLmJsdXIoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNvdXRcIlxuXHRcdH0sXG5cdFx0Y2xpY2s6IHtcblxuXHRcdFx0Ly8gRm9yIGNoZWNrYm94LCBmaXJlIG5hdGl2ZSBldmVudCBzbyBjaGVja2VkIHN0YXRlIHdpbGwgYmUgcmlnaHRcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMudHlwZSA9PT0gXCJjaGVja2JveFwiICYmIHRoaXMuY2xpY2sgJiYgalF1ZXJ5Lm5vZGVOYW1lKCB0aGlzLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHR0aGlzLmNsaWNrKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBGb3IgY3Jvc3MtYnJvd3NlciBjb25zaXN0ZW5jeSwgZG9uJ3QgZmlyZSBuYXRpdmUgLmNsaWNrKCkgb24gbGlua3Ncblx0XHRcdF9kZWZhdWx0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkubm9kZU5hbWUoIGV2ZW50LnRhcmdldCwgXCJhXCIgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0YmVmb3JldW5sb2FkOiB7XG5cdFx0XHRwb3N0RGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDIwK1xuXHRcdFx0XHQvLyBGaXJlZm94IGRvZXNuJ3QgYWxlcnQgaWYgdGhlIHJldHVyblZhbHVlIGZpZWxkIGlzIG5vdCBzZXQuXG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgZXZlbnQub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRldmVudC5vcmlnaW5hbEV2ZW50LnJldHVyblZhbHVlID0gZXZlbnQucmVzdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiggZWxlbSwgdHlwZSwgaGFuZGxlICkge1xuXG5cdC8vIFRoaXMgXCJpZlwiIGlzIG5lZWRlZCBmb3IgcGxhaW4gb2JqZWN0c1xuXHRpZiAoIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciApIHtcblx0XHRlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIGhhbmRsZSApO1xuXHR9XG59O1xuXG5qUXVlcnkuRXZlbnQgPSBmdW5jdGlvbiggc3JjLCBwcm9wcyApIHtcblxuXHQvLyBBbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgdGhlICduZXcnIGtleXdvcmRcblx0aWYgKCAhKCB0aGlzIGluc3RhbmNlb2YgalF1ZXJ5LkV2ZW50ICkgKSB7XG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuRXZlbnQoIHNyYywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIEV2ZW50IG9iamVjdFxuXHRpZiAoIHNyYyAmJiBzcmMudHlwZSApIHtcblx0XHR0aGlzLm9yaWdpbmFsRXZlbnQgPSBzcmM7XG5cdFx0dGhpcy50eXBlID0gc3JjLnR5cGU7XG5cblx0XHQvLyBFdmVudHMgYnViYmxpbmcgdXAgdGhlIGRvY3VtZW50IG1heSBoYXZlIGJlZW4gbWFya2VkIGFzIHByZXZlbnRlZFxuXHRcdC8vIGJ5IGEgaGFuZGxlciBsb3dlciBkb3duIHRoZSB0cmVlOyByZWZsZWN0IHRoZSBjb3JyZWN0IHZhbHVlLlxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gc3JjLmRlZmF1bHRQcmV2ZW50ZWQgfHxcblx0XHRcdFx0c3JjLmRlZmF1bHRQcmV2ZW50ZWQgPT09IHVuZGVmaW5lZCAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD0yLjMgb25seVxuXHRcdFx0XHRzcmMucmV0dXJuVmFsdWUgPT09IGZhbHNlID9cblx0XHRcdHJldHVyblRydWUgOlxuXHRcdFx0cmV0dXJuRmFsc2U7XG5cblx0XHQvLyBDcmVhdGUgdGFyZ2V0IHByb3BlcnRpZXNcblx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgPD02IC0gNyBvbmx5XG5cdFx0Ly8gVGFyZ2V0IHNob3VsZCBub3QgYmUgYSB0ZXh0IG5vZGUgKCM1MDQsICMxMzE0Mylcblx0XHR0aGlzLnRhcmdldCA9ICggc3JjLnRhcmdldCAmJiBzcmMudGFyZ2V0Lm5vZGVUeXBlID09PSAzICkgP1xuXHRcdFx0c3JjLnRhcmdldC5wYXJlbnROb2RlIDpcblx0XHRcdHNyYy50YXJnZXQ7XG5cblx0XHR0aGlzLmN1cnJlbnRUYXJnZXQgPSBzcmMuY3VycmVudFRhcmdldDtcblx0XHR0aGlzLnJlbGF0ZWRUYXJnZXQgPSBzcmMucmVsYXRlZFRhcmdldDtcblxuXHQvLyBFdmVudCB0eXBlXG5cdH0gZWxzZSB7XG5cdFx0dGhpcy50eXBlID0gc3JjO1xuXHR9XG5cblx0Ly8gUHV0IGV4cGxpY2l0bHkgcHJvdmlkZWQgcHJvcGVydGllcyBvbnRvIHRoZSBldmVudCBvYmplY3Rcblx0aWYgKCBwcm9wcyApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aGlzLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcblx0dGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCBqUXVlcnkubm93KCk7XG5cblx0Ly8gTWFyayBpdCBhcyBmaXhlZFxuXHR0aGlzWyBqUXVlcnkuZXhwYW5kbyBdID0gdHJ1ZTtcbn07XG5cbi8vIGpRdWVyeS5FdmVudCBpcyBiYXNlZCBvbiBET00zIEV2ZW50cyBhcyBzcGVjaWZpZWQgYnkgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgQmluZGluZ1xuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMDMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDMwMzMxL2VjbWEtc2NyaXB0LWJpbmRpbmcuaHRtbFxualF1ZXJ5LkV2ZW50LnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IGpRdWVyeS5FdmVudCxcblx0aXNEZWZhdWx0UHJldmVudGVkOiByZXR1cm5GYWxzZSxcblx0aXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzU2ltdWxhdGVkOiBmYWxzZSxcblxuXHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdH1cblx0fSxcblx0c3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cblx0XHR0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9XG59O1xuXG4vLyBJbmNsdWRlcyBhbGwgY29tbW9uIGV2ZW50IHByb3BzIGluY2x1ZGluZyBLZXlFdmVudCBhbmQgTW91c2VFdmVudCBzcGVjaWZpYyBwcm9wc1xualF1ZXJ5LmVhY2goIHtcblx0YWx0S2V5OiB0cnVlLFxuXHRidWJibGVzOiB0cnVlLFxuXHRjYW5jZWxhYmxlOiB0cnVlLFxuXHRjaGFuZ2VkVG91Y2hlczogdHJ1ZSxcblx0Y3RybEtleTogdHJ1ZSxcblx0ZGV0YWlsOiB0cnVlLFxuXHRldmVudFBoYXNlOiB0cnVlLFxuXHRtZXRhS2V5OiB0cnVlLFxuXHRwYWdlWDogdHJ1ZSxcblx0cGFnZVk6IHRydWUsXG5cdHNoaWZ0S2V5OiB0cnVlLFxuXHR2aWV3OiB0cnVlLFxuXHRcImNoYXJcIjogdHJ1ZSxcblx0Y2hhckNvZGU6IHRydWUsXG5cdGtleTogdHJ1ZSxcblx0a2V5Q29kZTogdHJ1ZSxcblx0YnV0dG9uOiB0cnVlLFxuXHRidXR0b25zOiB0cnVlLFxuXHRjbGllbnRYOiB0cnVlLFxuXHRjbGllbnRZOiB0cnVlLFxuXHRvZmZzZXRYOiB0cnVlLFxuXHRvZmZzZXRZOiB0cnVlLFxuXHRwb2ludGVySWQ6IHRydWUsXG5cdHBvaW50ZXJUeXBlOiB0cnVlLFxuXHRzY3JlZW5YOiB0cnVlLFxuXHRzY3JlZW5ZOiB0cnVlLFxuXHR0YXJnZXRUb3VjaGVzOiB0cnVlLFxuXHR0b0VsZW1lbnQ6IHRydWUsXG5cdHRvdWNoZXM6IHRydWUsXG5cblx0d2hpY2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xuXG5cdFx0Ly8gQWRkIHdoaWNoIGZvciBrZXkgZXZlbnRzXG5cdFx0aWYgKCBldmVudC53aGljaCA9PSBudWxsICYmIHJrZXlFdmVudC50ZXN0KCBldmVudC50eXBlICkgKSB7XG5cdFx0XHRyZXR1cm4gZXZlbnQuY2hhckNvZGUgIT0gbnVsbCA/IGV2ZW50LmNoYXJDb2RlIDogZXZlbnQua2V5Q29kZTtcblx0XHR9XG5cblx0XHQvLyBBZGQgd2hpY2ggZm9yIGNsaWNrOiAxID09PSBsZWZ0OyAyID09PSBtaWRkbGU7IDMgPT09IHJpZ2h0XG5cdFx0aWYgKCAhZXZlbnQud2hpY2ggJiYgYnV0dG9uICE9PSB1bmRlZmluZWQgJiYgcm1vdXNlRXZlbnQudGVzdCggZXZlbnQudHlwZSApICkge1xuXHRcdFx0aWYgKCBidXR0b24gJiAxICkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBidXR0b24gJiAyICkge1xuXHRcdFx0XHRyZXR1cm4gMztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBidXR0b24gJiA0ICkge1xuXHRcdFx0XHRyZXR1cm4gMjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LndoaWNoO1xuXHR9XG59LCBqUXVlcnkuZXZlbnQuYWRkUHJvcCApO1xuXG4vLyBDcmVhdGUgbW91c2VlbnRlci9sZWF2ZSBldmVudHMgdXNpbmcgbW91c2VvdmVyL291dCBhbmQgZXZlbnQtdGltZSBjaGVja3Ncbi8vIHNvIHRoYXQgZXZlbnQgZGVsZWdhdGlvbiB3b3JrcyBpbiBqUXVlcnkuXG4vLyBEbyB0aGUgc2FtZSBmb3IgcG9pbnRlcmVudGVyL3BvaW50ZXJsZWF2ZSBhbmQgcG9pbnRlcm92ZXIvcG9pbnRlcm91dFxuLy9cbi8vIFN1cHBvcnQ6IFNhZmFyaSA3IG9ubHlcbi8vIFNhZmFyaSBzZW5kcyBtb3VzZWVudGVyIHRvbyBvZnRlbjsgc2VlOlxuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDcwMjU4XG4vLyBmb3IgdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBidWcgKGl0IGV4aXN0ZWQgaW4gb2xkZXIgQ2hyb21lIHZlcnNpb25zIGFzIHdlbGwpLlxualF1ZXJ5LmVhY2goIHtcblx0bW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIixcblx0bW91c2VsZWF2ZTogXCJtb3VzZW91dFwiLFxuXHRwb2ludGVyZW50ZXI6IFwicG9pbnRlcm92ZXJcIixcblx0cG9pbnRlcmxlYXZlOiBcInBvaW50ZXJvdXRcIlxufSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIG9yaWcgXSA9IHtcblx0XHRkZWxlZ2F0ZVR5cGU6IGZpeCxcblx0XHRiaW5kVHlwZTogZml4LFxuXG5cdFx0aGFuZGxlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgcmV0LFxuXHRcdFx0XHR0YXJnZXQgPSB0aGlzLFxuXHRcdFx0XHRyZWxhdGVkID0gZXZlbnQucmVsYXRlZFRhcmdldCxcblx0XHRcdFx0aGFuZGxlT2JqID0gZXZlbnQuaGFuZGxlT2JqO1xuXG5cdFx0XHQvLyBGb3IgbW91c2VlbnRlci9sZWF2ZSBjYWxsIHRoZSBoYW5kbGVyIGlmIHJlbGF0ZWQgaXMgb3V0c2lkZSB0aGUgdGFyZ2V0LlxuXHRcdFx0Ly8gTkI6IE5vIHJlbGF0ZWRUYXJnZXQgaWYgdGhlIG1vdXNlIGxlZnQvZW50ZXJlZCB0aGUgYnJvd3NlciB3aW5kb3dcblx0XHRcdGlmICggIXJlbGF0ZWQgfHwgKCByZWxhdGVkICE9PSB0YXJnZXQgJiYgIWpRdWVyeS5jb250YWlucyggdGFyZ2V0LCByZWxhdGVkICkgKSApIHtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGhhbmRsZU9iai5vcmlnVHlwZTtcblx0XHRcdFx0cmV0ID0gaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRldmVudC50eXBlID0gZml4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRvbjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdG9uZTogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCAxICk7XG5cdH0sXG5cdG9mZjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZm4gKSB7XG5cdFx0dmFyIGhhbmRsZU9iaiwgdHlwZTtcblx0XHRpZiAoIHR5cGVzICYmIHR5cGVzLnByZXZlbnREZWZhdWx0ICYmIHR5cGVzLmhhbmRsZU9iaiApIHtcblxuXHRcdFx0Ly8gKCBldmVudCApICBkaXNwYXRjaGVkIGpRdWVyeS5FdmVudFxuXHRcdFx0aGFuZGxlT2JqID0gdHlwZXMuaGFuZGxlT2JqO1xuXHRcdFx0alF1ZXJ5KCB0eXBlcy5kZWxlZ2F0ZVRhcmdldCApLm9mZihcblx0XHRcdFx0aGFuZGxlT2JqLm5hbWVzcGFjZSA/XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlICsgXCIuXCIgKyBoYW5kbGVPYmoubmFtZXNwYWNlIDpcblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUsXG5cdFx0XHRcdGhhbmRsZU9iai5zZWxlY3Rvcixcblx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXJcblx0XHRcdCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtb2JqZWN0IFssIHNlbGVjdG9yXSApXG5cdFx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0XHR0aGlzLm9mZiggdHlwZSwgc2VsZWN0b3IsIHR5cGVzWyB0eXBlIF0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHNlbGVjdG9yID09PSBmYWxzZSB8fCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcyBbLCBmbl0gKVxuXHRcdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggdGhpcywgdHlwZXMsIGZuLCBzZWxlY3RvciApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbnZhclxuXG5cdC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzbGludC9lc2xpbnQvaXNzdWVzLzMyMjlcblx0cnhodG1sVGFnID0gLzwoPyFhcmVhfGJyfGNvbHxlbWJlZHxocnxpbWd8aW5wdXR8bGlua3xtZXRhfHBhcmFtKSgoW2Etel1bXlxcL1xcMD5cXHgyMFxcdFxcclxcblxcZl0qKVtePl0qKVxcLz4vZ2ksXG5cblx0LyogZXNsaW50LWVuYWJsZSAqL1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTAgLSAxMSwgRWRnZSAxMiAtIDEzXG5cdC8vIEluIElFL0VkZ2UgdXNpbmcgcmVnZXggZ3JvdXBzIGhlcmUgY2F1c2VzIHNldmVyZSBzbG93ZG93bnMuXG5cdC8vIFNlZSBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzE3MzY1MTIvXG5cdHJub0lubmVyaHRtbCA9IC88c2NyaXB0fDxzdHlsZXw8bGluay9pLFxuXG5cdC8vIGNoZWNrZWQ9XCJjaGVja2VkXCIgb3IgY2hlY2tlZFxuXHRyY2hlY2tlZCA9IC9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksXG5cdHJzY3JpcHRUeXBlTWFza2VkID0gL150cnVlXFwvKC4qKS8sXG5cdHJjbGVhblNjcmlwdCA9IC9eXFxzKjwhKD86XFxbQ0RBVEFcXFt8LS0pfCg/OlxcXVxcXXwtLSk+XFxzKiQvZztcblxuZnVuY3Rpb24gbWFuaXB1bGF0aW9uVGFyZ2V0KCBlbGVtLCBjb250ZW50ICkge1xuXHRpZiAoIGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJ0YWJsZVwiICkgJiZcblx0XHRqUXVlcnkubm9kZU5hbWUoIGNvbnRlbnQubm9kZVR5cGUgIT09IDExID8gY29udGVudCA6IGNvbnRlbnQuZmlyc3RDaGlsZCwgXCJ0clwiICkgKSB7XG5cblx0XHRyZXR1cm4gZWxlbS5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJ0Ym9keVwiIClbIDAgXSB8fCBlbGVtO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbi8vIFJlcGxhY2UvcmVzdG9yZSB0aGUgdHlwZSBhdHRyaWJ1dGUgb2Ygc2NyaXB0IGVsZW1lbnRzIGZvciBzYWZlIERPTSBtYW5pcHVsYXRpb25cbmZ1bmN0aW9uIGRpc2FibGVTY3JpcHQoIGVsZW0gKSB7XG5cdGVsZW0udHlwZSA9ICggZWxlbS5nZXRBdHRyaWJ1dGUoIFwidHlwZVwiICkgIT09IG51bGwgKSArIFwiL1wiICsgZWxlbS50eXBlO1xuXHRyZXR1cm4gZWxlbTtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVTY3JpcHQoIGVsZW0gKSB7XG5cdHZhciBtYXRjaCA9IHJzY3JpcHRUeXBlTWFza2VkLmV4ZWMoIGVsZW0udHlwZSApO1xuXG5cdGlmICggbWF0Y2ggKSB7XG5cdFx0ZWxlbS50eXBlID0gbWF0Y2hbIDEgXTtcblx0fSBlbHNlIHtcblx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggXCJ0eXBlXCIgKTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5mdW5jdGlvbiBjbG9uZUNvcHlFdmVudCggc3JjLCBkZXN0ICkge1xuXHR2YXIgaSwgbCwgdHlwZSwgcGRhdGFPbGQsIHBkYXRhQ3VyLCB1ZGF0YU9sZCwgdWRhdGFDdXIsIGV2ZW50cztcblxuXHRpZiAoIGRlc3Qubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gMS4gQ29weSBwcml2YXRlIGRhdGE6IGV2ZW50cywgaGFuZGxlcnMsIGV0Yy5cblx0aWYgKCBkYXRhUHJpdi5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHRwZGF0YU9sZCA9IGRhdGFQcml2LmFjY2Vzcyggc3JjICk7XG5cdFx0cGRhdGFDdXIgPSBkYXRhUHJpdi5zZXQoIGRlc3QsIHBkYXRhT2xkICk7XG5cdFx0ZXZlbnRzID0gcGRhdGFPbGQuZXZlbnRzO1xuXG5cdFx0aWYgKCBldmVudHMgKSB7XG5cdFx0XHRkZWxldGUgcGRhdGFDdXIuaGFuZGxlO1xuXHRcdFx0cGRhdGFDdXIuZXZlbnRzID0ge307XG5cblx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IGV2ZW50c1sgdHlwZSBdLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBkZXN0LCB0eXBlLCBldmVudHNbIHR5cGUgXVsgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyAyLiBDb3B5IHVzZXIgZGF0YVxuXHRpZiAoIGRhdGFVc2VyLmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHVkYXRhT2xkID0gZGF0YVVzZXIuYWNjZXNzKCBzcmMgKTtcblx0XHR1ZGF0YUN1ciA9IGpRdWVyeS5leHRlbmQoIHt9LCB1ZGF0YU9sZCApO1xuXG5cdFx0ZGF0YVVzZXIuc2V0KCBkZXN0LCB1ZGF0YUN1ciApO1xuXHR9XG59XG5cbi8vIEZpeCBJRSBidWdzLCBzZWUgc3VwcG9ydCB0ZXN0c1xuZnVuY3Rpb24gZml4SW5wdXQoIHNyYywgZGVzdCApIHtcblx0dmFyIG5vZGVOYW1lID0gZGVzdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdC8vIEZhaWxzIHRvIHBlcnNpc3QgdGhlIGNoZWNrZWQgc3RhdGUgb2YgYSBjbG9uZWQgY2hlY2tib3ggb3IgcmFkaW8gYnV0dG9uLlxuXHRpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgcmNoZWNrYWJsZVR5cGUudGVzdCggc3JjLnR5cGUgKSApIHtcblx0XHRkZXN0LmNoZWNrZWQgPSBzcmMuY2hlY2tlZDtcblxuXHQvLyBGYWlscyB0byByZXR1cm4gdGhlIHNlbGVjdGVkIG9wdGlvbiB0byB0aGUgZGVmYXVsdCBzZWxlY3RlZCBzdGF0ZSB3aGVuIGNsb25pbmcgb3B0aW9uc1xuXHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5vZGVOYW1lID09PSBcInRleHRhcmVhXCIgKSB7XG5cdFx0ZGVzdC5kZWZhdWx0VmFsdWUgPSBzcmMuZGVmYXVsdFZhbHVlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGRvbU1hbmlwKCBjb2xsZWN0aW9uLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApIHtcblxuXHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdGFyZ3MgPSBjb25jYXQuYXBwbHkoIFtdLCBhcmdzICk7XG5cblx0dmFyIGZyYWdtZW50LCBmaXJzdCwgc2NyaXB0cywgaGFzU2NyaXB0cywgbm9kZSwgZG9jLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBjb2xsZWN0aW9uLmxlbmd0aCxcblx0XHRpTm9DbG9uZSA9IGwgLSAxLFxuXHRcdHZhbHVlID0gYXJnc1sgMCBdLFxuXHRcdGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHQvLyBXZSBjYW4ndCBjbG9uZU5vZGUgZnJhZ21lbnRzIHRoYXQgY29udGFpbiBjaGVja2VkLCBpbiBXZWJLaXRcblx0aWYgKCBpc0Z1bmN0aW9uIHx8XG5cdFx0XHQoIGwgPiAxICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc3VwcG9ydC5jaGVja0Nsb25lICYmIHJjaGVja2VkLnRlc3QoIHZhbHVlICkgKSApIHtcblx0XHRyZXR1cm4gY29sbGVjdGlvbi5lYWNoKCBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGNvbGxlY3Rpb24uZXEoIGluZGV4ICk7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdGFyZ3NbIDAgXSA9IHZhbHVlLmNhbGwoIHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSApO1xuXHRcdFx0fVxuXHRcdFx0ZG9tTWFuaXAoIHNlbGYsIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICk7XG5cdFx0fSApO1xuXHR9XG5cblx0aWYgKCBsICkge1xuXHRcdGZyYWdtZW50ID0gYnVpbGRGcmFnbWVudCggYXJncywgY29sbGVjdGlvblsgMCBdLm93bmVyRG9jdW1lbnQsIGZhbHNlLCBjb2xsZWN0aW9uLCBpZ25vcmVkICk7XG5cdFx0Zmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0aWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdGZyYWdtZW50ID0gZmlyc3Q7XG5cdFx0fVxuXG5cdFx0Ly8gUmVxdWlyZSBlaXRoZXIgbmV3IGNvbnRlbnQgb3IgYW4gaW50ZXJlc3QgaW4gaWdub3JlZCBlbGVtZW50cyB0byBpbnZva2UgdGhlIGNhbGxiYWNrXG5cdFx0aWYgKCBmaXJzdCB8fCBpZ25vcmVkICkge1xuXHRcdFx0c2NyaXB0cyA9IGpRdWVyeS5tYXAoIGdldEFsbCggZnJhZ21lbnQsIFwic2NyaXB0XCIgKSwgZGlzYWJsZVNjcmlwdCApO1xuXHRcdFx0aGFzU2NyaXB0cyA9IHNjcmlwdHMubGVuZ3RoO1xuXG5cdFx0XHQvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtXG5cdFx0XHQvLyBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcblx0XHRcdC8vIGJlaW5nIGVtcHRpZWQgaW5jb3JyZWN0bHkgaW4gY2VydGFpbiBzaXR1YXRpb25zICgjODA3MCkuXG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdG5vZGUgPSBmcmFnbWVudDtcblxuXHRcdFx0XHRpZiAoIGkgIT09IGlOb0Nsb25lICkge1xuXHRcdFx0XHRcdG5vZGUgPSBqUXVlcnkuY2xvbmUoIG5vZGUsIHRydWUsIHRydWUgKTtcblxuXHRcdFx0XHRcdC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cblx0XHRcdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBzY3JpcHRzLCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhbGxiYWNrLmNhbGwoIGNvbGxlY3Rpb25bIGkgXSwgbm9kZSwgaSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cdFx0XHRcdGRvYyA9IHNjcmlwdHNbIHNjcmlwdHMubGVuZ3RoIC0gMSBdLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRcdFx0Ly8gUmVlbmFibGUgc2NyaXB0c1xuXHRcdFx0XHRqUXVlcnkubWFwKCBzY3JpcHRzLCByZXN0b3JlU2NyaXB0ICk7XG5cblx0XHRcdFx0Ly8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvblxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGhhc1NjcmlwdHM7IGkrKyApIHtcblx0XHRcdFx0XHRub2RlID0gc2NyaXB0c1sgaSBdO1xuXHRcdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggbm9kZS50eXBlIHx8IFwiXCIgKSAmJlxuXHRcdFx0XHRcdFx0IWRhdGFQcml2LmFjY2Vzcyggbm9kZSwgXCJnbG9iYWxFdmFsXCIgKSAmJlxuXHRcdFx0XHRcdFx0alF1ZXJ5LmNvbnRhaW5zKCBkb2MsIG5vZGUgKSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBub2RlLnNyYyApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBPcHRpb25hbCBBSkFYIGRlcGVuZGVuY3ksIGJ1dCB3b24ndCBydW4gc2NyaXB0cyBpZiBub3QgcHJlc2VudFxuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5fZXZhbFVybCApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuX2V2YWxVcmwoIG5vZGUuc3JjICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdERPTUV2YWwoIG5vZGUudGV4dENvbnRlbnQucmVwbGFjZSggcmNsZWFuU2NyaXB0LCBcIlwiICksIGRvYyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjb2xsZWN0aW9uO1xufVxuXG5mdW5jdGlvbiByZW1vdmUoIGVsZW0sIHNlbGVjdG9yLCBrZWVwRGF0YSApIHtcblx0dmFyIG5vZGUsXG5cdFx0bm9kZXMgPSBzZWxlY3RvciA/IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBlbGVtICkgOiBlbGVtLFxuXHRcdGkgPSAwO1xuXG5cdGZvciAoIDsgKCBub2RlID0gbm9kZXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRpZiAoICFrZWVwRGF0YSAmJiBub2RlLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBub2RlICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG5vZGUucGFyZW50Tm9kZSApIHtcblx0XHRcdGlmICgga2VlcERhdGEgJiYgalF1ZXJ5LmNvbnRhaW5zKCBub2RlLm93bmVyRG9jdW1lbnQsIG5vZGUgKSApIHtcblx0XHRcdFx0c2V0R2xvYmFsRXZhbCggZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdH1cblx0XHRcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggbm9kZSApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGh0bWxQcmVmaWx0ZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHJldHVybiBodG1sLnJlcGxhY2UoIHJ4aHRtbFRhZywgXCI8JDE+PC8kMj5cIiApO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZWxlbSwgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0dmFyIGksIGwsIHNyY0VsZW1lbnRzLCBkZXN0RWxlbWVudHMsXG5cdFx0XHRjbG9uZSA9IGVsZW0uY2xvbmVOb2RlKCB0cnVlICksXG5cdFx0XHRpblBhZ2UgPSBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXG5cdFx0Ly8gRml4IElFIGNsb25pbmcgaXNzdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCAmJiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgZWxlbS5ub2RlVHlwZSA9PT0gMTEgKSAmJlxuXHRcdFx0XHQhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIFdlIGVzY2hldyBTaXp6bGUgaGVyZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uczogaHR0cHM6Ly9qc3BlcmYuY29tL2dldGFsbC12cy1zaXp6bGUvMlxuXHRcdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSApO1xuXHRcdFx0c3JjRWxlbWVudHMgPSBnZXRBbGwoIGVsZW0gKTtcblxuXHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGZpeElucHV0KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvcHkgdGhlIGV2ZW50cyBmcm9tIHRoZSBvcmlnaW5hbCB0byB0aGUgY2xvbmVcblx0XHRpZiAoIGRhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRpZiAoIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0XHRzcmNFbGVtZW50cyA9IHNyY0VsZW1lbnRzIHx8IGdldEFsbCggZWxlbSApO1xuXHRcdFx0XHRkZXN0RWxlbWVudHMgPSBkZXN0RWxlbWVudHMgfHwgZ2V0QWxsKCBjbG9uZSApO1xuXG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGNsb25lQ29weUV2ZW50KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjbG9uZUNvcHlFdmVudCggZWxlbSwgY2xvbmUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSwgXCJzY3JpcHRcIiApO1xuXHRcdGlmICggZGVzdEVsZW1lbnRzLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCBkZXN0RWxlbWVudHMsICFpblBhZ2UgJiYgZ2V0QWxsKCBlbGVtLCBcInNjcmlwdFwiICkgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gdGhlIGNsb25lZCBzZXRcblx0XHRyZXR1cm4gY2xvbmU7XG5cdH0sXG5cblx0Y2xlYW5EYXRhOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cdFx0dmFyIGRhdGEsIGVsZW0sIHR5cGUsXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWwsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKCBlbGVtID0gZWxlbXNbIGkgXSApICE9PSB1bmRlZmluZWQ7IGkrKyApIHtcblx0XHRcdGlmICggYWNjZXB0RGF0YSggZWxlbSApICkge1xuXHRcdFx0XHRpZiAoICggZGF0YSA9IGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSApICkge1xuXHRcdFx0XHRcdGlmICggZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCB0eXBlIGluIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWxbIHR5cGUgXSApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gVGhpcyBpcyBhIHNob3J0Y3V0IHRvIGF2b2lkIGpRdWVyeS5ldmVudC5yZW1vdmUncyBvdmVyaGVhZFxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdICkge1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcblx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRkZXRhY2g6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yICk7XG5cdH0sXG5cblx0dGV4dDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnRleHQoIHRoaXMgKSA6XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdGFwcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdHByZXBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoIGVsZW0sIHRhcmdldC5maXJzdENoaWxkICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGJlZm9yZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YWZ0ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzLm5leHRTaWJsaW5nICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSB0aGlzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0Ly8gUHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cblx0XHRcdFx0Ly8gUmVtb3ZlIGFueSByZW1haW5pbmcgbm9kZXNcblx0XHRcdFx0ZWxlbS50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRkYXRhQW5kRXZlbnRzID0gZGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZmFsc2UgOiBkYXRhQW5kRXZlbnRzO1xuXHRcdGRlZXBEYXRhQW5kRXZlbnRzID0gZGVlcERhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGRhdGFBbmRFdmVudHMgOiBkZWVwRGF0YUFuZEV2ZW50cztcblxuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmNsb25lKCB0aGlzLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApO1xuXHRcdH0gKTtcblx0fSxcblxuXHRodG1sOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF0gfHwge30sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRsID0gdGhpcy5sZW5ndGg7XG5cblx0XHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5pbm5lckhUTUw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNlZSBpZiB3ZSBjYW4gdGFrZSBhIHNob3J0Y3V0IGFuZCBqdXN0IHVzZSBpbm5lckhUTUxcblx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmICFybm9Jbm5lcmh0bWwudGVzdCggdmFsdWUgKSAmJlxuXHRcdFx0XHQhd3JhcE1hcFsgKCBydGFnTmFtZS5leGVjKCB2YWx1ZSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpIF0gKSB7XG5cblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuaHRtbFByZWZpbHRlciggdmFsdWUgKTtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRcdGVsZW0gPSB0aGlzWyBpIF0gfHwge307XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblx0XHRcdFx0XHRcdFx0ZWxlbS5pbm5lckhUTUwgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlbGVtID0gMDtcblxuXHRcdFx0XHQvLyBJZiB1c2luZyBpbm5lckhUTUwgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgdXNlIHRoZSBmYWxsYmFjayBtZXRob2Rcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5hcHBlbmQoIHZhbHVlICk7XG5cdFx0XHR9XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRyZXBsYWNlV2l0aDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGlnbm9yZWQgPSBbXTtcblxuXHRcdC8vIE1ha2UgdGhlIGNoYW5nZXMsIHJlcGxhY2luZyBlYWNoIG5vbi1pZ25vcmVkIGNvbnRleHQgZWxlbWVudCB3aXRoIHRoZSBuZXcgY29udGVudFxuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG5cblx0XHRcdGlmICggalF1ZXJ5LmluQXJyYXkoIHRoaXMsIGlnbm9yZWQgKSA8IDAgKSB7XG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggdGhpcyApICk7XG5cdFx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRcdHBhcmVudC5yZXBsYWNlQ2hpbGQoIGVsZW0sIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gRm9yY2UgY2FsbGJhY2sgaW52b2NhdGlvblxuXHRcdH0sIGlnbm9yZWQgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCgge1xuXHRhcHBlbmRUbzogXCJhcHBlbmRcIixcblx0cHJlcGVuZFRvOiBcInByZXBlbmRcIixcblx0aW5zZXJ0QmVmb3JlOiBcImJlZm9yZVwiLFxuXHRpbnNlcnRBZnRlcjogXCJhZnRlclwiLFxuXHRyZXBsYWNlQWxsOiBcInJlcGxhY2VXaXRoXCJcbn0sIGZ1bmN0aW9uKCBuYW1lLCBvcmlnaW5hbCApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGVsZW1zLFxuXHRcdFx0cmV0ID0gW10sXG5cdFx0XHRpbnNlcnQgPSBqUXVlcnkoIHNlbGVjdG9yICksXG5cdFx0XHRsYXN0ID0gaW5zZXJ0Lmxlbmd0aCAtIDEsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgaSA8PSBsYXN0OyBpKysgKSB7XG5cdFx0XHRlbGVtcyA9IGkgPT09IGxhc3QgPyB0aGlzIDogdGhpcy5jbG9uZSggdHJ1ZSApO1xuXHRcdFx0alF1ZXJ5KCBpbnNlcnRbIGkgXSApWyBvcmlnaW5hbCBdKCBlbGVtcyApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdC8vIC5nZXQoKSBiZWNhdXNlIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdHB1c2guYXBwbHkoIHJldCwgZWxlbXMuZ2V0KCkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHJldCApO1xuXHR9O1xufSApO1xudmFyIHJtYXJnaW4gPSAoIC9ebWFyZ2luLyApO1xuXG52YXIgcm51bW5vbnB4ID0gbmV3IFJlZ0V4cCggXCJeKFwiICsgcG51bSArIFwiKSg/IXB4KVthLXolXSskXCIsIFwiaVwiICk7XG5cbnZhciBnZXRTdHlsZXMgPSBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seSwgRmlyZWZveCA8PTMwICgjMTUwOTgsICMxNDE1MClcblx0XHQvLyBJRSB0aHJvd3Mgb24gZWxlbWVudHMgY3JlYXRlZCBpbiBwb3B1cHNcblx0XHQvLyBGRiBtZWFud2hpbGUgdGhyb3dzIG9uIGZyYW1lIGVsZW1lbnRzIHRocm91Z2ggXCJkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlXCJcblx0XHR2YXIgdmlldyA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcblxuXHRcdGlmICggIXZpZXcgfHwgIXZpZXcub3BlbmVyICkge1xuXHRcdFx0dmlldyA9IHdpbmRvdztcblx0XHR9XG5cblx0XHRyZXR1cm4gdmlldy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtICk7XG5cdH07XG5cblxuXG4oIGZ1bmN0aW9uKCkge1xuXG5cdC8vIEV4ZWN1dGluZyBib3RoIHBpeGVsUG9zaXRpb24gJiBib3hTaXppbmdSZWxpYWJsZSB0ZXN0cyByZXF1aXJlIG9ubHkgb25lIGxheW91dFxuXHQvLyBzbyB0aGV5J3JlIGV4ZWN1dGVkIGF0IHRoZSBzYW1lIHRpbWUgdG8gc2F2ZSB0aGUgc2Vjb25kIGNvbXB1dGF0aW9uLlxuXHRmdW5jdGlvbiBjb21wdXRlU3R5bGVUZXN0cygpIHtcblxuXHRcdC8vIFRoaXMgaXMgYSBzaW5nbGV0b24sIHdlIG5lZWQgdG8gZXhlY3V0ZSBpdCBvbmx5IG9uY2Vcblx0XHRpZiAoICFkaXYgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0ZGl2LnN0eWxlLmNzc1RleHQgPVxuXHRcdFx0XCJib3gtc2l6aW5nOmJvcmRlci1ib3g7XCIgK1xuXHRcdFx0XCJwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO1wiICtcblx0XHRcdFwibWFyZ2luOmF1dG87Ym9yZGVyOjFweDtwYWRkaW5nOjFweDtcIiArXG5cdFx0XHRcInRvcDoxJTt3aWR0aDo1MCVcIjtcblx0XHRkaXYuaW5uZXJIVE1MID0gXCJcIjtcblx0XHRkb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoIGNvbnRhaW5lciApO1xuXG5cdFx0dmFyIGRpdlN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGRpdiApO1xuXHRcdHBpeGVsUG9zaXRpb25WYWwgPSBkaXZTdHlsZS50b3AgIT09IFwiMSVcIjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIEZpcmVmb3ggPD0zIC0gNDRcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnRWYWwgPSBkaXZTdHlsZS5tYXJnaW5MZWZ0ID09PSBcIjJweFwiO1xuXHRcdGJveFNpemluZ1JlbGlhYmxlVmFsID0gZGl2U3R5bGUud2lkdGggPT09IFwiNHB4XCI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5XG5cdFx0Ly8gU29tZSBzdHlsZXMgY29tZSBiYWNrIHdpdGggcGVyY2VudGFnZSB2YWx1ZXMsIGV2ZW4gdGhvdWdoIHRoZXkgc2hvdWxkbid0XG5cdFx0ZGl2LnN0eWxlLm1hcmdpblJpZ2h0ID0gXCI1MCVcIjtcblx0XHRwaXhlbE1hcmdpblJpZ2h0VmFsID0gZGl2U3R5bGUubWFyZ2luUmlnaHQgPT09IFwiNHB4XCI7XG5cblx0XHRkb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lciApO1xuXG5cdFx0Ly8gTnVsbGlmeSB0aGUgZGl2IHNvIGl0IHdvdWxkbid0IGJlIHN0b3JlZCBpbiB0aGUgbWVtb3J5IGFuZFxuXHRcdC8vIGl0IHdpbGwgYWxzbyBiZSBhIHNpZ24gdGhhdCBjaGVja3MgYWxyZWFkeSBwZXJmb3JtZWRcblx0XHRkaXYgPSBudWxsO1xuXHR9XG5cblx0dmFyIHBpeGVsUG9zaXRpb25WYWwsIGJveFNpemluZ1JlbGlhYmxlVmFsLCBwaXhlbE1hcmdpblJpZ2h0VmFsLCByZWxpYWJsZU1hcmdpbkxlZnRWYWwsXG5cdFx0Y29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLFxuXHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuXHQvLyBGaW5pc2ggZWFybHkgaW4gbGltaXRlZCAobm9uLWJyb3dzZXIpIGVudmlyb25tZW50c1xuXHRpZiAoICFkaXYuc3R5bGUgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHQvLyBTdHlsZSBvZiBjbG9uZWQgZWxlbWVudCBhZmZlY3RzIHNvdXJjZSBlbGVtZW50IGNsb25lZCAoIzg5MDgpXG5cdGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiY29udGVudC1ib3hcIjtcblx0ZGl2LmNsb25lTm9kZSggdHJ1ZSApLnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJcIjtcblx0c3VwcG9ydC5jbGVhckNsb25lU3R5bGUgPSBkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPT09IFwiY29udGVudC1ib3hcIjtcblxuXHRjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IFwiYm9yZGVyOjA7d2lkdGg6OHB4O2hlaWdodDowO3RvcDowO2xlZnQ6LTk5OTlweDtcIiArXG5cdFx0XCJwYWRkaW5nOjA7bWFyZ2luLXRvcDoxcHg7cG9zaXRpb246YWJzb2x1dGVcIjtcblx0Y29udGFpbmVyLmFwcGVuZENoaWxkKCBkaXYgKTtcblxuXHRqUXVlcnkuZXh0ZW5kKCBzdXBwb3J0LCB7XG5cdFx0cGl4ZWxQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHBpeGVsUG9zaXRpb25WYWw7XG5cdFx0fSxcblx0XHRib3hTaXppbmdSZWxpYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIGJveFNpemluZ1JlbGlhYmxlVmFsO1xuXHRcdH0sXG5cdFx0cGl4ZWxNYXJnaW5SaWdodDogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHBpeGVsTWFyZ2luUmlnaHRWYWw7XG5cdFx0fSxcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiByZWxpYWJsZU1hcmdpbkxlZnRWYWw7XG5cdFx0fVxuXHR9ICk7XG59ICkoKTtcblxuXG5mdW5jdGlvbiBjdXJDU1MoIGVsZW0sIG5hbWUsIGNvbXB1dGVkICkge1xuXHR2YXIgd2lkdGgsIG1pbldpZHRoLCBtYXhXaWR0aCwgcmV0LFxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRjb21wdXRlZCA9IGNvbXB1dGVkIHx8IGdldFN0eWxlcyggZWxlbSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdC8vIGdldFByb3BlcnR5VmFsdWUgaXMgb25seSBuZWVkZWQgZm9yIC5jc3MoJ2ZpbHRlcicpICgjMTI1MzcpXG5cdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0cmV0ID0gY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZSggbmFtZSApIHx8IGNvbXB1dGVkWyBuYW1lIF07XG5cblx0XHRpZiAoIHJldCA9PT0gXCJcIiAmJiAhalF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSApIHtcblx0XHRcdHJldCA9IGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIEEgdHJpYnV0ZSB0byB0aGUgXCJhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzXCJcblx0XHQvLyBBbmRyb2lkIEJyb3dzZXIgcmV0dXJucyBwZXJjZW50YWdlIGZvciBzb21lIHZhbHVlcyxcblx0XHQvLyBidXQgd2lkdGggc2VlbXMgdG8gYmUgcmVsaWFibHkgcGl4ZWxzLlxuXHRcdC8vIFRoaXMgaXMgYWdhaW5zdCB0aGUgQ1NTT00gZHJhZnQgc3BlYzpcblx0XHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI3Jlc29sdmVkLXZhbHVlc1xuXHRcdGlmICggIXN1cHBvcnQucGl4ZWxNYXJnaW5SaWdodCgpICYmIHJudW1ub25weC50ZXN0KCByZXQgKSAmJiBybWFyZ2luLnRlc3QoIG5hbWUgKSApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xuXHRcdFx0d2lkdGggPSBzdHlsZS53aWR0aDtcblx0XHRcdG1pbldpZHRoID0gc3R5bGUubWluV2lkdGg7XG5cdFx0XHRtYXhXaWR0aCA9IHN0eWxlLm1heFdpZHRoO1xuXG5cdFx0XHQvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IHN0eWxlLm1heFdpZHRoID0gc3R5bGUud2lkdGggPSByZXQ7XG5cdFx0XHRyZXQgPSBjb21wdXRlZC53aWR0aDtcblxuXHRcdFx0Ly8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuXHRcdFx0c3R5bGUud2lkdGggPSB3aWR0aDtcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gbWluV2lkdGg7XG5cdFx0XHRzdHlsZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXQgIT09IHVuZGVmaW5lZCA/XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0Ly8gSUUgcmV0dXJucyB6SW5kZXggdmFsdWUgYXMgYW4gaW50ZWdlci5cblx0XHRyZXQgKyBcIlwiIDpcblx0XHRyZXQ7XG59XG5cblxuZnVuY3Rpb24gYWRkR2V0SG9va0lmKCBjb25kaXRpb25GbiwgaG9va0ZuICkge1xuXG5cdC8vIERlZmluZSB0aGUgaG9vaywgd2UnbGwgY2hlY2sgb24gdGhlIGZpcnN0IHJ1biBpZiBpdCdzIHJlYWxseSBuZWVkZWQuXG5cdHJldHVybiB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggY29uZGl0aW9uRm4oKSApIHtcblxuXHRcdFx0XHQvLyBIb29rIG5vdCBuZWVkZWQgKG9yIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBpdCBkdWVcblx0XHRcdFx0Ly8gdG8gbWlzc2luZyBkZXBlbmRlbmN5KSwgcmVtb3ZlIGl0LlxuXHRcdFx0XHRkZWxldGUgdGhpcy5nZXQ7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSG9vayBuZWVkZWQ7IHJlZGVmaW5lIGl0IHNvIHRoYXQgdGhlIHN1cHBvcnQgdGVzdCBpcyBub3QgZXhlY3V0ZWQgYWdhaW4uXG5cdFx0XHRyZXR1cm4gKCB0aGlzLmdldCA9IGhvb2tGbiApLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9XG5cdH07XG59XG5cblxudmFyXG5cblx0Ly8gU3dhcHBhYmxlIGlmIGRpc3BsYXkgaXMgbm9uZSBvciBzdGFydHMgd2l0aCB0YWJsZVxuXHQvLyBleGNlcHQgXCJ0YWJsZVwiLCBcInRhYmxlLWNlbGxcIiwgb3IgXCJ0YWJsZS1jYXB0aW9uXCJcblx0Ly8gU2VlIGhlcmUgZm9yIGRpc3BsYXkgdmFsdWVzOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0NTUy9kaXNwbGF5XG5cdHJkaXNwbGF5c3dhcCA9IC9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxcblx0Y3NzU2hvdyA9IHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiwgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiwgZGlzcGxheTogXCJibG9ja1wiIH0sXG5cdGNzc05vcm1hbFRyYW5zZm9ybSA9IHtcblx0XHRsZXR0ZXJTcGFjaW5nOiBcIjBcIixcblx0XHRmb250V2VpZ2h0OiBcIjQwMFwiXG5cdH0sXG5cblx0Y3NzUHJlZml4ZXMgPSBbIFwiV2Via2l0XCIsIFwiTW96XCIsIFwibXNcIiBdLFxuXHRlbXB0eVN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLnN0eWxlO1xuXG4vLyBSZXR1cm4gYSBjc3MgcHJvcGVydHkgbWFwcGVkIHRvIGEgcG90ZW50aWFsbHkgdmVuZG9yIHByZWZpeGVkIHByb3BlcnR5XG5mdW5jdGlvbiB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHtcblxuXHQvLyBTaG9ydGN1dCBmb3IgbmFtZXMgdGhhdCBhcmUgbm90IHZlbmRvciBwcmVmaXhlZFxuXHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRyZXR1cm4gbmFtZTtcblx0fVxuXG5cdC8vIENoZWNrIGZvciB2ZW5kb3IgcHJlZml4ZWQgbmFtZXNcblx0dmFyIGNhcE5hbWUgPSBuYW1lWyAwIF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoIDEgKSxcblx0XHRpID0gY3NzUHJlZml4ZXMubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdG5hbWUgPSBjc3NQcmVmaXhlc1sgaSBdICsgY2FwTmFtZTtcblx0XHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRcdHJldHVybiBuYW1lO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICkge1xuXG5cdC8vIEFueSByZWxhdGl2ZSAoKy8tKSB2YWx1ZXMgaGF2ZSBhbHJlYWR5IGJlZW5cblx0Ly8gbm9ybWFsaXplZCBhdCB0aGlzIHBvaW50XG5cdHZhciBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApO1xuXHRyZXR1cm4gbWF0Y2hlcyA/XG5cblx0XHQvLyBHdWFyZCBhZ2FpbnN0IHVuZGVmaW5lZCBcInN1YnRyYWN0XCIsIGUuZy4sIHdoZW4gdXNlZCBhcyBpbiBjc3NIb29rc1xuXHRcdE1hdGgubWF4KCAwLCBtYXRjaGVzWyAyIF0gLSAoIHN1YnRyYWN0IHx8IDAgKSApICsgKCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgOlxuXHRcdHZhbHVlO1xufVxuXG5mdW5jdGlvbiBhdWdtZW50V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEsIGlzQm9yZGVyQm94LCBzdHlsZXMgKSB7XG5cdHZhciBpLFxuXHRcdHZhbCA9IDA7XG5cblx0Ly8gSWYgd2UgYWxyZWFkeSBoYXZlIHRoZSByaWdodCBtZWFzdXJlbWVudCwgYXZvaWQgYXVnbWVudGF0aW9uXG5cdGlmICggZXh0cmEgPT09ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSApIHtcblx0XHRpID0gNDtcblxuXHQvLyBPdGhlcndpc2UgaW5pdGlhbGl6ZSBmb3IgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBwcm9wZXJ0aWVzXG5cdH0gZWxzZSB7XG5cdFx0aSA9IG5hbWUgPT09IFwid2lkdGhcIiA/IDEgOiAwO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgNDsgaSArPSAyICkge1xuXG5cdFx0Ly8gQm90aCBib3ggbW9kZWxzIGV4Y2x1ZGUgbWFyZ2luLCBzbyBhZGQgaXQgaWYgd2Ugd2FudCBpdFxuXHRcdGlmICggZXh0cmEgPT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHR2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgZXh0cmEgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0JvcmRlckJveCApIHtcblxuXHRcdFx0Ly8gYm9yZGVyLWJveCBpbmNsdWRlcyBwYWRkaW5nLCBzbyByZW1vdmUgaXQgaWYgd2Ugd2FudCBjb250ZW50XG5cdFx0XHRpZiAoIGV4dHJhID09PSBcImNvbnRlbnRcIiApIHtcblx0XHRcdFx0dmFsIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBib3JkZXIgbm9yIG1hcmdpbiwgc28gcmVtb3ZlIGJvcmRlclxuXHRcdFx0aWYgKCBleHRyYSAhPT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdFx0dmFsIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgY29udGVudCwgc28gYWRkIHBhZGRpbmdcblx0XHRcdHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgY29udGVudCBub3IgcGFkZGluZywgc28gYWRkIGJvcmRlclxuXHRcdFx0aWYgKCBleHRyYSAhPT0gXCJwYWRkaW5nXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB2YWw7XG59XG5cbmZ1bmN0aW9uIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICkge1xuXG5cdC8vIFN0YXJ0IHdpdGggb2Zmc2V0IHByb3BlcnR5LCB3aGljaCBpcyBlcXVpdmFsZW50IHRvIHRoZSBib3JkZXItYm94IHZhbHVlXG5cdHZhciB2YWwsXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IHRydWUsXG5cdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXG5cdFx0aXNCb3JkZXJCb3ggPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlXG5cdC8vIGluIElFIHRocm93cyBhbiBlcnJvci5cblx0aWYgKCBlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICkge1xuXHRcdHZhbCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbIG5hbWUgXTtcblx0fVxuXG5cdC8vIFNvbWUgbm9uLWh0bWwgZWxlbWVudHMgcmV0dXJuIHVuZGVmaW5lZCBmb3Igb2Zmc2V0V2lkdGgsIHNvIGNoZWNrIGZvciBudWxsL3VuZGVmaW5lZFxuXHQvLyBzdmcgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02NDkyODVcblx0Ly8gTWF0aE1MIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NDkxNjY4XG5cdGlmICggdmFsIDw9IDAgfHwgdmFsID09IG51bGwgKSB7XG5cblx0XHQvLyBGYWxsIGJhY2sgdG8gY29tcHV0ZWQgdGhlbiB1bmNvbXB1dGVkIGNzcyBpZiBuZWNlc3Nhcnlcblx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuXHRcdGlmICggdmFsIDwgMCB8fCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdHZhbCA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBDb21wdXRlZCB1bml0IGlzIG5vdCBwaXhlbHMuIFN0b3AgaGVyZSBhbmQgcmV0dXJuLlxuXHRcdGlmICggcm51bW5vbnB4LnRlc3QoIHZhbCApICkge1xuXHRcdFx0cmV0dXJuIHZhbDtcblx0XHR9XG5cblx0XHQvLyBDaGVjayBmb3Igc3R5bGUgaW4gY2FzZSBhIGJyb3dzZXIgd2hpY2ggcmV0dXJucyB1bnJlbGlhYmxlIHZhbHVlc1xuXHRcdC8vIGZvciBnZXRDb21wdXRlZFN0eWxlIHNpbGVudGx5IGZhbGxzIGJhY2sgdG8gdGhlIHJlbGlhYmxlIGVsZW0uc3R5bGVcblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gaXNCb3JkZXJCb3ggJiZcblx0XHRcdCggc3VwcG9ydC5ib3hTaXppbmdSZWxpYWJsZSgpIHx8IHZhbCA9PT0gZWxlbS5zdHlsZVsgbmFtZSBdICk7XG5cblx0XHQvLyBOb3JtYWxpemUgXCJcIiwgYXV0bywgYW5kIHByZXBhcmUgZm9yIGV4dHJhXG5cdFx0dmFsID0gcGFyc2VGbG9hdCggdmFsICkgfHwgMDtcblx0fVxuXG5cdC8vIFVzZSB0aGUgYWN0aXZlIGJveC1zaXppbmcgbW9kZWwgdG8gYWRkL3N1YnRyYWN0IGlycmVsZXZhbnQgc3R5bGVzXG5cdHJldHVybiAoIHZhbCArXG5cdFx0YXVnbWVudFdpZHRoT3JIZWlnaHQoXG5cdFx0XHRlbGVtLFxuXHRcdFx0bmFtZSxcblx0XHRcdGV4dHJhIHx8ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSxcblx0XHRcdHZhbHVlSXNCb3JkZXJCb3gsXG5cdFx0XHRzdHlsZXNcblx0XHQpXG5cdCkgKyBcInB4XCI7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBBZGQgaW4gc3R5bGUgcHJvcGVydHkgaG9va3MgZm9yIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHRcblx0Ly8gYmVoYXZpb3Igb2YgZ2V0dGluZyBhbmQgc2V0dGluZyBhIHN0eWxlIHByb3BlcnR5XG5cdGNzc0hvb2tzOiB7XG5cdFx0b3BhY2l0eToge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBXZSBzaG91bGQgYWx3YXlzIGdldCBhIG51bWJlciBiYWNrIGZyb20gb3BhY2l0eVxuXHRcdFx0XHRcdHZhciByZXQgPSBjdXJDU1MoIGVsZW0sIFwib3BhY2l0eVwiICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJldCA9PT0gXCJcIiA/IFwiMVwiIDogcmV0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIERvbid0IGF1dG9tYXRpY2FsbHkgYWRkIFwicHhcIiB0byB0aGVzZSBwb3NzaWJseS11bml0bGVzcyBwcm9wZXJ0aWVzXG5cdGNzc051bWJlcjoge1xuXHRcdFwiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnRcIjogdHJ1ZSxcblx0XHRcImNvbHVtbkNvdW50XCI6IHRydWUsXG5cdFx0XCJmaWxsT3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwiZmxleEdyb3dcIjogdHJ1ZSxcblx0XHRcImZsZXhTaHJpbmtcIjogdHJ1ZSxcblx0XHRcImZvbnRXZWlnaHRcIjogdHJ1ZSxcblx0XHRcImxpbmVIZWlnaHRcIjogdHJ1ZSxcblx0XHRcIm9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcIm9yZGVyXCI6IHRydWUsXG5cdFx0XCJvcnBoYW5zXCI6IHRydWUsXG5cdFx0XCJ3aWRvd3NcIjogdHJ1ZSxcblx0XHRcInpJbmRleFwiOiB0cnVlLFxuXHRcdFwiem9vbVwiOiB0cnVlXG5cdH0sXG5cblx0Ly8gQWRkIGluIHByb3BlcnRpZXMgd2hvc2UgbmFtZXMgeW91IHdpc2ggdG8gZml4IGJlZm9yZVxuXHQvLyBzZXR0aW5nIG9yIGdldHRpbmcgdGhlIHZhbHVlXG5cdGNzc1Byb3BzOiB7XG5cdFx0XCJmbG9hdFwiOiBcImNzc0Zsb2F0XCJcblx0fSxcblxuXHQvLyBHZXQgYW5kIHNldCB0aGUgc3R5bGUgcHJvcGVydHkgb24gYSBET00gTm9kZVxuXHRzdHlsZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlLCBleHRyYSApIHtcblxuXHRcdC8vIERvbid0IHNldCBzdHlsZXMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggIWVsZW0gfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICFlbGVtLnN0eWxlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdHZhciByZXQsIHR5cGUsIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0XHRuYW1lID0galF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdIHx8XG5cdFx0XHQoIGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSA9IHZlbmRvclByb3BOYW1lKCBvcmlnTmFtZSApIHx8IG9yaWdOYW1lICk7XG5cblx0XHQvLyBHZXRzIGhvb2sgZm9yIHRoZSBwcmVmaXhlZCB2ZXJzaW9uLCB0aGVuIHVucHJlZml4ZWQgdmVyc2lvblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UncmUgc2V0dGluZyBhIHZhbHVlXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdFx0Ly8gQ29udmVydCBcIis9XCIgb3IgXCItPVwiIHRvIHJlbGF0aXZlIG51bWJlcnMgKCM3MzQ1KVxuXHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICYmICggcmV0ID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiYgcmV0WyAxIF0gKSB7XG5cdFx0XHRcdHZhbHVlID0gYWRqdXN0Q1NTKCBlbGVtLCBuYW1lLCByZXQgKTtcblxuXHRcdFx0XHQvLyBGaXhlcyBidWcgIzkyMzdcblx0XHRcdFx0dHlwZSA9IFwibnVtYmVyXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IG51bGwgYW5kIE5hTiB2YWx1ZXMgYXJlbid0IHNldCAoIzcxMTYpXG5cdFx0XHRpZiAoIHZhbHVlID09IG51bGwgfHwgdmFsdWUgIT09IHZhbHVlICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgbnVtYmVyIHdhcyBwYXNzZWQgaW4sIGFkZCB0aGUgdW5pdCAoZXhjZXB0IGZvciBjZXJ0YWluIENTUyBwcm9wZXJ0aWVzKVxuXHRcdFx0aWYgKCB0eXBlID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHR2YWx1ZSArPSByZXQgJiYgcmV0WyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBvcmlnTmFtZSBdID8gXCJcIiA6IFwicHhcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBiYWNrZ3JvdW5kLSogcHJvcHMgYWZmZWN0IG9yaWdpbmFsIGNsb25lJ3MgdmFsdWVzXG5cdFx0XHRpZiAoICFzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSAmJiB2YWx1ZSA9PT0gXCJcIiAmJiBuYW1lLmluZGV4T2YoIFwiYmFja2dyb3VuZFwiICkgPT09IDAgKSB7XG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSBcImluaGVyaXRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCwgdXNlIHRoYXQgdmFsdWUsIG90aGVyd2lzZSBqdXN0IHNldCB0aGUgc3BlY2lmaWVkIHZhbHVlXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHxcblx0XHRcdFx0KCB2YWx1ZSA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBub24tY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBmYWxzZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIGp1c3QgZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBzdHlsZSBvYmplY3Rcblx0XHRcdHJldHVybiBzdHlsZVsgbmFtZSBdO1xuXHRcdH1cblx0fSxcblxuXHRjc3M6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBleHRyYSwgc3R5bGVzICkge1xuXHRcdHZhciB2YWwsIG51bSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdG5hbWUgPSBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gfHxcblx0XHRcdCggalF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIG9yaWdOYW1lICkgfHwgb3JpZ05hbWUgKTtcblxuXHRcdC8vIFRyeSBwcmVmaXhlZCBuYW1lIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIG5hbWVcblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsID0gaG9va3MuZ2V0KCBlbGVtLCB0cnVlLCBleHRyYSApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSwgaWYgYSB3YXkgdG8gZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBleGlzdHMsIHVzZSB0aGF0XG5cdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBcIm5vcm1hbFwiIHRvIGNvbXB1dGVkIHZhbHVlXG5cdFx0aWYgKCB2YWwgPT09IFwibm9ybWFsXCIgJiYgbmFtZSBpbiBjc3NOb3JtYWxUcmFuc2Zvcm0gKSB7XG5cdFx0XHR2YWwgPSBjc3NOb3JtYWxUcmFuc2Zvcm1bIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIG51bWVyaWMgaWYgZm9yY2VkIG9yIGEgcXVhbGlmaWVyIHdhcyBwcm92aWRlZCBhbmQgdmFsIGxvb2tzIG51bWVyaWNcblx0XHRpZiAoIGV4dHJhID09PSBcIlwiIHx8IGV4dHJhICkge1xuXHRcdFx0bnVtID0gcGFyc2VGbG9hdCggdmFsICk7XG5cdFx0XHRyZXR1cm4gZXh0cmEgPT09IHRydWUgfHwgaXNGaW5pdGUoIG51bSApID8gbnVtIHx8IDAgOiB2YWw7XG5cdFx0fVxuXHRcdHJldHVybiB2YWw7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCwgZXh0cmEgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdC8vIENlcnRhaW4gZWxlbWVudHMgY2FuIGhhdmUgZGltZW5zaW9uIGluZm8gaWYgd2UgaW52aXNpYmx5IHNob3cgdGhlbVxuXHRcdFx0XHQvLyBidXQgaXQgbXVzdCBoYXZlIGEgY3VycmVudCBkaXNwbGF5IHN0eWxlIHRoYXQgd291bGQgYmVuZWZpdFxuXHRcdFx0XHRyZXR1cm4gcmRpc3BsYXlzd2FwLnRlc3QoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgKSAmJlxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrXG5cdFx0XHRcdFx0Ly8gVGFibGUgY29sdW1ucyBpbiBTYWZhcmkgaGF2ZSBub24temVybyBvZmZzZXRXaWR0aCAmIHplcm9cblx0XHRcdFx0XHQvLyBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCB1bmxlc3MgZGlzcGxheSBpcyBjaGFuZ2VkLlxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHRcdFx0XHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGEgZGlzY29ubmVjdGVkIG5vZGVcblx0XHRcdFx0XHQvLyBpbiBJRSB0aHJvd3MgYW4gZXJyb3IuXG5cdFx0XHRcdFx0KCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCB8fCAhZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCApID9cblx0XHRcdFx0XHRcdHN3YXAoIGVsZW0sIGNzc1Nob3csIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKTtcblx0XHRcdFx0XHRcdH0gKSA6XG5cdFx0XHRcdFx0XHRnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSB7XG5cdFx0XHR2YXIgbWF0Y2hlcyxcblx0XHRcdFx0c3R5bGVzID0gZXh0cmEgJiYgZ2V0U3R5bGVzKCBlbGVtICksXG5cdFx0XHRcdHN1YnRyYWN0ID0gZXh0cmEgJiYgYXVnbWVudFdpZHRoT3JIZWlnaHQoXG5cdFx0XHRcdFx0ZWxlbSxcblx0XHRcdFx0XHRuYW1lLFxuXHRcdFx0XHRcdGV4dHJhLFxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0XHRcdFx0c3R5bGVzXG5cdFx0XHRcdCk7XG5cblx0XHRcdC8vIENvbnZlcnQgdG8gcGl4ZWxzIGlmIHZhbHVlIGFkanVzdG1lbnQgaXMgbmVlZGVkXG5cdFx0XHRpZiAoIHN1YnRyYWN0ICYmICggbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmXG5cdFx0XHRcdCggbWF0Y2hlc1sgMyBdIHx8IFwicHhcIiApICE9PSBcInB4XCIgKSB7XG5cblx0XHRcdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApO1xuXHRcdH1cblx0fTtcbn0gKTtcblxualF1ZXJ5LmNzc0hvb2tzLm1hcmdpbkxlZnQgPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucmVsaWFibGVNYXJnaW5MZWZ0LFxuXHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdHJldHVybiAoIHBhcnNlRmxvYXQoIGN1ckNTUyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIgKSApIHx8XG5cdFx0XHRcdGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtXG5cdFx0XHRcdFx0c3dhcCggZWxlbSwgeyBtYXJnaW5MZWZ0OiAwIH0sIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcblx0XHRcdFx0XHR9IClcblx0XHRcdFx0KSArIFwicHhcIjtcblx0XHR9XG5cdH1cbik7XG5cbi8vIFRoZXNlIGhvb2tzIGFyZSB1c2VkIGJ5IGFuaW1hdGUgdG8gZXhwYW5kIHByb3BlcnRpZXNcbmpRdWVyeS5lYWNoKCB7XG5cdG1hcmdpbjogXCJcIixcblx0cGFkZGluZzogXCJcIixcblx0Ym9yZGVyOiBcIldpZHRoXCJcbn0sIGZ1bmN0aW9uKCBwcmVmaXgsIHN1ZmZpeCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXSA9IHtcblx0XHRleHBhbmQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBpID0gMCxcblx0XHRcdFx0ZXhwYW5kZWQgPSB7fSxcblxuXHRcdFx0XHQvLyBBc3N1bWVzIGEgc2luZ2xlIG51bWJlciBpZiBub3QgYSBzdHJpbmdcblx0XHRcdFx0cGFydHMgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZS5zcGxpdCggXCIgXCIgKSA6IFsgdmFsdWUgXTtcblxuXHRcdFx0Zm9yICggOyBpIDwgNDsgaSsrICkge1xuXHRcdFx0XHRleHBhbmRlZFsgcHJlZml4ICsgY3NzRXhwYW5kWyBpIF0gKyBzdWZmaXggXSA9XG5cdFx0XHRcdFx0cGFydHNbIGkgXSB8fCBwYXJ0c1sgaSAtIDIgXSB8fCBwYXJ0c1sgMCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXhwYW5kZWQ7XG5cdFx0fVxuXHR9O1xuXG5cdGlmICggIXJtYXJnaW4udGVzdCggcHJlZml4ICkgKSB7XG5cdFx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXS5zZXQgPSBzZXRQb3NpdGl2ZU51bWJlcjtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGNzczogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdHZhciBzdHlsZXMsIGxlbixcblx0XHRcdFx0bWFwID0ge30sXG5cdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCBuYW1lICkgKSB7XG5cdFx0XHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApO1xuXHRcdFx0XHRsZW4gPSBuYW1lLmxlbmd0aDtcblxuXHRcdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRtYXBbIG5hbWVbIGkgXSBdID0galF1ZXJ5LmNzcyggZWxlbSwgbmFtZVsgaSBdLCBmYWxzZSwgc3R5bGVzICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbWFwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSwgdmFsdWUgKSA6XG5cdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKTtcblx0XHR9LCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fVxufSApO1xuXG5cbmZ1bmN0aW9uIFR3ZWVuKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApIHtcblx0cmV0dXJuIG5ldyBUd2Vlbi5wcm90b3R5cGUuaW5pdCggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKTtcbn1cbmpRdWVyeS5Ud2VlbiA9IFR3ZWVuO1xuXG5Ud2Vlbi5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBUd2Vlbixcblx0aW5pdDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nLCB1bml0ICkge1xuXHRcdHRoaXMuZWxlbSA9IGVsZW07XG5cdFx0dGhpcy5wcm9wID0gcHJvcDtcblx0XHR0aGlzLmVhc2luZyA9IGVhc2luZyB8fCBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0O1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0dGhpcy5zdGFydCA9IHRoaXMubm93ID0gdGhpcy5jdXIoKTtcblx0XHR0aGlzLmVuZCA9IGVuZDtcblx0XHR0aGlzLnVuaXQgPSB1bml0IHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApO1xuXHR9LFxuXHRjdXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRyZXR1cm4gaG9va3MgJiYgaG9va3MuZ2V0ID9cblx0XHRcdGhvb2tzLmdldCggdGhpcyApIDpcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5nZXQoIHRoaXMgKTtcblx0fSxcblx0cnVuOiBmdW5jdGlvbiggcGVyY2VudCApIHtcblx0XHR2YXIgZWFzZWQsXG5cdFx0XHRob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kdXJhdGlvbiApIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBqUXVlcnkuZWFzaW5nWyB0aGlzLmVhc2luZyBdKFxuXHRcdFx0XHRwZXJjZW50LCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKiBwZXJjZW50LCAwLCAxLCB0aGlzLm9wdGlvbnMuZHVyYXRpb25cblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBwZXJjZW50O1xuXHRcdH1cblx0XHR0aGlzLm5vdyA9ICggdGhpcy5lbmQgLSB0aGlzLnN0YXJ0ICkgKiBlYXNlZCArIHRoaXMuc3RhcnQ7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zdGVwICkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnN0ZXAuY2FsbCggdGhpcy5lbGVtLCB0aGlzLm5vdywgdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgaG9va3Muc2V0ICkge1xuXHRcdFx0aG9va3Muc2V0KCB0aGlzICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5zZXQoIHRoaXMgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn07XG5cblR3ZWVuLnByb3RvdHlwZS5pbml0LnByb3RvdHlwZSA9IFR3ZWVuLnByb3RvdHlwZTtcblxuVHdlZW4ucHJvcEhvb2tzID0ge1xuXHRfZGVmYXVsdDoge1xuXHRcdGdldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdFx0dmFyIHJlc3VsdDtcblxuXHRcdFx0Ly8gVXNlIGEgcHJvcGVydHkgb24gdGhlIGVsZW1lbnQgZGlyZWN0bHkgd2hlbiBpdCBpcyBub3QgYSBET00gZWxlbWVudCxcblx0XHRcdC8vIG9yIHdoZW4gdGhlcmUgaXMgbm8gbWF0Y2hpbmcgc3R5bGUgcHJvcGVydHkgdGhhdCBleGlzdHMuXG5cdFx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgIT09IDEgfHxcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdICE9IG51bGwgJiYgdHdlZW4uZWxlbS5zdHlsZVsgdHdlZW4ucHJvcCBdID09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF07XG5cdFx0XHR9XG5cblx0XHRcdC8vIFBhc3NpbmcgYW4gZW1wdHkgc3RyaW5nIGFzIGEgM3JkIHBhcmFtZXRlciB0byAuY3NzIHdpbGwgYXV0b21hdGljYWxseVxuXHRcdFx0Ly8gYXR0ZW1wdCBhIHBhcnNlRmxvYXQgYW5kIGZhbGxiYWNrIHRvIGEgc3RyaW5nIGlmIHRoZSBwYXJzZSBmYWlscy5cblx0XHRcdC8vIFNpbXBsZSB2YWx1ZXMgc3VjaCBhcyBcIjEwcHhcIiBhcmUgcGFyc2VkIHRvIEZsb2F0O1xuXHRcdFx0Ly8gY29tcGxleCB2YWx1ZXMgc3VjaCBhcyBcInJvdGF0ZSgxcmFkKVwiIGFyZSByZXR1cm5lZCBhcy1pcy5cblx0XHRcdHJlc3VsdCA9IGpRdWVyeS5jc3MoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIFwiXCIgKTtcblxuXHRcdFx0Ly8gRW1wdHkgc3RyaW5ncywgbnVsbCwgdW5kZWZpbmVkIGFuZCBcImF1dG9cIiBhcmUgY29udmVydGVkIHRvIDAuXG5cdFx0XHRyZXR1cm4gIXJlc3VsdCB8fCByZXN1bHQgPT09IFwiYXV0b1wiID8gMCA6IHJlc3VsdDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXG5cdFx0XHQvLyBVc2Ugc3RlcCBob29rIGZvciBiYWNrIGNvbXBhdC5cblx0XHRcdC8vIFVzZSBjc3NIb29rIGlmIGl0cyB0aGVyZS5cblx0XHRcdC8vIFVzZSAuc3R5bGUgaWYgYXZhaWxhYmxlIGFuZCB1c2UgcGxhaW4gcHJvcGVydGllcyB3aGVyZSBhdmFpbGFibGUuXG5cdFx0XHRpZiAoIGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0oIHR3ZWVuICk7XG5cdFx0XHR9IGVsc2UgaWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdCggdHdlZW4uZWxlbS5zdHlsZVsgalF1ZXJ5LmNzc1Byb3BzWyB0d2Vlbi5wcm9wIF0gXSAhPSBudWxsIHx8XG5cdFx0XHRcdFx0alF1ZXJ5LmNzc0hvb2tzWyB0d2Vlbi5wcm9wIF0gKSApIHtcblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCB0d2Vlbi5ub3cgKyB0d2Vlbi51bml0ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gUGFuaWMgYmFzZWQgYXBwcm9hY2ggdG8gc2V0dGluZyB0aGluZ3Mgb24gZGlzY29ubmVjdGVkIG5vZGVzXG5Ud2Vlbi5wcm9wSG9va3Muc2Nyb2xsVG9wID0gVHdlZW4ucHJvcEhvb2tzLnNjcm9sbExlZnQgPSB7XG5cdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAmJiB0d2Vlbi5lbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZWFzaW5nID0ge1xuXHRsaW5lYXI6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiBwO1xuXHR9LFxuXHRzd2luZzogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIDAuNSAtIE1hdGguY29zKCBwICogTWF0aC5QSSApIC8gMjtcblx0fSxcblx0X2RlZmF1bHQ6IFwic3dpbmdcIlxufTtcblxualF1ZXJ5LmZ4ID0gVHdlZW4ucHJvdG90eXBlLmluaXQ7XG5cbi8vIEJhY2sgY29tcGF0IDwxLjggZXh0ZW5zaW9uIHBvaW50XG5qUXVlcnkuZnguc3RlcCA9IHt9O1xuXG5cblxuXG52YXJcblx0ZnhOb3csIHRpbWVySWQsXG5cdHJmeHR5cGVzID0gL14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLFxuXHRycnVuID0gL3F1ZXVlSG9va3MkLztcblxuZnVuY3Rpb24gcmFmKCkge1xuXHRpZiAoIHRpbWVySWQgKSB7XG5cdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSggcmFmICk7XG5cdFx0alF1ZXJ5LmZ4LnRpY2soKTtcblx0fVxufVxuXG4vLyBBbmltYXRpb25zIGNyZWF0ZWQgc3luY2hyb25vdXNseSB3aWxsIHJ1biBzeW5jaHJvbm91c2x5XG5mdW5jdGlvbiBjcmVhdGVGeE5vdygpIHtcblx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdGZ4Tm93ID0gdW5kZWZpbmVkO1xuXHR9ICk7XG5cdHJldHVybiAoIGZ4Tm93ID0galF1ZXJ5Lm5vdygpICk7XG59XG5cbi8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXG5mdW5jdGlvbiBnZW5GeCggdHlwZSwgaW5jbHVkZVdpZHRoICkge1xuXHR2YXIgd2hpY2gsXG5cdFx0aSA9IDAsXG5cdFx0YXR0cnMgPSB7IGhlaWdodDogdHlwZSB9O1xuXG5cdC8vIElmIHdlIGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMSB0byBkbyBhbGwgY3NzRXhwYW5kIHZhbHVlcyxcblx0Ly8gb3RoZXJ3aXNlIHN0ZXAgdmFsdWUgaXMgMiB0byBza2lwIG92ZXIgTGVmdCBhbmQgUmlnaHRcblx0aW5jbHVkZVdpZHRoID0gaW5jbHVkZVdpZHRoID8gMSA6IDA7XG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiAtIGluY2x1ZGVXaWR0aCApIHtcblx0XHR3aGljaCA9IGNzc0V4cGFuZFsgaSBdO1xuXHRcdGF0dHJzWyBcIm1hcmdpblwiICsgd2hpY2ggXSA9IGF0dHJzWyBcInBhZGRpbmdcIiArIHdoaWNoIF0gPSB0eXBlO1xuXHR9XG5cblx0aWYgKCBpbmNsdWRlV2lkdGggKSB7XG5cdFx0YXR0cnMub3BhY2l0eSA9IGF0dHJzLndpZHRoID0gdHlwZTtcblx0fVxuXG5cdHJldHVybiBhdHRycztcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHdlZW4oIHZhbHVlLCBwcm9wLCBhbmltYXRpb24gKSB7XG5cdHZhciB0d2Vlbixcblx0XHRjb2xsZWN0aW9uID0gKCBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXSApLmNvbmNhdCggQW5pbWF0aW9uLnR3ZWVuZXJzWyBcIipcIiBdICksXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGlmICggKCB0d2VlbiA9IGNvbGxlY3Rpb25bIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBwcm9wLCB2YWx1ZSApICkgKSB7XG5cblx0XHRcdC8vIFdlJ3JlIGRvbmUgd2l0aCB0aGlzIHByb3BlcnR5XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRQcmVmaWx0ZXIoIGVsZW0sIHByb3BzLCBvcHRzICkge1xuXHR2YXIgcHJvcCwgdmFsdWUsIHRvZ2dsZSwgaG9va3MsIG9sZGZpcmUsIHByb3BUd2VlbiwgcmVzdG9yZURpc3BsYXksIGRpc3BsYXksXG5cdFx0aXNCb3ggPSBcIndpZHRoXCIgaW4gcHJvcHMgfHwgXCJoZWlnaHRcIiBpbiBwcm9wcyxcblx0XHRhbmltID0gdGhpcyxcblx0XHRvcmlnID0ge30sXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlLFxuXHRcdGhpZGRlbiA9IGVsZW0ubm9kZVR5cGUgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICksXG5cdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZnhzaG93XCIgKTtcblxuXHQvLyBRdWV1ZS1za2lwcGluZyBhbmltYXRpb25zIGhpamFjayB0aGUgZnggaG9va3Ncblx0aWYgKCAhb3B0cy5xdWV1ZSApIHtcblx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgXCJmeFwiICk7XG5cdFx0aWYgKCBob29rcy51bnF1ZXVlZCA9PSBudWxsICkge1xuXHRcdFx0aG9va3MudW5xdWV1ZWQgPSAwO1xuXHRcdFx0b2xkZmlyZSA9IGhvb2tzLmVtcHR5LmZpcmU7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIWhvb2tzLnVucXVldWVkICkge1xuXHRcdFx0XHRcdG9sZGZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0aG9va3MudW5xdWV1ZWQrKztcblxuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5zdXJlIHRoZSBjb21wbGV0ZSBoYW5kbGVyIGlzIGNhbGxlZCBiZWZvcmUgdGhpcyBjb21wbGV0ZXNcblx0XHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aG9va3MudW5xdWV1ZWQtLTtcblx0XHRcdFx0aWYgKCAhalF1ZXJ5LnF1ZXVlKCBlbGVtLCBcImZ4XCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gRGV0ZWN0IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdGZvciAoIHByb3AgaW4gcHJvcHMgKSB7XG5cdFx0dmFsdWUgPSBwcm9wc1sgcHJvcCBdO1xuXHRcdGlmICggcmZ4dHlwZXMudGVzdCggdmFsdWUgKSApIHtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgcHJvcCBdO1xuXHRcdFx0dG9nZ2xlID0gdG9nZ2xlIHx8IHZhbHVlID09PSBcInRvZ2dsZVwiO1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gKCBoaWRkZW4gPyBcImhpZGVcIiA6IFwic2hvd1wiICkgKSB7XG5cblx0XHRcdFx0Ly8gUHJldGVuZCB0byBiZSBoaWRkZW4gaWYgdGhpcyBpcyBhIFwic2hvd1wiIGFuZFxuXHRcdFx0XHQvLyB0aGVyZSBpcyBzdGlsbCBkYXRhIGZyb20gYSBzdG9wcGVkIHNob3cvaGlkZVxuXHRcdFx0XHRpZiAoIHZhbHVlID09PSBcInNob3dcIiAmJiBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gdHJ1ZTtcblxuXHRcdFx0XHQvLyBJZ25vcmUgYWxsIG90aGVyIG5vLW9wIHNob3cvaGlkZSBkYXRhXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG9yaWdbIHByb3AgXSA9IGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gfHwgalF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQmFpbCBvdXQgaWYgdGhpcyBpcyBhIG5vLW9wIGxpa2UgLmhpZGUoKS5oaWRlKClcblx0cHJvcFR3ZWVuID0gIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wcyApO1xuXHRpZiAoICFwcm9wVHdlZW4gJiYgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIG9yaWcgKSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBSZXN0cmljdCBcIm92ZXJmbG93XCIgYW5kIFwiZGlzcGxheVwiIHN0eWxlcyBkdXJpbmcgYm94IGFuaW1hdGlvbnNcblx0aWYgKCBpc0JveCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxM1xuXHRcdC8vIFJlY29yZCBhbGwgMyBvdmVyZmxvdyBhdHRyaWJ1dGVzIGJlY2F1c2UgSUUgZG9lcyBub3QgaW5mZXIgdGhlIHNob3J0aGFuZFxuXHRcdC8vIGZyb20gaWRlbnRpY2FsbHktdmFsdWVkIG92ZXJmbG93WCBhbmQgb3ZlcmZsb3dZXG5cdFx0b3B0cy5vdmVyZmxvdyA9IFsgc3R5bGUub3ZlcmZsb3csIHN0eWxlLm92ZXJmbG93WCwgc3R5bGUub3ZlcmZsb3dZIF07XG5cblx0XHQvLyBJZGVudGlmeSBhIGRpc3BsYXkgdHlwZSwgcHJlZmVycmluZyBvbGQgc2hvdy9oaWRlIGRhdGEgb3ZlciB0aGUgQ1NTIGNhc2NhZGVcblx0XHRyZXN0b3JlRGlzcGxheSA9IGRhdGFTaG93ICYmIGRhdGFTaG93LmRpc3BsYXk7XG5cdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0fVxuXHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ICkge1xuXHRcdFx0XHRkaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEdldCBub25lbXB0eSB2YWx1ZShzKSBieSB0ZW1wb3JhcmlseSBmb3JjaW5nIHZpc2liaWxpdHlcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG5cdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5IHx8IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQW5pbWF0ZSBpbmxpbmUgZWxlbWVudHMgYXMgaW5saW5lLWJsb2NrXG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcImlubGluZVwiIHx8IGRpc3BsYXkgPT09IFwiaW5saW5lLWJsb2NrXCIgJiYgcmVzdG9yZURpc3BsYXkgIT0gbnVsbCApIHtcblx0XHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJmbG9hdFwiICkgPT09IFwibm9uZVwiICkge1xuXG5cdFx0XHRcdC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIGRpc3BsYXkgdmFsdWUgYXQgdGhlIGVuZCBvZiBwdXJlIHNob3cvaGlkZSBhbmltYXRpb25zXG5cdFx0XHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRkaXNwbGF5ID0gc3R5bGUuZGlzcGxheTtcblx0XHRcdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGlzcGxheSA9PT0gXCJub25lXCIgPyBcIlwiIDogZGlzcGxheTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBvcHRzLm92ZXJmbG93ICkge1xuXHRcdHN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRzdHlsZS5vdmVyZmxvdyA9IG9wdHMub3ZlcmZsb3dbIDAgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WCA9IG9wdHMub3ZlcmZsb3dbIDEgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WSA9IG9wdHMub3ZlcmZsb3dbIDIgXTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBJbXBsZW1lbnQgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0cHJvcFR3ZWVuID0gZmFsc2U7XG5cdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblxuXHRcdC8vIEdlbmVyYWwgc2hvdy9oaWRlIHNldHVwIGZvciB0aGlzIGVsZW1lbnQgYW5pbWF0aW9uXG5cdFx0aWYgKCAhcHJvcFR3ZWVuICkge1xuXHRcdFx0aWYgKCBkYXRhU2hvdyApIHtcblx0XHRcdFx0aWYgKCBcImhpZGRlblwiIGluIGRhdGFTaG93ICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IGRhdGFTaG93LmhpZGRlbjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIFwiZnhzaG93XCIsIHsgZGlzcGxheTogcmVzdG9yZURpc3BsYXkgfSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdG9yZSBoaWRkZW4vdmlzaWJsZSBmb3IgdG9nZ2xlIHNvIGAuc3RvcCgpLnRvZ2dsZSgpYCBcInJldmVyc2VzXCJcblx0XHRcdGlmICggdG9nZ2xlICkge1xuXHRcdFx0XHRkYXRhU2hvdy5oaWRkZW4gPSAhaGlkZGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTaG93IGVsZW1lbnRzIGJlZm9yZSBhbmltYXRpbmcgdGhlbVxuXHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0XHQvLyBUaGUgZmluYWwgc3RlcCBvZiBhIFwiaGlkZVwiIGFuaW1hdGlvbiBpcyBhY3R1YWxseSBoaWRpbmcgdGhlIGVsZW1lbnRcblx0XHRcdFx0aWYgKCAhaGlkZGVuICkge1xuXHRcdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJmeHNob3dcIiApO1xuXHRcdFx0XHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBvcmlnWyBwcm9wIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdC8vIFBlci1wcm9wZXJ0eSBzZXR1cFxuXHRcdHByb3BUd2VlbiA9IGNyZWF0ZVR3ZWVuKCBoaWRkZW4gPyBkYXRhU2hvd1sgcHJvcCBdIDogMCwgcHJvcCwgYW5pbSApO1xuXHRcdGlmICggISggcHJvcCBpbiBkYXRhU2hvdyApICkge1xuXHRcdFx0ZGF0YVNob3dbIHByb3AgXSA9IHByb3BUd2Vlbi5zdGFydDtcblx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRwcm9wVHdlZW4uZW5kID0gcHJvcFR3ZWVuLnN0YXJ0O1xuXHRcdFx0XHRwcm9wVHdlZW4uc3RhcnQgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBwcm9wRmlsdGVyKCBwcm9wcywgc3BlY2lhbEVhc2luZyApIHtcblx0dmFyIGluZGV4LCBuYW1lLCBlYXNpbmcsIHZhbHVlLCBob29rcztcblxuXHQvLyBjYW1lbENhc2UsIHNwZWNpYWxFYXNpbmcgYW5kIGV4cGFuZCBjc3NIb29rIHBhc3Ncblx0Zm9yICggaW5kZXggaW4gcHJvcHMgKSB7XG5cdFx0bmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIGluZGV4ICk7XG5cdFx0ZWFzaW5nID0gc3BlY2lhbEVhc2luZ1sgbmFtZSBdO1xuXHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF07XG5cdFx0aWYgKCBqUXVlcnkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdGVhc2luZyA9IHZhbHVlWyAxIF07XG5cdFx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdID0gdmFsdWVbIDAgXTtcblx0XHR9XG5cblx0XHRpZiAoIGluZGV4ICE9PSBuYW1lICkge1xuXHRcdFx0cHJvcHNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBpbmRleCBdO1xuXHRcdH1cblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF07XG5cdFx0aWYgKCBob29rcyAmJiBcImV4cGFuZFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsdWUgPSBob29rcy5leHBhbmQoIHZhbHVlICk7XG5cdFx0XHRkZWxldGUgcHJvcHNbIG5hbWUgXTtcblxuXHRcdFx0Ly8gTm90IHF1aXRlICQuZXh0ZW5kLCB0aGlzIHdvbid0IG92ZXJ3cml0ZSBleGlzdGluZyBrZXlzLlxuXHRcdFx0Ly8gUmV1c2luZyAnaW5kZXgnIGJlY2F1c2Ugd2UgaGF2ZSB0aGUgY29ycmVjdCBcIm5hbWVcIlxuXHRcdFx0Zm9yICggaW5kZXggaW4gdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggISggaW5kZXggaW4gcHJvcHMgKSApIHtcblx0XHRcdFx0XHRwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyBpbmRleCBdO1xuXHRcdFx0XHRcdHNwZWNpYWxFYXNpbmdbIGluZGV4IF0gPSBlYXNpbmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0c3BlY2lhbEVhc2luZ1sgbmFtZSBdID0gZWFzaW5nO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBBbmltYXRpb24oIGVsZW0sIHByb3BlcnRpZXMsIG9wdGlvbnMgKSB7XG5cdHZhciByZXN1bHQsXG5cdFx0c3RvcHBlZCxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gQW5pbWF0aW9uLnByZWZpbHRlcnMubGVuZ3RoLFxuXHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCkuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRG9uJ3QgbWF0Y2ggZWxlbSBpbiB0aGUgOmFuaW1hdGVkIHNlbGVjdG9yXG5cdFx0XHRkZWxldGUgdGljay5lbGVtO1xuXHRcdH0gKSxcblx0XHR0aWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHZhciBjdXJyZW50VGltZSA9IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRcdHJlbWFpbmluZyA9IE1hdGgubWF4KCAwLCBhbmltYXRpb24uc3RhcnRUaW1lICsgYW5pbWF0aW9uLmR1cmF0aW9uIC0gY3VycmVudFRpbWUgKSxcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuMyBvbmx5XG5cdFx0XHRcdC8vIEFyY2hhaWMgY3Jhc2ggYnVnIHdvbid0IGFsbG93IHVzIHRvIHVzZSBgMSAtICggMC41IHx8IDAgKWAgKCMxMjQ5Nylcblx0XHRcdFx0dGVtcCA9IHJlbWFpbmluZyAvIGFuaW1hdGlvbi5kdXJhdGlvbiB8fCAwLFxuXHRcdFx0XHRwZXJjZW50ID0gMSAtIHRlbXAsXG5cdFx0XHRcdGluZGV4ID0gMCxcblx0XHRcdFx0bGVuZ3RoID0gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGg7XG5cblx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCBwZXJjZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBwZXJjZW50LCByZW1haW5pbmcgXSApO1xuXG5cdFx0XHRpZiAoIHBlcmNlbnQgPCAxICYmIGxlbmd0aCApIHtcblx0XHRcdFx0cmV0dXJuIHJlbWFpbmluZztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiBdICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGFuaW1hdGlvbiA9IGRlZmVycmVkLnByb21pc2UoIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRwcm9wczogalF1ZXJ5LmV4dGVuZCgge30sIHByb3BlcnRpZXMgKSxcblx0XHRcdG9wdHM6IGpRdWVyeS5leHRlbmQoIHRydWUsIHtcblx0XHRcdFx0c3BlY2lhbEVhc2luZzoge30sXG5cdFx0XHRcdGVhc2luZzogalF1ZXJ5LmVhc2luZy5fZGVmYXVsdFxuXHRcdFx0fSwgb3B0aW9ucyApLFxuXHRcdFx0b3JpZ2luYWxQcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxuXHRcdFx0b3JpZ2luYWxPcHRpb25zOiBvcHRpb25zLFxuXHRcdFx0c3RhcnRUaW1lOiBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0ZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG5cdFx0XHR0d2VlbnM6IFtdLFxuXHRcdFx0Y3JlYXRlVHdlZW46IGZ1bmN0aW9uKCBwcm9wLCBlbmQgKSB7XG5cdFx0XHRcdHZhciB0d2VlbiA9IGpRdWVyeS5Ud2VlbiggZWxlbSwgYW5pbWF0aW9uLm9wdHMsIHByb3AsIGVuZCxcblx0XHRcdFx0XHRcdGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmdbIHByb3AgXSB8fCBhbmltYXRpb24ub3B0cy5lYXNpbmcgKTtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVucy5wdXNoKCB0d2VlbiApO1xuXHRcdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0XHR9LFxuXHRcdFx0c3RvcDogZnVuY3Rpb24oIGdvdG9FbmQgKSB7XG5cdFx0XHRcdHZhciBpbmRleCA9IDAsXG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBhcmUgZ29pbmcgdG8gdGhlIGVuZCwgd2Ugd2FudCB0byBydW4gYWxsIHRoZSB0d2VlbnNcblx0XHRcdFx0XHQvLyBvdGhlcndpc2Ugd2Ugc2tpcCB0aGlzIHBhcnRcblx0XHRcdFx0XHRsZW5ndGggPSBnb3RvRW5kID8gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGggOiAwO1xuXHRcdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RvcHBlZCA9IHRydWU7XG5cdFx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIDEgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlc29sdmUgd2hlbiB3ZSBwbGF5ZWQgdGhlIGxhc3QgZnJhbWU7IG90aGVyd2lzZSwgcmVqZWN0XG5cdFx0XHRcdGlmICggZ290b0VuZCApIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0fSApLFxuXHRcdHByb3BzID0gYW5pbWF0aW9uLnByb3BzO1xuXG5cdHByb3BGaWx0ZXIoIHByb3BzLCBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nICk7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRyZXN1bHQgPSBBbmltYXRpb24ucHJlZmlsdGVyc1sgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIGVsZW0sIHByb3BzLCBhbmltYXRpb24ub3B0cyApO1xuXHRcdGlmICggcmVzdWx0ICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcmVzdWx0LnN0b3AgKSApIHtcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCBhbmltYXRpb24uZWxlbSwgYW5pbWF0aW9uLm9wdHMucXVldWUgKS5zdG9wID1cblx0XHRcdFx0XHRqUXVlcnkucHJveHkoIHJlc3VsdC5zdG9wLCByZXN1bHQgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXHR9XG5cblx0alF1ZXJ5Lm1hcCggcHJvcHMsIGNyZWF0ZVR3ZWVuLCBhbmltYXRpb24gKTtcblxuXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBhbmltYXRpb24ub3B0cy5zdGFydCApICkge1xuXHRcdGFuaW1hdGlvbi5vcHRzLnN0YXJ0LmNhbGwoIGVsZW0sIGFuaW1hdGlvbiApO1xuXHR9XG5cblx0alF1ZXJ5LmZ4LnRpbWVyKFxuXHRcdGpRdWVyeS5leHRlbmQoIHRpY2ssIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRhbmltOiBhbmltYXRpb24sXG5cdFx0XHRxdWV1ZTogYW5pbWF0aW9uLm9wdHMucXVldWVcblx0XHR9IClcblx0KTtcblxuXHQvLyBhdHRhY2ggY2FsbGJhY2tzIGZyb20gb3B0aW9uc1xuXHRyZXR1cm4gYW5pbWF0aW9uLnByb2dyZXNzKCBhbmltYXRpb24ub3B0cy5wcm9ncmVzcyApXG5cdFx0LmRvbmUoIGFuaW1hdGlvbi5vcHRzLmRvbmUsIGFuaW1hdGlvbi5vcHRzLmNvbXBsZXRlIClcblx0XHQuZmFpbCggYW5pbWF0aW9uLm9wdHMuZmFpbCApXG5cdFx0LmFsd2F5cyggYW5pbWF0aW9uLm9wdHMuYWx3YXlzICk7XG59XG5cbmpRdWVyeS5BbmltYXRpb24gPSBqUXVlcnkuZXh0ZW5kKCBBbmltYXRpb24sIHtcblxuXHR0d2VlbmVyczoge1xuXHRcdFwiKlwiOiBbIGZ1bmN0aW9uKCBwcm9wLCB2YWx1ZSApIHtcblx0XHRcdHZhciB0d2VlbiA9IHRoaXMuY3JlYXRlVHdlZW4oIHByb3AsIHZhbHVlICk7XG5cdFx0XHRhZGp1c3RDU1MoIHR3ZWVuLmVsZW0sIHByb3AsIHJjc3NOdW0uZXhlYyggdmFsdWUgKSwgdHdlZW4gKTtcblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9IF1cblx0fSxcblxuXHR0d2VlbmVyOiBmdW5jdGlvbiggcHJvcHMsIGNhbGxiYWNrICkge1xuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHByb3BzICkgKSB7XG5cdFx0XHRjYWxsYmFjayA9IHByb3BzO1xuXHRcdFx0cHJvcHMgPSBbIFwiKlwiIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHByb3BzID0gcHJvcHMubWF0Y2goIHJub3RodG1sd2hpdGUgKTtcblx0XHR9XG5cblx0XHR2YXIgcHJvcCxcblx0XHRcdGluZGV4ID0gMCxcblx0XHRcdGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRwcm9wID0gcHJvcHNbIGluZGV4IF07XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSA9IEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0udW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH0sXG5cblx0cHJlZmlsdGVyczogWyBkZWZhdWx0UHJlZmlsdGVyIF0sXG5cblx0cHJlZmlsdGVyOiBmdW5jdGlvbiggY2FsbGJhY2ssIHByZXBlbmQgKSB7XG5cdFx0aWYgKCBwcmVwZW5kICkge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMudW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMucHVzaCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxualF1ZXJ5LnNwZWVkID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGZuICkge1xuXHR2YXIgb3B0ID0gc3BlZWQgJiYgdHlwZW9mIHNwZWVkID09PSBcIm9iamVjdFwiID8galF1ZXJ5LmV4dGVuZCgge30sIHNwZWVkICkgOiB7XG5cdFx0Y29tcGxldGU6IGZuIHx8ICFmbiAmJiBlYXNpbmcgfHxcblx0XHRcdGpRdWVyeS5pc0Z1bmN0aW9uKCBzcGVlZCApICYmIHNwZWVkLFxuXHRcdGR1cmF0aW9uOiBzcGVlZCxcblx0XHRlYXNpbmc6IGZuICYmIGVhc2luZyB8fCBlYXNpbmcgJiYgIWpRdWVyeS5pc0Z1bmN0aW9uKCBlYXNpbmcgKSAmJiBlYXNpbmdcblx0fTtcblxuXHQvLyBHbyB0byB0aGUgZW5kIHN0YXRlIGlmIGZ4IGFyZSBvZmYgb3IgaWYgZG9jdW1lbnQgaXMgaGlkZGVuXG5cdGlmICggalF1ZXJ5LmZ4Lm9mZiB8fCBkb2N1bWVudC5oaWRkZW4gKSB7XG5cdFx0b3B0LmR1cmF0aW9uID0gMDtcblxuXHR9IGVsc2Uge1xuXHRcdGlmICggdHlwZW9mIG9wdC5kdXJhdGlvbiAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdGlmICggb3B0LmR1cmF0aW9uIGluIGpRdWVyeS5meC5zcGVlZHMgKSB7XG5cdFx0XHRcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHNbIG9wdC5kdXJhdGlvbiBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzLl9kZWZhdWx0O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBvcHQucXVldWUgLSB0cnVlL3VuZGVmaW5lZC9udWxsIC0+IFwiZnhcIlxuXHRpZiAoIG9wdC5xdWV1ZSA9PSBudWxsIHx8IG9wdC5xdWV1ZSA9PT0gdHJ1ZSApIHtcblx0XHRvcHQucXVldWUgPSBcImZ4XCI7XG5cdH1cblxuXHQvLyBRdWV1ZWluZ1xuXHRvcHQub2xkID0gb3B0LmNvbXBsZXRlO1xuXG5cdG9wdC5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIG9wdC5vbGQgKSApIHtcblx0XHRcdG9wdC5vbGQuY2FsbCggdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0LnF1ZXVlICkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIG9wdC5xdWV1ZSApO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gb3B0O1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmYWRlVG86IGZ1bmN0aW9uKCBzcGVlZCwgdG8sIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cblx0XHQvLyBTaG93IGFueSBoaWRkZW4gZWxlbWVudHMgYWZ0ZXIgc2V0dGluZyBvcGFjaXR5IHRvIDBcblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGlzSGlkZGVuV2l0aGluVHJlZSApLmNzcyggXCJvcGFjaXR5XCIsIDAgKS5zaG93KClcblxuXHRcdFx0Ly8gQW5pbWF0ZSB0byB0aGUgdmFsdWUgc3BlY2lmaWVkXG5cdFx0XHQuZW5kKCkuYW5pbWF0ZSggeyBvcGFjaXR5OiB0byB9LCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9LFxuXHRhbmltYXRlOiBmdW5jdGlvbiggcHJvcCwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGVtcHR5ID0galF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3AgKSxcblx0XHRcdG9wdGFsbCA9IGpRdWVyeS5zcGVlZCggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSxcblx0XHRcdGRvQW5pbWF0aW9uID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gT3BlcmF0ZSBvbiBhIGNvcHkgb2YgcHJvcCBzbyBwZXItcHJvcGVydHkgZWFzaW5nIHdvbid0IGJlIGxvc3Rcblx0XHRcdFx0dmFyIGFuaW0gPSBBbmltYXRpb24oIHRoaXMsIGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wICksIG9wdGFsbCApO1xuXG5cdFx0XHRcdC8vIEVtcHR5IGFuaW1hdGlvbnMsIG9yIGZpbmlzaGluZyByZXNvbHZlcyBpbW1lZGlhdGVseVxuXHRcdFx0XHRpZiAoIGVtcHR5IHx8IGRhdGFQcml2LmdldCggdGhpcywgXCJmaW5pc2hcIiApICkge1xuXHRcdFx0XHRcdGFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0ZG9BbmltYXRpb24uZmluaXNoID0gZG9BbmltYXRpb247XG5cblx0XHRyZXR1cm4gZW1wdHkgfHwgb3B0YWxsLnF1ZXVlID09PSBmYWxzZSA/XG5cdFx0XHR0aGlzLmVhY2goIGRvQW5pbWF0aW9uICkgOlxuXHRcdFx0dGhpcy5xdWV1ZSggb3B0YWxsLnF1ZXVlLCBkb0FuaW1hdGlvbiApO1xuXHR9LFxuXHRzdG9wOiBmdW5jdGlvbiggdHlwZSwgY2xlYXJRdWV1ZSwgZ290b0VuZCApIHtcblx0XHR2YXIgc3RvcFF1ZXVlID0gZnVuY3Rpb24oIGhvb2tzICkge1xuXHRcdFx0dmFyIHN0b3AgPSBob29rcy5zdG9wO1xuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRzdG9wKCBnb3RvRW5kICk7XG5cdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRnb3RvRW5kID0gY2xlYXJRdWV1ZTtcblx0XHRcdGNsZWFyUXVldWUgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBjbGVhclF1ZXVlICYmIHR5cGUgIT09IGZhbHNlICkge1xuXHRcdFx0dGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZGVxdWV1ZSA9IHRydWUsXG5cdFx0XHRcdGluZGV4ID0gdHlwZSAhPSBudWxsICYmIHR5cGUgKyBcInF1ZXVlSG9va3NcIixcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0ZGF0YSA9IGRhdGFQcml2LmdldCggdGhpcyApO1xuXG5cdFx0XHRpZiAoIGluZGV4ICkge1xuXHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICkge1xuXHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCBpbmRleCBpbiBkYXRhICkge1xuXHRcdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgJiYgcnJ1bi50ZXN0KCBpbmRleCApICkge1xuXHRcdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiZcblx0XHRcdFx0XHQoIHR5cGUgPT0gbnVsbCB8fCB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSApIHtcblxuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIGdvdG9FbmQgKTtcblx0XHRcdFx0XHRkZXF1ZXVlID0gZmFsc2U7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGFydCB0aGUgbmV4dCBpbiB0aGUgcXVldWUgaWYgdGhlIGxhc3Qgc3RlcCB3YXNuJ3QgZm9yY2VkLlxuXHRcdFx0Ly8gVGltZXJzIGN1cnJlbnRseSB3aWxsIGNhbGwgdGhlaXIgY29tcGxldGUgY2FsbGJhY2tzLCB3aGljaFxuXHRcdFx0Ly8gd2lsbCBkZXF1ZXVlIGJ1dCBvbmx5IGlmIHRoZXkgd2VyZSBnb3RvRW5kLlxuXHRcdFx0aWYgKCBkZXF1ZXVlIHx8ICFnb3RvRW5kICkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblx0ZmluaXNoOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRpZiAoIHR5cGUgIT09IGZhbHNlICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpbmRleCxcblx0XHRcdFx0ZGF0YSA9IGRhdGFQcml2LmdldCggdGhpcyApLFxuXHRcdFx0XHRxdWV1ZSA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlXCIgXSxcblx0XHRcdFx0aG9va3MgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgXSxcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0bGVuZ3RoID0gcXVldWUgPyBxdWV1ZS5sZW5ndGggOiAwO1xuXG5cdFx0XHQvLyBFbmFibGUgZmluaXNoaW5nIGZsYWcgb24gcHJpdmF0ZSBkYXRhXG5cdFx0XHRkYXRhLmZpbmlzaCA9IHRydWU7XG5cblx0XHRcdC8vIEVtcHR5IHRoZSBxdWV1ZSBmaXJzdFxuXHRcdFx0alF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBbXSApO1xuXG5cdFx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnN0b3AgKSB7XG5cdFx0XHRcdGhvb2tzLnN0b3AuY2FsbCggdGhpcywgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYWN0aXZlIGFuaW1hdGlvbnMsIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJiB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSB7XG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFuaW1hdGlvbnMgaW4gdGhlIG9sZCBxdWV1ZSBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdGlmICggcXVldWVbIGluZGV4IF0gJiYgcXVldWVbIGluZGV4IF0uZmluaXNoICkge1xuXHRcdFx0XHRcdHF1ZXVlWyBpbmRleCBdLmZpbmlzaC5jYWxsKCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVHVybiBvZmYgZmluaXNoaW5nIGZsYWdcblx0XHRcdGRlbGV0ZSBkYXRhLmZpbmlzaDtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJ0b2dnbGVcIiwgXCJzaG93XCIsIFwiaGlkZVwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHR2YXIgY3NzRm4gPSBqUXVlcnkuZm5bIG5hbWUgXTtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHNwZWVkID09IG51bGwgfHwgdHlwZW9mIHNwZWVkID09PSBcImJvb2xlYW5cIiA/XG5cdFx0XHRjc3NGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICkgOlxuXHRcdFx0dGhpcy5hbmltYXRlKCBnZW5GeCggbmFtZSwgdHJ1ZSApLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG4vLyBHZW5lcmF0ZSBzaG9ydGN1dHMgZm9yIGN1c3RvbSBhbmltYXRpb25zXG5qUXVlcnkuZWFjaCgge1xuXHRzbGlkZURvd246IGdlbkZ4KCBcInNob3dcIiApLFxuXHRzbGlkZVVwOiBnZW5GeCggXCJoaWRlXCIgKSxcblx0c2xpZGVUb2dnbGU6IGdlbkZ4KCBcInRvZ2dsZVwiICksXG5cdGZhZGVJbjogeyBvcGFjaXR5OiBcInNob3dcIiB9LFxuXHRmYWRlT3V0OiB7IG9wYWNpdHk6IFwiaGlkZVwiIH0sXG5cdGZhZGVUb2dnbGU6IHsgb3BhY2l0eTogXCJ0b2dnbGVcIiB9XG59LCBmdW5jdGlvbiggbmFtZSwgcHJvcHMgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLmFuaW1hdGUoIHByb3BzLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkudGltZXJzID0gW107XG5qUXVlcnkuZngudGljayA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgdGltZXIsXG5cdFx0aSA9IDAsXG5cdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycztcblxuXHRmeE5vdyA9IGpRdWVyeS5ub3coKTtcblxuXHRmb3IgKCA7IGkgPCB0aW1lcnMubGVuZ3RoOyBpKysgKSB7XG5cdFx0dGltZXIgPSB0aW1lcnNbIGkgXTtcblxuXHRcdC8vIENoZWNrcyB0aGUgdGltZXIgaGFzIG5vdCBhbHJlYWR5IGJlZW4gcmVtb3ZlZFxuXHRcdGlmICggIXRpbWVyKCkgJiYgdGltZXJzWyBpIF0gPT09IHRpbWVyICkge1xuXHRcdFx0dGltZXJzLnNwbGljZSggaS0tLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCAhdGltZXJzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZnguc3RvcCgpO1xuXHR9XG5cdGZ4Tm93ID0gdW5kZWZpbmVkO1xufTtcblxualF1ZXJ5LmZ4LnRpbWVyID0gZnVuY3Rpb24oIHRpbWVyICkge1xuXHRqUXVlcnkudGltZXJzLnB1c2goIHRpbWVyICk7XG5cdGlmICggdGltZXIoKSApIHtcblx0XHRqUXVlcnkuZnguc3RhcnQoKTtcblx0fSBlbHNlIHtcblx0XHRqUXVlcnkudGltZXJzLnBvcCgpO1xuXHR9XG59O1xuXG5qUXVlcnkuZnguaW50ZXJ2YWwgPSAxMztcbmpRdWVyeS5meC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoICF0aW1lcklkICkge1xuXHRcdHRpbWVySWQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID9cblx0XHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHJhZiApIDpcblx0XHRcdHdpbmRvdy5zZXRJbnRlcnZhbCggalF1ZXJ5LmZ4LnRpY2ssIGpRdWVyeS5meC5pbnRlcnZhbCApO1xuXHR9XG59O1xuXG5qUXVlcnkuZnguc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSApIHtcblx0XHR3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoIHRpbWVySWQgKTtcblx0fSBlbHNlIHtcblx0XHR3aW5kb3cuY2xlYXJJbnRlcnZhbCggdGltZXJJZCApO1xuXHR9XG5cblx0dGltZXJJZCA9IG51bGw7XG59O1xuXG5qUXVlcnkuZnguc3BlZWRzID0ge1xuXHRzbG93OiA2MDAsXG5cdGZhc3Q6IDIwMCxcblxuXHQvLyBEZWZhdWx0IHNwZWVkXG5cdF9kZWZhdWx0OiA0MDBcbn07XG5cblxuLy8gQmFzZWQgb2ZmIG9mIHRoZSBwbHVnaW4gYnkgQ2xpbnQgSGVsZmVycywgd2l0aCBwZXJtaXNzaW9uLlxuLy8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTAwMzI0MDE0NzQ3L2h0dHA6Ly9ibGluZHNpZ25hbHMuY29tL2luZGV4LnBocC8yMDA5LzA3L2pxdWVyeS1kZWxheS9cbmpRdWVyeS5mbi5kZWxheSA9IGZ1bmN0aW9uKCB0aW1lLCB0eXBlICkge1xuXHR0aW1lID0galF1ZXJ5LmZ4ID8galF1ZXJ5LmZ4LnNwZWVkc1sgdGltZSBdIHx8IHRpbWUgOiB0aW1lO1xuXHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUsIGZ1bmN0aW9uKCBuZXh0LCBob29rcyApIHtcblx0XHR2YXIgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCBuZXh0LCB0aW1lICk7XG5cdFx0aG9va3Muc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dCApO1xuXHRcdH07XG5cdH0gKTtcbn07XG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICksXG5cdFx0c2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzZWxlY3RcIiApLFxuXHRcdG9wdCA9IHNlbGVjdC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvcHRpb25cIiApICk7XG5cblx0aW5wdXQudHlwZSA9IFwiY2hlY2tib3hcIjtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4zIG9ubHlcblx0Ly8gRGVmYXVsdCB2YWx1ZSBmb3IgYSBjaGVja2JveCBzaG91bGQgYmUgXCJvblwiXG5cdHN1cHBvcnQuY2hlY2tPbiA9IGlucHV0LnZhbHVlICE9PSBcIlwiO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBNdXN0IGFjY2VzcyBzZWxlY3RlZEluZGV4IHRvIG1ha2UgZGVmYXVsdCBvcHRpb25zIHNlbGVjdFxuXHRzdXBwb3J0Lm9wdFNlbGVjdGVkID0gb3B0LnNlbGVjdGVkO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBBbiBpbnB1dCBsb3NlcyBpdHMgdmFsdWUgYWZ0ZXIgYmVjb21pbmcgYSByYWRpb1xuXHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRpbnB1dC52YWx1ZSA9IFwidFwiO1xuXHRpbnB1dC50eXBlID0gXCJyYWRpb1wiO1xuXHRzdXBwb3J0LnJhZGlvVmFsdWUgPSBpbnB1dC52YWx1ZSA9PT0gXCJ0XCI7XG59ICkoKTtcblxuXG52YXIgYm9vbEhvb2ssXG5cdGF0dHJIYW5kbGUgPSBqUXVlcnkuZXhwci5hdHRySGFuZGxlO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkuYXR0ciwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggdGhpcywgbmFtZSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgYXR0cmlidXRlcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEZhbGxiYWNrIHRvIHByb3Agd2hlbiBhdHRyaWJ1dGVzIGFyZSBub3Qgc3VwcG9ydGVkXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnByb3AoIGVsZW0sIG5hbWUsIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXR0cmlidXRlIGhvb2tzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBsb3dlcmNhc2UgdmVyc2lvblxuXHRcdC8vIEdyYWIgbmVjZXNzYXJ5IGhvb2sgaWYgb25lIGlzIGRlZmluZWRcblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblx0XHRcdGhvb2tzID0galF1ZXJ5LmF0dHJIb29rc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0KCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QoIG5hbWUgKSA/IGJvb2xIb29rIDogdW5kZWZpbmVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgdmFsdWUgKyBcIlwiICk7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0Ly8gTm9uLWV4aXN0ZW50IGF0dHJpYnV0ZXMgcmV0dXJuIG51bGwsIHdlIG5vcm1hbGl6ZSB0byB1bmRlZmluZWRcblx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyB1bmRlZmluZWQgOiByZXQ7XG5cdH0sXG5cblx0YXR0ckhvb2tzOiB7XG5cdFx0dHlwZToge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggIXN1cHBvcnQucmFkaW9WYWx1ZSAmJiB2YWx1ZSA9PT0gXCJyYWRpb1wiICYmXG5cdFx0XHRcdFx0alF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHR2YXIgdmFsID0gZWxlbS52YWx1ZTtcblx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIHZhbHVlICk7XG5cdFx0XHRcdFx0aWYgKCB2YWwgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnZhbHVlID0gdmFsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdHZhciBuYW1lLFxuXHRcdFx0aSA9IDAsXG5cblx0XHRcdC8vIEF0dHJpYnV0ZSBuYW1lcyBjYW4gY29udGFpbiBub24tSFRNTCB3aGl0ZXNwYWNlIGNoYXJhY3RlcnNcblx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2F0dHJpYnV0ZXMtMlxuXHRcdFx0YXR0ck5hbWVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKTtcblxuXHRcdGlmICggYXR0ck5hbWVzICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHR3aGlsZSAoICggbmFtZSA9IGF0dHJOYW1lc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIG5hbWUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSG9va3MgZm9yIGJvb2xlYW4gYXR0cmlidXRlc1xuYm9vbEhvb2sgPSB7XG5cdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xuXHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdoZW4gc2V0IHRvIGZhbHNlXG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgbmFtZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gbmFtZTtcblx0fVxufTtcblxualF1ZXJ5LmVhY2goIGpRdWVyeS5leHByLm1hdGNoLmJvb2wuc291cmNlLm1hdGNoKCAvXFx3Ky9nICksIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHR2YXIgZ2V0dGVyID0gYXR0ckhhbmRsZVsgbmFtZSBdIHx8IGpRdWVyeS5maW5kLmF0dHI7XG5cblx0YXR0ckhhbmRsZVsgbmFtZSBdID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciByZXQsIGhhbmRsZSxcblx0XHRcdGxvd2VyY2FzZU5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRpZiAoICFpc1hNTCApIHtcblxuXHRcdFx0Ly8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcCBieSB0ZW1wb3JhcmlseSByZW1vdmluZyB0aGlzIGZ1bmN0aW9uIGZyb20gdGhlIGdldHRlclxuXHRcdFx0aGFuZGxlID0gYXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdO1xuXHRcdFx0YXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gcmV0O1xuXHRcdFx0cmV0ID0gZ2V0dGVyKCBlbGVtLCBuYW1lLCBpc1hNTCApICE9IG51bGwgP1xuXHRcdFx0XHRsb3dlcmNhc2VOYW1lIDpcblx0XHRcdFx0bnVsbDtcblx0XHRcdGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXSA9IGhhbmRsZTtcblx0XHR9XG5cdFx0cmV0dXJuIHJldDtcblx0fTtcbn0gKTtcblxuXG5cblxudmFyIHJmb2N1c2FibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyY2xpY2thYmxlID0gL14oPzphfGFyZWEpJC9pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkucHJvcCwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlUHJvcDogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkZWxldGUgdGhpc1sgalF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lIF07XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBwcm9wZXJ0aWVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIEZpeCBuYW1lIGFuZCBhdHRhY2ggaG9va3Ncblx0XHRcdG5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5wcm9wSG9va3NbIG5hbWUgXTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gKCBlbGVtWyBuYW1lIF0gPSB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldHVybiBlbGVtWyBuYW1lIF07XG5cdH0sXG5cblx0cHJvcEhvb2tzOiB7XG5cdFx0dGFiSW5kZXg6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHRcdFx0XHQvLyBlbGVtLnRhYkluZGV4IGRvZXNuJ3QgYWx3YXlzIHJldHVybiB0aGVcblx0XHRcdFx0Ly8gY29ycmVjdCB2YWx1ZSB3aGVuIGl0IGhhc24ndCBiZWVuIGV4cGxpY2l0bHkgc2V0XG5cdFx0XHRcdC8vIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDE0MTExNjIzMzM0Ny9odHRwOi8vZmx1aWRwcm9qZWN0Lm9yZy9ibG9nLzIwMDgvMDEvMDkvZ2V0dGluZy1zZXR0aW5nLWFuZC1yZW1vdmluZy10YWJpbmRleC12YWx1ZXMtd2l0aC1qYXZhc2NyaXB0L1xuXHRcdFx0XHQvLyBVc2UgcHJvcGVyIGF0dHJpYnV0ZSByZXRyaWV2YWwoIzEyMDcyKVxuXHRcdFx0XHR2YXIgdGFiaW5kZXggPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInRhYmluZGV4XCIgKTtcblxuXHRcdFx0XHRpZiAoIHRhYmluZGV4ICkge1xuXHRcdFx0XHRcdHJldHVybiBwYXJzZUludCggdGFiaW5kZXgsIDEwICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0cmZvY3VzYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgfHxcblx0XHRcdFx0XHRyY2xpY2thYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSAmJlxuXHRcdFx0XHRcdGVsZW0uaHJlZlxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cHJvcEZpeDoge1xuXHRcdFwiZm9yXCI6IFwiaHRtbEZvclwiLFxuXHRcdFwiY2xhc3NcIjogXCJjbGFzc05hbWVcIlxuXHR9XG59ICk7XG5cbi8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuLy8gQWNjZXNzaW5nIHRoZSBzZWxlY3RlZEluZGV4IHByb3BlcnR5XG4vLyBmb3JjZXMgdGhlIGJyb3dzZXIgdG8gcmVzcGVjdCBzZXR0aW5nIHNlbGVjdGVkXG4vLyBvbiB0aGUgb3B0aW9uXG4vLyBUaGUgZ2V0dGVyIGVuc3VyZXMgYSBkZWZhdWx0IG9wdGlvbiBpcyBzZWxlY3RlZFxuLy8gd2hlbiBpbiBhbiBvcHRncm91cFxuLy8gZXNsaW50IHJ1bGUgXCJuby11bnVzZWQtZXhwcmVzc2lvbnNcIiBpcyBkaXNhYmxlZCBmb3IgdGhpcyBjb2RlXG4vLyBzaW5jZSBpdCBjb25zaWRlcnMgc3VjaCBhY2Nlc3Npb25zIG5vb3BcbmlmICggIXN1cHBvcnQub3B0U2VsZWN0ZWQgKSB7XG5cdGpRdWVyeS5wcm9wSG9va3Muc2VsZWN0ZWQgPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0LyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xuXG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgJiYgcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFwib2ZmXCIgKi9cblxuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRwYXJlbnQuc2VsZWN0ZWRJbmRleDtcblxuXHRcdFx0XHRpZiAoIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbmpRdWVyeS5lYWNoKCBbXG5cdFwidGFiSW5kZXhcIixcblx0XCJyZWFkT25seVwiLFxuXHRcIm1heExlbmd0aFwiLFxuXHRcImNlbGxTcGFjaW5nXCIsXG5cdFwiY2VsbFBhZGRpbmdcIixcblx0XCJyb3dTcGFuXCIsXG5cdFwiY29sU3BhblwiLFxuXHRcInVzZU1hcFwiLFxuXHRcImZyYW1lQm9yZGVyXCIsXG5cdFwiY29udGVudEVkaXRhYmxlXCJcbl0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkucHJvcEZpeFsgdGhpcy50b0xvd2VyQ2FzZSgpIF0gPSB0aGlzO1xufSApO1xuXG5cblxuXG5cdC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlIGFjY29yZGluZyB0byBIVE1MIHNwZWNcblx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5mcmFzdHJ1Y3R1cmUuaHRtbCNzdHJpcC1hbmQtY29sbGFwc2Utd2hpdGVzcGFjZVxuXHRmdW5jdGlvbiBzdHJpcEFuZENvbGxhcHNlKCB2YWx1ZSApIHtcblx0XHR2YXIgdG9rZW5zID0gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblx0XHRyZXR1cm4gdG9rZW5zLmpvaW4oIFwiIFwiICk7XG5cdH1cblxuXG5mdW5jdGlvbiBnZXRDbGFzcyggZWxlbSApIHtcblx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlICYmIGVsZW0uZ2V0QXR0cmlidXRlKCBcImNsYXNzXCIgKSB8fCBcIlwiO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGFkZENsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmFkZENsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZSApIHtcblx0XHRcdGNsYXNzZXMgPSB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggY3VyVmFsdWUgKSArIFwiIFwiICk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcblx0XHRcdFx0XHRcdGlmICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApIDwgMCApIHtcblx0XHRcdFx0XHRcdFx0Y3VyICs9IGNsYXp6ICsgXCIgXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZW1vdmVDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5yZW1vdmVDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB0aGlzLmF0dHIoIFwiY2xhc3NcIiwgXCJcIiApO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlICkge1xuXHRcdFx0Y2xhc3NlcyA9IHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cblx0XHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggZWxlbSApO1xuXG5cdFx0XHRcdC8vIFRoaXMgZXhwcmVzc2lvbiBpcyBoZXJlIGZvciBiZXR0ZXIgY29tcHJlc3NpYmlsaXR5IChzZWUgYWRkQ2xhc3MpXG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGN1clZhbHVlICkgKyBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSAqYWxsKiBpbnN0YW5jZXNcblx0XHRcdFx0XHRcdHdoaWxlICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciA9IGN1ci5yZXBsYWNlKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIsIFwiIFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR0b2dnbGVDbGFzczogZnVuY3Rpb24oIHZhbHVlLCBzdGF0ZVZhbCApIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdGlmICggdHlwZW9mIHN0YXRlVmFsID09PSBcImJvb2xlYW5cIiAmJiB0eXBlID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlVmFsID8gdGhpcy5hZGRDbGFzcyggdmFsdWUgKSA6IHRoaXMucmVtb3ZlQ2xhc3MoIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS50b2dnbGVDbGFzcyhcblx0XHRcdFx0XHR2YWx1ZS5jYWxsKCB0aGlzLCBpLCBnZXRDbGFzcyggdGhpcyApLCBzdGF0ZVZhbCApLFxuXHRcdFx0XHRcdHN0YXRlVmFsXG5cdFx0XHRcdCk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2xhc3NOYW1lLCBpLCBzZWxmLCBjbGFzc05hbWVzO1xuXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0Ly8gVG9nZ2xlIGluZGl2aWR1YWwgY2xhc3MgbmFtZXNcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdHNlbGYgPSBqUXVlcnkoIHRoaXMgKTtcblx0XHRcdFx0Y2xhc3NOYW1lcyA9IHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cblx0XHRcdFx0d2hpbGUgKCAoIGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbIGkrKyBdICkgKSB7XG5cblx0XHRcdFx0XHQvLyBDaGVjayBlYWNoIGNsYXNzTmFtZSBnaXZlbiwgc3BhY2Ugc2VwYXJhdGVkIGxpc3Rcblx0XHRcdFx0XHRpZiAoIHNlbGYuaGFzQ2xhc3MoIGNsYXNzTmFtZSApICkge1xuXHRcdFx0XHRcdFx0c2VsZi5yZW1vdmVDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNlbGYuYWRkQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBUb2dnbGUgd2hvbGUgY2xhc3MgbmFtZVxuXHRcdFx0fSBlbHNlIGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdFx0Y2xhc3NOYW1lID0gZ2V0Q2xhc3MoIHRoaXMgKTtcblx0XHRcdFx0aWYgKCBjbGFzc05hbWUgKSB7XG5cblx0XHRcdFx0XHQvLyBTdG9yZSBjbGFzc05hbWUgaWYgc2V0XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiwgY2xhc3NOYW1lICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiB0aGUgZWxlbWVudCBoYXMgYSBjbGFzcyBuYW1lIG9yIGlmIHdlJ3JlIHBhc3NlZCBgZmFsc2VgLFxuXHRcdFx0XHQvLyB0aGVuIHJlbW92ZSB0aGUgd2hvbGUgY2xhc3NuYW1lIChpZiB0aGVyZSB3YXMgb25lLCB0aGUgYWJvdmUgc2F2ZWQgaXQpLlxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYnJpbmcgYmFjayB3aGF0ZXZlciB3YXMgcHJldmlvdXNseSBzYXZlZCAoaWYgYW55dGhpbmcpLFxuXHRcdFx0XHQvLyBmYWxsaW5nIGJhY2sgdG8gdGhlIGVtcHR5IHN0cmluZyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG5cdFx0XHRcdGlmICggdGhpcy5zZXRBdHRyaWJ1dGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIixcblx0XHRcdFx0XHRcdGNsYXNzTmFtZSB8fCB2YWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0XHRcdFx0XCJcIiA6XG5cdFx0XHRcdFx0XHRkYXRhUHJpdi5nZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiICkgfHwgXCJcIlxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0aGFzQ2xhc3M6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgY2xhc3NOYW1lLCBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRjbGFzc05hbWUgPSBcIiBcIiArIHNlbGVjdG9yICsgXCIgXCI7XG5cdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdCggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBnZXRDbGFzcyggZWxlbSApICkgKyBcIiBcIiApLmluZGV4T2YoIGNsYXNzTmFtZSApID4gLTEgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBycmV0dXJuID0gL1xcci9nO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHZhbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBob29rcywgcmV0LCBpc0Z1bmN0aW9uLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyBlbGVtLnR5cGUgXSB8fFxuXHRcdFx0XHRcdGpRdWVyeS52YWxIb29rc1sgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdFx0aWYgKCBob29rcyAmJlxuXHRcdFx0XHRcdFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgXCJ2YWx1ZVwiICkgKSAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXQgPSBlbGVtLnZhbHVlO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXNcblx0XHRcdFx0aWYgKCB0eXBlb2YgcmV0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRcdHJldHVybiByZXQucmVwbGFjZSggcnJldHVybiwgXCJcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSGFuZGxlIGNhc2VzIHdoZXJlIHZhbHVlIGlzIG51bGwvdW5kZWYgb3IgbnVtYmVyXG5cdFx0XHRcdHJldHVybiByZXQgPT0gbnVsbCA/IFwiXCIgOiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdHZhciB2YWw7XG5cblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlLmNhbGwoIHRoaXMsIGksIGpRdWVyeSggdGhpcyApLnZhbCgpICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVHJlYXQgbnVsbC91bmRlZmluZWQgYXMgXCJcIjsgY29udmVydCBudW1iZXJzIHRvIHN0cmluZ1xuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0dmFsID0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0dmFsICs9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGpRdWVyeS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0dmFsID0galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKyBcIlwiO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyB0aGlzLnR5cGUgXSB8fCBqUXVlcnkudmFsSG9va3NbIHRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHQvLyBJZiBzZXQgcmV0dXJucyB1bmRlZmluZWQsIGZhbGwgYmFjayB0byBub3JtYWwgc2V0dGluZ1xuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8IGhvb2tzLnNldCggdGhpcywgdmFsLCBcInZhbHVlXCIgKSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHZhbEhvb2tzOiB7XG5cdFx0b3B0aW9uOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdHZhciB2YWwgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInZhbHVlXCIgKTtcblx0XHRcdFx0cmV0dXJuIHZhbCAhPSBudWxsID9cblx0XHRcdFx0XHR2YWwgOlxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExIG9ubHlcblx0XHRcdFx0XHQvLyBvcHRpb24udGV4dCB0aHJvd3MgZXhjZXB0aW9ucyAoIzE0Njg2LCAjMTQ4NTgpXG5cdFx0XHRcdFx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2Vcblx0XHRcdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2Utd2hpdGVzcGFjZVxuXHRcdFx0XHRcdHN0cmlwQW5kQ29sbGFwc2UoIGpRdWVyeS50ZXh0KCBlbGVtICkgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNlbGVjdDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHZhbHVlLCBvcHRpb24sIGksXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHRpbmRleCA9IGVsZW0uc2VsZWN0ZWRJbmRleCxcblx0XHRcdFx0XHRvbmUgPSBlbGVtLnR5cGUgPT09IFwic2VsZWN0LW9uZVwiLFxuXHRcdFx0XHRcdHZhbHVlcyA9IG9uZSA/IG51bGwgOiBbXSxcblx0XHRcdFx0XHRtYXggPSBvbmUgPyBpbmRleCArIDEgOiBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHRpZiAoIGluZGV4IDwgMCApIHtcblx0XHRcdFx0XHRpID0gbWF4O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aSA9IG9uZSA/IGluZGV4IDogMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIHNlbGVjdGVkIG9wdGlvbnNcblx0XHRcdFx0Zm9yICggOyBpIDwgbWF4OyBpKysgKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHQvLyBJRTgtOSBkb2Vzbid0IHVwZGF0ZSBzZWxlY3RlZCBhZnRlciBmb3JtIHJlc2V0ICgjMjU1MSlcblx0XHRcdFx0XHRpZiAoICggb3B0aW9uLnNlbGVjdGVkIHx8IGkgPT09IGluZGV4ICkgJiZcblxuXHRcdFx0XHRcdFx0XHQvLyBEb24ndCByZXR1cm4gb3B0aW9ucyB0aGF0IGFyZSBkaXNhYmxlZCBvciBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHRcdFx0XHRcdCFvcHRpb24uZGlzYWJsZWQgJiZcblx0XHRcdFx0XHRcdFx0KCAhb3B0aW9uLnBhcmVudE5vZGUuZGlzYWJsZWQgfHxcblx0XHRcdFx0XHRcdFx0XHQhalF1ZXJ5Lm5vZGVOYW1lKCBvcHRpb24ucGFyZW50Tm9kZSwgXCJvcHRncm91cFwiICkgKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gR2V0IHRoZSBzcGVjaWZpYyB2YWx1ZSBmb3IgdGhlIG9wdGlvblxuXHRcdFx0XHRcdFx0dmFsdWUgPSBqUXVlcnkoIG9wdGlvbiApLnZhbCgpO1xuXG5cdFx0XHRcdFx0XHQvLyBXZSBkb24ndCBuZWVkIGFuIGFycmF5IGZvciBvbmUgc2VsZWN0c1xuXHRcdFx0XHRcdFx0aWYgKCBvbmUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gTXVsdGktU2VsZWN0cyByZXR1cm4gYW4gYXJyYXlcblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIG9wdGlvblNldCwgb3B0aW9uLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0dmFsdWVzID0galF1ZXJ5Lm1ha2VBcnJheSggdmFsdWUgKSxcblx0XHRcdFx0XHRpID0gb3B0aW9ucy5sZW5ndGg7XG5cblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0LyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cblxuXHRcdFx0XHRcdGlmICggb3B0aW9uLnNlbGVjdGVkID1cblx0XHRcdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBqUXVlcnkudmFsSG9va3Mub3B0aW9uLmdldCggb3B0aW9uICksIHZhbHVlcyApID4gLTFcblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdG9wdGlvblNldCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRm9yY2UgYnJvd3NlcnMgdG8gYmVoYXZlIGNvbnNpc3RlbnRseSB3aGVuIG5vbi1tYXRjaGluZyB2YWx1ZSBpcyBzZXRcblx0XHRcdFx0aWYgKCAhb3B0aW9uU2V0ICkge1xuXHRcdFx0XHRcdGVsZW0uc2VsZWN0ZWRJbmRleCA9IC0xO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIFJhZGlvcyBhbmQgY2hlY2tib3hlcyBnZXR0ZXIvc2V0dGVyXG5qUXVlcnkuZWFjaCggWyBcInJhZGlvXCIsIFwiY2hlY2tib3hcIiBdLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0gPSB7XG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLmNoZWNrZWQgPSBqUXVlcnkuaW5BcnJheSggalF1ZXJ5KCBlbGVtICkudmFsKCksIHZhbHVlICkgPiAtMSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0aWYgKCAhc3VwcG9ydC5jaGVja09uICkge1xuXHRcdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdLmdldCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gbnVsbCA/IFwib25cIiA6IGVsZW0udmFsdWU7XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG4vLyBSZXR1cm4galF1ZXJ5IGZvciBhdHRyaWJ1dGVzLW9ubHkgaW5jbHVzaW9uXG5cblxudmFyIHJmb2N1c01vcnBoID0gL14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvO1xuXG5qUXVlcnkuZXh0ZW5kKCBqUXVlcnkuZXZlbnQsIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggZXZlbnQsIGRhdGEsIGVsZW0sIG9ubHlIYW5kbGVycyApIHtcblxuXHRcdHZhciBpLCBjdXIsIHRtcCwgYnViYmxlVHlwZSwgb250eXBlLCBoYW5kbGUsIHNwZWNpYWwsXG5cdFx0XHRldmVudFBhdGggPSBbIGVsZW0gfHwgZG9jdW1lbnQgXSxcblx0XHRcdHR5cGUgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwidHlwZVwiICkgPyBldmVudC50eXBlIDogZXZlbnQsXG5cdFx0XHRuYW1lc3BhY2VzID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcIm5hbWVzcGFjZVwiICkgPyBldmVudC5uYW1lc3BhY2Uuc3BsaXQoIFwiLlwiICkgOiBbXTtcblxuXHRcdGN1ciA9IHRtcCA9IGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50O1xuXG5cdFx0Ly8gRG9uJ3QgZG8gZXZlbnRzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBmb2N1cy9ibHVyIG1vcnBocyB0byBmb2N1c2luL291dDsgZW5zdXJlIHdlJ3JlIG5vdCBmaXJpbmcgdGhlbSByaWdodCBub3dcblx0XHRpZiAoIHJmb2N1c01vcnBoLnRlc3QoIHR5cGUgKyBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlLmluZGV4T2YoIFwiLlwiICkgPiAtMSApIHtcblxuXHRcdFx0Ly8gTmFtZXNwYWNlZCB0cmlnZ2VyOyBjcmVhdGUgYSByZWdleHAgdG8gbWF0Y2ggZXZlbnQgdHlwZSBpbiBoYW5kbGUoKVxuXHRcdFx0bmFtZXNwYWNlcyA9IHR5cGUuc3BsaXQoIFwiLlwiICk7XG5cdFx0XHR0eXBlID0gbmFtZXNwYWNlcy5zaGlmdCgpO1xuXHRcdFx0bmFtZXNwYWNlcy5zb3J0KCk7XG5cdFx0fVxuXHRcdG9udHlwZSA9IHR5cGUuaW5kZXhPZiggXCI6XCIgKSA8IDAgJiYgXCJvblwiICsgdHlwZTtcblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhIGpRdWVyeS5FdmVudCBvYmplY3QsIE9iamVjdCwgb3IganVzdCBhbiBldmVudCB0eXBlIHN0cmluZ1xuXHRcdGV2ZW50ID0gZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0ZXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggdHlwZSwgdHlwZW9mIGV2ZW50ID09PSBcIm9iamVjdFwiICYmIGV2ZW50ICk7XG5cblx0XHQvLyBUcmlnZ2VyIGJpdG1hc2s6ICYgMSBmb3IgbmF0aXZlIGhhbmRsZXJzOyAmIDIgZm9yIGpRdWVyeSAoYWx3YXlzIHRydWUpXG5cdFx0ZXZlbnQuaXNUcmlnZ2VyID0gb25seUhhbmRsZXJzID8gMiA6IDM7XG5cdFx0ZXZlbnQubmFtZXNwYWNlID0gbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApO1xuXHRcdGV2ZW50LnJuYW1lc3BhY2UgPSBldmVudC5uYW1lc3BhY2UgP1xuXHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICkgOlxuXHRcdFx0bnVsbDtcblxuXHRcdC8vIENsZWFuIHVwIHRoZSBldmVudCBpbiBjYXNlIGl0IGlzIGJlaW5nIHJldXNlZFxuXHRcdGV2ZW50LnJlc3VsdCA9IHVuZGVmaW5lZDtcblx0XHRpZiAoICFldmVudC50YXJnZXQgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBlbGVtO1xuXHRcdH1cblxuXHRcdC8vIENsb25lIGFueSBpbmNvbWluZyBkYXRhIGFuZCBwcmVwZW5kIHRoZSBldmVudCwgY3JlYXRpbmcgdGhlIGhhbmRsZXIgYXJnIGxpc3Rcblx0XHRkYXRhID0gZGF0YSA9PSBudWxsID9cblx0XHRcdFsgZXZlbnQgXSA6XG5cdFx0XHRqUXVlcnkubWFrZUFycmF5KCBkYXRhLCBbIGV2ZW50IF0gKTtcblxuXHRcdC8vIEFsbG93IHNwZWNpYWwgZXZlbnRzIHRvIGRyYXcgb3V0c2lkZSB0aGUgbGluZXNcblx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgc3BlY2lhbC50cmlnZ2VyICYmIHNwZWNpYWwudHJpZ2dlci5hcHBseSggZWxlbSwgZGF0YSApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgZXZlbnQgcHJvcGFnYXRpb24gcGF0aCBpbiBhZHZhbmNlLCBwZXIgVzNDIGV2ZW50cyBzcGVjICgjOTk1MSlcblx0XHQvLyBCdWJibGUgdXAgdG8gZG9jdW1lbnQsIHRoZW4gdG8gd2luZG93OyB3YXRjaCBmb3IgYSBnbG9iYWwgb3duZXJEb2N1bWVudCB2YXIgKCM5NzI0KVxuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhc3BlY2lhbC5ub0J1YmJsZSAmJiAhalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdGJ1YmJsZVR5cGUgPSBzcGVjaWFsLmRlbGVnYXRlVHlwZSB8fCB0eXBlO1xuXHRcdFx0aWYgKCAhcmZvY3VzTW9ycGgudGVzdCggYnViYmxlVHlwZSArIHR5cGUgKSApIHtcblx0XHRcdFx0Y3VyID0gY3VyLnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKCA7IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0dG1wID0gY3VyO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPbmx5IGFkZCB3aW5kb3cgaWYgd2UgZ290IHRvIGRvY3VtZW50IChlLmcuLCBub3QgcGxhaW4gb2JqIG9yIGRldGFjaGVkIERPTSlcblx0XHRcdGlmICggdG1wID09PSAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCApICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggdG1wLmRlZmF1bHRWaWV3IHx8IHRtcC5wYXJlbnRXaW5kb3cgfHwgd2luZG93ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmlyZSBoYW5kbGVycyBvbiB0aGUgZXZlbnQgcGF0aFxuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBjdXIgPSBldmVudFBhdGhbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cblx0XHRcdGV2ZW50LnR5cGUgPSBpID4gMSA/XG5cdFx0XHRcdGJ1YmJsZVR5cGUgOlxuXHRcdFx0XHRzcGVjaWFsLmJpbmRUeXBlIHx8IHR5cGU7XG5cblx0XHRcdC8vIGpRdWVyeSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSAoIGRhdGFQcml2LmdldCggY3VyLCBcImV2ZW50c1wiICkgfHwge30gKVsgZXZlbnQudHlwZSBdICYmXG5cdFx0XHRcdGRhdGFQcml2LmdldCggY3VyLCBcImhhbmRsZVwiICk7XG5cdFx0XHRpZiAoIGhhbmRsZSApIHtcblx0XHRcdFx0aGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTmF0aXZlIGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9IG9udHlwZSAmJiBjdXJbIG9udHlwZSBdO1xuXHRcdFx0aWYgKCBoYW5kbGUgJiYgaGFuZGxlLmFwcGx5ICYmIGFjY2VwdERhdGEoIGN1ciApICkge1xuXHRcdFx0XHRldmVudC5yZXN1bHQgPSBoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRldmVudC50eXBlID0gdHlwZTtcblxuXHRcdC8vIElmIG5vYm9keSBwcmV2ZW50ZWQgdGhlIGRlZmF1bHQgYWN0aW9uLCBkbyBpdCBub3dcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICkge1xuXG5cdFx0XHRpZiAoICggIXNwZWNpYWwuX2RlZmF1bHQgfHxcblx0XHRcdFx0c3BlY2lhbC5fZGVmYXVsdC5hcHBseSggZXZlbnRQYXRoLnBvcCgpLCBkYXRhICkgPT09IGZhbHNlICkgJiZcblx0XHRcdFx0YWNjZXB0RGF0YSggZWxlbSApICkge1xuXG5cdFx0XHRcdC8vIENhbGwgYSBuYXRpdmUgRE9NIG1ldGhvZCBvbiB0aGUgdGFyZ2V0IHdpdGggdGhlIHNhbWUgbmFtZSBhcyB0aGUgZXZlbnQuXG5cdFx0XHRcdC8vIERvbid0IGRvIGRlZmF1bHQgYWN0aW9ucyBvbiB3aW5kb3csIHRoYXQncyB3aGVyZSBnbG9iYWwgdmFyaWFibGVzIGJlICgjNjE3MClcblx0XHRcdFx0aWYgKCBvbnR5cGUgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIGVsZW1bIHR5cGUgXSApICYmICFqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vIERvbid0IHJlLXRyaWdnZXIgYW4gb25GT08gZXZlbnQgd2hlbiB3ZSBjYWxsIGl0cyBGT08oKSBtZXRob2Rcblx0XHRcdFx0XHR0bXAgPSBlbGVtWyBvbnR5cGUgXTtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSBudWxsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZXZlbnQgcmUtdHJpZ2dlcmluZyBvZiB0aGUgc2FtZSBldmVudCwgc2luY2Ugd2UgYWxyZWFkeSBidWJibGVkIGl0IGFib3ZlXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHR5cGU7XG5cdFx0XHRcdFx0ZWxlbVsgdHlwZSBdKCk7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSB0bXA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHQvLyBQaWdneWJhY2sgb24gYSBkb25vciBldmVudCB0byBzaW11bGF0ZSBhIGRpZmZlcmVudCBvbmVcblx0Ly8gVXNlZCBvbmx5IGZvciBgZm9jdXMoaW4gfCBvdXQpYCBldmVudHNcblx0c2ltdWxhdGU6IGZ1bmN0aW9uKCB0eXBlLCBlbGVtLCBldmVudCApIHtcblx0XHR2YXIgZSA9IGpRdWVyeS5leHRlbmQoXG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCksXG5cdFx0XHRldmVudCxcblx0XHRcdHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0aXNTaW11bGF0ZWQ6IHRydWVcblx0XHRcdH1cblx0XHQpO1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIGUsIG51bGwsIGVsZW0gKTtcblx0fVxuXG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCB0aGlzICk7XG5cdFx0fSApO1xuXHR9LFxuXHR0cmlnZ2VySGFuZGxlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF07XG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCBlbGVtLCB0cnVlICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cblxualF1ZXJ5LmVhY2goICggXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgcmVzaXplIHNjcm9sbCBjbGljayBkYmxjbGljayBcIiArXG5cdFwibW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmUgXCIgK1xuXHRcImNoYW5nZSBzZWxlY3Qgc3VibWl0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgY29udGV4dG1lbnVcIiApLnNwbGl0KCBcIiBcIiApLFxuXHRmdW5jdGlvbiggaSwgbmFtZSApIHtcblxuXHQvLyBIYW5kbGUgZXZlbnQgYmluZGluZ1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgP1xuXHRcdFx0dGhpcy5vbiggbmFtZSwgbnVsbCwgZGF0YSwgZm4gKSA6XG5cdFx0XHR0aGlzLnRyaWdnZXIoIG5hbWUgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRob3ZlcjogZnVuY3Rpb24oIGZuT3ZlciwgZm5PdXQgKSB7XG5cdFx0cmV0dXJuIHRoaXMubW91c2VlbnRlciggZm5PdmVyICkubW91c2VsZWF2ZSggZm5PdXQgfHwgZm5PdmVyICk7XG5cdH1cbn0gKTtcblxuXG5cblxuc3VwcG9ydC5mb2N1c2luID0gXCJvbmZvY3VzaW5cIiBpbiB3aW5kb3c7XG5cblxuLy8gU3VwcG9ydDogRmlyZWZveCA8PTQ0XG4vLyBGaXJlZm94IGRvZXNuJ3QgaGF2ZSBmb2N1cyhpbiB8IG91dCkgZXZlbnRzXG4vLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY4Nzc4N1xuLy9cbi8vIFN1cHBvcnQ6IENocm9tZSA8PTQ4IC0gNDksIFNhZmFyaSA8PTkuMCAtIDkuMVxuLy8gZm9jdXMoaW4gfCBvdXQpIGV2ZW50cyBmaXJlIGFmdGVyIGZvY3VzICYgYmx1ciBldmVudHMsXG4vLyB3aGljaCBpcyBzcGVjIHZpb2xhdGlvbiAtIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWZvY3VzZXZlbnQtZXZlbnQtb3JkZXJcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDQ5ODU3XG5pZiAoICFzdXBwb3J0LmZvY3VzaW4gKSB7XG5cdGpRdWVyeS5lYWNoKCB7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cblx0XHQvLyBBdHRhY2ggYSBzaW5nbGUgY2FwdHVyaW5nIGhhbmRsZXIgb24gdGhlIGRvY3VtZW50IHdoaWxlIHNvbWVvbmUgd2FudHMgZm9jdXNpbi9mb2N1c291dFxuXHRcdHZhciBoYW5kbGVyID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnNpbXVsYXRlKCBmaXgsIGV2ZW50LnRhcmdldCwgalF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgKSApO1xuXHRcdH07XG5cblx0XHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZml4IF0gPSB7XG5cdFx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKTtcblxuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHRkb2MuYWRkRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXgsICggYXR0YWNoZXMgfHwgMCApICsgMSApO1xuXHRcdFx0fSxcblx0XHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApIC0gMTtcblxuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHRkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZG9jLCBmaXggKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXgsIGF0dGFjaGVzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9ICk7XG59XG52YXIgbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb247XG5cbnZhciBub25jZSA9IGpRdWVyeS5ub3coKTtcblxudmFyIHJxdWVyeSA9ICggL1xcPy8gKTtcblxuXG5cbi8vIENyb3NzLWJyb3dzZXIgeG1sIHBhcnNpbmdcbmpRdWVyeS5wYXJzZVhNTCA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHR2YXIgeG1sO1xuXHRpZiAoICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcblx0Ly8gSUUgdGhyb3dzIG9uIHBhcnNlRnJvbVN0cmluZyB3aXRoIGludmFsaWQgaW5wdXQuXG5cdHRyeSB7XG5cdFx0eG1sID0gKCBuZXcgd2luZG93LkRPTVBhcnNlcigpICkucGFyc2VGcm9tU3RyaW5nKCBkYXRhLCBcInRleHQveG1sXCIgKTtcblx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0eG1sID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0aWYgKCAheG1sIHx8IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJwYXJzZXJlcnJvclwiICkubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5lcnJvciggXCJJbnZhbGlkIFhNTDogXCIgKyBkYXRhICk7XG5cdH1cblx0cmV0dXJuIHhtbDtcbn07XG5cblxudmFyXG5cdHJicmFja2V0ID0gL1xcW1xcXSQvLFxuXHRyQ1JMRiA9IC9cXHI/XFxuL2csXG5cdHJzdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxcblx0cnN1Ym1pdHRhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xuXG5mdW5jdGlvbiBidWlsZFBhcmFtcyggcHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQgKSB7XG5cdHZhciBuYW1lO1xuXG5cdGlmICggalF1ZXJ5LmlzQXJyYXkoIG9iaiApICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIGFycmF5IGl0ZW0uXG5cdFx0alF1ZXJ5LmVhY2goIG9iaiwgZnVuY3Rpb24oIGksIHYgKSB7XG5cdFx0XHRpZiAoIHRyYWRpdGlvbmFsIHx8IHJicmFja2V0LnRlc3QoIHByZWZpeCApICkge1xuXG5cdFx0XHRcdC8vIFRyZWF0IGVhY2ggYXJyYXkgaXRlbSBhcyBhIHNjYWxhci5cblx0XHRcdFx0YWRkKCBwcmVmaXgsIHYgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBJdGVtIGlzIG5vbi1zY2FsYXIgKGFycmF5IG9yIG9iamVjdCksIGVuY29kZSBpdHMgbnVtZXJpYyBpbmRleC5cblx0XHRcdFx0YnVpbGRQYXJhbXMoXG5cdFx0XHRcdFx0cHJlZml4ICsgXCJbXCIgKyAoIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHYgIT0gbnVsbCA/IGkgOiBcIlwiICkgKyBcIl1cIixcblx0XHRcdFx0XHR2LFxuXHRcdFx0XHRcdHRyYWRpdGlvbmFsLFxuXHRcdFx0XHRcdGFkZFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHR9IGVsc2UgaWYgKCAhdHJhZGl0aW9uYWwgJiYgalF1ZXJ5LnR5cGUoIG9iaiApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCArIFwiW1wiICsgbmFtZSArIFwiXVwiLCBvYmpbIG5hbWUgXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHNjYWxhciBpdGVtLlxuXHRcdGFkZCggcHJlZml4LCBvYmogKTtcblx0fVxufVxuXG4vLyBTZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZlxuLy8ga2V5L3ZhbHVlcyBpbnRvIGEgcXVlcnkgc3RyaW5nXG5qUXVlcnkucGFyYW0gPSBmdW5jdGlvbiggYSwgdHJhZGl0aW9uYWwgKSB7XG5cdHZhciBwcmVmaXgsXG5cdFx0cyA9IFtdLFxuXHRcdGFkZCA9IGZ1bmN0aW9uKCBrZXksIHZhbHVlT3JGdW5jdGlvbiApIHtcblxuXHRcdFx0Ly8gSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaW52b2tlIGl0IGFuZCB1c2UgaXRzIHJldHVybiB2YWx1ZVxuXHRcdFx0dmFyIHZhbHVlID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlT3JGdW5jdGlvbiApID9cblx0XHRcdFx0dmFsdWVPckZ1bmN0aW9uKCkgOlxuXHRcdFx0XHR2YWx1ZU9yRnVuY3Rpb247XG5cblx0XHRcdHNbIHMubGVuZ3RoIF0gPSBlbmNvZGVVUklDb21wb25lbnQoIGtleSApICsgXCI9XCIgK1xuXHRcdFx0XHRlbmNvZGVVUklDb21wb25lbnQoIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKTtcblx0XHR9O1xuXG5cdC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuXG5cdGlmICggalF1ZXJ5LmlzQXJyYXkoIGEgKSB8fCAoIGEuanF1ZXJ5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggYSApICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgdGhlIGZvcm0gZWxlbWVudHNcblx0XHRqUXVlcnkuZWFjaCggYSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRhZGQoIHRoaXMubmFtZSwgdGhpcy52YWx1ZSApO1xuXHRcdH0gKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXCJvbGRcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcblx0XHQvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cblx0XHRmb3IgKCBwcmVmaXggaW4gYSApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXgsIGFbIHByZWZpeCBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSByZXN1bHRpbmcgc2VyaWFsaXphdGlvblxuXHRyZXR1cm4gcy5qb2luKCBcIiZcIiApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnkucGFyYW0oIHRoaXMuc2VyaWFsaXplQXJyYXkoKSApO1xuXHR9LFxuXHRzZXJpYWxpemVBcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gQ2FuIGFkZCBwcm9wSG9vayBmb3IgXCJlbGVtZW50c1wiIHRvIGZpbHRlciBvciBhZGQgZm9ybSBlbGVtZW50c1xuXHRcdFx0dmFyIGVsZW1lbnRzID0galF1ZXJ5LnByb3AoIHRoaXMsIFwiZWxlbWVudHNcIiApO1xuXHRcdFx0cmV0dXJuIGVsZW1lbnRzID8galF1ZXJ5Lm1ha2VBcnJheSggZWxlbWVudHMgKSA6IHRoaXM7XG5cdFx0fSApXG5cdFx0LmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuXHRcdFx0Ly8gVXNlIC5pcyggXCI6ZGlzYWJsZWRcIiApIHNvIHRoYXQgZmllbGRzZXRbZGlzYWJsZWRdIHdvcmtzXG5cdFx0XHRyZXR1cm4gdGhpcy5uYW1lICYmICFqUXVlcnkoIHRoaXMgKS5pcyggXCI6ZGlzYWJsZWRcIiApICYmXG5cdFx0XHRcdHJzdWJtaXR0YWJsZS50ZXN0KCB0aGlzLm5vZGVOYW1lICkgJiYgIXJzdWJtaXR0ZXJUeXBlcy50ZXN0KCB0eXBlICkgJiZcblx0XHRcdFx0KCB0aGlzLmNoZWNrZWQgfHwgIXJjaGVja2FibGVUeXBlLnRlc3QoIHR5cGUgKSApO1xuXHRcdH0gKVxuXHRcdC5tYXAoIGZ1bmN0aW9uKCBpLCBlbGVtICkge1xuXHRcdFx0dmFyIHZhbCA9IGpRdWVyeSggdGhpcyApLnZhbCgpO1xuXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBqUXVlcnkuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdH0gKS5nZXQoKTtcblx0fVxufSApO1xuXG5cbnZhclxuXHRyMjAgPSAvJTIwL2csXG5cdHJoYXNoID0gLyMuKiQvLFxuXHRyYW50aUNhY2hlID0gLyhbPyZdKV89W14mXSovLFxuXHRyaGVhZGVycyA9IC9eKC4qPyk6WyBcXHRdKihbXlxcclxcbl0qKSQvbWcsXG5cblx0Ly8gIzc2NTMsICM4MTI1LCAjODE1MjogbG9jYWwgcHJvdG9jb2wgZGV0ZWN0aW9uXG5cdHJsb2NhbFByb3RvY29sID0gL14oPzphYm91dHxhcHB8YXBwLXN0b3JhZ2V8ListZXh0ZW5zaW9ufGZpbGV8cmVzfHdpZGdldCk6JC8sXG5cdHJub0NvbnRlbnQgPSAvXig/OkdFVHxIRUFEKSQvLFxuXHRycHJvdG9jb2wgPSAvXlxcL1xcLy8sXG5cblx0LyogUHJlZmlsdGVyc1xuXHQgKiAxKSBUaGV5IGFyZSB1c2VmdWwgdG8gaW50cm9kdWNlIGN1c3RvbSBkYXRhVHlwZXMgKHNlZSBhamF4L2pzb25wLmpzIGZvciBhbiBleGFtcGxlKVxuXHQgKiAyKSBUaGVzZSBhcmUgY2FsbGVkOlxuXHQgKiAgICAtIEJFRk9SRSBhc2tpbmcgZm9yIGEgdHJhbnNwb3J0XG5cdCAqICAgIC0gQUZURVIgcGFyYW0gc2VyaWFsaXphdGlvbiAocy5kYXRhIGlzIGEgc3RyaW5nIGlmIHMucHJvY2Vzc0RhdGEgaXMgdHJ1ZSlcblx0ICogMykga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiA0KSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDUpIGV4ZWN1dGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGNvbnRpbnVlIGRvd24gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHRwcmVmaWx0ZXJzID0ge30sXG5cblx0LyogVHJhbnNwb3J0cyBiaW5kaW5nc1xuXHQgKiAxKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDIpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogMykgc2VsZWN0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gZ28gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHR0cmFuc3BvcnRzID0ge30sXG5cblx0Ly8gQXZvaWQgY29tbWVudC1wcm9sb2cgY2hhciBzZXF1ZW5jZSAoIzEwMDk4KTsgbXVzdCBhcHBlYXNlIGxpbnQgYW5kIGV2YWRlIGNvbXByZXNzaW9uXG5cdGFsbFR5cGVzID0gXCIqL1wiLmNvbmNhdCggXCIqXCIgKSxcblxuXHQvLyBBbmNob3IgdGFnIGZvciBwYXJzaW5nIHRoZSBkb2N1bWVudCBvcmlnaW5cblx0b3JpZ2luQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcblx0b3JpZ2luQW5jaG9yLmhyZWYgPSBsb2NhdGlvbi5ocmVmO1xuXG4vLyBCYXNlIFwiY29uc3RydWN0b3JcIiBmb3IgalF1ZXJ5LmFqYXhQcmVmaWx0ZXIgYW5kIGpRdWVyeS5hamF4VHJhbnNwb3J0XG5mdW5jdGlvbiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSApIHtcblxuXHQvLyBkYXRhVHlwZUV4cHJlc3Npb24gaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvIFwiKlwiXG5cdHJldHVybiBmdW5jdGlvbiggZGF0YVR5cGVFeHByZXNzaW9uLCBmdW5jICkge1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVFeHByZXNzaW9uICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZnVuYyA9IGRhdGFUeXBlRXhwcmVzc2lvbjtcblx0XHRcdGRhdGFUeXBlRXhwcmVzc2lvbiA9IFwiKlwiO1xuXHRcdH1cblxuXHRcdHZhciBkYXRhVHlwZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0ZGF0YVR5cGVzID0gZGF0YVR5cGVFeHByZXNzaW9uLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGZ1bmMgKSApIHtcblxuXHRcdFx0Ly8gRm9yIGVhY2ggZGF0YVR5cGUgaW4gdGhlIGRhdGFUeXBlRXhwcmVzc2lvblxuXHRcdFx0d2hpbGUgKCAoIGRhdGFUeXBlID0gZGF0YVR5cGVzWyBpKysgXSApICkge1xuXG5cdFx0XHRcdC8vIFByZXBlbmQgaWYgcmVxdWVzdGVkXG5cdFx0XHRcdGlmICggZGF0YVR5cGVbIDAgXSA9PT0gXCIrXCIgKSB7XG5cdFx0XHRcdFx0ZGF0YVR5cGUgPSBkYXRhVHlwZS5zbGljZSggMSApIHx8IFwiKlwiO1xuXHRcdFx0XHRcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkudW5zaGlmdCggZnVuYyApO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBhcHBlbmRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnB1c2goIGZ1bmMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxuLy8gQmFzZSBpbnNwZWN0aW9uIGZ1bmN0aW9uIGZvciBwcmVmaWx0ZXJzIGFuZCB0cmFuc3BvcnRzXG5mdW5jdGlvbiBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlLCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICkge1xuXG5cdHZhciBpbnNwZWN0ZWQgPSB7fSxcblx0XHRzZWVraW5nVHJhbnNwb3J0ID0gKCBzdHJ1Y3R1cmUgPT09IHRyYW5zcG9ydHMgKTtcblxuXHRmdW5jdGlvbiBpbnNwZWN0KCBkYXRhVHlwZSApIHtcblx0XHR2YXIgc2VsZWN0ZWQ7XG5cdFx0aW5zcGVjdGVkWyBkYXRhVHlwZSBdID0gdHJ1ZTtcblx0XHRqUXVlcnkuZWFjaCggc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdLCBmdW5jdGlvbiggXywgcHJlZmlsdGVyT3JGYWN0b3J5ICkge1xuXHRcdFx0dmFyIGRhdGFUeXBlT3JUcmFuc3BvcnQgPSBwcmVmaWx0ZXJPckZhY3RvcnkoIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKTtcblx0XHRcdGlmICggdHlwZW9mIGRhdGFUeXBlT3JUcmFuc3BvcnQgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXNlZWtpbmdUcmFuc3BvcnQgJiYgIWluc3BlY3RlZFsgZGF0YVR5cGVPclRyYW5zcG9ydCBdICkge1xuXG5cdFx0XHRcdG9wdGlvbnMuZGF0YVR5cGVzLnVuc2hpZnQoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0aW5zcGVjdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IGVsc2UgaWYgKCBzZWVraW5nVHJhbnNwb3J0ICkge1xuXHRcdFx0XHRyZXR1cm4gISggc2VsZWN0ZWQgPSBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdHJldHVybiBzZWxlY3RlZDtcblx0fVxuXG5cdHJldHVybiBpbnNwZWN0KCBvcHRpb25zLmRhdGFUeXBlc1sgMCBdICkgfHwgIWluc3BlY3RlZFsgXCIqXCIgXSAmJiBpbnNwZWN0KCBcIipcIiApO1xufVxuXG4vLyBBIHNwZWNpYWwgZXh0ZW5kIGZvciBhamF4IG9wdGlvbnNcbi8vIHRoYXQgdGFrZXMgXCJmbGF0XCIgb3B0aW9ucyAobm90IHRvIGJlIGRlZXAgZXh0ZW5kZWQpXG4vLyBGaXhlcyAjOTg4N1xuZnVuY3Rpb24gYWpheEV4dGVuZCggdGFyZ2V0LCBzcmMgKSB7XG5cdHZhciBrZXksIGRlZXAsXG5cdFx0ZmxhdE9wdGlvbnMgPSBqUXVlcnkuYWpheFNldHRpbmdzLmZsYXRPcHRpb25zIHx8IHt9O1xuXG5cdGZvciAoIGtleSBpbiBzcmMgKSB7XG5cdFx0aWYgKCBzcmNbIGtleSBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQoIGZsYXRPcHRpb25zWyBrZXkgXSA/IHRhcmdldCA6ICggZGVlcCB8fCAoIGRlZXAgPSB7fSApICkgKVsga2V5IF0gPSBzcmNbIGtleSBdO1xuXHRcdH1cblx0fVxuXHRpZiAoIGRlZXAgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdHJ1ZSwgdGFyZ2V0LCBkZWVwICk7XG5cdH1cblxuXHRyZXR1cm4gdGFyZ2V0O1xufVxuXG4vKiBIYW5kbGVzIHJlc3BvbnNlcyB0byBhbiBhamF4IHJlcXVlc3Q6XG4gKiAtIGZpbmRzIHRoZSByaWdodCBkYXRhVHlwZSAobWVkaWF0ZXMgYmV0d2VlbiBjb250ZW50LXR5cGUgYW5kIGV4cGVjdGVkIGRhdGFUeXBlKVxuICogLSByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKSB7XG5cblx0dmFyIGN0LCB0eXBlLCBmaW5hbERhdGFUeXBlLCBmaXJzdERhdGFUeXBlLFxuXHRcdGNvbnRlbnRzID0gcy5jb250ZW50cyxcblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcztcblxuXHQvLyBSZW1vdmUgYXV0byBkYXRhVHlwZSBhbmQgZ2V0IGNvbnRlbnQtdHlwZSBpbiB0aGUgcHJvY2Vzc1xuXHR3aGlsZSAoIGRhdGFUeXBlc1sgMCBdID09PSBcIipcIiApIHtcblx0XHRkYXRhVHlwZXMuc2hpZnQoKTtcblx0XHRpZiAoIGN0ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRjdCA9IHMubWltZVR5cGUgfHwganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSBrbm93biBjb250ZW50LXR5cGVcblx0aWYgKCBjdCApIHtcblx0XHRmb3IgKCB0eXBlIGluIGNvbnRlbnRzICkge1xuXHRcdFx0aWYgKCBjb250ZW50c1sgdHlwZSBdICYmIGNvbnRlbnRzWyB0eXBlIF0udGVzdCggY3QgKSApIHtcblx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHR5cGUgKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSByZXNwb25zZSBmb3IgdGhlIGV4cGVjdGVkIGRhdGFUeXBlXG5cdGlmICggZGF0YVR5cGVzWyAwIF0gaW4gcmVzcG9uc2VzICkge1xuXHRcdGZpbmFsRGF0YVR5cGUgPSBkYXRhVHlwZXNbIDAgXTtcblx0fSBlbHNlIHtcblxuXHRcdC8vIFRyeSBjb252ZXJ0aWJsZSBkYXRhVHlwZXNcblx0XHRmb3IgKCB0eXBlIGluIHJlc3BvbnNlcyApIHtcblx0XHRcdGlmICggIWRhdGFUeXBlc1sgMCBdIHx8IHMuY29udmVydGVyc1sgdHlwZSArIFwiIFwiICsgZGF0YVR5cGVzWyAwIF0gXSApIHtcblx0XHRcdFx0ZmluYWxEYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhZmlyc3REYXRhVHlwZSApIHtcblx0XHRcdFx0Zmlyc3REYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gT3IganVzdCB1c2UgZmlyc3Qgb25lXG5cdFx0ZmluYWxEYXRhVHlwZSA9IGZpbmFsRGF0YVR5cGUgfHwgZmlyc3REYXRhVHlwZTtcblx0fVxuXG5cdC8vIElmIHdlIGZvdW5kIGEgZGF0YVR5cGVcblx0Ly8gV2UgYWRkIHRoZSBkYXRhVHlwZSB0byB0aGUgbGlzdCBpZiBuZWVkZWRcblx0Ly8gYW5kIHJldHVybiB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuXHRpZiAoIGZpbmFsRGF0YVR5cGUgKSB7XG5cdFx0aWYgKCBmaW5hbERhdGFUeXBlICE9PSBkYXRhVHlwZXNbIDAgXSApIHtcblx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCBmaW5hbERhdGFUeXBlICk7XG5cdFx0fVxuXHRcdHJldHVybiByZXNwb25zZXNbIGZpbmFsRGF0YVR5cGUgXTtcblx0fVxufVxuXG4vKiBDaGFpbiBjb252ZXJzaW9ucyBnaXZlbiB0aGUgcmVxdWVzdCBhbmQgdGhlIG9yaWdpbmFsIHJlc3BvbnNlXG4gKiBBbHNvIHNldHMgdGhlIHJlc3BvbnNlWFhYIGZpZWxkcyBvbiB0aGUganFYSFIgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICkge1xuXHR2YXIgY29udjIsIGN1cnJlbnQsIGNvbnYsIHRtcCwgcHJldixcblx0XHRjb252ZXJ0ZXJzID0ge30sXG5cblx0XHQvLyBXb3JrIHdpdGggYSBjb3B5IG9mIGRhdGFUeXBlcyBpbiBjYXNlIHdlIG5lZWQgdG8gbW9kaWZ5IGl0IGZvciBjb252ZXJzaW9uXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXMuc2xpY2UoKTtcblxuXHQvLyBDcmVhdGUgY29udmVydGVycyBtYXAgd2l0aCBsb3dlcmNhc2VkIGtleXNcblx0aWYgKCBkYXRhVHlwZXNbIDEgXSApIHtcblx0XHRmb3IgKCBjb252IGluIHMuY29udmVydGVycyApIHtcblx0XHRcdGNvbnZlcnRlcnNbIGNvbnYudG9Mb3dlckNhc2UoKSBdID0gcy5jb252ZXJ0ZXJzWyBjb252IF07XG5cdFx0fVxuXHR9XG5cblx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdC8vIENvbnZlcnQgdG8gZWFjaCBzZXF1ZW50aWFsIGRhdGFUeXBlXG5cdHdoaWxlICggY3VycmVudCApIHtcblxuXHRcdGlmICggcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdICkge1xuXHRcdFx0anFYSFJbIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSBdID0gcmVzcG9uc2U7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgdGhlIGRhdGFGaWx0ZXIgaWYgcHJvdmlkZWRcblx0XHRpZiAoICFwcmV2ICYmIGlzU3VjY2VzcyAmJiBzLmRhdGFGaWx0ZXIgKSB7XG5cdFx0XHRyZXNwb25zZSA9IHMuZGF0YUZpbHRlciggcmVzcG9uc2UsIHMuZGF0YVR5cGUgKTtcblx0XHR9XG5cblx0XHRwcmV2ID0gY3VycmVudDtcblx0XHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0XHRpZiAoIGN1cnJlbnQgKSB7XG5cblx0XHRcdC8vIFRoZXJlJ3Mgb25seSB3b3JrIHRvIGRvIGlmIGN1cnJlbnQgZGF0YVR5cGUgaXMgbm9uLWF1dG9cblx0XHRcdGlmICggY3VycmVudCA9PT0gXCIqXCIgKSB7XG5cblx0XHRcdFx0Y3VycmVudCA9IHByZXY7XG5cblx0XHRcdC8vIENvbnZlcnQgcmVzcG9uc2UgaWYgcHJldiBkYXRhVHlwZSBpcyBub24tYXV0byBhbmQgZGlmZmVycyBmcm9tIGN1cnJlbnRcblx0XHRcdH0gZWxzZSBpZiAoIHByZXYgIT09IFwiKlwiICYmIHByZXYgIT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU2VlayBhIGRpcmVjdCBjb252ZXJ0ZXJcblx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIGN1cnJlbnQgXSB8fCBjb252ZXJ0ZXJzWyBcIiogXCIgKyBjdXJyZW50IF07XG5cblx0XHRcdFx0Ly8gSWYgbm9uZSBmb3VuZCwgc2VlayBhIHBhaXJcblx0XHRcdFx0aWYgKCAhY29udiApIHtcblx0XHRcdFx0XHRmb3IgKCBjb252MiBpbiBjb252ZXJ0ZXJzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBJZiBjb252MiBvdXRwdXRzIGN1cnJlbnRcblx0XHRcdFx0XHRcdHRtcCA9IGNvbnYyLnNwbGl0KCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0aWYgKCB0bXBbIDEgXSA9PT0gY3VycmVudCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBJZiBwcmV2IGNhbiBiZSBjb252ZXJ0ZWQgdG8gYWNjZXB0ZWQgaW5wdXRcblx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIHRtcFsgMCBdIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRjb252ZXJ0ZXJzWyBcIiogXCIgKyB0bXBbIDAgXSBdO1xuXHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBDb25kZW5zZSBlcXVpdmFsZW5jZSBjb252ZXJ0ZXJzXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjb252ID09PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIGNvbnYyIF07XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIGluc2VydCB0aGUgaW50ZXJtZWRpYXRlIGRhdGFUeXBlXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggY29udmVydGVyc1sgY29udjIgXSAhPT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSB0bXBbIDAgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0bXBbIDEgXSApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFwcGx5IGNvbnZlcnRlciAoaWYgbm90IGFuIGVxdWl2YWxlbmNlKVxuXHRcdFx0XHRpZiAoIGNvbnYgIT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHQvLyBVbmxlc3MgZXJyb3JzIGFyZSBhbGxvd2VkIHRvIGJ1YmJsZSwgY2F0Y2ggYW5kIHJldHVybiB0aGVtXG5cdFx0XHRcdFx0aWYgKCBjb252ICYmIHMudGhyb3dzICkge1xuXHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0ZTogXCJwYXJzZXJlcnJvclwiLFxuXHRcdFx0XHRcdFx0XHRcdGVycm9yOiBjb252ID8gZSA6IFwiTm8gY29udmVyc2lvbiBmcm9tIFwiICsgcHJldiArIFwiIHRvIFwiICsgY3VycmVudFxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB7IHN0YXRlOiBcInN1Y2Nlc3NcIiwgZGF0YTogcmVzcG9uc2UgfTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIENvdW50ZXIgZm9yIGhvbGRpbmcgdGhlIG51bWJlciBvZiBhY3RpdmUgcXVlcmllc1xuXHRhY3RpdmU6IDAsXG5cblx0Ly8gTGFzdC1Nb2RpZmllZCBoZWFkZXIgY2FjaGUgZm9yIG5leHQgcmVxdWVzdFxuXHRsYXN0TW9kaWZpZWQ6IHt9LFxuXHRldGFnOiB7fSxcblxuXHRhamF4U2V0dGluZ3M6IHtcblx0XHR1cmw6IGxvY2F0aW9uLmhyZWYsXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRpc0xvY2FsOiBybG9jYWxQcm90b2NvbC50ZXN0KCBsb2NhdGlvbi5wcm90b2NvbCApLFxuXHRcdGdsb2JhbDogdHJ1ZSxcblx0XHRwcm9jZXNzRGF0YTogdHJ1ZSxcblx0XHRhc3luYzogdHJ1ZSxcblx0XHRjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLThcIixcblxuXHRcdC8qXG5cdFx0dGltZW91dDogMCxcblx0XHRkYXRhOiBudWxsLFxuXHRcdGRhdGFUeXBlOiBudWxsLFxuXHRcdHVzZXJuYW1lOiBudWxsLFxuXHRcdHBhc3N3b3JkOiBudWxsLFxuXHRcdGNhY2hlOiBudWxsLFxuXHRcdHRocm93czogZmFsc2UsXG5cdFx0dHJhZGl0aW9uYWw6IGZhbHNlLFxuXHRcdGhlYWRlcnM6IHt9LFxuXHRcdCovXG5cblx0XHRhY2NlcHRzOiB7XG5cdFx0XHRcIipcIjogYWxsVHlwZXMsXG5cdFx0XHR0ZXh0OiBcInRleHQvcGxhaW5cIixcblx0XHRcdGh0bWw6IFwidGV4dC9odG1sXCIsXG5cdFx0XHR4bWw6IFwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFwiLFxuXHRcdFx0anNvbjogXCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHRcIlxuXHRcdH0sXG5cblx0XHRjb250ZW50czoge1xuXHRcdFx0eG1sOiAvXFxieG1sXFxiLyxcblx0XHRcdGh0bWw6IC9cXGJodG1sLyxcblx0XHRcdGpzb246IC9cXGJqc29uXFxiL1xuXHRcdH0sXG5cblx0XHRyZXNwb25zZUZpZWxkczoge1xuXHRcdFx0eG1sOiBcInJlc3BvbnNlWE1MXCIsXG5cdFx0XHR0ZXh0OiBcInJlc3BvbnNlVGV4dFwiLFxuXHRcdFx0anNvbjogXCJyZXNwb25zZUpTT05cIlxuXHRcdH0sXG5cblx0XHQvLyBEYXRhIGNvbnZlcnRlcnNcblx0XHQvLyBLZXlzIHNlcGFyYXRlIHNvdXJjZSAob3IgY2F0Y2hhbGwgXCIqXCIpIGFuZCBkZXN0aW5hdGlvbiB0eXBlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG5cdFx0Y29udmVydGVyczoge1xuXG5cdFx0XHQvLyBDb252ZXJ0IGFueXRoaW5nIHRvIHRleHRcblx0XHRcdFwiKiB0ZXh0XCI6IFN0cmluZyxcblxuXHRcdFx0Ly8gVGV4dCB0byBodG1sICh0cnVlID0gbm8gdHJhbnNmb3JtYXRpb24pXG5cdFx0XHRcInRleHQgaHRtbFwiOiB0cnVlLFxuXG5cdFx0XHQvLyBFdmFsdWF0ZSB0ZXh0IGFzIGEganNvbiBleHByZXNzaW9uXG5cdFx0XHRcInRleHQganNvblwiOiBKU09OLnBhcnNlLFxuXG5cdFx0XHQvLyBQYXJzZSB0ZXh0IGFzIHhtbFxuXHRcdFx0XCJ0ZXh0IHhtbFwiOiBqUXVlcnkucGFyc2VYTUxcblx0XHR9LFxuXG5cdFx0Ly8gRm9yIG9wdGlvbnMgdGhhdCBzaG91bGRuJ3QgYmUgZGVlcCBleHRlbmRlZDpcblx0XHQvLyB5b3UgY2FuIGFkZCB5b3VyIG93biBjdXN0b20gb3B0aW9ucyBoZXJlIGlmXG5cdFx0Ly8gYW5kIHdoZW4geW91IGNyZWF0ZSBvbmUgdGhhdCBzaG91bGRuJ3QgYmVcblx0XHQvLyBkZWVwIGV4dGVuZGVkIChzZWUgYWpheEV4dGVuZClcblx0XHRmbGF0T3B0aW9uczoge1xuXHRcdFx0dXJsOiB0cnVlLFxuXHRcdFx0Y29udGV4dDogdHJ1ZVxuXHRcdH1cblx0fSxcblxuXHQvLyBDcmVhdGVzIGEgZnVsbCBmbGVkZ2VkIHNldHRpbmdzIG9iamVjdCBpbnRvIHRhcmdldFxuXHQvLyB3aXRoIGJvdGggYWpheFNldHRpbmdzIGFuZCBzZXR0aW5ncyBmaWVsZHMuXG5cdC8vIElmIHRhcmdldCBpcyBvbWl0dGVkLCB3cml0ZXMgaW50byBhamF4U2V0dGluZ3MuXG5cdGFqYXhTZXR1cDogZnVuY3Rpb24oIHRhcmdldCwgc2V0dGluZ3MgKSB7XG5cdFx0cmV0dXJuIHNldHRpbmdzID9cblxuXHRcdFx0Ly8gQnVpbGRpbmcgYSBzZXR0aW5ncyBvYmplY3Rcblx0XHRcdGFqYXhFeHRlbmQoIGFqYXhFeHRlbmQoIHRhcmdldCwgalF1ZXJ5LmFqYXhTZXR0aW5ncyApLCBzZXR0aW5ncyApIDpcblxuXHRcdFx0Ly8gRXh0ZW5kaW5nIGFqYXhTZXR0aW5nc1xuXHRcdFx0YWpheEV4dGVuZCggalF1ZXJ5LmFqYXhTZXR0aW5ncywgdGFyZ2V0ICk7XG5cdH0sXG5cblx0YWpheFByZWZpbHRlcjogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzICksXG5cdGFqYXhUcmFuc3BvcnQ6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cyApLFxuXG5cdC8vIE1haW4gbWV0aG9kXG5cdGFqYXg6IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBJZiB1cmwgaXMgYW4gb2JqZWN0LCBzaW11bGF0ZSBwcmUtMS41IHNpZ25hdHVyZVxuXHRcdGlmICggdHlwZW9mIHVybCA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdG9wdGlvbnMgPSB1cmw7XG5cdFx0XHR1cmwgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gRm9yY2Ugb3B0aW9ucyB0byBiZSBhbiBvYmplY3Rcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdHZhciB0cmFuc3BvcnQsXG5cblx0XHRcdC8vIFVSTCB3aXRob3V0IGFudGktY2FjaGUgcGFyYW1cblx0XHRcdGNhY2hlVVJMLFxuXG5cdFx0XHQvLyBSZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcsXG5cdFx0XHRyZXNwb25zZUhlYWRlcnMsXG5cblx0XHRcdC8vIHRpbWVvdXQgaGFuZGxlXG5cdFx0XHR0aW1lb3V0VGltZXIsXG5cblx0XHRcdC8vIFVybCBjbGVhbnVwIHZhclxuXHRcdFx0dXJsQW5jaG9yLFxuXG5cdFx0XHQvLyBSZXF1ZXN0IHN0YXRlIChiZWNvbWVzIGZhbHNlIHVwb24gc2VuZCBhbmQgdHJ1ZSB1cG9uIGNvbXBsZXRpb24pXG5cdFx0XHRjb21wbGV0ZWQsXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgZ2xvYmFsIGV2ZW50cyBhcmUgdG8gYmUgZGlzcGF0Y2hlZFxuXHRcdFx0ZmlyZUdsb2JhbHMsXG5cblx0XHRcdC8vIExvb3AgdmFyaWFibGVcblx0XHRcdGksXG5cblx0XHRcdC8vIHVuY2FjaGVkIHBhcnQgb2YgdGhlIHVybFxuXHRcdFx0dW5jYWNoZWQsXG5cblx0XHRcdC8vIENyZWF0ZSB0aGUgZmluYWwgb3B0aW9ucyBvYmplY3Rcblx0XHRcdHMgPSBqUXVlcnkuYWpheFNldHVwKCB7fSwgb3B0aW9ucyApLFxuXG5cdFx0XHQvLyBDYWxsYmFja3MgY29udGV4dFxuXHRcdFx0Y2FsbGJhY2tDb250ZXh0ID0gcy5jb250ZXh0IHx8IHMsXG5cblx0XHRcdC8vIENvbnRleHQgZm9yIGdsb2JhbCBldmVudHMgaXMgY2FsbGJhY2tDb250ZXh0IGlmIGl0IGlzIGEgRE9NIG5vZGUgb3IgalF1ZXJ5IGNvbGxlY3Rpb25cblx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dCA9IHMuY29udGV4dCAmJlxuXHRcdFx0XHQoIGNhbGxiYWNrQ29udGV4dC5ub2RlVHlwZSB8fCBjYWxsYmFja0NvbnRleHQuanF1ZXJ5ICkgP1xuXHRcdFx0XHRcdGpRdWVyeSggY2FsbGJhY2tDb250ZXh0ICkgOlxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudCxcblxuXHRcdFx0Ly8gRGVmZXJyZWRzXG5cdFx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZCA9IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0c3RhdHVzQ29kZSA9IHMuc3RhdHVzQ29kZSB8fCB7fSxcblxuXHRcdFx0Ly8gSGVhZGVycyAodGhleSBhcmUgc2VudCBhbGwgYXQgb25jZSlcblx0XHRcdHJlcXVlc3RIZWFkZXJzID0ge30sXG5cdFx0XHRyZXF1ZXN0SGVhZGVyc05hbWVzID0ge30sXG5cblx0XHRcdC8vIERlZmF1bHQgYWJvcnQgbWVzc2FnZVxuXHRcdFx0c3RyQWJvcnQgPSBcImNhbmNlbGVkXCIsXG5cblx0XHRcdC8vIEZha2UgeGhyXG5cdFx0XHRqcVhIUiA9IHtcblx0XHRcdFx0cmVhZHlTdGF0ZTogMCxcblxuXHRcdFx0XHQvLyBCdWlsZHMgaGVhZGVycyBoYXNodGFibGUgaWYgbmVlZGVkXG5cdFx0XHRcdGdldFJlc3BvbnNlSGVhZGVyOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0XHRcdHZhciBtYXRjaDtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0XHRcdGlmICggIXJlc3BvbnNlSGVhZGVycyApIHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzID0ge307XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKCBtYXRjaCA9IHJoZWFkZXJzLmV4ZWMoIHJlc3BvbnNlSGVhZGVyc1N0cmluZyApICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzWyBtYXRjaFsgMSBdLnRvTG93ZXJDYXNlKCkgXSA9IG1hdGNoWyAyIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG1hdGNoID0gcmVzcG9uc2VIZWFkZXJzWyBrZXkudG9Mb3dlckNhc2UoKSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2ggPT0gbnVsbCA/IG51bGwgOiBtYXRjaDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBSYXcgc3RyaW5nXG5cdFx0XHRcdGdldEFsbFJlc3BvbnNlSGVhZGVyczogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNvbXBsZXRlZCA/IHJlc3BvbnNlSGVhZGVyc1N0cmluZyA6IG51bGw7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FjaGVzIHRoZSBoZWFkZXJcblx0XHRcdFx0c2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRuYW1lID0gcmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gPVxuXHRcdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc05hbWVzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fCBuYW1lO1xuXHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBPdmVycmlkZXMgcmVzcG9uc2UgY29udGVudC10eXBlIGhlYWRlclxuXHRcdFx0XHRvdmVycmlkZU1pbWVUeXBlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0cy5taW1lVHlwZSA9IHR5cGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRcdHN0YXR1c0NvZGU6IGZ1bmN0aW9uKCBtYXAgKSB7XG5cdFx0XHRcdFx0dmFyIGNvZGU7XG5cdFx0XHRcdFx0aWYgKCBtYXAgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBFeGVjdXRlIHRoZSBhcHByb3ByaWF0ZSBjYWxsYmFja3Ncblx0XHRcdFx0XHRcdFx0anFYSFIuYWx3YXlzKCBtYXBbIGpxWEhSLnN0YXR1cyBdICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIExhenktYWRkIHRoZSBuZXcgY2FsbGJhY2tzIGluIGEgd2F5IHRoYXQgcHJlc2VydmVzIG9sZCBvbmVzXG5cdFx0XHRcdFx0XHRcdGZvciAoIGNvZGUgaW4gbWFwICkge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXR1c0NvZGVbIGNvZGUgXSA9IFsgc3RhdHVzQ29kZVsgY29kZSBdLCBtYXBbIGNvZGUgXSBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhbmNlbCB0aGUgcmVxdWVzdFxuXHRcdFx0XHRhYm9ydDogZnVuY3Rpb24oIHN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0dmFyIGZpbmFsVGV4dCA9IHN0YXR1c1RleHQgfHwgc3RyQWJvcnQ7XG5cdFx0XHRcdFx0aWYgKCB0cmFuc3BvcnQgKSB7XG5cdFx0XHRcdFx0XHR0cmFuc3BvcnQuYWJvcnQoIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkb25lKCAwLCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdC8vIEF0dGFjaCBkZWZlcnJlZHNcblx0XHRkZWZlcnJlZC5wcm9taXNlKCBqcVhIUiApO1xuXG5cdFx0Ly8gQWRkIHByb3RvY29sIGlmIG5vdCBwcm92aWRlZCAocHJlZmlsdGVycyBtaWdodCBleHBlY3QgaXQpXG5cdFx0Ly8gSGFuZGxlIGZhbHN5IHVybCBpbiB0aGUgc2V0dGluZ3Mgb2JqZWN0ICgjMTAwOTM6IGNvbnNpc3RlbmN5IHdpdGggb2xkIHNpZ25hdHVyZSlcblx0XHQvLyBXZSBhbHNvIHVzZSB0aGUgdXJsIHBhcmFtZXRlciBpZiBhdmFpbGFibGVcblx0XHRzLnVybCA9ICggKCB1cmwgfHwgcy51cmwgfHwgbG9jYXRpb24uaHJlZiApICsgXCJcIiApXG5cdFx0XHQucmVwbGFjZSggcnByb3RvY29sLCBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiApO1xuXG5cdFx0Ly8gQWxpYXMgbWV0aG9kIG9wdGlvbiB0byB0eXBlIGFzIHBlciB0aWNrZXQgIzEyMDA0XG5cdFx0cy50eXBlID0gb3B0aW9ucy5tZXRob2QgfHwgb3B0aW9ucy50eXBlIHx8IHMubWV0aG9kIHx8IHMudHlwZTtcblxuXHRcdC8vIEV4dHJhY3QgZGF0YVR5cGVzIGxpc3Rcblx0XHRzLmRhdGFUeXBlcyA9ICggcy5kYXRhVHlwZSB8fCBcIipcIiApLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblxuXHRcdC8vIEEgY3Jvc3MtZG9tYWluIHJlcXVlc3QgaXMgaW4gb3JkZXIgd2hlbiB0aGUgb3JpZ2luIGRvZXNuJ3QgbWF0Y2ggdGhlIGN1cnJlbnQgb3JpZ2luLlxuXHRcdGlmICggcy5jcm9zc0RvbWFpbiA9PSBudWxsICkge1xuXHRcdFx0dXJsQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04IC0gMTEsIEVkZ2UgMTIgLSAxM1xuXHRcdFx0Ly8gSUUgdGhyb3dzIGV4Y2VwdGlvbiBvbiBhY2Nlc3NpbmcgdGhlIGhyZWYgcHJvcGVydHkgaWYgdXJsIGlzIG1hbGZvcm1lZCxcblx0XHRcdC8vIGUuZy4gaHR0cDovL2V4YW1wbGUuY29tOjgweC9cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHVybEFuY2hvci5ocmVmID0gcy51cmw7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04IC0gMTEgb25seVxuXHRcdFx0XHQvLyBBbmNob3IncyBob3N0IHByb3BlcnR5IGlzbid0IGNvcnJlY3RseSBzZXQgd2hlbiBzLnVybCBpcyByZWxhdGl2ZVxuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHVybEFuY2hvci5ocmVmO1xuXHRcdFx0XHRzLmNyb3NzRG9tYWluID0gb3JpZ2luQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgb3JpZ2luQW5jaG9yLmhvc3QgIT09XG5cdFx0XHRcdFx0dXJsQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgdXJsQW5jaG9yLmhvc3Q7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBhbiBlcnJvciBwYXJzaW5nIHRoZSBVUkwsIGFzc3VtZSBpdCBpcyBjcm9zc0RvbWFpbixcblx0XHRcdFx0Ly8gaXQgY2FuIGJlIHJlamVjdGVkIGJ5IHRoZSB0cmFuc3BvcnQgaWYgaXQgaXMgaW52YWxpZFxuXHRcdFx0XHRzLmNyb3NzRG9tYWluID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IGRhdGEgaWYgbm90IGFscmVhZHkgYSBzdHJpbmdcblx0XHRpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmIHR5cGVvZiBzLmRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRzLmRhdGEgPSBqUXVlcnkucGFyYW0oIHMuZGF0YSwgcy50cmFkaXRpb25hbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHByZWZpbHRlcnNcblx0XHRpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGEgcHJlZmlsdGVyLCBzdG9wIHRoZXJlXG5cdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0fVxuXG5cdFx0Ly8gV2UgY2FuIGZpcmUgZ2xvYmFsIGV2ZW50cyBhcyBvZiBub3cgaWYgYXNrZWQgdG9cblx0XHQvLyBEb24ndCBmaXJlIGV2ZW50cyBpZiBqUXVlcnkuZXZlbnQgaXMgdW5kZWZpbmVkIGluIGFuIEFNRC11c2FnZSBzY2VuYXJpbyAoIzE1MTE4KVxuXHRcdGZpcmVHbG9iYWxzID0galF1ZXJ5LmV2ZW50ICYmIHMuZ2xvYmFsO1xuXG5cdFx0Ly8gV2F0Y2ggZm9yIGEgbmV3IHNldCBvZiByZXF1ZXN0c1xuXHRcdGlmICggZmlyZUdsb2JhbHMgJiYgalF1ZXJ5LmFjdGl2ZSsrID09PSAwICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0YXJ0XCIgKTtcblx0XHR9XG5cblx0XHQvLyBVcHBlcmNhc2UgdGhlIHR5cGVcblx0XHRzLnR5cGUgPSBzLnR5cGUudG9VcHBlckNhc2UoKTtcblxuXHRcdC8vIERldGVybWluZSBpZiByZXF1ZXN0IGhhcyBjb250ZW50XG5cdFx0cy5oYXNDb250ZW50ID0gIXJub0NvbnRlbnQudGVzdCggcy50eXBlICk7XG5cblx0XHQvLyBTYXZlIHRoZSBVUkwgaW4gY2FzZSB3ZSdyZSB0b3lpbmcgd2l0aCB0aGUgSWYtTW9kaWZpZWQtU2luY2Vcblx0XHQvLyBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIgbGF0ZXIgb25cblx0XHQvLyBSZW1vdmUgaGFzaCB0byBzaW1wbGlmeSB1cmwgbWFuaXB1bGF0aW9uXG5cdFx0Y2FjaGVVUkwgPSBzLnVybC5yZXBsYWNlKCByaGFzaCwgXCJcIiApO1xuXG5cdFx0Ly8gTW9yZSBvcHRpb25zIGhhbmRsaW5nIGZvciByZXF1ZXN0cyB3aXRoIG5vIGNvbnRlbnRcblx0XHRpZiAoICFzLmhhc0NvbnRlbnQgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBoYXNoIHNvIHdlIGNhbiBwdXQgaXQgYmFja1xuXHRcdFx0dW5jYWNoZWQgPSBzLnVybC5zbGljZSggY2FjaGVVUkwubGVuZ3RoICk7XG5cblx0XHRcdC8vIElmIGRhdGEgaXMgYXZhaWxhYmxlLCBhcHBlbmQgZGF0YSB0byB1cmxcblx0XHRcdGlmICggcy5kYXRhICkge1xuXHRcdFx0XHRjYWNoZVVSTCArPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgcy5kYXRhO1xuXG5cdFx0XHRcdC8vICM5NjgyOiByZW1vdmUgZGF0YSBzbyB0aGF0IGl0J3Mgbm90IHVzZWQgaW4gYW4gZXZlbnR1YWwgcmV0cnlcblx0XHRcdFx0ZGVsZXRlIHMuZGF0YTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIG9yIHVwZGF0ZSBhbnRpLWNhY2hlIHBhcmFtIGlmIG5lZWRlZFxuXHRcdFx0aWYgKCBzLmNhY2hlID09PSBmYWxzZSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgPSBjYWNoZVVSTC5yZXBsYWNlKCByYW50aUNhY2hlLCBcIiQxXCIgKTtcblx0XHRcdFx0dW5jYWNoZWQgPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgXCJfPVwiICsgKCBub25jZSsrICkgKyB1bmNhY2hlZDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUHV0IGhhc2ggYW5kIGFudGktY2FjaGUgb24gdGhlIFVSTCB0aGF0IHdpbGwgYmUgcmVxdWVzdGVkIChnaC0xNzMyKVxuXHRcdFx0cy51cmwgPSBjYWNoZVVSTCArIHVuY2FjaGVkO1xuXG5cdFx0Ly8gQ2hhbmdlICclMjAnIHRvICcrJyBpZiB0aGlzIGlzIGVuY29kZWQgZm9ybSBib2R5IGNvbnRlbnQgKGdoLTI2NTgpXG5cdFx0fSBlbHNlIGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiZcblx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiICkuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICkge1xuXHRcdFx0cy5kYXRhID0gcy5kYXRhLnJlcGxhY2UoIHIyMCwgXCIrXCIgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0aWYgKCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU1vZGlmaWVkLVNpbmNlXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTm9uZS1NYXRjaFwiLCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgY29ycmVjdCBoZWFkZXIsIGlmIGRhdGEgaXMgYmVpbmcgc2VudFxuXHRcdGlmICggcy5kYXRhICYmIHMuaGFzQ29udGVudCAmJiBzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSB8fCBvcHRpb25zLmNvbnRlbnRUeXBlICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgQWNjZXB0cyBoZWFkZXIgZm9yIHRoZSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgZGF0YVR5cGVcblx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFxuXHRcdFx0XCJBY2NlcHRcIixcblx0XHRcdHMuZGF0YVR5cGVzWyAwIF0gJiYgcy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gP1xuXHRcdFx0XHRzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSArXG5cdFx0XHRcdFx0KCBzLmRhdGFUeXBlc1sgMCBdICE9PSBcIipcIiA/IFwiLCBcIiArIGFsbFR5cGVzICsgXCI7IHE9MC4wMVwiIDogXCJcIiApIDpcblx0XHRcdFx0cy5hY2NlcHRzWyBcIipcIiBdXG5cdFx0KTtcblxuXHRcdC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxuXHRcdGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggaSwgcy5oZWFkZXJzWyBpIF0gKTtcblx0XHR9XG5cblx0XHQvLyBBbGxvdyBjdXN0b20gaGVhZGVycy9taW1ldHlwZXMgYW5kIGVhcmx5IGFib3J0XG5cdFx0aWYgKCBzLmJlZm9yZVNlbmQgJiZcblx0XHRcdCggcy5iZWZvcmVTZW5kLmNhbGwoIGNhbGxiYWNrQ29udGV4dCwganFYSFIsIHMgKSA9PT0gZmFsc2UgfHwgY29tcGxldGVkICkgKSB7XG5cblx0XHRcdC8vIEFib3J0IGlmIG5vdCBkb25lIGFscmVhZHkgYW5kIHJldHVyblxuXHRcdFx0cmV0dXJuIGpxWEhSLmFib3J0KCk7XG5cdFx0fVxuXG5cdFx0Ly8gQWJvcnRpbmcgaXMgbm8gbG9uZ2VyIGEgY2FuY2VsbGF0aW9uXG5cdFx0c3RyQWJvcnQgPSBcImFib3J0XCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrcyBvbiBkZWZlcnJlZHNcblx0XHRjb21wbGV0ZURlZmVycmVkLmFkZCggcy5jb21wbGV0ZSApO1xuXHRcdGpxWEhSLmRvbmUoIHMuc3VjY2VzcyApO1xuXHRcdGpxWEhSLmZhaWwoIHMuZXJyb3IgKTtcblxuXHRcdC8vIEdldCB0cmFuc3BvcnRcblx0XHR0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIG5vIHRyYW5zcG9ydCwgd2UgYXV0by1hYm9ydFxuXHRcdGlmICggIXRyYW5zcG9ydCApIHtcblx0XHRcdGRvbmUoIC0xLCBcIk5vIFRyYW5zcG9ydFwiICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSAxO1xuXG5cdFx0XHQvLyBTZW5kIGdsb2JhbCBldmVudFxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheFNlbmRcIiwgWyBqcVhIUiwgcyBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGFqYXhTZW5kLCBzdG9wIHRoZXJlXG5cdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaW1lb3V0XG5cdFx0XHRpZiAoIHMuYXN5bmMgJiYgcy50aW1lb3V0ID4gMCApIHtcblx0XHRcdFx0dGltZW91dFRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGpxWEhSLmFib3J0KCBcInRpbWVvdXRcIiApO1xuXHRcdFx0XHR9LCBzLnRpbWVvdXQgKTtcblx0XHRcdH1cblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29tcGxldGVkID0gZmFsc2U7XG5cdFx0XHRcdHRyYW5zcG9ydC5zZW5kKCByZXF1ZXN0SGVhZGVycywgZG9uZSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gUmV0aHJvdyBwb3N0LWNvbXBsZXRpb24gZXhjZXB0aW9uc1xuXHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUHJvcGFnYXRlIG90aGVycyBhcyByZXN1bHRzXG5cdFx0XHRcdGRvbmUoIC0xLCBlICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGJhY2sgZm9yIHdoZW4gZXZlcnl0aGluZyBpcyBkb25lXG5cdFx0ZnVuY3Rpb24gZG9uZSggc3RhdHVzLCBuYXRpdmVTdGF0dXNUZXh0LCByZXNwb25zZXMsIGhlYWRlcnMgKSB7XG5cdFx0XHR2YXIgaXNTdWNjZXNzLCBzdWNjZXNzLCBlcnJvciwgcmVzcG9uc2UsIG1vZGlmaWVkLFxuXHRcdFx0XHRzdGF0dXNUZXh0ID0gbmF0aXZlU3RhdHVzVGV4dDtcblxuXHRcdFx0Ly8gSWdub3JlIHJlcGVhdCBpbnZvY2F0aW9uc1xuXHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29tcGxldGVkID0gdHJ1ZTtcblxuXHRcdFx0Ly8gQ2xlYXIgdGltZW91dCBpZiBpdCBleGlzdHNcblx0XHRcdGlmICggdGltZW91dFRpbWVyICkge1xuXHRcdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0VGltZXIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGVyZWZlcmVuY2UgdHJhbnNwb3J0IGZvciBlYXJseSBnYXJiYWdlIGNvbGxlY3Rpb25cblx0XHRcdC8vIChubyBtYXR0ZXIgaG93IGxvbmcgdGhlIGpxWEhSIG9iamVjdCB3aWxsIGJlIHVzZWQpXG5cdFx0XHR0cmFuc3BvcnQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdC8vIENhY2hlIHJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyA9IGhlYWRlcnMgfHwgXCJcIjtcblxuXHRcdFx0Ly8gU2V0IHJlYWR5U3RhdGVcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XG5cblx0XHRcdC8vIERldGVybWluZSBpZiBzdWNjZXNzZnVsXG5cdFx0XHRpc1N1Y2Nlc3MgPSBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNDtcblxuXHRcdFx0Ly8gR2V0IHJlc3BvbnNlIGRhdGFcblx0XHRcdGlmICggcmVzcG9uc2VzICkge1xuXHRcdFx0XHRyZXNwb25zZSA9IGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCBubyBtYXR0ZXIgd2hhdCAodGhhdCB3YXkgcmVzcG9uc2VYWFggZmllbGRzIGFyZSBhbHdheXMgc2V0KVxuXHRcdFx0cmVzcG9uc2UgPSBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKTtcblxuXHRcdFx0Ly8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXG5cdFx0XHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0XHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiTGFzdC1Nb2RpZmllZFwiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJldGFnXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZiBubyBjb250ZW50XG5cdFx0XHRcdGlmICggc3RhdHVzID09PSAyMDQgfHwgcy50eXBlID09PSBcIkhFQURcIiApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub2NvbnRlbnRcIjtcblxuXHRcdFx0XHQvLyBpZiBub3QgbW9kaWZpZWRcblx0XHRcdFx0fSBlbHNlIGlmICggc3RhdHVzID09PSAzMDQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm90bW9kaWZpZWRcIjtcblxuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGRhdGEsIGxldCdzIGNvbnZlcnQgaXRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdGU7XG5cdFx0XHRcdFx0c3VjY2VzcyA9IHJlc3BvbnNlLmRhdGE7XG5cdFx0XHRcdFx0ZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcblx0XHRcdFx0XHRpc1N1Y2Nlc3MgPSAhZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gRXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHQgYW5kIG5vcm1hbGl6ZSBmb3Igbm9uLWFib3J0c1xuXHRcdFx0XHRlcnJvciA9IHN0YXR1c1RleHQ7XG5cdFx0XHRcdGlmICggc3RhdHVzIHx8ICFzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcImVycm9yXCI7XG5cdFx0XHRcdFx0aWYgKCBzdGF0dXMgPCAwICkge1xuXHRcdFx0XHRcdFx0c3RhdHVzID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGRhdGEgZm9yIHRoZSBmYWtlIHhociBvYmplY3Rcblx0XHRcdGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcblx0XHRcdGpxWEhSLnN0YXR1c1RleHQgPSAoIG5hdGl2ZVN0YXR1c1RleHQgfHwgc3RhdHVzVGV4dCApICsgXCJcIjtcblxuXHRcdFx0Ly8gU3VjY2Vzcy9FcnJvclxuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsgc3VjY2Vzcywgc3RhdHVzVGV4dCwganFYSFIgXSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0LCBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRqcVhIUi5zdGF0dXNDb2RlKCBzdGF0dXNDb2RlICk7XG5cdFx0XHRzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggaXNTdWNjZXNzID8gXCJhamF4U3VjY2Vzc1wiIDogXCJhamF4RXJyb3JcIixcblx0XHRcdFx0XHRbIGpxWEhSLCBzLCBpc1N1Y2Nlc3MgPyBzdWNjZXNzIDogZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb21wbGV0ZVxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZC5maXJlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0IF0gKTtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheENvbXBsZXRlXCIsIFsganFYSFIsIHMgXSApO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSB0aGUgZ2xvYmFsIEFKQVggY291bnRlclxuXHRcdFx0XHRpZiAoICEoIC0talF1ZXJ5LmFjdGl2ZSApICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdG9wXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBqcVhIUjtcblx0fSxcblxuXHRnZXRKU09OOiBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCBkYXRhLCBjYWxsYmFjaywgXCJqc29uXCIgKTtcblx0fSxcblxuXHRnZXRTY3JpcHQ6IGZ1bmN0aW9uKCB1cmwsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIHVuZGVmaW5lZCwgY2FsbGJhY2ssIFwic2NyaXB0XCIgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImdldFwiLCBcInBvc3RcIiBdLCBmdW5jdGlvbiggaSwgbWV0aG9kICkge1xuXHRqUXVlcnlbIG1ldGhvZCBdID0gZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2ssIHR5cGUgKSB7XG5cblx0XHQvLyBTaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZFxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGRhdGEgKSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IGNhbGxiYWNrO1xuXHRcdFx0Y2FsbGJhY2sgPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBUaGUgdXJsIGNhbiBiZSBhbiBvcHRpb25zIG9iamVjdCAod2hpY2ggdGhlbiBtdXN0IGhhdmUgLnVybClcblx0XHRyZXR1cm4galF1ZXJ5LmFqYXgoIGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdHVybDogdXJsLFxuXHRcdFx0dHlwZTogbWV0aG9kLFxuXHRcdFx0ZGF0YVR5cGU6IHR5cGUsXG5cdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0c3VjY2VzczogY2FsbGJhY2tcblx0XHR9LCBqUXVlcnkuaXNQbGFpbk9iamVjdCggdXJsICkgJiYgdXJsICkgKTtcblx0fTtcbn0gKTtcblxuXG5qUXVlcnkuX2V2YWxVcmwgPSBmdW5jdGlvbiggdXJsICkge1xuXHRyZXR1cm4galF1ZXJ5LmFqYXgoIHtcblx0XHR1cmw6IHVybCxcblxuXHRcdC8vIE1ha2UgdGhpcyBleHBsaWNpdCwgc2luY2UgdXNlciBjYW4gb3ZlcnJpZGUgdGhpcyB0aHJvdWdoIGFqYXhTZXR1cCAoIzExMjY0KVxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0ZGF0YVR5cGU6IFwic2NyaXB0XCIsXG5cdFx0Y2FjaGU6IHRydWUsXG5cdFx0YXN5bmM6IGZhbHNlLFxuXHRcdGdsb2JhbDogZmFsc2UsXG5cdFx0XCJ0aHJvd3NcIjogdHJ1ZVxuXHR9ICk7XG59O1xuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0d3JhcEFsbDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIHdyYXA7XG5cblx0XHRpZiAoIHRoaXNbIDAgXSApIHtcblx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdFx0aHRtbCA9IGh0bWwuY2FsbCggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRoZSBlbGVtZW50cyB0byB3cmFwIHRoZSB0YXJnZXQgYXJvdW5kXG5cdFx0XHR3cmFwID0galF1ZXJ5KCBodG1sLCB0aGlzWyAwIF0ub3duZXJEb2N1bWVudCApLmVxKCAwICkuY2xvbmUoIHRydWUgKTtcblxuXHRcdFx0aWYgKCB0aGlzWyAwIF0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0d3JhcC5pbnNlcnRCZWZvcmUoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHR3cmFwLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gdGhpcztcblxuXHRcdFx0XHR3aGlsZSAoIGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQgKSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZWxlbTtcblx0XHRcdH0gKS5hcHBlbmQoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR3cmFwSW5uZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwSW5uZXIoIGh0bWwuY2FsbCggdGhpcywgaSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGpRdWVyeSggdGhpcyApLFxuXHRcdFx0XHRjb250ZW50cyA9IHNlbGYuY29udGVudHMoKTtcblxuXHRcdFx0aWYgKCBjb250ZW50cy5sZW5ndGggKSB7XG5cdFx0XHRcdGNvbnRlbnRzLndyYXBBbGwoIGh0bWwgKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VsZi5hcHBlbmQoIGh0bWwgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0d3JhcDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwQWxsKCBpc0Z1bmN0aW9uID8gaHRtbC5jYWxsKCB0aGlzLCBpICkgOiBodG1sICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdHVud3JhcDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHRoaXMucGFyZW50KCBzZWxlY3RvciApLm5vdCggXCJib2R5XCIgKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLnJlcGxhY2VXaXRoKCB0aGlzLmNoaWxkTm9kZXMgKTtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZXhwci5wc2V1ZG9zLmhpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gIWpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSggZWxlbSApO1xufTtcbmpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gISEoIGVsZW0ub2Zmc2V0V2lkdGggfHwgZWxlbS5vZmZzZXRIZWlnaHQgfHwgZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApO1xufTtcblxuXG5cblxualF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIgPSBmdW5jdGlvbigpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xuXHR9IGNhdGNoICggZSApIHt9XG59O1xuXG52YXIgeGhyU3VjY2Vzc1N0YXR1cyA9IHtcblxuXHRcdC8vIEZpbGUgcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgY29kZSAwLCBhc3N1bWUgMjAwXG5cdFx0MDogMjAwLFxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHQvLyAjMTQ1MDogc29tZXRpbWVzIElFIHJldHVybnMgMTIyMyB3aGVuIGl0IHNob3VsZCBiZSAyMDRcblx0XHQxMjIzOiAyMDRcblx0fSxcblx0eGhyU3VwcG9ydGVkID0galF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIoKTtcblxuc3VwcG9ydC5jb3JzID0gISF4aHJTdXBwb3J0ZWQgJiYgKCBcIndpdGhDcmVkZW50aWFsc1wiIGluIHhoclN1cHBvcnRlZCApO1xuc3VwcG9ydC5hamF4ID0geGhyU3VwcG9ydGVkID0gISF4aHJTdXBwb3J0ZWQ7XG5cbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0dmFyIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrO1xuXG5cdC8vIENyb3NzIGRvbWFpbiBvbmx5IGFsbG93ZWQgaWYgc3VwcG9ydGVkIHRocm91Z2ggWE1MSHR0cFJlcXVlc3Rcblx0aWYgKCBzdXBwb3J0LmNvcnMgfHwgeGhyU3VwcG9ydGVkICYmICFvcHRpb25zLmNyb3NzRG9tYWluICkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggaGVhZGVycywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHZhciBpLFxuXHRcdFx0XHRcdHhociA9IG9wdGlvbnMueGhyKCk7XG5cblx0XHRcdFx0eGhyLm9wZW4oXG5cdFx0XHRcdFx0b3B0aW9ucy50eXBlLFxuXHRcdFx0XHRcdG9wdGlvbnMudXJsLFxuXHRcdFx0XHRcdG9wdGlvbnMuYXN5bmMsXG5cdFx0XHRcdFx0b3B0aW9ucy51c2VybmFtZSxcblx0XHRcdFx0XHRvcHRpb25zLnBhc3N3b3JkXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gQXBwbHkgY3VzdG9tIGZpZWxkcyBpZiBwcm92aWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdGZvciAoIGkgaW4gb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0XHR4aHJbIGkgXSA9IG9wdGlvbnMueGhyRmllbGRzWyBpIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGUgbWltZSB0eXBlIGlmIG5lZWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMubWltZVR5cGUgJiYgeGhyLm92ZXJyaWRlTWltZVR5cGUgKSB7XG5cdFx0XHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUoIG9wdGlvbnMubWltZVR5cGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFgtUmVxdWVzdGVkLVdpdGggaGVhZGVyXG5cdFx0XHRcdC8vIEZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMsIHNlZWluZyBhcyBjb25kaXRpb25zIGZvciBhIHByZWZsaWdodCBhcmVcblx0XHRcdFx0Ly8gYWtpbiB0byBhIGppZ3NhdyBwdXp6bGUsIHdlIHNpbXBseSBuZXZlciBzZXQgaXQgdG8gYmUgc3VyZS5cblx0XHRcdFx0Ly8gKGl0IGNhbiBhbHdheXMgYmUgc2V0IG9uIGEgcGVyLXJlcXVlc3QgYmFzaXMgb3IgZXZlbiB1c2luZyBhamF4U2V0dXApXG5cdFx0XHRcdC8vIEZvciBzYW1lLWRvbWFpbiByZXF1ZXN0cywgd29uJ3QgY2hhbmdlIGhlYWRlciBpZiBhbHJlYWR5IHByb3ZpZGVkLlxuXHRcdFx0XHRpZiAoICFvcHRpb25zLmNyb3NzRG9tYWluICYmICFoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdICkge1xuXHRcdFx0XHRcdGhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gPSBcIlhNTEh0dHBSZXF1ZXN0XCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZXQgaGVhZGVyc1xuXHRcdFx0XHRmb3IgKCBpIGluIGhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoIGksIGhlYWRlcnNbIGkgXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayA9IGVycm9yQ2FsbGJhY2sgPSB4aHIub25sb2FkID1cblx0XHRcdFx0XHRcdFx0XHR4aHIub25lcnJvciA9IHhoci5vbmFib3J0ID0geGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlID09PSBcImFib3J0XCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0eGhyLmFib3J0KCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwiZXJyb3JcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gT24gYSBtYW51YWwgbmF0aXZlIGFib3J0LCBJRTkgdGhyb3dzXG5cdFx0XHRcdFx0XHRcdFx0Ly8gZXJyb3JzIG9uIGFueSBwcm9wZXJ0eSBhY2Nlc3MgdGhhdCBpcyBub3QgcmVhZHlTdGF0ZVxuXHRcdFx0XHRcdFx0XHRcdGlmICggdHlwZW9mIHhoci5zdGF0dXMgIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggMCwgXCJlcnJvclwiICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIEZpbGU6IHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIDA7IHNlZSAjODYwNSwgIzE0MjA3XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblx0XHRcdFx0XHRcdFx0XHRcdHhoclN1Y2Nlc3NTdGF0dXNbIHhoci5zdGF0dXMgXSB8fCB4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHQsXG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBJRTkgaGFzIG5vIFhIUjIgYnV0IHRocm93cyBvbiBiaW5hcnkgKHRyYWMtMTE0MjYpXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBGb3IgWEhSMiBub24tdGV4dCwgbGV0IHRoZSBjYWxsZXIgaGFuZGxlIGl0IChnaC0yNDk4KVxuXHRcdFx0XHRcdFx0XHRcdFx0KCB4aHIucmVzcG9uc2VUeXBlIHx8IFwidGV4dFwiICkgIT09IFwidGV4dFwiICB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHhoci5yZXNwb25zZVRleHQgIT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IGJpbmFyeTogeGhyLnJlc3BvbnNlIH0gOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IHRleHQ6IHhoci5yZXNwb25zZVRleHQgfSxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIExpc3RlbiB0byBldmVudHNcblx0XHRcdFx0eGhyLm9ubG9hZCA9IGNhbGxiYWNrKCk7XG5cdFx0XHRcdGVycm9yQ2FsbGJhY2sgPSB4aHIub25lcnJvciA9IGNhbGxiYWNrKCBcImVycm9yXCIgKTtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA5IG9ubHlcblx0XHRcdFx0Ly8gVXNlIG9ucmVhZHlzdGF0ZWNoYW5nZSB0byByZXBsYWNlIG9uYWJvcnRcblx0XHRcdFx0Ly8gdG8gaGFuZGxlIHVuY2F1Z2h0IGFib3J0c1xuXHRcdFx0XHRpZiAoIHhoci5vbmFib3J0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0eGhyLm9uYWJvcnQgPSBlcnJvckNhbGxiYWNrO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2hlY2sgcmVhZHlTdGF0ZSBiZWZvcmUgdGltZW91dCBhcyBpdCBjaGFuZ2VzXG5cdFx0XHRcdFx0XHRpZiAoIHhoci5yZWFkeVN0YXRlID09PSA0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFsbG93IG9uZXJyb3IgdG8gYmUgY2FsbGVkIGZpcnN0LFxuXHRcdFx0XHRcdFx0XHQvLyBidXQgdGhhdCB3aWxsIG5vdCBoYW5kbGUgYSBuYXRpdmUgYWJvcnRcblx0XHRcdFx0XHRcdFx0Ly8gQWxzbywgc2F2ZSBlcnJvckNhbGxiYWNrIHRvIGEgdmFyaWFibGVcblx0XHRcdFx0XHRcdFx0Ly8gYXMgeGhyLm9uZXJyb3IgY2Fubm90IGJlIGFjY2Vzc2VkXG5cdFx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3JDYWxsYmFjaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDcmVhdGUgdGhlIGFib3J0IGNhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gY2FsbGJhY2soIFwiYWJvcnRcIiApO1xuXG5cdFx0XHRcdHRyeSB7XG5cblx0XHRcdFx0XHQvLyBEbyBzZW5kIHRoZSByZXF1ZXN0ICh0aGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24pXG5cdFx0XHRcdFx0eGhyLnNlbmQoIG9wdGlvbnMuaGFzQ29udGVudCAmJiBvcHRpb25zLmRhdGEgfHwgbnVsbCApO1xuXHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdC8vICMxNDY4MzogT25seSByZXRocm93IGlmIHRoaXMgaGFzbid0IGJlZW4gbm90aWZpZWQgYXMgYW4gZXJyb3IgeWV0XG5cdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUHJldmVudCBhdXRvLWV4ZWN1dGlvbiBvZiBzY3JpcHRzIHdoZW4gbm8gZXhwbGljaXQgZGF0YVR5cGUgd2FzIHByb3ZpZGVkIChTZWUgZ2gtMjQzMilcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMuY29udGVudHMuc2NyaXB0ID0gZmFsc2U7XG5cdH1cbn0gKTtcblxuLy8gSW5zdGFsbCBzY3JpcHQgZGF0YVR5cGVcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0YWNjZXB0czoge1xuXHRcdHNjcmlwdDogXCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIFwiICtcblx0XHRcdFwiYXBwbGljYXRpb24vZWNtYXNjcmlwdCwgYXBwbGljYXRpb24veC1lY21hc2NyaXB0XCJcblx0fSxcblx0Y29udGVudHM6IHtcblx0XHRzY3JpcHQ6IC9cXGIoPzpqYXZhfGVjbWEpc2NyaXB0XFxiL1xuXHR9LFxuXHRjb252ZXJ0ZXJzOiB7XG5cdFx0XCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCB0ZXh0ICk7XG5cdFx0XHRyZXR1cm4gdGV4dDtcblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSGFuZGxlIGNhY2hlJ3Mgc3BlY2lhbCBjYXNlIGFuZCBjcm9zc0RvbWFpblxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRzLmNhY2hlID0gZmFsc2U7XG5cdH1cblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMudHlwZSA9IFwiR0VUXCI7XG5cdH1cbn0gKTtcblxuLy8gQmluZCBzY3JpcHQgdGFnIGhhY2sgdHJhbnNwb3J0XG5qUXVlcnkuYWpheFRyYW5zcG9ydCggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cblx0Ly8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiByZXF1ZXN0c1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0dmFyIHNjcmlwdCwgY2FsbGJhY2s7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBfLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0c2NyaXB0ID0galF1ZXJ5KCBcIjxzY3JpcHQ+XCIgKS5wcm9wKCB7XG5cdFx0XHRcdFx0Y2hhcnNldDogcy5zY3JpcHRDaGFyc2V0LFxuXHRcdFx0XHRcdHNyYzogcy51cmxcblx0XHRcdFx0fSApLm9uKFxuXHRcdFx0XHRcdFwibG9hZCBlcnJvclwiLFxuXHRcdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIGV2dCApIHtcblx0XHRcdFx0XHRcdHNjcmlwdC5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gbnVsbDtcblx0XHRcdFx0XHRcdGlmICggZXZ0ICkge1xuXHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggZXZ0LnR5cGUgPT09IFwiZXJyb3JcIiA/IDQwNCA6IDIwMCwgZXZ0LnR5cGUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gVXNlIG5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIHRvIGF2b2lkIG91ciBkb21NYW5pcCBBSkFYIHRyaWNrZXJ5XG5cdFx0XHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdFsgMCBdICk7XG5cdFx0XHR9LFxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBvbGRDYWxsYmFja3MgPSBbXSxcblx0cmpzb25wID0gLyg9KVxcPyg/PSZ8JCl8XFw/XFw/LztcblxuLy8gRGVmYXVsdCBqc29ucCBzZXR0aW5nc1xualF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRqc29ucDogXCJjYWxsYmFja1wiLFxuXHRqc29ucENhbGxiYWNrOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2FsbGJhY2sgPSBvbGRDYWxsYmFja3MucG9wKCkgfHwgKCBqUXVlcnkuZXhwYW5kbyArIFwiX1wiICsgKCBub25jZSsrICkgKTtcblx0XHR0aGlzWyBjYWxsYmFjayBdID0gdHJ1ZTtcblx0XHRyZXR1cm4gY2FsbGJhY2s7XG5cdH1cbn0gKTtcblxuLy8gRGV0ZWN0LCBub3JtYWxpemUgb3B0aW9ucyBhbmQgaW5zdGFsbCBjYWxsYmFja3MgZm9yIGpzb25wIHJlcXVlc3RzXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJqc29uIGpzb25wXCIsIGZ1bmN0aW9uKCBzLCBvcmlnaW5hbFNldHRpbmdzLCBqcVhIUiApIHtcblxuXHR2YXIgY2FsbGJhY2tOYW1lLCBvdmVyd3JpdHRlbiwgcmVzcG9uc2VDb250YWluZXIsXG5cdFx0anNvblByb3AgPSBzLmpzb25wICE9PSBmYWxzZSAmJiAoIHJqc29ucC50ZXN0KCBzLnVybCApID9cblx0XHRcdFwidXJsXCIgOlxuXHRcdFx0dHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQoIHMuY29udGVudFR5cGUgfHwgXCJcIiApXG5cdFx0XHRcdFx0LmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCAmJlxuXHRcdFx0XHRyanNvbnAudGVzdCggcy5kYXRhICkgJiYgXCJkYXRhXCJcblx0XHQpO1xuXG5cdC8vIEhhbmRsZSBpZmYgdGhlIGV4cGVjdGVkIGRhdGEgdHlwZSBpcyBcImpzb25wXCIgb3Igd2UgaGF2ZSBhIHBhcmFtZXRlciB0byBzZXRcblx0aWYgKCBqc29uUHJvcCB8fCBzLmRhdGFUeXBlc1sgMCBdID09PSBcImpzb25wXCIgKSB7XG5cblx0XHQvLyBHZXQgY2FsbGJhY2sgbmFtZSwgcmVtZW1iZXJpbmcgcHJlZXhpc3RpbmcgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGl0XG5cdFx0Y2FsbGJhY2tOYW1lID0gcy5qc29ucENhbGxiYWNrID0galF1ZXJ5LmlzRnVuY3Rpb24oIHMuanNvbnBDYWxsYmFjayApID9cblx0XHRcdHMuanNvbnBDYWxsYmFjaygpIDpcblx0XHRcdHMuanNvbnBDYWxsYmFjaztcblxuXHRcdC8vIEluc2VydCBjYWxsYmFjayBpbnRvIHVybCBvciBmb3JtIGRhdGFcblx0XHRpZiAoIGpzb25Qcm9wICkge1xuXHRcdFx0c1sganNvblByb3AgXSA9IHNbIGpzb25Qcm9wIF0ucmVwbGFjZSggcmpzb25wLCBcIiQxXCIgKyBjYWxsYmFja05hbWUgKTtcblx0XHR9IGVsc2UgaWYgKCBzLmpzb25wICE9PSBmYWxzZSApIHtcblx0XHRcdHMudXJsICs9ICggcnF1ZXJ5LnRlc3QoIHMudXJsICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmpzb25wICsgXCI9XCIgKyBjYWxsYmFja05hbWU7XG5cdFx0fVxuXG5cdFx0Ly8gVXNlIGRhdGEgY29udmVydGVyIHRvIHJldHJpZXZlIGpzb24gYWZ0ZXIgc2NyaXB0IGV4ZWN1dGlvblxuXHRcdHMuY29udmVydGVyc1sgXCJzY3JpcHQganNvblwiIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIXJlc3BvbnNlQ29udGFpbmVyICkge1xuXHRcdFx0XHRqUXVlcnkuZXJyb3IoIGNhbGxiYWNrTmFtZSArIFwiIHdhcyBub3QgY2FsbGVkXCIgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXNwb25zZUNvbnRhaW5lclsgMCBdO1xuXHRcdH07XG5cblx0XHQvLyBGb3JjZSBqc29uIGRhdGFUeXBlXG5cdFx0cy5kYXRhVHlwZXNbIDAgXSA9IFwianNvblwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja1xuXHRcdG92ZXJ3cml0dGVuID0gd2luZG93WyBjYWxsYmFja05hbWUgXTtcblx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IGFyZ3VtZW50cztcblx0XHR9O1xuXG5cdFx0Ly8gQ2xlYW4tdXAgZnVuY3Rpb24gKGZpcmVzIGFmdGVyIGNvbnZlcnRlcnMpXG5cdFx0anFYSFIuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gSWYgcHJldmlvdXMgdmFsdWUgZGlkbid0IGV4aXN0IC0gcmVtb3ZlIGl0XG5cdFx0XHRpZiAoIG92ZXJ3cml0dGVuID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGpRdWVyeSggd2luZG93ICkucmVtb3ZlUHJvcCggY2FsbGJhY2tOYW1lICk7XG5cblx0XHRcdC8vIE90aGVyd2lzZSByZXN0b3JlIHByZWV4aXN0aW5nIHZhbHVlXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gb3ZlcndyaXR0ZW47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNhdmUgYmFjayBhcyBmcmVlXG5cdFx0XHRpZiAoIHNbIGNhbGxiYWNrTmFtZSBdICkge1xuXG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHJlLXVzaW5nIHRoZSBvcHRpb25zIGRvZXNuJ3Qgc2NyZXcgdGhpbmdzIGFyb3VuZFxuXHRcdFx0XHRzLmpzb25wQ2FsbGJhY2sgPSBvcmlnaW5hbFNldHRpbmdzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHRcdFx0Ly8gU2F2ZSB0aGUgY2FsbGJhY2sgbmFtZSBmb3IgZnV0dXJlIHVzZVxuXHRcdFx0XHRvbGRDYWxsYmFja3MucHVzaCggY2FsbGJhY2tOYW1lICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhbGwgaWYgaXQgd2FzIGEgZnVuY3Rpb24gYW5kIHdlIGhhdmUgYSByZXNwb25zZVxuXHRcdFx0aWYgKCByZXNwb25zZUNvbnRhaW5lciAmJiBqUXVlcnkuaXNGdW5jdGlvbiggb3ZlcndyaXR0ZW4gKSApIHtcblx0XHRcdFx0b3ZlcndyaXR0ZW4oIHJlc3BvbnNlQ29udGFpbmVyWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBvdmVyd3JpdHRlbiA9IHVuZGVmaW5lZDtcblx0XHR9ICk7XG5cblx0XHQvLyBEZWxlZ2F0ZSB0byBzY3JpcHRcblx0XHRyZXR1cm4gXCJzY3JpcHRcIjtcblx0fVxufSApO1xuXG5cblxuXG4vLyBTdXBwb3J0OiBTYWZhcmkgOCBvbmx5XG4vLyBJbiBTYWZhcmkgOCBkb2N1bWVudHMgY3JlYXRlZCB2aWEgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50XG4vLyBjb2xsYXBzZSBzaWJsaW5nIGZvcm1zOiB0aGUgc2Vjb25kIG9uZSBiZWNvbWVzIGEgY2hpbGQgb2YgdGhlIGZpcnN0IG9uZS5cbi8vIEJlY2F1c2Ugb2YgdGhhdCwgdGhpcyBzZWN1cml0eSBtZWFzdXJlIGhhcyB0byBiZSBkaXNhYmxlZCBpbiBTYWZhcmkgOC5cbi8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzczMzdcbnN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ID0gKCBmdW5jdGlvbigpIHtcblx0dmFyIGJvZHkgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKS5ib2R5O1xuXHRib2R5LmlubmVySFRNTCA9IFwiPGZvcm0+PC9mb3JtPjxmb3JtPjwvZm9ybT5cIjtcblx0cmV0dXJuIGJvZHkuY2hpbGROb2Rlcy5sZW5ndGggPT09IDI7XG59ICkoKTtcblxuXG4vLyBBcmd1bWVudCBcImRhdGFcIiBzaG91bGQgYmUgc3RyaW5nIG9mIGh0bWxcbi8vIGNvbnRleHQgKG9wdGlvbmFsKTogSWYgc3BlY2lmaWVkLCB0aGUgZnJhZ21lbnQgd2lsbCBiZSBjcmVhdGVkIGluIHRoaXMgY29udGV4dCxcbi8vIGRlZmF1bHRzIHRvIGRvY3VtZW50XG4vLyBrZWVwU2NyaXB0cyAob3B0aW9uYWwpOiBJZiB0cnVlLCB3aWxsIGluY2x1ZGUgc2NyaXB0cyBwYXNzZWQgaW4gdGhlIGh0bWwgc3RyaW5nXG5qUXVlcnkucGFyc2VIVE1MID0gZnVuY3Rpb24oIGRhdGEsIGNvbnRleHQsIGtlZXBTY3JpcHRzICkge1xuXHRpZiAoIHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBbXTtcblx0fVxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRrZWVwU2NyaXB0cyA9IGNvbnRleHQ7XG5cdFx0Y29udGV4dCA9IGZhbHNlO1xuXHR9XG5cblx0dmFyIGJhc2UsIHBhcnNlZCwgc2NyaXB0cztcblxuXHRpZiAoICFjb250ZXh0ICkge1xuXG5cdFx0Ly8gU3RvcCBzY3JpcHRzIG9yIGlubGluZSBldmVudCBoYW5kbGVycyBmcm9tIGJlaW5nIGV4ZWN1dGVkIGltbWVkaWF0ZWx5XG5cdFx0Ly8gYnkgdXNpbmcgZG9jdW1lbnQuaW1wbGVtZW50YXRpb25cblx0XHRpZiAoIHN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ICkge1xuXHRcdFx0Y29udGV4dCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXCJcIiApO1xuXG5cdFx0XHQvLyBTZXQgdGhlIGJhc2UgaHJlZiBmb3IgdGhlIGNyZWF0ZWQgZG9jdW1lbnRcblx0XHRcdC8vIHNvIGFueSBwYXJzZWQgZWxlbWVudHMgd2l0aCBVUkxzXG5cdFx0XHQvLyBhcmUgYmFzZWQgb24gdGhlIGRvY3VtZW50J3MgVVJMIChnaC0yOTY1KVxuXHRcdFx0YmFzZSA9IGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJiYXNlXCIgKTtcblx0XHRcdGJhc2UuaHJlZiA9IGRvY3VtZW50LmxvY2F0aW9uLmhyZWY7XG5cdFx0XHRjb250ZXh0LmhlYWQuYXBwZW5kQ2hpbGQoIGJhc2UgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29udGV4dCA9IGRvY3VtZW50O1xuXHRcdH1cblx0fVxuXG5cdHBhcnNlZCA9IHJzaW5nbGVUYWcuZXhlYyggZGF0YSApO1xuXHRzY3JpcHRzID0gIWtlZXBTY3JpcHRzICYmIFtdO1xuXG5cdC8vIFNpbmdsZSB0YWdcblx0aWYgKCBwYXJzZWQgKSB7XG5cdFx0cmV0dXJuIFsgY29udGV4dC5jcmVhdGVFbGVtZW50KCBwYXJzZWRbIDEgXSApIF07XG5cdH1cblxuXHRwYXJzZWQgPSBidWlsZEZyYWdtZW50KCBbIGRhdGEgXSwgY29udGV4dCwgc2NyaXB0cyApO1xuXG5cdGlmICggc2NyaXB0cyAmJiBzY3JpcHRzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkoIHNjcmlwdHMgKS5yZW1vdmUoKTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBwYXJzZWQuY2hpbGROb2RlcyApO1xufTtcblxuXG4vKipcbiAqIExvYWQgYSB1cmwgaW50byBhIHBhZ2VcbiAqL1xualF1ZXJ5LmZuLmxvYWQgPSBmdW5jdGlvbiggdXJsLCBwYXJhbXMsIGNhbGxiYWNrICkge1xuXHR2YXIgc2VsZWN0b3IsIHR5cGUsIHJlc3BvbnNlLFxuXHRcdHNlbGYgPSB0aGlzLFxuXHRcdG9mZiA9IHVybC5pbmRleE9mKCBcIiBcIiApO1xuXG5cdGlmICggb2ZmID4gLTEgKSB7XG5cdFx0c2VsZWN0b3IgPSBzdHJpcEFuZENvbGxhcHNlKCB1cmwuc2xpY2UoIG9mZiApICk7XG5cdFx0dXJsID0gdXJsLnNsaWNlKCAwLCBvZmYgKTtcblx0fVxuXG5cdC8vIElmIGl0J3MgYSBmdW5jdGlvblxuXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBwYXJhbXMgKSApIHtcblxuXHRcdC8vIFdlIGFzc3VtZSB0aGF0IGl0J3MgdGhlIGNhbGxiYWNrXG5cdFx0Y2FsbGJhY2sgPSBwYXJhbXM7XG5cdFx0cGFyYW1zID0gdW5kZWZpbmVkO1xuXG5cdC8vIE90aGVyd2lzZSwgYnVpbGQgYSBwYXJhbSBzdHJpbmdcblx0fSBlbHNlIGlmICggcGFyYW1zICYmIHR5cGVvZiBwYXJhbXMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0dHlwZSA9IFwiUE9TVFwiO1xuXHR9XG5cblx0Ly8gSWYgd2UgaGF2ZSBlbGVtZW50cyB0byBtb2RpZnksIG1ha2UgdGhlIHJlcXVlc3Rcblx0aWYgKCBzZWxmLmxlbmd0aCA+IDAgKSB7XG5cdFx0alF1ZXJ5LmFqYXgoIHtcblx0XHRcdHVybDogdXJsLFxuXG5cdFx0XHQvLyBJZiBcInR5cGVcIiB2YXJpYWJsZSBpcyB1bmRlZmluZWQsIHRoZW4gXCJHRVRcIiBtZXRob2Qgd2lsbCBiZSB1c2VkLlxuXHRcdFx0Ly8gTWFrZSB2YWx1ZSBvZiB0aGlzIGZpZWxkIGV4cGxpY2l0IHNpbmNlXG5cdFx0XHQvLyB1c2VyIGNhbiBvdmVycmlkZSBpdCB0aHJvdWdoIGFqYXhTZXR1cCBtZXRob2Rcblx0XHRcdHR5cGU6IHR5cGUgfHwgXCJHRVRcIixcblx0XHRcdGRhdGFUeXBlOiBcImh0bWxcIixcblx0XHRcdGRhdGE6IHBhcmFtc1xuXHRcdH0gKS5kb25lKCBmdW5jdGlvbiggcmVzcG9uc2VUZXh0ICkge1xuXG5cdFx0XHQvLyBTYXZlIHJlc3BvbnNlIGZvciB1c2UgaW4gY29tcGxldGUgY2FsbGJhY2tcblx0XHRcdHJlc3BvbnNlID0gYXJndW1lbnRzO1xuXG5cdFx0XHRzZWxmLmh0bWwoIHNlbGVjdG9yID9cblxuXHRcdFx0XHQvLyBJZiBhIHNlbGVjdG9yIHdhcyBzcGVjaWZpZWQsIGxvY2F0ZSB0aGUgcmlnaHQgZWxlbWVudHMgaW4gYSBkdW1teSBkaXZcblx0XHRcdFx0Ly8gRXhjbHVkZSBzY3JpcHRzIHRvIGF2b2lkIElFICdQZXJtaXNzaW9uIERlbmllZCcgZXJyb3JzXG5cdFx0XHRcdGpRdWVyeSggXCI8ZGl2PlwiICkuYXBwZW5kKCBqUXVlcnkucGFyc2VIVE1MKCByZXNwb25zZVRleHQgKSApLmZpbmQoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSB1c2UgdGhlIGZ1bGwgcmVzdWx0XG5cdFx0XHRcdHJlc3BvbnNlVGV4dCApO1xuXG5cdFx0Ly8gSWYgdGhlIHJlcXVlc3Qgc3VjY2VlZHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImRhdGFcIiwgXCJzdGF0dXNcIiwgXCJqcVhIUlwiXG5cdFx0Ly8gYnV0IHRoZXkgYXJlIGlnbm9yZWQgYmVjYXVzZSByZXNwb25zZSB3YXMgc2V0IGFib3ZlLlxuXHRcdC8vIElmIGl0IGZhaWxzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJqcVhIUlwiLCBcInN0YXR1c1wiLCBcImVycm9yXCJcblx0XHR9ICkuYWx3YXlzKCBjYWxsYmFjayAmJiBmdW5jdGlvbigganFYSFIsIHN0YXR1cyApIHtcblx0XHRcdHNlbGYuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNhbGxiYWNrLmFwcGx5KCB0aGlzLCByZXNwb25zZSB8fCBbIGpxWEhSLnJlc3BvbnNlVGV4dCwgc3RhdHVzLCBqcVhIUiBdICk7XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5cblxuXG4vLyBBdHRhY2ggYSBidW5jaCBvZiBmdW5jdGlvbnMgZm9yIGhhbmRsaW5nIGNvbW1vbiBBSkFYIGV2ZW50c1xualF1ZXJ5LmVhY2goIFtcblx0XCJhamF4U3RhcnRcIixcblx0XCJhamF4U3RvcFwiLFxuXHRcImFqYXhDb21wbGV0ZVwiLFxuXHRcImFqYXhFcnJvclwiLFxuXHRcImFqYXhTdWNjZXNzXCIsXG5cdFwiYWpheFNlbmRcIlxuXSwgZnVuY3Rpb24oIGksIHR5cGUgKSB7XG5cdGpRdWVyeS5mblsgdHlwZSBdID0gZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlLCBmbiApO1xuXHR9O1xufSApO1xuXG5cblxuXG5qUXVlcnkuZXhwci5wc2V1ZG9zLmFuaW1hdGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiBqUXVlcnkuZ3JlcCggalF1ZXJ5LnRpbWVycywgZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiBlbGVtID09PSBmbi5lbGVtO1xuXHR9ICkubGVuZ3RoO1xufTtcblxuXG5cblxuLyoqXG4gKiBHZXRzIGEgd2luZG93IGZyb20gYW4gZWxlbWVudFxuICovXG5mdW5jdGlvbiBnZXRXaW5kb3coIGVsZW0gKSB7XG5cdHJldHVybiBqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSA/IGVsZW0gOiBlbGVtLm5vZGVUeXBlID09PSA5ICYmIGVsZW0uZGVmYXVsdFZpZXc7XG59XG5cbmpRdWVyeS5vZmZzZXQgPSB7XG5cdHNldE9mZnNldDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGkgKSB7XG5cdFx0dmFyIGN1clBvc2l0aW9uLCBjdXJMZWZ0LCBjdXJDU1NUb3AsIGN1clRvcCwgY3VyT2Zmc2V0LCBjdXJDU1NMZWZ0LCBjYWxjdWxhdGVQb3NpdGlvbixcblx0XHRcdHBvc2l0aW9uID0galF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICksXG5cdFx0XHRjdXJFbGVtID0galF1ZXJ5KCBlbGVtICksXG5cdFx0XHRwcm9wcyA9IHt9O1xuXG5cdFx0Ly8gU2V0IHBvc2l0aW9uIGZpcnN0LCBpbi1jYXNlIHRvcC9sZWZ0IGFyZSBzZXQgZXZlbiBvbiBzdGF0aWMgZWxlbVxuXHRcdGlmICggcG9zaXRpb24gPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRlbGVtLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuXHRcdH1cblxuXHRcdGN1ck9mZnNldCA9IGN1ckVsZW0ub2Zmc2V0KCk7XG5cdFx0Y3VyQ1NTVG9wID0galF1ZXJ5LmNzcyggZWxlbSwgXCJ0b3BcIiApO1xuXHRcdGN1ckNTU0xlZnQgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImxlZnRcIiApO1xuXHRcdGNhbGN1bGF0ZVBvc2l0aW9uID0gKCBwb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiIHx8IHBvc2l0aW9uID09PSBcImZpeGVkXCIgKSAmJlxuXHRcdFx0KCBjdXJDU1NUb3AgKyBjdXJDU1NMZWZ0ICkuaW5kZXhPZiggXCJhdXRvXCIgKSA+IC0xO1xuXG5cdFx0Ly8gTmVlZCB0byBiZSBhYmxlIHRvIGNhbGN1bGF0ZSBwb3NpdGlvbiBpZiBlaXRoZXJcblx0XHQvLyB0b3Agb3IgbGVmdCBpcyBhdXRvIGFuZCBwb3NpdGlvbiBpcyBlaXRoZXIgYWJzb2x1dGUgb3IgZml4ZWRcblx0XHRpZiAoIGNhbGN1bGF0ZVBvc2l0aW9uICkge1xuXHRcdFx0Y3VyUG9zaXRpb24gPSBjdXJFbGVtLnBvc2l0aW9uKCk7XG5cdFx0XHRjdXJUb3AgPSBjdXJQb3NpdGlvbi50b3A7XG5cdFx0XHRjdXJMZWZ0ID0gY3VyUG9zaXRpb24ubGVmdDtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJUb3AgPSBwYXJzZUZsb2F0KCBjdXJDU1NUb3AgKSB8fCAwO1xuXHRcdFx0Y3VyTGVmdCA9IHBhcnNlRmxvYXQoIGN1ckNTU0xlZnQgKSB8fCAwO1xuXHRcdH1cblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIG9wdGlvbnMgKSApIHtcblxuXHRcdFx0Ly8gVXNlIGpRdWVyeS5leHRlbmQgaGVyZSB0byBhbGxvdyBtb2RpZmljYXRpb24gb2YgY29vcmRpbmF0ZXMgYXJndW1lbnQgKGdoLTE4NDgpXG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucy5jYWxsKCBlbGVtLCBpLCBqUXVlcnkuZXh0ZW5kKCB7fSwgY3VyT2Zmc2V0ICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMudG9wICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy50b3AgPSAoIG9wdGlvbnMudG9wIC0gY3VyT2Zmc2V0LnRvcCApICsgY3VyVG9wO1xuXHRcdH1cblx0XHRpZiAoIG9wdGlvbnMubGVmdCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMubGVmdCA9ICggb3B0aW9ucy5sZWZ0IC0gY3VyT2Zmc2V0LmxlZnQgKSArIGN1ckxlZnQ7XG5cdFx0fVxuXG5cdFx0aWYgKCBcInVzaW5nXCIgaW4gb3B0aW9ucyApIHtcblx0XHRcdG9wdGlvbnMudXNpbmcuY2FsbCggZWxlbSwgcHJvcHMgKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJFbGVtLmNzcyggcHJvcHMgKTtcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0b2Zmc2V0OiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHRcdC8vIFByZXNlcnZlIGNoYWluaW5nIGZvciBzZXR0ZXJcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucyA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0dGhpcyA6XG5cdFx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5Lm9mZnNldC5zZXRPZmZzZXQoIHRoaXMsIG9wdGlvbnMsIGkgKTtcblx0XHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHZhciBkb2NFbGVtLCB3aW4sIHJlY3QsIGRvYyxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGFcblx0XHQvLyBkaXNjb25uZWN0ZWQgbm9kZSBpbiBJRSB0aHJvd3MgYW4gZXJyb3Jcblx0XHRpZiAoICFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cdFx0fVxuXG5cdFx0cmVjdCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHQvLyBNYWtlIHN1cmUgZWxlbWVudCBpcyBub3QgaGlkZGVuIChkaXNwbGF5OiBub25lKVxuXHRcdGlmICggcmVjdC53aWR0aCB8fCByZWN0LmhlaWdodCApIHtcblx0XHRcdGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudDtcblx0XHRcdHdpbiA9IGdldFdpbmRvdyggZG9jICk7XG5cdFx0XHRkb2NFbGVtID0gZG9jLmRvY3VtZW50RWxlbWVudDtcblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0dG9wOiByZWN0LnRvcCArIHdpbi5wYWdlWU9mZnNldCAtIGRvY0VsZW0uY2xpZW50VG9wLFxuXHRcdFx0XHRsZWZ0OiByZWN0LmxlZnQgKyB3aW4ucGFnZVhPZmZzZXQgLSBkb2NFbGVtLmNsaWVudExlZnRcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHplcm9zIGZvciBkaXNjb25uZWN0ZWQgYW5kIGhpZGRlbiBlbGVtZW50cyAoZ2gtMjMxMClcblx0XHRyZXR1cm4gcmVjdDtcblx0fSxcblxuXHRwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCAhdGhpc1sgMCBdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBvZmZzZXRQYXJlbnQsIG9mZnNldCxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRwYXJlbnRPZmZzZXQgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuXG5cdFx0Ly8gRml4ZWQgZWxlbWVudHMgYXJlIG9mZnNldCBmcm9tIHdpbmRvdyAocGFyZW50T2Zmc2V0ID0ge3RvcDowLCBsZWZ0OiAwfSxcblx0XHQvLyBiZWNhdXNlIGl0IGlzIGl0cyBvbmx5IG9mZnNldCBwYXJlbnRcblx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApID09PSBcImZpeGVkXCIgKSB7XG5cblx0XHRcdC8vIEFzc3VtZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QgaXMgdGhlcmUgd2hlbiBjb21wdXRlZCBwb3NpdGlvbiBpcyBmaXhlZFxuXHRcdFx0b2Zmc2V0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEdldCAqcmVhbCogb2Zmc2V0UGFyZW50XG5cdFx0XHRvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudCgpO1xuXG5cdFx0XHQvLyBHZXQgY29ycmVjdCBvZmZzZXRzXG5cdFx0XHRvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xuXHRcdFx0aWYgKCAhalF1ZXJ5Lm5vZGVOYW1lKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJodG1sXCIgKSApIHtcblx0XHRcdFx0cGFyZW50T2Zmc2V0ID0gb2Zmc2V0UGFyZW50Lm9mZnNldCgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgb2Zmc2V0UGFyZW50IGJvcmRlcnNcblx0XHRcdHBhcmVudE9mZnNldCA9IHtcblx0XHRcdFx0dG9wOiBwYXJlbnRPZmZzZXQudG9wICsgalF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50WyAwIF0sIFwiYm9yZGVyVG9wV2lkdGhcIiwgdHJ1ZSApLFxuXHRcdFx0XHRsZWZ0OiBwYXJlbnRPZmZzZXQubGVmdCArIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudFsgMCBdLCBcImJvcmRlckxlZnRXaWR0aFwiLCB0cnVlIClcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gU3VidHJhY3QgcGFyZW50IG9mZnNldHMgYW5kIGVsZW1lbnQgbWFyZ2luc1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IG9mZnNldC50b3AgLSBwYXJlbnRPZmZzZXQudG9wIC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5Ub3BcIiwgdHJ1ZSApLFxuXHRcdFx0bGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luTGVmdFwiLCB0cnVlIClcblx0XHR9O1xuXHR9LFxuXG5cdC8vIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGRvY3VtZW50RWxlbWVudCBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuXHQvLyAxKSBGb3IgdGhlIGVsZW1lbnQgaW5zaWRlIHRoZSBpZnJhbWUgd2l0aG91dCBvZmZzZXRQYXJlbnQsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuXG5cdC8vICAgIGRvY3VtZW50RWxlbWVudCBvZiB0aGUgcGFyZW50IHdpbmRvd1xuXHQvLyAyKSBGb3IgdGhlIGhpZGRlbiBvciBkZXRhY2hlZCBlbGVtZW50XG5cdC8vIDMpIEZvciBib2R5IG9yIGh0bWwgZWxlbWVudCwgaS5lLiBpbiBjYXNlIG9mIHRoZSBodG1sIG5vZGUgLSBpdCB3aWxsIHJldHVybiBpdHNlbGZcblx0Ly9cblx0Ly8gYnV0IHRob3NlIGV4Y2VwdGlvbnMgd2VyZSBuZXZlciBwcmVzZW50ZWQgYXMgYSByZWFsIGxpZmUgdXNlLWNhc2VzXG5cdC8vIGFuZCBtaWdodCBiZSBjb25zaWRlcmVkIGFzIG1vcmUgcHJlZmVyYWJsZSByZXN1bHRzLlxuXHQvL1xuXHQvLyBUaGlzIGxvZ2ljLCBob3dldmVyLCBpcyBub3QgZ3VhcmFudGVlZCBhbmQgY2FuIGNoYW5nZSBhdCBhbnkgcG9pbnQgaW4gdGhlIGZ1dHVyZVxuXHRvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQ7XG5cblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnRFbGVtZW50O1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG4vLyBDcmVhdGUgc2Nyb2xsTGVmdCBhbmQgc2Nyb2xsVG9wIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IHNjcm9sbExlZnQ6IFwicGFnZVhPZmZzZXRcIiwgc2Nyb2xsVG9wOiBcInBhZ2VZT2Zmc2V0XCIgfSwgZnVuY3Rpb24oIG1ldGhvZCwgcHJvcCApIHtcblx0dmFyIHRvcCA9IFwicGFnZVlPZmZzZXRcIiA9PT0gcHJvcDtcblxuXHRqUXVlcnkuZm5bIG1ldGhvZCBdID0gZnVuY3Rpb24oIHZhbCApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbWV0aG9kLCB2YWwgKSB7XG5cdFx0XHR2YXIgd2luID0gZ2V0V2luZG93KCBlbGVtICk7XG5cblx0XHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiB3aW4gPyB3aW5bIHByb3AgXSA6IGVsZW1bIG1ldGhvZCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHdpbiApIHtcblx0XHRcdFx0d2luLnNjcm9sbFRvKFxuXHRcdFx0XHRcdCF0b3AgPyB2YWwgOiB3aW4ucGFnZVhPZmZzZXQsXG5cdFx0XHRcdFx0dG9wID8gdmFsIDogd2luLnBhZ2VZT2Zmc2V0XG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1bIG1ldGhvZCBdID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0sIG1ldGhvZCwgdmFsLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH07XG59ICk7XG5cbi8vIFN1cHBvcnQ6IFNhZmFyaSA8PTcgLSA5LjEsIENocm9tZSA8PTM3IC0gNDlcbi8vIEFkZCB0aGUgdG9wL2xlZnQgY3NzSG9va3MgdXNpbmcgalF1ZXJ5LmZuLnBvc2l0aW9uXG4vLyBXZWJraXQgYnVnOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjkwODRcbi8vIEJsaW5rIGJ1ZzogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NTg5MzQ3XG4vLyBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgcGVyY2VudCB3aGVuIHNwZWNpZmllZCBmb3IgdG9wL2xlZnQvYm90dG9tL3JpZ2h0O1xuLy8gcmF0aGVyIHRoYW4gbWFrZSB0aGUgY3NzIG1vZHVsZSBkZXBlbmQgb24gdGhlIG9mZnNldCBtb2R1bGUsIGp1c3QgY2hlY2sgZm9yIGl0IGhlcmVcbmpRdWVyeS5lYWNoKCBbIFwidG9wXCIsIFwibGVmdFwiIF0sIGZ1bmN0aW9uKCBpLCBwcm9wICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByb3AgXSA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5waXhlbFBvc2l0aW9uLFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGNvbXB1dGVkID0gY3VyQ1NTKCBlbGVtLCBwcm9wICk7XG5cblx0XHRcdFx0Ly8gSWYgY3VyQ1NTIHJldHVybnMgcGVyY2VudGFnZSwgZmFsbGJhY2sgdG8gb2Zmc2V0XG5cdFx0XHRcdHJldHVybiBybnVtbm9ucHgudGVzdCggY29tcHV0ZWQgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBlbGVtICkucG9zaXRpb24oKVsgcHJvcCBdICsgXCJweFwiIDpcblx0XHRcdFx0XHRjb21wdXRlZDtcblx0XHRcdH1cblx0XHR9XG5cdCk7XG59ICk7XG5cblxuLy8gQ3JlYXRlIGlubmVySGVpZ2h0LCBpbm5lcldpZHRoLCBoZWlnaHQsIHdpZHRoLCBvdXRlckhlaWdodCBhbmQgb3V0ZXJXaWR0aCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBIZWlnaHQ6IFwiaGVpZ2h0XCIsIFdpZHRoOiBcIndpZHRoXCIgfSwgZnVuY3Rpb24oIG5hbWUsIHR5cGUgKSB7XG5cdGpRdWVyeS5lYWNoKCB7IHBhZGRpbmc6IFwiaW5uZXJcIiArIG5hbWUsIGNvbnRlbnQ6IHR5cGUsIFwiXCI6IFwib3V0ZXJcIiArIG5hbWUgfSxcblx0XHRmdW5jdGlvbiggZGVmYXVsdEV4dHJhLCBmdW5jTmFtZSApIHtcblxuXHRcdC8vIE1hcmdpbiBpcyBvbmx5IGZvciBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aFxuXHRcdGpRdWVyeS5mblsgZnVuY05hbWUgXSA9IGZ1bmN0aW9uKCBtYXJnaW4sIHZhbHVlICkge1xuXHRcdFx0dmFyIGNoYWluYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKCBkZWZhdWx0RXh0cmEgfHwgdHlwZW9mIG1hcmdpbiAhPT0gXCJib29sZWFuXCIgKSxcblx0XHRcdFx0ZXh0cmEgPSBkZWZhdWx0RXh0cmEgfHwgKCBtYXJnaW4gPT09IHRydWUgfHwgdmFsdWUgPT09IHRydWUgPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIiApO1xuXG5cdFx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgdHlwZSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBkb2M7XG5cblx0XHRcdFx0aWYgKCBqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vICQoIHdpbmRvdyApLm91dGVyV2lkdGgvSGVpZ2h0IHJldHVybiB3L2ggaW5jbHVkaW5nIHNjcm9sbGJhcnMgKGdoLTE3MjkpXG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmNOYW1lLmluZGV4T2YoIFwib3V0ZXJcIiApID09PSAwID9cblx0XHRcdFx0XHRcdGVsZW1bIFwiaW5uZXJcIiArIG5hbWUgXSA6XG5cdFx0XHRcdFx0XHRlbGVtLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFsgXCJjbGllbnRcIiArIG5hbWUgXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEdldCBkb2N1bWVudCB3aWR0aCBvciBoZWlnaHRcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdGRvYyA9IGVsZW0uZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0XHRcdFx0Ly8gRWl0aGVyIHNjcm9sbFtXaWR0aC9IZWlnaHRdIG9yIG9mZnNldFtXaWR0aC9IZWlnaHRdIG9yIGNsaWVudFtXaWR0aC9IZWlnaHRdLFxuXHRcdFx0XHRcdC8vIHdoaWNoZXZlciBpcyBncmVhdGVzdFxuXHRcdFx0XHRcdHJldHVybiBNYXRoLm1heChcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJzY3JvbGxcIiArIG5hbWUgXSwgZG9jWyBcInNjcm9sbFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcIm9mZnNldFwiICsgbmFtZSBdLCBkb2NbIFwib2Zmc2V0XCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRkb2NbIFwiY2xpZW50XCIgKyBuYW1lIF1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXG5cdFx0XHRcdFx0Ly8gR2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudCwgcmVxdWVzdGluZyBidXQgbm90IGZvcmNpbmcgcGFyc2VGbG9hdFxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIHR5cGUsIGV4dHJhICkgOlxuXG5cdFx0XHRcdFx0Ly8gU2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudFxuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgdHlwZSwgdmFsdWUsIGV4dHJhICk7XG5cdFx0XHR9LCB0eXBlLCBjaGFpbmFibGUgPyBtYXJnaW4gOiB1bmRlZmluZWQsIGNoYWluYWJsZSApO1xuXHRcdH07XG5cdH0gKTtcbn0gKTtcblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0YmluZDogZnVuY3Rpb24oIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIG51bGwsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuYmluZDogZnVuY3Rpb24oIHR5cGVzLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vZmYoIHR5cGVzLCBudWxsLCBmbiApO1xuXHR9LFxuXG5cdGRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBmbiApIHtcblxuXHRcdC8vICggbmFtZXNwYWNlICkgb3IgKCBzZWxlY3RvciwgdHlwZXMgWywgZm5dIClcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/XG5cdFx0XHR0aGlzLm9mZiggc2VsZWN0b3IsIFwiKipcIiApIDpcblx0XHRcdHRoaXMub2ZmKCB0eXBlcywgc2VsZWN0b3IgfHwgXCIqKlwiLCBmbiApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5wYXJzZUpTT04gPSBKU09OLnBhcnNlO1xuXG5cblxuXG4vLyBSZWdpc3RlciBhcyBhIG5hbWVkIEFNRCBtb2R1bGUsIHNpbmNlIGpRdWVyeSBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXJcbi8vIGZpbGVzIHRoYXQgbWF5IHVzZSBkZWZpbmUsIGJ1dCBub3QgdmlhIGEgcHJvcGVyIGNvbmNhdGVuYXRpb24gc2NyaXB0IHRoYXRcbi8vIHVuZGVyc3RhbmRzIGFub255bW91cyBBTUQgbW9kdWxlcy4gQSBuYW1lZCBBTUQgaXMgc2FmZXN0IGFuZCBtb3N0IHJvYnVzdFxuLy8gd2F5IHRvIHJlZ2lzdGVyLiBMb3dlcmNhc2UganF1ZXJ5IGlzIHVzZWQgYmVjYXVzZSBBTUQgbW9kdWxlIG5hbWVzIGFyZVxuLy8gZGVyaXZlZCBmcm9tIGZpbGUgbmFtZXMsIGFuZCBqUXVlcnkgaXMgbm9ybWFsbHkgZGVsaXZlcmVkIGluIGEgbG93ZXJjYXNlXG4vLyBmaWxlIG5hbWUuIERvIHRoaXMgYWZ0ZXIgY3JlYXRpbmcgdGhlIGdsb2JhbCBzbyB0aGF0IGlmIGFuIEFNRCBtb2R1bGUgd2FudHNcbi8vIHRvIGNhbGwgbm9Db25mbGljdCB0byBoaWRlIHRoaXMgdmVyc2lvbiBvZiBqUXVlcnksIGl0IHdpbGwgd29yay5cblxuLy8gTm90ZSB0aGF0IGZvciBtYXhpbXVtIHBvcnRhYmlsaXR5LCBsaWJyYXJpZXMgdGhhdCBhcmUgbm90IGpRdWVyeSBzaG91bGRcbi8vIGRlY2xhcmUgdGhlbXNlbHZlcyBhcyBhbm9ueW1vdXMgbW9kdWxlcywgYW5kIGF2b2lkIHNldHRpbmcgYSBnbG9iYWwgaWYgYW5cbi8vIEFNRCBsb2FkZXIgaXMgcHJlc2VudC4galF1ZXJ5IGlzIGEgc3BlY2lhbCBjYXNlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vanJidXJrZS9yZXF1aXJlanMvd2lraS9VcGRhdGluZy1leGlzdGluZy1saWJyYXJpZXMjd2lraS1hbm9uXG5cbmlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cdGRlZmluZSggXCJqcXVlcnlcIiwgW10sIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnk7XG5cdH0gKTtcbn1cblxuXG5cblxudmFyXG5cblx0Ly8gTWFwIG92ZXIgalF1ZXJ5IGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF9qUXVlcnkgPSB3aW5kb3cualF1ZXJ5LFxuXG5cdC8vIE1hcCBvdmVyIHRoZSAkIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF8kID0gd2luZG93LiQ7XG5cbmpRdWVyeS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oIGRlZXAgKSB7XG5cdGlmICggd2luZG93LiQgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cuJCA9IF8kO1xuXHR9XG5cblx0aWYgKCBkZWVwICYmIHdpbmRvdy5qUXVlcnkgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cualF1ZXJ5ID0gX2pRdWVyeTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnk7XG59O1xuXG4vLyBFeHBvc2UgalF1ZXJ5IGFuZCAkIGlkZW50aWZpZXJzLCBldmVuIGluIEFNRFxuLy8gKCM3MTAyI2NvbW1lbnQ6MTAsIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNTU3KVxuLy8gYW5kIENvbW1vbkpTIGZvciBicm93c2VyIGVtdWxhdG9ycyAoIzEzNTY2KVxuaWYgKCAhbm9HbG9iYWwgKSB7XG5cdHdpbmRvdy5qUXVlcnkgPSB3aW5kb3cuJCA9IGpRdWVyeTtcbn1cblxuXG5cblxuXG5yZXR1cm4galF1ZXJ5O1xufSApO1xuIiwidmFyIGYgPSByZXF1aXJlKCdmbG9ja2luZy9kaXN0L2Zsb2NraW5nLW5vLWpxdWVyeS5qcycpO1xuY29uc29sZS5sb2coZik7XG4iXX0=
